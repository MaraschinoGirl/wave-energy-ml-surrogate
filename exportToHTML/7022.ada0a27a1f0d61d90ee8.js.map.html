<html>
<head>
<title>7022.ada0a27a1f0d61d90ee8.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7022.ada0a27a1f0d61d90ee8.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7022.ada0a27a1f0d61d90ee8.js?v=ada0a27a1f0d61d90ee8&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,QAAQ,0DAA0D;AAC9F;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/mllike.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function mlLike(parserConfig) {</span><span class="s3">\n  </span><span class="s1">var words = {</span><span class="s3">\n    </span><span class="s1">'as': 'keyword',</span><span class="s3">\n    </span><span class="s1">'do': 'keyword',</span><span class="s3">\n    </span><span class="s1">'else': 'keyword',</span><span class="s3">\n    </span><span class="s1">'end': 'keyword',</span><span class="s3">\n    </span><span class="s1">'exception': 'keyword',</span><span class="s3">\n    </span><span class="s1">'fun': 'keyword',</span><span class="s3">\n    </span><span class="s1">'functor': 'keyword',</span><span class="s3">\n    </span><span class="s1">'if': 'keyword',</span><span class="s3">\n    </span><span class="s1">'in': 'keyword',</span><span class="s3">\n    </span><span class="s1">'include': 'keyword',</span><span class="s3">\n    </span><span class="s1">'let': 'keyword',</span><span class="s3">\n    </span><span class="s1">'of': 'keyword',</span><span class="s3">\n    </span><span class="s1">'open': 'keyword',</span><span class="s3">\n    </span><span class="s1">'rec': 'keyword',</span><span class="s3">\n    </span><span class="s1">'struct': 'keyword',</span><span class="s3">\n    </span><span class="s1">'then': 'keyword',</span><span class="s3">\n    </span><span class="s1">'type': 'keyword',</span><span class="s3">\n    </span><span class="s1">'val': 'keyword',</span><span class="s3">\n    </span><span class="s1">'while': 'keyword',</span><span class="s3">\n    </span><span class="s1">'with': 'keyword'</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">var extraWords = parserConfig.extraWords || {};</span><span class="s3">\n  </span><span class="s1">for (var prop in extraWords) {</span><span class="s3">\n    </span><span class="s1">if (extraWords.hasOwnProperty(prop)) {</span><span class="s3">\n      </span><span class="s1">words[prop] = parserConfig.extraWords[prop];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var hintWords = [];</span><span class="s3">\n  </span><span class="s1">for (var k in words) { hintWords.push(k); }</span><span class="s3">\n\n  </span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch = stream.next();</span><span class="s3">\n\n    </span><span class="s1">if (ch === '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenString;</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch === '{') {</span><span class="s3">\n      </span><span class="s1">if (stream.eat('|')) {</span><span class="s3">\n        </span><span class="s1">state.longString = true;</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenLongString;</span><span class="s3">\n        </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch === '(') {</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^</span><span class="s3">\\</span><span class="s1">*(?!</span><span class="s3">\\</span><span class="s1">))/)) {</span><span class="s3">\n        </span><span class="s1">state.commentLevel++;</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenComment;</span><span class="s3">\n        </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch === '~' || ch === '?') {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/</span><span class="s3">\\</span><span class="s1">w/);</span><span class="s3">\n      </span><span class="s1">return 'variableName.special';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch === '`') {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/</span><span class="s3">\\</span><span class="s1">w/);</span><span class="s3">\n      </span><span class="s1">return 'quote';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch === '/' &amp;&amp; parserConfig.slashComments &amp;&amp; stream.eat('/')) {</span><span class="s3">\n      </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n      </span><span class="s1">return 'comment';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">d/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">if (ch === '0' &amp;&amp; stream.eat(/[bB]/)) {</span><span class="s3">\n        </span><span class="s1">stream.eatWhile(/[01]/);</span><span class="s3">\n      </span><span class="s1">} if (ch === '0' &amp;&amp; stream.eat(/[xX]/)) {</span><span class="s3">\n        </span><span class="s1">stream.eatWhile(/[0-9a-fA-F]/)</span><span class="s3">\n      </span><span class="s1">} if (ch === '0' &amp;&amp; stream.eat(/[oO]/)) {</span><span class="s3">\n        </span><span class="s1">stream.eatWhile(/[0-7]/);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">d_]/);</span><span class="s3">\n        </span><span class="s1">if (stream.eat('.')) {</span><span class="s3">\n          </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">d]/);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (stream.eat(/[eE]/)) {</span><span class="s3">\n          </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">-+]/);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return 'number';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if ( /[+</span><span class="s3">\\</span><span class="s1">-*&amp;%=&lt;&gt;!?|@</span><span class="s3">\\</span><span class="s1">.~:]/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">return 'operator';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/);</span><span class="s3">\n      </span><span class="s1">var cur = stream.current();</span><span class="s3">\n      </span><span class="s1">return words.hasOwnProperty(cur) ? words[cur] : 'variable';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenString(stream, state) {</span><span class="s3">\n    </span><span class="s1">var next, end = false, escaped = false;</span><span class="s3">\n    </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (next === '</span><span class="s3">\&quot;</span><span class="s1">' &amp;&amp; !escaped) {</span><span class="s3">\n        </span><span class="s1">end = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">escaped = !escaped &amp;&amp; next === '</span><span class="s3">\\\\</span><span class="s1">';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end &amp;&amp; !escaped) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 'string';</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n    </span><span class="s1">var prev, next;</span><span class="s3">\n    </span><span class="s1">while(state.commentLevel &gt; 0 &amp;&amp; (next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (prev === '(' &amp;&amp; next === '*') state.commentLevel++;</span><span class="s3">\n      </span><span class="s1">if (prev === '*' &amp;&amp; next === ')') state.commentLevel--;</span><span class="s3">\n      </span><span class="s1">prev = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (state.commentLevel &lt;= 0) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 'comment';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenLongString(stream, state) {</span><span class="s3">\n    </span><span class="s1">var prev, next;</span><span class="s3">\n    </span><span class="s1">while (state.longString &amp;&amp; (next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (prev === '|' &amp;&amp; next === '}') state.longString = false;</span><span class="s3">\n      </span><span class="s1">prev = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!state.longString) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 'string';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">startState: function() {return {tokenize: tokenBase, commentLevel: 0, longString: false};},</span><span class="s3">\n    </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">languageData: {</span><span class="s3">\n      </span><span class="s1">autocomplete: hintWords,</span><span class="s3">\n      </span><span class="s1">commentTokens: {</span><span class="s3">\n        </span><span class="s1">line: parserConfig.slashComments ? </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot; </span><span class="s1">: undefined,</span><span class="s3">\n        </span><span class="s1">block: {open: </span><span class="s3">\&quot;</span><span class="s1">(*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*)</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const oCaml = mlLike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">ocaml</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">extraWords: {</span><span class="s3">\n    </span><span class="s1">'and': 'keyword',</span><span class="s3">\n    </span><span class="s1">'assert': 'keyword',</span><span class="s3">\n    </span><span class="s1">'begin': 'keyword',</span><span class="s3">\n    </span><span class="s1">'class': 'keyword',</span><span class="s3">\n    </span><span class="s1">'constraint': 'keyword',</span><span class="s3">\n    </span><span class="s1">'done': 'keyword',</span><span class="s3">\n    </span><span class="s1">'downto': 'keyword',</span><span class="s3">\n    </span><span class="s1">'external': 'keyword',</span><span class="s3">\n    </span><span class="s1">'function': 'keyword',</span><span class="s3">\n    </span><span class="s1">'initializer': 'keyword',</span><span class="s3">\n    </span><span class="s1">'lazy': 'keyword',</span><span class="s3">\n    </span><span class="s1">'match': 'keyword',</span><span class="s3">\n    </span><span class="s1">'method': 'keyword',</span><span class="s3">\n    </span><span class="s1">'module': 'keyword',</span><span class="s3">\n    </span><span class="s1">'mutable': 'keyword',</span><span class="s3">\n    </span><span class="s1">'new': 'keyword',</span><span class="s3">\n    </span><span class="s1">'nonrec': 'keyword',</span><span class="s3">\n    </span><span class="s1">'object': 'keyword',</span><span class="s3">\n    </span><span class="s1">'private': 'keyword',</span><span class="s3">\n    </span><span class="s1">'sig': 'keyword',</span><span class="s3">\n    </span><span class="s1">'to': 'keyword',</span><span class="s3">\n    </span><span class="s1">'try': 'keyword',</span><span class="s3">\n    </span><span class="s1">'value': 'keyword',</span><span class="s3">\n    </span><span class="s1">'virtual': 'keyword',</span><span class="s3">\n    </span><span class="s1">'when': 'keyword',</span><span class="s3">\n\n    </span><span class="s1">// builtins</span><span class="s3">\n    </span><span class="s1">'raise': 'builtin',</span><span class="s3">\n    </span><span class="s1">'failwith': 'builtin',</span><span class="s3">\n    </span><span class="s1">'true': 'builtin',</span><span class="s3">\n    </span><span class="s1">'false': 'builtin',</span><span class="s3">\n\n    </span><span class="s1">// Pervasives builtins</span><span class="s3">\n    </span><span class="s1">'asr': 'builtin',</span><span class="s3">\n    </span><span class="s1">'land': 'builtin',</span><span class="s3">\n    </span><span class="s1">'lor': 'builtin',</span><span class="s3">\n    </span><span class="s1">'lsl': 'builtin',</span><span class="s3">\n    </span><span class="s1">'lsr': 'builtin',</span><span class="s3">\n    </span><span class="s1">'lxor': 'builtin',</span><span class="s3">\n    </span><span class="s1">'mod': 'builtin',</span><span class="s3">\n    </span><span class="s1">'or': 'builtin',</span><span class="s3">\n\n    </span><span class="s1">// More Pervasives</span><span class="s3">\n    </span><span class="s1">'raise_notrace': 'builtin',</span><span class="s3">\n    </span><span class="s1">'trace': 'builtin',</span><span class="s3">\n    </span><span class="s1">'exit': 'builtin',</span><span class="s3">\n    </span><span class="s1">'print_string': 'builtin',</span><span class="s3">\n    </span><span class="s1">'print_endline': 'builtin',</span><span class="s3">\n\n     </span><span class="s1">'int': 'type',</span><span class="s3">\n     </span><span class="s1">'float': 'type',</span><span class="s3">\n     </span><span class="s1">'bool': 'type',</span><span class="s3">\n     </span><span class="s1">'char': 'type',</span><span class="s3">\n     </span><span class="s1">'string': 'type',</span><span class="s3">\n     </span><span class="s1">'unit': 'type',</span><span class="s3">\n\n     </span><span class="s1">// Modules</span><span class="s3">\n     </span><span class="s1">'List': 'builtin'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export const fSharp = mlLike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">fsharp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">extraWords: {</span><span class="s3">\n    </span><span class="s1">'abstract': 'keyword',</span><span class="s3">\n    </span><span class="s1">'assert': 'keyword',</span><span class="s3">\n    </span><span class="s1">'base': 'keyword',</span><span class="s3">\n    </span><span class="s1">'begin': 'keyword',</span><span class="s3">\n    </span><span class="s1">'class': 'keyword',</span><span class="s3">\n    </span><span class="s1">'default': 'keyword',</span><span class="s3">\n    </span><span class="s1">'delegate': 'keyword',</span><span class="s3">\n    </span><span class="s1">'do!': 'keyword',</span><span class="s3">\n    </span><span class="s1">'done': 'keyword',</span><span class="s3">\n    </span><span class="s1">'downcast': 'keyword',</span><span class="s3">\n    </span><span class="s1">'downto': 'keyword',</span><span class="s3">\n    </span><span class="s1">'elif': 'keyword',</span><span class="s3">\n    </span><span class="s1">'extern': 'keyword',</span><span class="s3">\n    </span><span class="s1">'finally': 'keyword',</span><span class="s3">\n    </span><span class="s1">'for': 'keyword',</span><span class="s3">\n    </span><span class="s1">'function': 'keyword',</span><span class="s3">\n    </span><span class="s1">'global': 'keyword',</span><span class="s3">\n    </span><span class="s1">'inherit': 'keyword',</span><span class="s3">\n    </span><span class="s1">'inline': 'keyword',</span><span class="s3">\n    </span><span class="s1">'interface': 'keyword',</span><span class="s3">\n    </span><span class="s1">'internal': 'keyword',</span><span class="s3">\n    </span><span class="s1">'lazy': 'keyword',</span><span class="s3">\n    </span><span class="s1">'let!': 'keyword',</span><span class="s3">\n    </span><span class="s1">'match': 'keyword',</span><span class="s3">\n    </span><span class="s1">'member': 'keyword',</span><span class="s3">\n    </span><span class="s1">'module': 'keyword',</span><span class="s3">\n    </span><span class="s1">'mutable': 'keyword',</span><span class="s3">\n    </span><span class="s1">'namespace': 'keyword',</span><span class="s3">\n    </span><span class="s1">'new': 'keyword',</span><span class="s3">\n    </span><span class="s1">'null': 'keyword',</span><span class="s3">\n    </span><span class="s1">'override': 'keyword',</span><span class="s3">\n    </span><span class="s1">'private': 'keyword',</span><span class="s3">\n    </span><span class="s1">'public': 'keyword',</span><span class="s3">\n    </span><span class="s1">'return!': 'keyword',</span><span class="s3">\n    </span><span class="s1">'return': 'keyword',</span><span class="s3">\n    </span><span class="s1">'select': 'keyword',</span><span class="s3">\n    </span><span class="s1">'static': 'keyword',</span><span class="s3">\n    </span><span class="s1">'to': 'keyword',</span><span class="s3">\n    </span><span class="s1">'try': 'keyword',</span><span class="s3">\n    </span><span class="s1">'upcast': 'keyword',</span><span class="s3">\n    </span><span class="s1">'use!': 'keyword',</span><span class="s3">\n    </span><span class="s1">'use': 'keyword',</span><span class="s3">\n    </span><span class="s1">'void': 'keyword',</span><span class="s3">\n    </span><span class="s1">'when': 'keyword',</span><span class="s3">\n    </span><span class="s1">'yield!': 'keyword',</span><span class="s3">\n    </span><span class="s1">'yield': 'keyword',</span><span class="s3">\n\n    </span><span class="s1">// Reserved words</span><span class="s3">\n    </span><span class="s1">'atomic': 'keyword',</span><span class="s3">\n    </span><span class="s1">'break': 'keyword',</span><span class="s3">\n    </span><span class="s1">'checked': 'keyword',</span><span class="s3">\n    </span><span class="s1">'component': 'keyword',</span><span class="s3">\n    </span><span class="s1">'const': 'keyword',</span><span class="s3">\n    </span><span class="s1">'constraint': 'keyword',</span><span class="s3">\n    </span><span class="s1">'constructor': 'keyword',</span><span class="s3">\n    </span><span class="s1">'continue': 'keyword',</span><span class="s3">\n    </span><span class="s1">'eager': 'keyword',</span><span class="s3">\n    </span><span class="s1">'event': 'keyword',</span><span class="s3">\n    </span><span class="s1">'external': 'keyword',</span><span class="s3">\n    </span><span class="s1">'fixed': 'keyword',</span><span class="s3">\n    </span><span class="s1">'method': 'keyword',</span><span class="s3">\n    </span><span class="s1">'mixin': 'keyword',</span><span class="s3">\n    </span><span class="s1">'object': 'keyword',</span><span class="s3">\n    </span><span class="s1">'parallel': 'keyword',</span><span class="s3">\n    </span><span class="s1">'process': 'keyword',</span><span class="s3">\n    </span><span class="s1">'protected': 'keyword',</span><span class="s3">\n    </span><span class="s1">'pure': 'keyword',</span><span class="s3">\n    </span><span class="s1">'sealed': 'keyword',</span><span class="s3">\n    </span><span class="s1">'tailcall': 'keyword',</span><span class="s3">\n    </span><span class="s1">'trait': 'keyword',</span><span class="s3">\n    </span><span class="s1">'virtual': 'keyword',</span><span class="s3">\n    </span><span class="s1">'volatile': 'keyword',</span><span class="s3">\n\n    </span><span class="s1">// builtins</span><span class="s3">\n    </span><span class="s1">'List': 'builtin',</span><span class="s3">\n    </span><span class="s1">'Seq': 'builtin',</span><span class="s3">\n    </span><span class="s1">'Map': 'builtin',</span><span class="s3">\n    </span><span class="s1">'Set': 'builtin',</span><span class="s3">\n    </span><span class="s1">'Option': 'builtin',</span><span class="s3">\n    </span><span class="s1">'int': 'builtin',</span><span class="s3">\n    </span><span class="s1">'string': 'builtin',</span><span class="s3">\n    </span><span class="s1">'not': 'builtin',</span><span class="s3">\n    </span><span class="s1">'true': 'builtin',</span><span class="s3">\n    </span><span class="s1">'false': 'builtin',</span><span class="s3">\n\n    </span><span class="s1">'raise': 'builtin',</span><span class="s3">\n    </span><span class="s1">'failwith': 'builtin'</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">slashComments: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export const sml = mlLike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">sml</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">extraWords: {</span><span class="s3">\n    </span><span class="s1">'abstype': 'keyword',</span><span class="s3">\n    </span><span class="s1">'and': 'keyword',</span><span class="s3">\n    </span><span class="s1">'andalso': 'keyword',</span><span class="s3">\n    </span><span class="s1">'case': 'keyword',</span><span class="s3">\n    </span><span class="s1">'datatype': 'keyword',</span><span class="s3">\n    </span><span class="s1">'fn': 'keyword',</span><span class="s3">\n    </span><span class="s1">'handle': 'keyword',</span><span class="s3">\n    </span><span class="s1">'infix': 'keyword',</span><span class="s3">\n    </span><span class="s1">'infixr': 'keyword',</span><span class="s3">\n    </span><span class="s1">'local': 'keyword',</span><span class="s3">\n    </span><span class="s1">'nonfix': 'keyword',</span><span class="s3">\n    </span><span class="s1">'op': 'keyword',</span><span class="s3">\n    </span><span class="s1">'orelse': 'keyword',</span><span class="s3">\n    </span><span class="s1">'raise': 'keyword',</span><span class="s3">\n    </span><span class="s1">'withtype': 'keyword',</span><span class="s3">\n    </span><span class="s1">'eqtype': 'keyword',</span><span class="s3">\n    </span><span class="s1">'sharing': 'keyword',</span><span class="s3">\n    </span><span class="s1">'sig': 'keyword',</span><span class="s3">\n    </span><span class="s1">'signature': 'keyword',</span><span class="s3">\n    </span><span class="s1">'structure': 'keyword',</span><span class="s3">\n    </span><span class="s1">'where': 'keyword',</span><span class="s3">\n    </span><span class="s1">'true': 'keyword',</span><span class="s3">\n    </span><span class="s1">'false': 'keyword',</span><span class="s3">\n\n    </span><span class="s1">// types</span><span class="s3">\n    </span><span class="s1">'int': 'builtin',</span><span class="s3">\n    </span><span class="s1">'real': 'builtin',</span><span class="s3">\n    </span><span class="s1">'string': 'builtin',</span><span class="s3">\n    </span><span class="s1">'char': 'builtin',</span><span class="s3">\n    </span><span class="s1">'bool': 'builtin'</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">slashComments: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>