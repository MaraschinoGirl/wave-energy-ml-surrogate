<html>
<head>
<title>3797.ad30e7a4bf8dc994e5be.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
3797.ad30e7a4bf8dc994e5be.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;3797.ad30e7a4bf8dc994e5be.js?v=ad30e7a4bf8dc994e5be&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;AAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mDAAQ;AAC9D;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mCAAmC;AACzC,MAAM,yCAAyC;AAC/C,MAAM,2CAA2C;AACjD,MAAM,uCAAuC;AAC7C,MAAM,yCAAyC;AAC/C,MAAM,mCAAmC;AACzC,MAAM,mCAAmC;AACzC,MAAM,iCAAiC;AACvC,MAAM,6CAA6C;AACnD,MAAM,2CAA2C;AACjD,MAAM,yCAAyC;AAC/C,MAAM,yCAAyC;AAC/C,MAAM,uCAAuC;AAC7C,MAAM,uCAAuC;AAC7C,MAAM,kFAAkF;AACxF,MAAM,mDAAmD;AACzD,MAAM,yEAAyE;AAC/E,MAAM,mFAAmF;AACzF,MAAM,kEAAkE;AACxE,MAAM,mFAAmF;AACzF,MAAM,2CAA2C;AACjD,MAAM,6CAA6C;AACnD,MAAM,6CAA6C;AACnD,MAAM,6CAA6C;AACnD,MAAM,mDAAmD;AACzD,MAAM,2CAA2C;AACjD,MAAM,yCAAyC;AAC/C,MAAM,mCAAmC;AACzC,MAAM,yCAAyC;AAC/C,MAAM;AACN;;AAE8G&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/highlight/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { NodeProp } from '@lezer/common';</span><span class="s3">\n\n</span><span class="s1">let nextTagID = 0;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Highlighting tags are markers that denote a highlighting category.</span><span class="s3">\n</span><span class="s1">They are [associated](#highlight.styleTags) with parts of a syntax</span><span class="s3">\n</span><span class="s1">tree by a language mode, and then mapped to an actual CSS style by</span><span class="s3">\n</span><span class="s1">a [highlighter](#highlight.Highlighter).</span><span class="s3">\n\n</span><span class="s1">Because syntax tree node types and highlight styles have to be</span><span class="s3">\n</span><span class="s1">able to talk the same language, CodeMirror uses a mostly _closed_</span><span class="s3">\n</span><span class="s1">[vocabulary](#highlight.tags) of syntax tags (as opposed to</span><span class="s3">\n</span><span class="s1">traditional open string-based systems, which make it hard for</span><span class="s3">\n</span><span class="s1">highlighting themes to cover all the tokens produced by the</span><span class="s3">\n</span><span class="s1">various languages).</span><span class="s3">\n\n</span><span class="s1">It _is_ possible to [define](#highlight.Tag^define) your own</span><span class="s3">\n</span><span class="s1">highlighting tags for system-internal use (where you control both</span><span class="s3">\n</span><span class="s1">the language package and the highlighter), but such tags will not</span><span class="s3">\n</span><span class="s1">be picked up by regular highlighters (though you can derive them</span><span class="s3">\n</span><span class="s1">from standard tags to allow highlighters to fall back to those).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Tag {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The set of this tag and all its parent tags, starting with</span><span class="s3">\n    </span><span class="s1">this one itself and sorted in order of decreasing specificity.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The base unmodified tag that this one is based on, if it's</span><span class="s3">\n    </span><span class="s1">modified @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">base, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The modifiers applied to this.base @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">modified) {</span><span class="s3">\n        </span><span class="s1">this.set = set;</span><span class="s3">\n        </span><span class="s1">this.base = base;</span><span class="s3">\n        </span><span class="s1">this.modified = modified;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.id = nextTagID++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a new tag. If `parent` is given, the tag is treated as a</span><span class="s3">\n    </span><span class="s1">sub-tag of that parent, and</span><span class="s3">\n    </span><span class="s1">[highlighters](#highlight.tagHighlighter) that don't mention</span><span class="s3">\n    </span><span class="s1">this tag will try to fall back to the parent tag (or grandparent</span><span class="s3">\n    </span><span class="s1">tag, etc).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(parent) {</span><span class="s3">\n        </span><span class="s1">if (parent === null || parent === void 0 ? void 0 : parent.base)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can not derive from a modified tag</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let tag = new Tag([], null, []);</span><span class="s3">\n        </span><span class="s1">tag.set.push(tag);</span><span class="s3">\n        </span><span class="s1">if (parent)</span><span class="s3">\n            </span><span class="s1">for (let t of parent.set)</span><span class="s3">\n                </span><span class="s1">tag.set.push(t);</span><span class="s3">\n        </span><span class="s1">return tag;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a tag _modifier_, which is a function that, given a tag,</span><span class="s3">\n    </span><span class="s1">will return a tag that is a subtag of the original. Applying the</span><span class="s3">\n    </span><span class="s1">same modifier to a twice tag will return the same value (`m1(t1)</span><span class="s3">\n    </span><span class="s1">== m1(t1)`) and applying multiple modifiers will, regardless or</span><span class="s3">\n    </span><span class="s1">order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).</span><span class="s3">\n    \n    </span><span class="s1">When multiple modifiers are applied to a given base tag, each</span><span class="s3">\n    </span><span class="s1">smaller set of modifiers is registered as a parent, so that for</span><span class="s3">\n    </span><span class="s1">example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,</span><span class="s3">\n    </span><span class="s1">`m1(m3(t1)`, and so on.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static defineModifier() {</span><span class="s3">\n        </span><span class="s1">let mod = new Modifier;</span><span class="s3">\n        </span><span class="s1">return (tag) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (tag.modified.indexOf(mod) &gt; -1)</span><span class="s3">\n                </span><span class="s1">return tag;</span><span class="s3">\n            </span><span class="s1">return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) =&gt; a.id - b.id));</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let nextModifierID = 0;</span><span class="s3">\n</span><span class="s1">class Modifier {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.instances = [];</span><span class="s3">\n        </span><span class="s1">this.id = nextModifierID++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static get(base, mods) {</span><span class="s3">\n        </span><span class="s1">if (!mods.length)</span><span class="s3">\n            </span><span class="s1">return base;</span><span class="s3">\n        </span><span class="s1">let exists = mods[0].instances.find(t =&gt; t.base == base &amp;&amp; sameArray(mods, t.modified));</span><span class="s3">\n        </span><span class="s1">if (exists)</span><span class="s3">\n            </span><span class="s1">return exists;</span><span class="s3">\n        </span><span class="s1">let set = [], tag = new Tag(set, base, mods);</span><span class="s3">\n        </span><span class="s1">for (let m of mods)</span><span class="s3">\n            </span><span class="s1">m.instances.push(tag);</span><span class="s3">\n        </span><span class="s1">let configs = powerSet(mods);</span><span class="s3">\n        </span><span class="s1">for (let parent of base.set)</span><span class="s3">\n            </span><span class="s1">if (!parent.modified.length)</span><span class="s3">\n                </span><span class="s1">for (let config of configs)</span><span class="s3">\n                    </span><span class="s1">set.push(Modifier.get(parent, config));</span><span class="s3">\n        </span><span class="s1">return tag;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameArray(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.length == b.length &amp;&amp; a.every((x, i) =&gt; x == b[i]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function powerSet(array) {</span><span class="s3">\n    </span><span class="s1">let sets = [[]];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; array.length; i++) {</span><span class="s3">\n        </span><span class="s1">for (let j = 0, e = sets.length; j &lt; e; j++) {</span><span class="s3">\n            </span><span class="s1">sets.push(sets[j].concat(array[i]));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return sets.sort((a, b) =&gt; b.length - a.length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This function is used to add a set of tags to a language syntax</span><span class="s3">\n</span><span class="s1">via [`NodeSet.extend`](#common.NodeSet.extend) or</span><span class="s3">\n</span><span class="s1">[`LRParser.configure`](#lr.LRParser.configure).</span><span class="s3">\n\n</span><span class="s1">The argument object maps node selectors to [highlighting</span><span class="s3">\n</span><span class="s1">tags](#highlight.Tag) or arrays of tags.</span><span class="s3">\n\n</span><span class="s1">Node selectors may hold one or more (space-separated) node paths.</span><span class="s3">\n</span><span class="s1">Such a path can be a [node name](#common.NodeType.name), or</span><span class="s3">\n</span><span class="s1">multiple node names (or `*` wildcards) separated by slash</span><span class="s3">\n</span><span class="s1">characters, as in `</span><span class="s3">\&quot;</span><span class="s1">Block/Declaration/VariableName</span><span class="s3">\&quot;</span><span class="s1">`. Such a path</span><span class="s3">\n</span><span class="s1">matches the final node but only if its direct parent nodes are the</span><span class="s3">\n</span><span class="s1">other nodes mentioned. A `*` in such a path matches any parent,</span><span class="s3">\n</span><span class="s1">but only a single level—wildcards that match multiple parents</span><span class="s3">\n</span><span class="s1">aren't supported, both for efficiency reasons and because Lezer</span><span class="s3">\n</span><span class="s1">trees make it rather hard to reason about what they would match.)</span><span class="s3">\n\n</span><span class="s1">A path can be ended with `/...` to indicate that the tag assigned</span><span class="s3">\n</span><span class="s1">to the node should also apply to all child nodes, even if they</span><span class="s3">\n</span><span class="s1">match their own style (by default, only the innermost style is</span><span class="s3">\n</span><span class="s1">used).</span><span class="s3">\n\n</span><span class="s1">When a path ends in `!`, as in `Attribute!`, no further matching</span><span class="s3">\n</span><span class="s1">happens for the node's child nodes, and the entire node gets the</span><span class="s3">\n</span><span class="s1">given style.</span><span class="s3">\n\n</span><span class="s1">In this notation, node names that contain `/`, `!`, `*`, or `...`</span><span class="s3">\n</span><span class="s1">must be quoted as JSON strings.</span><span class="s3">\n\n</span><span class="s1">For example:</span><span class="s3">\n\n</span><span class="s1">```javascript</span><span class="s3">\n</span><span class="s1">parser.withProps(</span><span class="s3">\n  </span><span class="s1">styleTags({</span><span class="s3">\n    </span><span class="s1">// Style Number and BigNumber nodes</span><span class="s3">\n    \&quot;</span><span class="s1">Number BigNumber</span><span class="s3">\&quot;</span><span class="s1">: tags.number,</span><span class="s3">\n    </span><span class="s1">// Style Escape nodes whose parent is String</span><span class="s3">\n    \&quot;</span><span class="s1">String/Escape</span><span class="s3">\&quot;</span><span class="s1">: tags.escape,</span><span class="s3">\n    </span><span class="s1">// Style anything inside Attributes nodes</span><span class="s3">\n    \&quot;</span><span class="s1">Attributes!</span><span class="s3">\&quot;</span><span class="s1">: tags.meta,</span><span class="s3">\n    </span><span class="s1">// Add a style to all content inside Italic nodes</span><span class="s3">\n    \&quot;</span><span class="s1">Italic/...</span><span class="s3">\&quot;</span><span class="s1">: tags.emphasis,</span><span class="s3">\n    </span><span class="s1">// Style InvalidString nodes as both `string` and `invalid`</span><span class="s3">\n    \&quot;</span><span class="s1">InvalidString</span><span class="s3">\&quot;</span><span class="s1">: [tags.string, tags.invalid],</span><span class="s3">\n    </span><span class="s1">// Style the node named </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">as punctuation</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">': tags.punctuation</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">```</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function styleTags(spec) {</span><span class="s3">\n    </span><span class="s1">let byName = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let prop in spec) {</span><span class="s3">\n        </span><span class="s1">let tags = spec[prop];</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(tags))</span><span class="s3">\n            </span><span class="s1">tags = [tags];</span><span class="s3">\n        </span><span class="s1">for (let part of prop.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">if (part) {</span><span class="s3">\n                </span><span class="s1">let pieces = [], mode = 2 /* Mode.Normal */, rest = part;</span><span class="s3">\n                </span><span class="s1">for (let pos = 0;;) {</span><span class="s3">\n                    </span><span class="s1">if (rest == </span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; pos &gt; 0 &amp;&amp; pos + 3 == part.length) {</span><span class="s3">\n                        </span><span class="s1">mode = 1 /* Mode.Inherit */;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">let m = /^</span><span class="s3">\&quot;</span><span class="s1">(?:[^</span><span class="s3">\&quot;\\\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.)*?</span><span class="s3">\&quot;</span><span class="s1">|[^</span><span class="s3">\\</span><span class="s1">/!]+/.exec(rest);</span><span class="s3">\n                    </span><span class="s1">if (!m)</span><span class="s3">\n                        </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid path: </span><span class="s3">\&quot; </span><span class="s1">+ part);</span><span class="s3">\n                    </span><span class="s1">pieces.push(m[0] == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: m[0][0] == '</span><span class="s3">\&quot;</span><span class="s1">' ? JSON.parse(m[0]) : m[0]);</span><span class="s3">\n                    </span><span class="s1">pos += m[0].length;</span><span class="s3">\n                    </span><span class="s1">if (pos == part.length)</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">let next = part[pos++];</span><span class="s3">\n                    </span><span class="s1">if (pos == part.length &amp;&amp; next == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                        </span><span class="s1">mode = 0 /* Mode.Opaque */;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (next != </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid path: </span><span class="s3">\&quot; </span><span class="s1">+ part);</span><span class="s3">\n                    </span><span class="s1">rest = part.slice(pos);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let last = pieces.length - 1, inner = pieces[last];</span><span class="s3">\n                </span><span class="s1">if (!inner)</span><span class="s3">\n                    </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid path: </span><span class="s3">\&quot; </span><span class="s1">+ part);</span><span class="s3">\n                </span><span class="s1">let rule = new Rule(tags, mode, last &gt; 0 ? pieces.slice(0, last) : null);</span><span class="s3">\n                </span><span class="s1">byName[inner] = rule.sort(byName[inner]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ruleNodeProp.add(byName);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const ruleNodeProp = new NodeProp();</span><span class="s3">\n</span><span class="s1">class Rule {</span><span class="s3">\n    </span><span class="s1">constructor(tags, mode, context, next) {</span><span class="s3">\n        </span><span class="s1">this.tags = tags;</span><span class="s3">\n        </span><span class="s1">this.mode = mode;</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n        </span><span class="s1">this.next = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get opaque() { return this.mode == 0 /* Mode.Opaque */; }</span><span class="s3">\n    </span><span class="s1">get inherit() { return this.mode == 1 /* Mode.Inherit */; }</span><span class="s3">\n    </span><span class="s1">sort(other) {</span><span class="s3">\n        </span><span class="s1">if (!other || other.depth &lt; this.depth) {</span><span class="s3">\n            </span><span class="s1">this.next = other;</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">other.next = this.sort(other.next);</span><span class="s3">\n        </span><span class="s1">return other;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get depth() { return this.context ? this.context.length : 0; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Rule.empty = new Rule([], 2 /* Mode.Normal */, null);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Define a [highlighter](#highlight.Highlighter) from an array of</span><span class="s3">\n</span><span class="s1">tag/class pairs. Classes associated with more specific tags will</span><span class="s3">\n</span><span class="s1">take precedence.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function tagHighlighter(tags, options) {</span><span class="s3">\n    </span><span class="s1">let map = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let style of tags) {</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(style.tag))</span><span class="s3">\n            </span><span class="s1">map[style.tag.id] = style.class;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">for (let tag of style.tag)</span><span class="s3">\n                </span><span class="s1">map[tag.id] = style.class;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let { scope, all = null } = options || {};</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">style: (tags) =&gt; {</span><span class="s3">\n            </span><span class="s1">let cls = all;</span><span class="s3">\n            </span><span class="s1">for (let tag of tags) {</span><span class="s3">\n                </span><span class="s1">for (let sub of tag.set) {</span><span class="s3">\n                    </span><span class="s1">let tagClass = map[sub.id];</span><span class="s3">\n                    </span><span class="s1">if (tagClass) {</span><span class="s3">\n                        </span><span class="s1">cls = cls ? cls + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ tagClass : tagClass;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return cls;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">scope</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function highlightTags(highlighters, tags) {</span><span class="s3">\n    </span><span class="s1">let result = null;</span><span class="s3">\n    </span><span class="s1">for (let highlighter of highlighters) {</span><span class="s3">\n        </span><span class="s1">let value = highlighter.style(tags);</span><span class="s3">\n        </span><span class="s1">if (value)</span><span class="s3">\n            </span><span class="s1">result = result ? result + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ value : value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Highlight the given [tree](#common.Tree) with the given</span><span class="s3">\n</span><span class="s1">[highlighter](#highlight.Highlighter). Often, the higher-level</span><span class="s3">\n</span><span class="s1">[`highlightCode`](#highlight.highlightCode) function is easier to</span><span class="s3">\n</span><span class="s1">use.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightTree(tree, highlighter, </span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Assign styling to a region of the text. Will be called, in order</span><span class="s3">\n</span><span class="s1">of position, for any ranges where more than zero classes apply.</span><span class="s3">\n</span><span class="s1">`classes` is a space separated string of CSS classes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">putStyle, </span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The start of the range to highlight.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">from = 0, </span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The end of the range.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">to = tree.length) {</span><span class="s3">\n    </span><span class="s1">let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);</span><span class="s3">\n    </span><span class="s1">builder.highlightRange(tree.cursor(), from, to, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, builder.highlighters);</span><span class="s3">\n    </span><span class="s1">builder.flush(to);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Highlight the given tree with the given highlighter, calling</span><span class="s3">\n</span><span class="s1">`putText` for every piece of text, either with a set of classes or</span><span class="s3">\n</span><span class="s1">with the empty string when unstyled, and `putBreak` for every line</span><span class="s3">\n</span><span class="s1">break.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {</span><span class="s3">\n    </span><span class="s1">let pos = from;</span><span class="s3">\n    </span><span class="s1">function writeTo(p, classes) {</span><span class="s3">\n        </span><span class="s1">if (p &lt;= pos)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">for (let text = code.slice(pos, p), i = 0;;) {</span><span class="s3">\n            </span><span class="s1">let nextBreak = text.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, i);</span><span class="s3">\n            </span><span class="s1">let upto = nextBreak &lt; 0 ? text.length : nextBreak;</span><span class="s3">\n            </span><span class="s1">if (upto &gt; i)</span><span class="s3">\n                </span><span class="s1">putText(text.slice(i, upto), classes);</span><span class="s3">\n            </span><span class="s1">if (nextBreak &lt; 0)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">putBreak();</span><span class="s3">\n            </span><span class="s1">i = nextBreak + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pos = p;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">highlightTree(tree, highlighter, (from, to, classes) =&gt; {</span><span class="s3">\n        </span><span class="s1">writeTo(from, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">writeTo(to, classes);</span><span class="s3">\n    </span><span class="s1">}, from, to);</span><span class="s3">\n    </span><span class="s1">writeTo(to, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HighlightBuilder {</span><span class="s3">\n    </span><span class="s1">constructor(at, highlighters, span) {</span><span class="s3">\n        </span><span class="s1">this.at = at;</span><span class="s3">\n        </span><span class="s1">this.highlighters = highlighters;</span><span class="s3">\n        </span><span class="s1">this.span = span;</span><span class="s3">\n        </span><span class="s1">this.class = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startSpan(at, cls) {</span><span class="s3">\n        </span><span class="s1">if (cls != this.class) {</span><span class="s3">\n            </span><span class="s1">this.flush(at);</span><span class="s3">\n            </span><span class="s1">if (at &gt; this.at)</span><span class="s3">\n                </span><span class="s1">this.at = at;</span><span class="s3">\n            </span><span class="s1">this.class = cls;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flush(to) {</span><span class="s3">\n        </span><span class="s1">if (to &gt; this.at &amp;&amp; this.class)</span><span class="s3">\n            </span><span class="s1">this.span(this.at, to, this.class);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">highlightRange(cursor, from, to, inheritedClass, highlighters) {</span><span class="s3">\n        </span><span class="s1">let { type, from: start, to: end } = cursor;</span><span class="s3">\n        </span><span class="s1">if (start &gt;= to || end &lt;= from)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (type.isTop)</span><span class="s3">\n            </span><span class="s1">highlighters = this.highlighters.filter(h =&gt; !h.scope || h.scope(type));</span><span class="s3">\n        </span><span class="s1">let cls = inheritedClass;</span><span class="s3">\n        </span><span class="s1">let rule = getStyleTags(cursor) || Rule.empty;</span><span class="s3">\n        </span><span class="s1">let tagCls = highlightTags(highlighters, rule.tags);</span><span class="s3">\n        </span><span class="s1">if (tagCls) {</span><span class="s3">\n            </span><span class="s1">if (cls)</span><span class="s3">\n                </span><span class="s1">cls += </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">cls += tagCls;</span><span class="s3">\n            </span><span class="s1">if (rule.mode == 1 /* Mode.Inherit */)</span><span class="s3">\n                </span><span class="s1">inheritedClass += (inheritedClass ? </span><span class="s3">\&quot; \&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + tagCls;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.startSpan(Math.max(from, start), cls);</span><span class="s3">\n        </span><span class="s1">if (rule.opaque)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let mounted = cursor.tree &amp;&amp; cursor.tree.prop(NodeProp.mounted);</span><span class="s3">\n        </span><span class="s1">if (mounted &amp;&amp; mounted.overlay) {</span><span class="s3">\n            </span><span class="s1">let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);</span><span class="s3">\n            </span><span class="s1">let innerHighlighters = this.highlighters.filter(h =&gt; !h.scope || h.scope(mounted.tree.type));</span><span class="s3">\n            </span><span class="s1">let hasChild = cursor.firstChild();</span><span class="s3">\n            </span><span class="s1">for (let i = 0, pos = start;; i++) {</span><span class="s3">\n                </span><span class="s1">let next = i &lt; mounted.overlay.length ? mounted.overlay[i] : null;</span><span class="s3">\n                </span><span class="s1">let nextPos = next ? next.from + start : end;</span><span class="s3">\n                </span><span class="s1">let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);</span><span class="s3">\n                </span><span class="s1">if (rangeFrom &lt; rangeTo &amp;&amp; hasChild) {</span><span class="s3">\n                    </span><span class="s1">while (cursor.from &lt; rangeTo) {</span><span class="s3">\n                        </span><span class="s1">this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);</span><span class="s3">\n                        </span><span class="s1">this.startSpan(Math.min(rangeTo, cursor.to), cls);</span><span class="s3">\n                        </span><span class="s1">if (cursor.to &gt;= nextPos || !cursor.nextSibling())</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!next || nextPos &gt; to)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">pos = next.to + start;</span><span class="s3">\n                </span><span class="s1">if (pos &gt; from) {</span><span class="s3">\n                    </span><span class="s1">this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), </span><span class="s3">\&quot;\&quot;</span><span class="s1">, innerHighlighters);</span><span class="s3">\n                    </span><span class="s1">this.startSpan(Math.min(to, pos), cls);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (hasChild)</span><span class="s3">\n                </span><span class="s1">cursor.parent();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (cursor.firstChild()) {</span><span class="s3">\n            </span><span class="s1">if (mounted)</span><span class="s3">\n                </span><span class="s1">inheritedClass = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">if (cursor.to &lt;= from)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">if (cursor.from &gt;= to)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">this.highlightRange(cursor, from, to, inheritedClass, highlighters);</span><span class="s3">\n                </span><span class="s1">this.startSpan(Math.min(to, cursor.to), cls);</span><span class="s3">\n            </span><span class="s1">} while (cursor.nextSibling());</span><span class="s3">\n            </span><span class="s1">cursor.parent();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Match a syntax node's [highlight rules](#highlight.styleTags). If</span><span class="s3">\n</span><span class="s1">there's a match, return its set of tags, and whether it is</span><span class="s3">\n</span><span class="s1">opaque (uses a `!`) or applies to all child nodes (`/...`).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getStyleTags(node) {</span><span class="s3">\n    </span><span class="s1">let rule = node.type.prop(ruleNodeProp);</span><span class="s3">\n    </span><span class="s1">while (rule &amp;&amp; rule.context &amp;&amp; !node.matchContext(rule.context))</span><span class="s3">\n        </span><span class="s1">rule = rule.next;</span><span class="s3">\n    </span><span class="s1">return rule || null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const t = Tag.define;</span><span class="s3">\n</span><span class="s1">const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The default set of highlighting [tags](#highlight.Tag).</span><span class="s3">\n\n</span><span class="s1">This collection is heavily biased towards programming languages,</span><span class="s3">\n</span><span class="s1">and necessarily incomplete. A full ontology of syntactic</span><span class="s3">\n</span><span class="s1">constructs would fill a stack of books, and be impractical to</span><span class="s3">\n</span><span class="s1">write themes for. So try to make do with this set. If all else</span><span class="s3">\n</span><span class="s1">fails, [open an</span><span class="s3">\n</span><span class="s1">issue](https://github.com/codemirror/codemirror.next) to propose a</span><span class="s3">\n</span><span class="s1">new tag, or [define](#highlight.Tag^define) a local custom tag for</span><span class="s3">\n</span><span class="s1">your use case.</span><span class="s3">\n\n</span><span class="s1">Note that it is not obligatory to always attach the most specific</span><span class="s3">\n</span><span class="s1">tag possible to an element—if your grammar can't easily</span><span class="s3">\n</span><span class="s1">distinguish a certain type of element (such as a local variable),</span><span class="s3">\n</span><span class="s1">it is okay to style it as its more general variant (a variable).</span><span class="s3">\n\n</span><span class="s1">For tags that extend some parent tag, the documentation links to</span><span class="s3">\n</span><span class="s1">the parent.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const tags = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A comment.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">comment,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A line [comment](#highlight.tags.comment).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lineComment: t(comment),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A block [comment](#highlight.tags.comment).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">blockComment: t(comment),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A documentation [comment](#highlight.tags.comment).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">docComment: t(comment),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Any kind of identifier.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [name](#highlight.tags.name) of a variable.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">variableName: t(name),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A type [name](#highlight.tags.name).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">typeName: typeName,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A tag name (subtag of [`typeName`](#highlight.tags.typeName)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">tagName: t(typeName),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A property or field [name](#highlight.tags.name).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">propertyName: propertyName,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">attributeName: t(propertyName),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [name](#highlight.tags.name) of a class.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">className: t(name),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A label [name](#highlight.tags.name).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">labelName: t(name),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A namespace [name](#highlight.tags.name).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">namespace: t(name),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [name](#highlight.tags.name) of a macro.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">macroName: t(name),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A literal value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">literal,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A string [literal](#highlight.tags.literal).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">string,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A documentation [string](#highlight.tags.string).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">docString: t(string),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A character literal (subtag of [string](#highlight.tags.string)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">character: t(string),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An attribute value (subtag of [string](#highlight.tags.string)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">attributeValue: t(string),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A number [literal](#highlight.tags.literal).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">number,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An integer [number](#highlight.tags.number) literal.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">integer: t(number),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A floating-point [number](#highlight.tags.number) literal.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">float: t(number),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A boolean [literal](#highlight.tags.literal).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">bool: t(literal),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Regular expression [literal](#highlight.tags.literal).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">regexp: t(literal),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An escape [literal](#highlight.tags.literal), for example a</span><span class="s3">\n    </span><span class="s1">backslash escape in a string.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">escape: t(literal),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A color [literal](#highlight.tags.literal).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">color: t(literal),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A URL [literal](#highlight.tags.literal).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">url: t(literal),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A language keyword.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">keyword,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [keyword](#highlight.tags.keyword) for the self or this</span><span class="s3">\n    </span><span class="s1">object.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">self: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [keyword](#highlight.tags.keyword) for null.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">null: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A [keyword](#highlight.tags.keyword) denoting some atomic value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">atom: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A [keyword](#highlight.tags.keyword) that represents a unit.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">unit: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A modifier [keyword](#highlight.tags.keyword).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">modifier: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A [keyword](#highlight.tags.keyword) that acts as an operator.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">operatorKeyword: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A control-flow related [keyword](#highlight.tags.keyword).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">controlKeyword: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A [keyword](#highlight.tags.keyword) that defines something.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">definitionKeyword: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A [keyword](#highlight.tags.keyword) related to defining or</span><span class="s3">\n    </span><span class="s1">interfacing with modules.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moduleKeyword: t(keyword),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An operator.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">operator,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An [operator](#highlight.tags.operator) that dereferences something.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">derefOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Arithmetic-related [operator](#highlight.tags.operator).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">arithmeticOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Logical [operator](#highlight.tags.operator).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">logicOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Bit [operator](#highlight.tags.operator).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">bitwiseOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Comparison [operator](#highlight.tags.operator).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compareOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Operator](#highlight.tags.operator) that updates its operand.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Operator](#highlight.tags.operator) that defines something.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">definitionOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Type-related [operator](#highlight.tags.operator).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">typeOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Control-flow [operator](#highlight.tags.operator).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">controlOperator: t(operator),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Program or markup punctuation.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">punctuation,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Punctuation](#highlight.tags.punctuation) that separates</span><span class="s3">\n    </span><span class="s1">things.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">separator: t(punctuation),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Bracket-style [punctuation](#highlight.tags.punctuation).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">bracket,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Angle [brackets](#highlight.tags.bracket) (usually `&lt;` and `&gt;`</span><span class="s3">\n    </span><span class="s1">tokens).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">angleBracket: t(bracket),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Square [brackets](#highlight.tags.bracket) (usually `[` and `]`</span><span class="s3">\n    </span><span class="s1">tokens).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">squareBracket: t(bracket),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Parentheses (usually `(` and `)` tokens). Subtag of</span><span class="s3">\n    </span><span class="s1">[bracket](#highlight.tags.bracket).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">paren: t(bracket),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Braces (usually `{` and `}` tokens). Subtag of</span><span class="s3">\n    </span><span class="s1">[bracket](#highlight.tags.bracket).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">brace: t(bracket),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Content, for example plain text in XML or markup documents.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">content,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that represents a heading.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A level 1 [heading](#highlight.tags.heading).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading1: t(heading),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A level 2 [heading](#highlight.tags.heading).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading2: t(heading),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A level 3 [heading](#highlight.tags.heading).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading3: t(heading),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A level 4 [heading](#highlight.tags.heading).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading4: t(heading),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A level 5 [heading](#highlight.tags.heading).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading5: t(heading),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A level 6 [heading](#highlight.tags.heading).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">heading6: t(heading),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A prose separator (such as a horizontal rule).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">contentSeparator: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that represents a list.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">list: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that represents a quote.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">quote: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that is emphasized.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">emphasis: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that is styled strong.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">strong: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that is part of a link.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">link: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that is styled as code or</span><span class="s3">\n    </span><span class="s1">monospace.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">monospace: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Content](#highlight.tags.content) that has a strike-through</span><span class="s3">\n    </span><span class="s1">style.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">strikethrough: t(content),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Inserted text in a change-tracking format.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">inserted: t(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Deleted text.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">deleted: t(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Changed text.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">changed: t(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An invalid or unsyntactic element.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">invalid: t(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Metadata or meta-instruction.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">meta,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Metadata](#highlight.tags.meta) that applies to the entire</span><span class="s3">\n    </span><span class="s1">document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">documentMeta: t(meta),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Metadata](#highlight.tags.meta) that annotates or adds</span><span class="s3">\n    </span><span class="s1">attributes to a given syntactic element.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">annotation: t(meta),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Processing instruction or preprocessor directive. Subtag of</span><span class="s3">\n    </span><span class="s1">[meta](#highlight.tags.meta).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">processingInstruction: t(meta),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Modifier](#highlight.Tag^defineModifier) that indicates that a</span><span class="s3">\n    </span><span class="s1">given element is being defined. Expected to be used with the</span><span class="s3">\n    </span><span class="s1">various [name](#highlight.tags.name) tags.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">definition: Tag.defineModifier(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Modifier](#highlight.Tag^defineModifier) that indicates that</span><span class="s3">\n    </span><span class="s1">something is constant. Mostly expected to be used with</span><span class="s3">\n    </span><span class="s1">[variable names](#highlight.tags.variableName).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constant: Tag.defineModifier(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Modifier](#highlight.Tag^defineModifier) used to indicate that</span><span class="s3">\n    </span><span class="s1">a [variable](#highlight.tags.variableName) or [property</span><span class="s3">\n    </span><span class="s1">name](#highlight.tags.propertyName) is being called or defined</span><span class="s3">\n    </span><span class="s1">as a function.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function: Tag.defineModifier(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Modifier](#highlight.Tag^defineModifier) that can be applied to</span><span class="s3">\n    </span><span class="s1">[names](#highlight.tags.name) to indicate that they belong to</span><span class="s3">\n    </span><span class="s1">the language's standard environment.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">standard: Tag.defineModifier(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">[Modifier](#highlight.Tag^defineModifier) that indicates a given</span><span class="s3">\n    </span><span class="s1">[names](#highlight.tags.name) is local to some scope.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">local: Tag.defineModifier(),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A generic variant [modifier](#highlight.Tag^defineModifier) that</span><span class="s3">\n    </span><span class="s1">can be used to tag language-specific alternative variants of</span><span class="s3">\n    </span><span class="s1">some common tag. It is recommended for themes to define special</span><span class="s3">\n    </span><span class="s1">forms of at least the [string](#highlight.tags.string) and</span><span class="s3">\n    </span><span class="s1">[variable name](#highlight.tags.variableName) tags, since those</span><span class="s3">\n    </span><span class="s1">come up a lot.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">special: Tag.defineModifier()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This is a highlighter that adds stable, predictable classes to</span><span class="s3">\n</span><span class="s1">tokens, for styling with external CSS.</span><span class="s3">\n\n</span><span class="s1">The following tags are mapped to their name prefixed with `</span><span class="s3">\&quot;</span><span class="s1">tok-</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">(for example `</span><span class="s3">\&quot;</span><span class="s1">tok-comment</span><span class="s3">\&quot;</span><span class="s1">`):</span><span class="s3">\n\n</span><span class="s1">* [`link`](#highlight.tags.link)</span><span class="s3">\n</span><span class="s1">* [`heading`](#highlight.tags.heading)</span><span class="s3">\n</span><span class="s1">* [`emphasis`](#highlight.tags.emphasis)</span><span class="s3">\n</span><span class="s1">* [`strong`](#highlight.tags.strong)</span><span class="s3">\n</span><span class="s1">* [`keyword`](#highlight.tags.keyword)</span><span class="s3">\n</span><span class="s1">* [`atom`](#highlight.tags.atom)</span><span class="s3">\n</span><span class="s1">* [`bool`](#highlight.tags.bool)</span><span class="s3">\n</span><span class="s1">* [`url`](#highlight.tags.url)</span><span class="s3">\n</span><span class="s1">* [`labelName`](#highlight.tags.labelName)</span><span class="s3">\n</span><span class="s1">* [`inserted`](#highlight.tags.inserted)</span><span class="s3">\n</span><span class="s1">* [`deleted`](#highlight.tags.deleted)</span><span class="s3">\n</span><span class="s1">* [`literal`](#highlight.tags.literal)</span><span class="s3">\n</span><span class="s1">* [`string`](#highlight.tags.string)</span><span class="s3">\n</span><span class="s1">* [`number`](#highlight.tags.number)</span><span class="s3">\n</span><span class="s1">* [`variableName`](#highlight.tags.variableName)</span><span class="s3">\n</span><span class="s1">* [`typeName`](#highlight.tags.typeName)</span><span class="s3">\n</span><span class="s1">* [`namespace`](#highlight.tags.namespace)</span><span class="s3">\n</span><span class="s1">* [`className`](#highlight.tags.className)</span><span class="s3">\n</span><span class="s1">* [`macroName`](#highlight.tags.macroName)</span><span class="s3">\n</span><span class="s1">* [`propertyName`](#highlight.tags.propertyName)</span><span class="s3">\n</span><span class="s1">* [`operator`](#highlight.tags.operator)</span><span class="s3">\n</span><span class="s1">* [`comment`](#highlight.tags.comment)</span><span class="s3">\n</span><span class="s1">* [`meta`](#highlight.tags.meta)</span><span class="s3">\n</span><span class="s1">* [`punctuation`](#highlight.tags.punctuation)</span><span class="s3">\n</span><span class="s1">* [`invalid`](#highlight.tags.invalid)</span><span class="s3">\n\n</span><span class="s1">In addition, these mappings are provided:</span><span class="s3">\n\n</span><span class="s1">* [`regexp`](#highlight.tags.regexp),</span><span class="s3">\n  </span><span class="s1">[`escape`](#highlight.tags.escape), and</span><span class="s3">\n  </span><span class="s1">[`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)</span><span class="s3">\n  </span><span class="s1">are mapped to `</span><span class="s3">\&quot;</span><span class="s1">tok-string2</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)</span><span class="s3">\n  </span><span class="s1">to `</span><span class="s3">\&quot;</span><span class="s1">tok-variableName2</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)</span><span class="s3">\n  </span><span class="s1">to `</span><span class="s3">\&quot;</span><span class="s1">tok-variableName tok-local</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)</span><span class="s3">\n  </span><span class="s1">to `</span><span class="s3">\&quot;</span><span class="s1">tok-variableName tok-definition</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)</span><span class="s3">\n  </span><span class="s1">to `</span><span class="s3">\&quot;</span><span class="s1">tok-propertyName tok-definition</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const classHighlighter = tagHighlighter([</span><span class="s3">\n    </span><span class="s1">{ tag: tags.link, class: </span><span class="s3">\&quot;</span><span class="s1">tok-link</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.heading, class: </span><span class="s3">\&quot;</span><span class="s1">tok-heading</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.emphasis, class: </span><span class="s3">\&quot;</span><span class="s1">tok-emphasis</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.strong, class: </span><span class="s3">\&quot;</span><span class="s1">tok-strong</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.keyword, class: </span><span class="s3">\&quot;</span><span class="s1">tok-keyword</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.atom, class: </span><span class="s3">\&quot;</span><span class="s1">tok-atom</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.bool, class: </span><span class="s3">\&quot;</span><span class="s1">tok-bool</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.url, class: </span><span class="s3">\&quot;</span><span class="s1">tok-url</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.labelName, class: </span><span class="s3">\&quot;</span><span class="s1">tok-labelName</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.inserted, class: </span><span class="s3">\&quot;</span><span class="s1">tok-inserted</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.deleted, class: </span><span class="s3">\&quot;</span><span class="s1">tok-deleted</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.literal, class: </span><span class="s3">\&quot;</span><span class="s1">tok-literal</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.string, class: </span><span class="s3">\&quot;</span><span class="s1">tok-string</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.number, class: </span><span class="s3">\&quot;</span><span class="s1">tok-number</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: </span><span class="s3">\&quot;</span><span class="s1">tok-string2</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.variableName, class: </span><span class="s3">\&quot;</span><span class="s1">tok-variableName</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.local(tags.variableName), class: </span><span class="s3">\&quot;</span><span class="s1">tok-variableName tok-local</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.definition(tags.variableName), class: </span><span class="s3">\&quot;</span><span class="s1">tok-variableName tok-definition</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.special(tags.variableName), class: </span><span class="s3">\&quot;</span><span class="s1">tok-variableName2</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.definition(tags.propertyName), class: </span><span class="s3">\&quot;</span><span class="s1">tok-propertyName tok-definition</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.typeName, class: </span><span class="s3">\&quot;</span><span class="s1">tok-typeName</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.namespace, class: </span><span class="s3">\&quot;</span><span class="s1">tok-namespace</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.className, class: </span><span class="s3">\&quot;</span><span class="s1">tok-className</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.macroName, class: </span><span class="s3">\&quot;</span><span class="s1">tok-macroName</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.propertyName, class: </span><span class="s3">\&quot;</span><span class="s1">tok-propertyName</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.operator, class: </span><span class="s3">\&quot;</span><span class="s1">tok-operator</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.comment, class: </span><span class="s3">\&quot;</span><span class="s1">tok-comment</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.meta, class: </span><span class="s3">\&quot;</span><span class="s1">tok-meta</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.invalid, class: </span><span class="s3">\&quot;</span><span class="s1">tok-invalid</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.punctuation, class: </span><span class="s3">\&quot;</span><span class="s1">tok-punctuation</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">export { Tag, classHighlighter, getStyleTags, highlightCode, highlightTree, styleTags, tagHighlighter, tags };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>