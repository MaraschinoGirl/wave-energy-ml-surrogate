<html>
<head>
<title>757.86f80ac05f38c4f4be68.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
757.86f80ac05f38c4f4be68.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;757.86f80ac05f38c4f4be68.js?v=86f80ac05f38c4f4be68&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;AAAA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;ACvL7B,eAAe,KAAiD,kBAAkB,mBAAO,CAAC,KAAO,GAAG,CAAuJ,CAAC,CAAC,qBAAM,cAAc,mBAAmB,SAAS,cAAc,4BAA4B,YAAY,qBAAqB,2DAA2D,uCAAuC,qCAAqC,oBAAoB,EAAE,iBAAiB,4FAA4F,eAAe,wCAAwC,SAAS,EAAE,mBAAmB,8BAA8B,qDAAqD,0BAA0B,6CAA6C,sBAAsB,6DAA6D,YAAY,eAAe,SAAS,iB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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAO,CAAC,KAA2B;AACxD,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,KAAgB;AAClD,YAAY,mBAAO,CAAC,KAAkB;AACtC,cAAc,mBAAO,CAAC,KAAmB;AACzC,eAAe,mBAAO,CAAC,KAAU;AACjC,cAAc,mBAAO,CAAC,KAAS;;;;;;;;AC5I/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,SAAS;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AA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ACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,WAAW,GAAG,WAAW,GAAG,WAAW;AAC7D;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA,sBAAsB,q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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxFA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClCA;AACA,SAAS,OAAO;AAChB,EAAE,OAAO;AACT,EAAE,OAAO;AACT,qBAAqB,OAAO;AAC5B;AACA;;AAEA;;;;;;;;ACRA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACvCA;AACA,oCAAoC,aAAa;AACjD,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,KAAa;AACzB,cAAc,mBAAO,CAAC,KAAS;AAC/B;;AAEA;AACA,WAAW,UAAU;AACrB,eAAe,cAAc;AAC7B,YAAY,WAAW;AACvB,UAAU,SAAS;AACnB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM,YAAY,OAAO,IAAI,KAAK;AAClD,gBAAgB,MAAM,YAAY,OAAO,IAAI,KAAK;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5DA,eAAe,mBAAO,CAAC,KAAmB;AAC1C,mBAAmB,mBAAO,CAAC,KAAuB;AAClD,QAAQ,MAAM;AACd,cAAc,mBAAO,CAAC,KAAkB;AACxC,kBAAkB,mBAAO,CAAC,KAAwB;AAClD,WAAW,mBAAO,CAAC,KAAiB;AACpC,WAAW,mBAAO,CAAC,KAAiB;AACpC,YAAY,mBAAO,CAAC,IAAkB;AACtC,YAAY,mBAAO,CAAC,KAAkB;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/EA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,KAA2B;AACrD,gBAAgB,mBAAO,CAAC,KAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,uBAAuB,IAAI;AAC3B,MAAM;AACN,uBAAuB,IAAI;AAC3B,MAAM;AACN,qBAAqB,KAAK,IAAI,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9CA,cAAc,mBAAO,CAAC,KAAqB;AAC3C,mBAAmB,mBAAO,CAAC,KAA0B;AACrD,QAAQ,MAAM;AACd,kBAAkB,mBAAO,CAAC,KAA2B;AACrD,gBAAgB,mBAAO,CAAC,KAAyB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtPA,cAAc,mBAAO,CAAC,KAAkB;;AAExC;AACA;AACA;AACA;;AAEA;;;;;;;;ACPA,cAAc,mBAAO,CAAC,KAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/process/browser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/react-paginate/dist/react-paginate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/classes/comparator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/classes/range.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/classes/semver.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/clean.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/cmp.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/coerce.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/compare-build.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/compare-loose.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/compare.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/diff.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/eq.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/gt.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/gte.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/inc.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/lt.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/lte.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/major.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/minor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/neq.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/parse.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/patch.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/prerelease.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/rcompare.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/rsort.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/satisfies.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/sort.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/functions/valid.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/internal/constants.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/internal/debug.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/internal/identifiers.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/internal/lrucache.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/internal/parse-options.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/internal/re.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/gtr.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/intersects.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/ltr.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/max-satisfying.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/min-satisfying.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/min-version.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/outside.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/simplify.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/subset.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/to-comparators.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/semver/ranges/valid.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// shim for using process in browser</span><span class="s3">\n</span><span class="s1">var process = module.exports = {};</span><span class="s3">\n\n</span><span class="s1">// cached from whatever global is present so that test runners that stub it</span><span class="s3">\n</span><span class="s1">// don't break things.  But we need to wrap it in a try catch in case it is</span><span class="s3">\n</span><span class="s1">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span><span class="s3">\n</span><span class="s1">// function because try/catches deoptimize in certain engines.</span><span class="s3">\n\n</span><span class="s1">var cachedSetTimeout;</span><span class="s3">\n</span><span class="s1">var cachedClearTimeout;</span><span class="s3">\n\n</span><span class="s1">function defaultSetTimout() {</span><span class="s3">\n    </span><span class="s1">throw new Error('setTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultClearTimeout () {</span><span class="s3">\n    </span><span class="s1">throw new Error('clearTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function () {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof setTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof clearTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} ())</span><span class="s3">\n</span><span class="s1">function runTimeout(fun) {</span><span class="s3">\n    </span><span class="s1">if (cachedSetTimeout === setTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if setTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedSetTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">} catch(e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(null, fun, 0);</span><span class="s3">\n        </span><span class="s1">} catch(e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(this, fun, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function runClearTimeout(marker) {</span><span class="s3">\n    </span><span class="s1">if (cachedClearTimeout === clearTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if clearTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedClearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">} catch (e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(null, marker);</span><span class="s3">\n        </span><span class="s1">} catch (e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span><span class="s3">\n            </span><span class="s1">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(this, marker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var queue = [];</span><span class="s3">\n</span><span class="s1">var draining = false;</span><span class="s3">\n</span><span class="s1">var currentQueue;</span><span class="s3">\n</span><span class="s1">var queueIndex = -1;</span><span class="s3">\n\n</span><span class="s1">function cleanUpNextTick() {</span><span class="s3">\n    </span><span class="s1">if (!draining || !currentQueue) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">if (currentQueue.length) {</span><span class="s3">\n        </span><span class="s1">queue = currentQueue.concat(queue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (queue.length) {</span><span class="s3">\n        </span><span class="s1">drainQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function drainQueue() {</span><span class="s3">\n    </span><span class="s1">if (draining) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var timeout = runTimeout(cleanUpNextTick);</span><span class="s3">\n    </span><span class="s1">draining = true;</span><span class="s3">\n\n    </span><span class="s1">var len = queue.length;</span><span class="s3">\n    </span><span class="s1">while(len) {</span><span class="s3">\n        </span><span class="s1">currentQueue = queue;</span><span class="s3">\n        </span><span class="s1">queue = [];</span><span class="s3">\n        </span><span class="s1">while (++queueIndex &lt; len) {</span><span class="s3">\n            </span><span class="s1">if (currentQueue) {</span><span class="s3">\n                </span><span class="s1">currentQueue[queueIndex].run();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n        </span><span class="s1">len = queue.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currentQueue = null;</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">runClearTimeout(timeout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">process.nextTick = function (fun) {</span><span class="s3">\n    </span><span class="s1">var args = new Array(arguments.length - 1);</span><span class="s3">\n    </span><span class="s1">if (arguments.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">for (var i = 1; i &lt; arguments.length; i++) {</span><span class="s3">\n            </span><span class="s1">args[i - 1] = arguments[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">queue.push(new Item(fun, args));</span><span class="s3">\n    </span><span class="s1">if (queue.length === 1 &amp;&amp; !draining) {</span><span class="s3">\n        </span><span class="s1">runTimeout(drainQueue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// v8 likes predictible objects</span><span class="s3">\n</span><span class="s1">function Item(fun, array) {</span><span class="s3">\n    </span><span class="s1">this.fun = fun;</span><span class="s3">\n    </span><span class="s1">this.array = array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Item.prototype.run = function () {</span><span class="s3">\n    </span><span class="s1">this.fun.apply(null, this.array);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.title = 'browser';</span><span class="s3">\n</span><span class="s1">process.browser = true;</span><span class="s3">\n</span><span class="s1">process.env = {};</span><span class="s3">\n</span><span class="s1">process.argv = [];</span><span class="s3">\n</span><span class="s1">process.version = ''; // empty string to avoid regexp issues</span><span class="s3">\n</span><span class="s1">process.versions = {};</span><span class="s3">\n\n</span><span class="s1">function noop() {}</span><span class="s3">\n\n</span><span class="s1">process.on = noop;</span><span class="s3">\n</span><span class="s1">process.addListener = noop;</span><span class="s3">\n</span><span class="s1">process.once = noop;</span><span class="s3">\n</span><span class="s1">process.off = noop;</span><span class="s3">\n</span><span class="s1">process.removeListener = noop;</span><span class="s3">\n</span><span class="s1">process.removeAllListeners = noop;</span><span class="s3">\n</span><span class="s1">process.emit = noop;</span><span class="s3">\n</span><span class="s1">process.prependListener = noop;</span><span class="s3">\n</span><span class="s1">process.prependOnceListener = noop;</span><span class="s3">\n\n</span><span class="s1">process.listeners = function (name) { return [] }</span><span class="s3">\n\n</span><span class="s1">process.binding = function (name) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.binding is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">process.cwd = function () { return '/' };</span><span class="s3">\n</span><span class="s1">process.chdir = function (dir) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.chdir is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.umask = function() { return 0; };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;!function(e,a){</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof exports&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof module?module.exports=a(require(</span><span class="s3">\&quot;</span><span class="s1">react</span><span class="s3">\&quot;</span><span class="s1">)):</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof define&amp;&amp;define.amd?define([</span><span class="s3">\&quot;</span><span class="s1">react</span><span class="s3">\&quot;</span><span class="s1">],a):</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof exports?exports.ReactPaginate=a(require(</span><span class="s3">\&quot;</span><span class="s1">react</span><span class="s3">\&quot;</span><span class="s1">)):e.ReactPaginate=a(e.React)}(global,(function(e){return function(e){var a={};function t(r){if(a[r])return a[r].exports;var n=a[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=a,t.d=function(e,a,r){t.o(e,a)||Object.defineProperty(e,a,{enumerable:!0,get:r})},t.r=function(e){</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:</span><span class="s3">\&quot;</span><span class="s1">Module</span><span class="s3">\&quot;</span><span class="s1">}),Object.defineProperty(e,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:!0})},t.t=function(e,a){if(1&amp;a&amp;&amp;(e=t(e)),8&amp;a)return e;if(4&amp;a&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">,{enumerable:!0,value:e}),2&amp;a&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">!=typeof e)for(var n in e)t.d(r,n,function(a){return e[a]}.bind(null,n));return r},t.n=function(e){var a=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return t.d(a,</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,a),a},t.o=function(e,a){return Object.prototype.hasOwnProperty.call(e,a)},t.p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,t(t.s=4)}([function(e,a,t){e.exports=t(2)()},function(a,t){a.exports=e},function(e,a,t){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var r=t(3);function n(){}function i(){}i.resetWarningCache=n,e.exports=function(){function e(e,a,t,n,i,o){if(o!==r){var s=new Error(</span><span class="s3">\&quot;</span><span class="s1">Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types</span><span class="s3">\&quot;</span><span class="s1">);throw s.name=</span><span class="s3">\&quot;</span><span class="s1">Invariant Violation</span><span class="s3">\&quot;</span><span class="s1">,s}}function a(){return e}e.isRequired=e;var t={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:a,element:e,elementType:e,instanceOf:a,node:e,objectOf:a,oneOf:a,oneOfType:a,shape:a,exact:a,checkPropTypes:i,resetWarningCache:n};return t.PropTypes=t,t}},function(e,a,t){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;e.exports=</span><span class="s3">\&quot;</span><span class="s1">SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED</span><span class="s3">\&quot;</span><span class="s1">},function(e,a,t){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;t.r(a);var r=t(1),n=t.n(r),i=t(0),o=t.n(i);function s(){return(s=Object.assign||function(e){for(var a=1;a&lt;arguments.length;a++){var t=arguments[a];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&amp;&amp;(e[r]=t[r])}return e}).apply(this,arguments)}var l=function(e){var a=e.pageClassName,t=e.pageLinkClassName,r=e.page,i=e.selected,o=e.activeClassName,l=e.activeLinkClassName,c=e.getEventListener,u=e.pageSelectedHandler,p=e.href,f=e.extraAriaContext,d=e.ariaLabel||</span><span class="s3">\&quot;</span><span class="s1">Page </span><span class="s3">\&quot;</span><span class="s1">+r+(f?</span><span class="s3">\&quot; \&quot;</span><span class="s1">+f:</span><span class="s3">\&quot;\&quot;</span><span class="s1">),g=null;return i&amp;&amp;(g=</span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot;</span><span class="s1">,d=e.ariaLabel||</span><span class="s3">\&quot;</span><span class="s1">Page </span><span class="s3">\&quot;</span><span class="s1">+r+</span><span class="s3">\&quot; </span><span class="s1">is your current page</span><span class="s3">\&quot;</span><span class="s1">,a=void 0!==a?a+</span><span class="s3">\&quot; \&quot;</span><span class="s1">+o:o,void 0!==t?void 0!==l&amp;&amp;(t=t+</span><span class="s3">\&quot; \&quot;</span><span class="s1">+l):t=l),n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">,{className:a},n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,s({role:</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">,className:t,href:p,tabIndex:</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">:d,</span><span class="s3">\&quot;</span><span class="s1">aria-current</span><span class="s3">\&quot;</span><span class="s1">:g,onKeyPress:u},c(u)),r))};l.propTypes={pageSelectedHandler:o.a.func.isRequired,selected:o.a.bool.isRequired,pageClassName:o.a.string,pageLinkClassName:o.a.string,activeClassName:o.a.string,activeLinkClassName:o.a.string,extraAriaContext:o.a.string,href:o.a.string,ariaLabel:o.a.string,page:o.a.number.isRequired,getEventListener:o.a.func.isRequired};var c=l;function u(){return(u=Object.assign||function(e){for(var a=1;a&lt;arguments.length;a++){var t=arguments[a];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&amp;&amp;(e[r]=t[r])}return e}).apply(this,arguments)}!function(){var e=</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">!=typeof reactHotLoaderGlobal?reactHotLoaderGlobal.default:void 0;if(e){var t=void 0!==a?a:exports;if(t)if(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">!=typeof t){for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=void 0;try{n=t[r]}catch(e){continue}e.register(n,r,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/PageView.js</span><span class="s3">\&quot;</span><span class="s1">)}}else e.register(t,</span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/PageView.js</span><span class="s3">\&quot;</span><span class="s1">)}}();var p=function(e){var a=e.breakLabel,t=e.breakClassName,r=e.breakLinkClassName,i=e.breakHandler,o=e.getEventListener,s=t||</span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">;return n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">,{className:s},n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,u({className:r,role:</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">,tabIndex:</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,onKeyPress:i},o(i)),a))};p.propTypes={breakLabel:o.a.oneOfType([o.a.string,o.a.node]),breakClassName:o.a.string,breakLinkClassName:o.a.string,breakHandler:o.a.func.isRequired,getEventListener:o.a.func.isRequired};var f=p;function d(e){return(d=</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof Symbol&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?</span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">:typeof e})(e)}function g(){return(g=Object.assign||function(e){for(var a=1;a&lt;arguments.length;a++){var t=arguments[a];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&amp;&amp;(e[r]=t[r])}return e}).apply(this,arguments)}function b(e,a){for(var t=0;t&lt;a.length;t++){var r=a[t];r.enumerable=r.enumerable||!1,r.configurable=!0,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}function v(e,a){return(v=Object.setPrototypeOf||function(e,a){return e.__proto__=a,e})(e,a)}function m(e){var a=function(){if(</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,r=C(e);if(a){var n=C(this).constructor;t=Reflect.construct(r,arguments,n)}else t=r.apply(this,arguments);return h(this,t)}}function h(e,a){return!a||</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">!==d(a)&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">!=typeof a?y(e):a}function y(e){if(void 0===e)throw new ReferenceError(</span><span class="s3">\&quot;</span><span class="s1">this hasn't been initialised - super() hasn't been called</span><span class="s3">\&quot;</span><span class="s1">);return e}function C(e){return(C=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function k(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}!function(){var e=</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">!=typeof reactHotLoaderGlobal?reactHotLoaderGlobal.default:void 0;if(e){var t=void 0!==a?a:exports;if(t)if(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">!=typeof t){for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=void 0;try{n=t[r]}catch(e){continue}e.register(n,r,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/BreakView.js</span><span class="s3">\&quot;</span><span class="s1">)}}else e.register(t,</span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/BreakView.js</span><span class="s3">\&quot;</span><span class="s1">)}}();var P=function(e){!function(e,a){if(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">!=typeof a&amp;&amp;null!==a)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Super expression must either be null or a function</span><span class="s3">\&quot;</span><span class="s1">);e.prototype=Object.create(a&amp;&amp;a.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),a&amp;&amp;v(e,a)}(o,e);var a,t,r,i=m(o);function o(e){var a,t;return function(e,a){if(!(e instanceof a))throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">)}(this,o),k(y(a=i.call(this,e)),</span><span class="s3">\&quot;</span><span class="s1">handlePreviousPage</span><span class="s3">\&quot;</span><span class="s1">,(function(e){var t=a.state.selected;e.preventDefault?e.preventDefault():e.returnValue=!1,t&gt;0&amp;&amp;a.handlePageSelected(t-1,e)})),k(y(a),</span><span class="s3">\&quot;</span><span class="s1">handleNextPage</span><span class="s3">\&quot;</span><span class="s1">,(function(e){var t=a.state.selected,r=a.props.pageCount;e.preventDefault?e.preventDefault():e.returnValue=!1,t&lt;r-1&amp;&amp;a.handlePageSelected(t+1,e)})),k(y(a),</span><span class="s3">\&quot;</span><span class="s1">handlePageSelected</span><span class="s3">\&quot;</span><span class="s1">,(function(e,t){t.preventDefault?t.preventDefault():t.returnValue=!1,a.state.selected!==e&amp;&amp;(a.setState({selected:e}),a.callCallback(e))})),k(y(a),</span><span class="s3">\&quot;</span><span class="s1">getEventListener</span><span class="s3">\&quot;</span><span class="s1">,(function(e){return k({},a.props.eventListener,e)})),k(y(a),</span><span class="s3">\&quot;</span><span class="s1">handleBreakClick</span><span class="s3">\&quot;</span><span class="s1">,(function(e,t){t.preventDefault?t.preventDefault():t.returnValue=!1;var r=a.state.selected;a.handlePageSelected(r&lt;e?a.getForwardJump():a.getBackwardJump(),t)})),k(y(a),</span><span class="s3">\&quot;</span><span class="s1">callCallback</span><span class="s3">\&quot;</span><span class="s1">,(function(e){void 0!==a.props.onPageChange&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof a.props.onPageChange&amp;&amp;a.props.onPageChange({selected:e})})),k(y(a),</span><span class="s3">\&quot;</span><span class="s1">pagination</span><span class="s3">\&quot;</span><span class="s1">,(function(){var e=[],t=a.props,r=t.pageRangeDisplayed,i=t.pageCount,o=t.marginPagesDisplayed,s=t.breakLabel,l=t.breakClassName,c=t.breakLinkClassName,u=a.state.selected;if(i&lt;=r)for(var p=0;p&lt;i;p++)e.push(a.getPageElement(p));else{var d,g,b,v=r/2,m=r-v;u&gt;i-r/2?v=r-(m=i-u):u&lt;r/2&amp;&amp;(m=r-(v=u));var h=function(e){return a.getPageElement(e)};for(d=0;d&lt;i;d++)(g=d+1)&lt;=o||g&gt;i-o||d&gt;=u-v&amp;&amp;d&lt;=u+m?e.push(h(d)):s&amp;&amp;e[e.length-1]!==b&amp;&amp;(b=n.a.createElement(f,{key:d,breakLabel:s,breakClassName:l,breakLinkClassName:c,breakHandler:a.handleBreakClick.bind(null,d),getEventListener:a.getEventListener}),e.push(b))}return e})),t=e.initialPage?e.initialPage:e.forcePage?e.forcePage:0,a.state={selected:t},a}return a=o,(t=[{key:</span><span class="s3">\&quot;</span><span class="s1">componentDidMount</span><span class="s3">\&quot;</span><span class="s1">,value:function(){var e=this.props,a=e.initialPage,t=e.disableInitialCallback,r=e.extraAriaContext;void 0===a||t||this.callCallback(a),r&amp;&amp;console.warn(</span><span class="s3">\&quot;</span><span class="s1">DEPRECATED (react-paginate): The extraAriaContext prop is deprecated. You should now use the ariaLabelBuilder instead.</span><span class="s3">\&quot;</span><span class="s1">)}},{key:</span><span class="s3">\&quot;</span><span class="s1">componentDidUpdate</span><span class="s3">\&quot;</span><span class="s1">,value:function(e){void 0!==this.props.forcePage&amp;&amp;this.props.forcePage!==e.forcePage&amp;&amp;this.setState({selected:this.props.forcePage})}},{key:</span><span class="s3">\&quot;</span><span class="s1">getForwardJump</span><span class="s3">\&quot;</span><span class="s1">,value:function(){var e=this.state.selected,a=this.props,t=a.pageCount,r=e+a.pageRangeDisplayed;return r&gt;=t?t-1:r}},{key:</span><span class="s3">\&quot;</span><span class="s1">getBackwardJump</span><span class="s3">\&quot;</span><span class="s1">,value:function(){var e=this.state.selected-this.props.pageRangeDisplayed;return e&lt;0?0:e}},{key:</span><span class="s3">\&quot;</span><span class="s1">hrefBuilder</span><span class="s3">\&quot;</span><span class="s1">,value:function(e){var a=this.props,t=a.hrefBuilder,r=a.pageCount;if(t&amp;&amp;e!==this.state.selected&amp;&amp;e&gt;=0&amp;&amp;e&lt;r)return t(e+1)}},{key:</span><span class="s3">\&quot;</span><span class="s1">ariaLabelBuilder</span><span class="s3">\&quot;</span><span class="s1">,value:function(e){var a=e===this.state.selected;if(this.props.ariaLabelBuilder&amp;&amp;e&gt;=0&amp;&amp;e&lt;this.props.pageCount){var t=this.props.ariaLabelBuilder(e+1,a);return this.props.extraAriaContext&amp;&amp;!a&amp;&amp;(t=t+</span><span class="s3">\&quot; \&quot;</span><span class="s1">+this.props.extraAriaContext),t}}},{key:</span><span class="s3">\&quot;</span><span class="s1">getPageElement</span><span class="s3">\&quot;</span><span class="s1">,value:function(e){var a=this.state.selected,t=this.props,r=t.pageClassName,i=t.pageLinkClassName,o=t.activeClassName,s=t.activeLinkClassName,l=t.extraAriaContext;return n.a.createElement(c,{key:e,pageSelectedHandler:this.handlePageSelected.bind(null,e),selected:a===e,pageClassName:r,pageLinkClassName:i,activeClassName:o,activeLinkClassName:s,extraAriaContext:l,href:this.hrefBuilder(e),ariaLabel:this.ariaLabelBuilder(e),page:e+1,getEventListener:this.getEventListener})}},{key:</span><span class="s3">\&quot;</span><span class="s1">render</span><span class="s3">\&quot;</span><span class="s1">,value:function(){var e=this.props,a=e.disabledClassName,t=e.pageCount,r=e.containerClassName,i=e.previousLabel,o=e.previousClassName,s=e.previousLinkClassName,l=e.previousAriaLabel,c=e.nextLabel,u=e.nextClassName,p=e.nextLinkClassName,f=e.nextAriaLabel,d=this.state.selected,b=o+(0===d?</span><span class="s3">\&quot; \&quot;</span><span class="s1">.concat(a):</span><span class="s3">\&quot;\&quot;</span><span class="s1">),v=u+(d===t-1?</span><span class="s3">\&quot; \&quot;</span><span class="s1">.concat(a):</span><span class="s3">\&quot;\&quot;</span><span class="s1">),m=0===d?</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">,h=d===t-1?</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">;return n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">,{className:r},n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">,{className:b},n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,g({className:s,href:this.hrefBuilder(d-1),tabIndex:</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,role:</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">,onKeyPress:this.handlePreviousPage,</span><span class="s3">\&quot;</span><span class="s1">aria-disabled</span><span class="s3">\&quot;</span><span class="s1">:m,</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">:l},this.getEventListener(this.handlePreviousPage)),i)),this.pagination(),n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">,{className:v},n.a.createElement(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,g({className:p,href:this.hrefBuilder(d+1),tabIndex:</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,role:</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">,onKeyPress:this.handleNextPage,</span><span class="s3">\&quot;</span><span class="s1">aria-disabled</span><span class="s3">\&quot;</span><span class="s1">:h,</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">:f},this.getEventListener(this.handleNextPage)),c)))}}])&amp;&amp;b(a.prototype,t),r&amp;&amp;b(a,r),o}(r.Component);k(P,</span><span class="s3">\&quot;</span><span class="s1">propTypes</span><span class="s3">\&quot;</span><span class="s1">,{pageCount:o.a.number.isRequired,pageRangeDisplayed:o.a.number.isRequired,marginPagesDisplayed:o.a.number.isRequired,previousLabel:o.a.node,previousAriaLabel:o.a.string,nextLabel:o.a.node,nextAriaLabel:o.a.string,breakLabel:o.a.oneOfType([o.a.string,o.a.node]),hrefBuilder:o.a.func,onPageChange:o.a.func,initialPage:o.a.number,forcePage:o.a.number,disableInitialCallback:o.a.bool,containerClassName:o.a.string,pageClassName:o.a.string,pageLinkClassName:o.a.string,activeClassName:o.a.string,activeLinkClassName:o.a.string,previousClassName:o.a.string,nextClassName:o.a.string,previousLinkClassName:o.a.string,nextLinkClassName:o.a.string,disabledClassName:o.a.string,breakClassName:o.a.string,breakLinkClassName:o.a.string,extraAriaContext:o.a.string,ariaLabelBuilder:o.a.func,eventListener:o.a.string}),k(P,</span><span class="s3">\&quot;</span><span class="s1">defaultProps</span><span class="s3">\&quot;</span><span class="s1">,{pageCount:10,pageRangeDisplayed:2,marginPagesDisplayed:3,activeClassName:</span><span class="s3">\&quot;</span><span class="s1">selected</span><span class="s3">\&quot;</span><span class="s1">,previousLabel:</span><span class="s3">\&quot;</span><span class="s1">Previous</span><span class="s3">\&quot;</span><span class="s1">,previousClassName:</span><span class="s3">\&quot;</span><span class="s1">previous</span><span class="s3">\&quot;</span><span class="s1">,previousAriaLabel:</span><span class="s3">\&quot;</span><span class="s1">Previous page</span><span class="s3">\&quot;</span><span class="s1">,nextLabel:</span><span class="s3">\&quot;</span><span class="s1">Next</span><span class="s3">\&quot;</span><span class="s1">,nextClassName:</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">,nextAriaLabel:</span><span class="s3">\&quot;</span><span class="s1">Next page</span><span class="s3">\&quot;</span><span class="s1">,breakLabel:</span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot;</span><span class="s1">,disabledClassName:</span><span class="s3">\&quot;</span><span class="s1">disabled</span><span class="s3">\&quot;</span><span class="s1">,disableInitialCallback:!1,eventListener:</span><span class="s3">\&quot;</span><span class="s1">onClick</span><span class="s3">\&quot;</span><span class="s1">}),function(){var e=</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">!=typeof reactHotLoaderGlobal?reactHotLoaderGlobal.default:void 0;if(e){var t=void 0!==a?a:exports;if(t)if(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">!=typeof t){for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=void 0;try{n=t[r]}catch(e){continue}e.register(n,r,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/PaginationBoxView.js</span><span class="s3">\&quot;</span><span class="s1">)}}else e.register(t,</span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/PaginationBoxView.js</span><span class="s3">\&quot;</span><span class="s1">)}}();a.default=P;!function(){var e=</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">!=typeof reactHotLoaderGlobal?reactHotLoaderGlobal.default:void 0;if(e){var t=void 0!==a?a:exports;if(t)if(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">!=typeof t){for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=void 0;try{n=t[r]}catch(e){continue}e.register(n,r,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/index.js</span><span class="s3">\&quot;</span><span class="s1">)}}else e.register(t,</span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">/home/adele/workspace/react-paginate/react_components/index.js</span><span class="s3">\&quot;</span><span class="s1">)}}()}])}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=react-paginate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;const ANY = Symbol('SemVer ANY')</span><span class="s3">\n</span><span class="s1">// hoisted class for cyclic dependency</span><span class="s3">\n</span><span class="s1">class Comparator {</span><span class="s3">\n  </span><span class="s1">static get ANY () {</span><span class="s3">\n    </span><span class="s1">return ANY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor (comp, options) {</span><span class="s3">\n    </span><span class="s1">options = parseOptions(options)</span><span class="s3">\n\n    </span><span class="s1">if (comp instanceof Comparator) {</span><span class="s3">\n      </span><span class="s1">if (comp.loose === !!options.loose) {</span><span class="s3">\n        </span><span class="s1">return comp</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">comp = comp.value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">comp = comp.trim().split(/</span><span class="s3">\\</span><span class="s1">s+/).join(' ')</span><span class="s3">\n    </span><span class="s1">debug('comparator', comp, options)</span><span class="s3">\n    </span><span class="s1">this.options = options</span><span class="s3">\n    </span><span class="s1">this.loose = !!options.loose</span><span class="s3">\n    </span><span class="s1">this.parse(comp)</span><span class="s3">\n\n    </span><span class="s1">if (this.semver === ANY) {</span><span class="s3">\n      </span><span class="s1">this.value = ''</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.value = this.operator + this.semver.version</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">debug('comp', this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">parse (comp) {</span><span class="s3">\n    </span><span class="s1">const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]</span><span class="s3">\n    </span><span class="s1">const m = comp.match(r)</span><span class="s3">\n\n    </span><span class="s1">if (!m) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(`Invalid comparator: ${comp}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.operator = m[1] !== undefined ? m[1] : ''</span><span class="s3">\n    </span><span class="s1">if (this.operator === '=') {</span><span class="s3">\n      </span><span class="s1">this.operator = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if it literally is just '&gt;' or '' then allow anything.</span><span class="s3">\n    </span><span class="s1">if (!m[2]) {</span><span class="s3">\n      </span><span class="s1">this.semver = ANY</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.semver = new SemVer(m[2], this.options.loose)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">return this.value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">test (version) {</span><span class="s3">\n    </span><span class="s1">debug('Comparator.test', version, this.options.loose)</span><span class="s3">\n\n    </span><span class="s1">if (this.semver === ANY || version === ANY) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof version === 'string') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">version = new SemVer(version, this.options)</span><span class="s3">\n      </span><span class="s1">} catch (er) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return cmp(version, this.operator, this.semver, this.options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">intersects (comp, options) {</span><span class="s3">\n    </span><span class="s1">if (!(comp instanceof Comparator)) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('a Comparator is required')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.operator === '') {</span><span class="s3">\n      </span><span class="s1">if (this.value === '') {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return new Range(comp.value, options).test(this.value)</span><span class="s3">\n    </span><span class="s1">} else if (comp.operator === '') {</span><span class="s3">\n      </span><span class="s1">if (comp.value === '') {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return new Range(this.value, options).test(comp.semver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">options = parseOptions(options)</span><span class="s3">\n\n    </span><span class="s1">// Special cases where nothing can possibly be lower</span><span class="s3">\n    </span><span class="s1">if (options.includePrerelease &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(this.value === '&lt;0.0.0-0' || comp.value === '&lt;0.0.0-0')) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!options.includePrerelease &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(this.value.startsWith('&lt;0.0.0') || comp.value.startsWith('&lt;0.0.0'))) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Same direction increasing (&gt; or &gt;=)</span><span class="s3">\n    </span><span class="s1">if (this.operator.startsWith('&gt;') &amp;&amp; comp.operator.startsWith('&gt;')) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Same direction decreasing (&lt; or &lt;=)</span><span class="s3">\n    </span><span class="s1">if (this.operator.startsWith('&lt;') &amp;&amp; comp.operator.startsWith('&lt;')) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// same SemVer and both sides are inclusive (&lt;= or &gt;=)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(this.semver.version === comp.semver.version) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.operator.includes('=') &amp;&amp; comp.operator.includes('=')) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// opposite directions less than</span><span class="s3">\n    </span><span class="s1">if (cmp(this.semver, '&lt;', comp.semver, options) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.operator.startsWith('&gt;') &amp;&amp; comp.operator.startsWith('&lt;')) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// opposite directions greater than</span><span class="s3">\n    </span><span class="s1">if (cmp(this.semver, '&gt;', comp.semver, options) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.operator.startsWith('&lt;') &amp;&amp; comp.operator.startsWith('&gt;')) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = Comparator</span><span class="s3">\n\n</span><span class="s1">const parseOptions = require('../internal/parse-options')</span><span class="s3">\n</span><span class="s1">const { safeRe: re, t } = require('../internal/re')</span><span class="s3">\n</span><span class="s1">const cmp = require('../functions/cmp')</span><span class="s3">\n</span><span class="s1">const debug = require('../internal/debug')</span><span class="s3">\n</span><span class="s1">const SemVer = require('./semver')</span><span class="s3">\n</span><span class="s1">const Range = require('./range')</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SPACE_CHARACTERS = /</span><span class="s3">\\</span><span class="s1">s+/g</span><span class="s3">\n\n</span><span class="s1">// hoisted class for cyclic dependency</span><span class="s3">\n</span><span class="s1">class Range {</span><span class="s3">\n  </span><span class="s1">constructor (range, options) {</span><span class="s3">\n    </span><span class="s1">options = parseOptions(options)</span><span class="s3">\n\n    </span><span class="s1">if (range instanceof Range) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">range.loose === !!options.loose &amp;&amp;</span><span class="s3">\n        </span><span class="s1">range.includePrerelease === !!options.includePrerelease</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return range</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return new Range(range.raw, options)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (range instanceof Comparator) {</span><span class="s3">\n      </span><span class="s1">// just put it in the set and return</span><span class="s3">\n      </span><span class="s1">this.raw = range.value</span><span class="s3">\n      </span><span class="s1">this.set = [[range]]</span><span class="s3">\n      </span><span class="s1">this.formatted = undefined</span><span class="s3">\n      </span><span class="s1">return this</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.options = options</span><span class="s3">\n    </span><span class="s1">this.loose = !!options.loose</span><span class="s3">\n    </span><span class="s1">this.includePrerelease = !!options.includePrerelease</span><span class="s3">\n\n    </span><span class="s1">// First reduce all whitespace as much as possible so we do not have to rely</span><span class="s3">\n    </span><span class="s1">// on potentially slow regexes like </span><span class="s3">\\</span><span class="s1">s*. This is then stored and used for</span><span class="s3">\n    </span><span class="s1">// future error messages as well.</span><span class="s3">\n    </span><span class="s1">this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')</span><span class="s3">\n\n    </span><span class="s1">// First, split on ||</span><span class="s3">\n    </span><span class="s1">this.set = this.raw</span><span class="s3">\n      </span><span class="s1">.split('||')</span><span class="s3">\n      </span><span class="s1">// map the range to a 2d array of comparators</span><span class="s3">\n      </span><span class="s1">.map(r =&gt; this.parseRange(r.trim()))</span><span class="s3">\n      </span><span class="s1">// throw out any comparator lists that are empty</span><span class="s3">\n      </span><span class="s1">// this generally means that it was not a valid range, which is allowed</span><span class="s3">\n      </span><span class="s1">// in loose mode, but will still throw if the WHOLE range is invalid.</span><span class="s3">\n      </span><span class="s1">.filter(c =&gt; c.length)</span><span class="s3">\n\n    </span><span class="s1">if (!this.set.length) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(`Invalid SemVer Range: ${this.raw}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if we have any that are not the null set, throw out null sets.</span><span class="s3">\n    </span><span class="s1">if (this.set.length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">// keep the first one, in case they're all null sets</span><span class="s3">\n      </span><span class="s1">const first = this.set[0]</span><span class="s3">\n      </span><span class="s1">this.set = this.set.filter(c =&gt; !isNullSet(c[0]))</span><span class="s3">\n      </span><span class="s1">if (this.set.length === 0) {</span><span class="s3">\n        </span><span class="s1">this.set = [first]</span><span class="s3">\n      </span><span class="s1">} else if (this.set.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">// if we have any that are *, then the range is just *</span><span class="s3">\n        </span><span class="s1">for (const c of this.set) {</span><span class="s3">\n          </span><span class="s1">if (c.length === 1 &amp;&amp; isAny(c[0])) {</span><span class="s3">\n            </span><span class="s1">this.set = [c]</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.formatted = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get range () {</span><span class="s3">\n    </span><span class="s1">if (this.formatted === undefined) {</span><span class="s3">\n      </span><span class="s1">this.formatted = ''</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; this.set.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n          </span><span class="s1">this.formatted += '||'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const comps = this.set[i]</span><span class="s3">\n        </span><span class="s1">for (let k = 0; k &lt; comps.length; k++) {</span><span class="s3">\n          </span><span class="s1">if (k &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this.formatted += ' '</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.formatted += comps[k].toString().trim()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.formatted</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">format () {</span><span class="s3">\n    </span><span class="s1">return this.range</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">return this.range</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">parseRange (range) {</span><span class="s3">\n    </span><span class="s1">// memoize range parsing for performance.</span><span class="s3">\n    </span><span class="s1">// this is a very hot path, and fully deterministic.</span><span class="s3">\n    </span><span class="s1">const memoOpts =</span><span class="s3">\n      </span><span class="s1">(this.options.includePrerelease &amp;&amp; FLAG_INCLUDE_PRERELEASE) |</span><span class="s3">\n      </span><span class="s1">(this.options.loose &amp;&amp; FLAG_LOOSE)</span><span class="s3">\n    </span><span class="s1">const memoKey = memoOpts + ':' + range</span><span class="s3">\n    </span><span class="s1">const cached = cache.get(memoKey)</span><span class="s3">\n    </span><span class="s1">if (cached) {</span><span class="s3">\n      </span><span class="s1">return cached</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const loose = this.options.loose</span><span class="s3">\n    </span><span class="s1">// `1.2.3 - 1.2.4` =&gt; `&gt;=1.2.3 &lt;=1.2.4`</span><span class="s3">\n    </span><span class="s1">const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]</span><span class="s3">\n    </span><span class="s1">range = range.replace(hr, hyphenReplace(this.options.includePrerelease))</span><span class="s3">\n    </span><span class="s1">debug('hyphen replace', range)</span><span class="s3">\n\n    </span><span class="s1">// `&gt; 1.2.3 &lt; 1.2.5` =&gt; `&gt;1.2.3 &lt;1.2.5`</span><span class="s3">\n    </span><span class="s1">range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)</span><span class="s3">\n    </span><span class="s1">debug('comparator trim', range)</span><span class="s3">\n\n    </span><span class="s1">// `~ 1.2.3` =&gt; `~1.2.3`</span><span class="s3">\n    </span><span class="s1">range = range.replace(re[t.TILDETRIM], tildeTrimReplace)</span><span class="s3">\n    </span><span class="s1">debug('tilde trim', range)</span><span class="s3">\n\n    </span><span class="s1">// `^ 1.2.3` =&gt; `^1.2.3`</span><span class="s3">\n    </span><span class="s1">range = range.replace(re[t.CARETTRIM], caretTrimReplace)</span><span class="s3">\n    </span><span class="s1">debug('caret trim', range)</span><span class="s3">\n\n    </span><span class="s1">// At this point, the range is completely trimmed and</span><span class="s3">\n    </span><span class="s1">// ready to be split into comparators.</span><span class="s3">\n\n    </span><span class="s1">let rangeList = range</span><span class="s3">\n      </span><span class="s1">.split(' ')</span><span class="s3">\n      </span><span class="s1">.map(comp =&gt; parseComparator(comp, this.options))</span><span class="s3">\n      </span><span class="s1">.join(' ')</span><span class="s3">\n      </span><span class="s1">.split(/</span><span class="s3">\\</span><span class="s1">s+/)</span><span class="s3">\n      </span><span class="s1">// &gt;=0.0.0 is equivalent to *</span><span class="s3">\n      </span><span class="s1">.map(comp =&gt; replaceGTE0(comp, this.options))</span><span class="s3">\n\n    </span><span class="s1">if (loose) {</span><span class="s3">\n      </span><span class="s1">// in loose mode, throw out any that are not valid comparators</span><span class="s3">\n      </span><span class="s1">rangeList = rangeList.filter(comp =&gt; {</span><span class="s3">\n        </span><span class="s1">debug('loose invalid filter', comp, this.options)</span><span class="s3">\n        </span><span class="s1">return !!comp.match(re[t.COMPARATORLOOSE])</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">debug('range list', rangeList)</span><span class="s3">\n\n    </span><span class="s1">// if any comparators are the null set, then replace with JUST null set</span><span class="s3">\n    </span><span class="s1">// if more than one comparator, remove any * comparators</span><span class="s3">\n    </span><span class="s1">// also, don't include the same comparator more than once</span><span class="s3">\n    </span><span class="s1">const rangeMap = new Map()</span><span class="s3">\n    </span><span class="s1">const comparators = rangeList.map(comp =&gt; new Comparator(comp, this.options))</span><span class="s3">\n    </span><span class="s1">for (const comp of comparators) {</span><span class="s3">\n      </span><span class="s1">if (isNullSet(comp)) {</span><span class="s3">\n        </span><span class="s1">return [comp]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">rangeMap.set(comp.value, comp)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (rangeMap.size &gt; 1 &amp;&amp; rangeMap.has('')) {</span><span class="s3">\n      </span><span class="s1">rangeMap.delete('')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const result = [...rangeMap.values()]</span><span class="s3">\n    </span><span class="s1">cache.set(memoKey, result)</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">intersects (range, options) {</span><span class="s3">\n    </span><span class="s1">if (!(range instanceof Range)) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('a Range is required')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.set.some((thisComparators) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">isSatisfiable(thisComparators, options) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">range.set.some((rangeComparators) =&gt; {</span><span class="s3">\n          </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">isSatisfiable(rangeComparators, options) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">thisComparators.every((thisComparator) =&gt; {</span><span class="s3">\n              </span><span class="s1">return rangeComparators.every((rangeComparator) =&gt; {</span><span class="s3">\n                </span><span class="s1">return thisComparator.intersects(rangeComparator, options)</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if ANY of the sets match ALL of its comparators, then pass</span><span class="s3">\n  </span><span class="s1">test (version) {</span><span class="s3">\n    </span><span class="s1">if (!version) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof version === 'string') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">version = new SemVer(version, this.options)</span><span class="s3">\n      </span><span class="s1">} catch (er) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; this.set.length; i++) {</span><span class="s3">\n      </span><span class="s1">if (testSet(this.set[i], version, this.options)) {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = Range</span><span class="s3">\n\n</span><span class="s1">const LRU = require('../internal/lrucache')</span><span class="s3">\n</span><span class="s1">const cache = new LRU()</span><span class="s3">\n\n</span><span class="s1">const parseOptions = require('../internal/parse-options')</span><span class="s3">\n</span><span class="s1">const Comparator = require('./comparator')</span><span class="s3">\n</span><span class="s1">const debug = require('../internal/debug')</span><span class="s3">\n</span><span class="s1">const SemVer = require('./semver')</span><span class="s3">\n</span><span class="s1">const {</span><span class="s3">\n  </span><span class="s1">safeRe: re,</span><span class="s3">\n  </span><span class="s1">t,</span><span class="s3">\n  </span><span class="s1">comparatorTrimReplace,</span><span class="s3">\n  </span><span class="s1">tildeTrimReplace,</span><span class="s3">\n  </span><span class="s1">caretTrimReplace,</span><span class="s3">\n</span><span class="s1">} = require('../internal/re')</span><span class="s3">\n</span><span class="s1">const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')</span><span class="s3">\n\n</span><span class="s1">const isNullSet = c =&gt; c.value === '&lt;0.0.0-0'</span><span class="s3">\n</span><span class="s1">const isAny = c =&gt; c.value === ''</span><span class="s3">\n\n</span><span class="s1">// take a set of comparators and determine whether there</span><span class="s3">\n</span><span class="s1">// exists a version which can satisfy it</span><span class="s3">\n</span><span class="s1">const isSatisfiable = (comparators, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">let result = true</span><span class="s3">\n  </span><span class="s1">const remainingComparators = comparators.slice()</span><span class="s3">\n  </span><span class="s1">let testComparator = remainingComparators.pop()</span><span class="s3">\n\n  </span><span class="s1">while (result &amp;&amp; remainingComparators.length) {</span><span class="s3">\n    </span><span class="s1">result = remainingComparators.every((otherComparator) =&gt; {</span><span class="s3">\n      </span><span class="s1">return testComparator.intersects(otherComparator, options)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">testComparator = remainingComparators.pop()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// comprised of xranges, tildes, stars, and gtlt's at this point.</span><span class="s3">\n</span><span class="s1">// already replaced the hyphen ranges</span><span class="s3">\n</span><span class="s1">// turn into a set of JUST comparators.</span><span class="s3">\n</span><span class="s1">const parseComparator = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">debug('comp', comp, options)</span><span class="s3">\n  </span><span class="s1">comp = replaceCarets(comp, options)</span><span class="s3">\n  </span><span class="s1">debug('caret', comp)</span><span class="s3">\n  </span><span class="s1">comp = replaceTildes(comp, options)</span><span class="s3">\n  </span><span class="s1">debug('tildes', comp)</span><span class="s3">\n  </span><span class="s1">comp = replaceXRanges(comp, options)</span><span class="s3">\n  </span><span class="s1">debug('xrange', comp)</span><span class="s3">\n  </span><span class="s1">comp = replaceStars(comp, options)</span><span class="s3">\n  </span><span class="s1">debug('stars', comp)</span><span class="s3">\n  </span><span class="s1">return comp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isX = id =&gt; !id || id.toLowerCase() === 'x' || id === '*'</span><span class="s3">\n\n</span><span class="s1">// ~, ~&gt; --&gt; * (any, kinda silly)</span><span class="s3">\n</span><span class="s1">// ~2, ~2.x, ~2.x.x, ~&gt;2, ~&gt;2.x ~&gt;2.x.x --&gt; &gt;=2.0.0 &lt;3.0.0-0</span><span class="s3">\n</span><span class="s1">// ~2.0, ~2.0.x, ~&gt;2.0, ~&gt;2.0.x --&gt; &gt;=2.0.0 &lt;2.1.0-0</span><span class="s3">\n</span><span class="s1">// ~1.2, ~1.2.x, ~&gt;1.2, ~&gt;1.2.x --&gt; &gt;=1.2.0 &lt;1.3.0-0</span><span class="s3">\n</span><span class="s1">// ~1.2.3, ~&gt;1.2.3 --&gt; &gt;=1.2.3 &lt;1.3.0-0</span><span class="s3">\n</span><span class="s1">// ~1.2.0, ~&gt;1.2.0 --&gt; &gt;=1.2.0 &lt;1.3.0-0</span><span class="s3">\n</span><span class="s1">// ~0.0.1 --&gt; &gt;=0.0.1 &lt;0.1.0-0</span><span class="s3">\n</span><span class="s1">const replaceTildes = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">return comp</span><span class="s3">\n    </span><span class="s1">.trim()</span><span class="s3">\n    </span><span class="s1">.split(/</span><span class="s3">\\</span><span class="s1">s+/)</span><span class="s3">\n    </span><span class="s1">.map((c) =&gt; replaceTilde(c, options))</span><span class="s3">\n    </span><span class="s1">.join(' ')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const replaceTilde = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]</span><span class="s3">\n  </span><span class="s1">return comp.replace(r, (_, M, m, p, pr) =&gt; {</span><span class="s3">\n    </span><span class="s1">debug('tilde', comp, _, M, m, p, pr)</span><span class="s3">\n    </span><span class="s1">let ret</span><span class="s3">\n\n    </span><span class="s1">if (isX(M)) {</span><span class="s3">\n      </span><span class="s1">ret = ''</span><span class="s3">\n    </span><span class="s1">} else if (isX(m)) {</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.0.0 &lt;${+M + 1}.0.0-0`</span><span class="s3">\n    </span><span class="s1">} else if (isX(p)) {</span><span class="s3">\n      </span><span class="s1">// ~1.2 == &gt;=1.2.0 &lt;1.3.0-0</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.${m}.0 &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n    </span><span class="s1">} else if (pr) {</span><span class="s3">\n      </span><span class="s1">debug('replaceTilde pr', pr)</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.${m}.${p}-${pr</span><span class="s3">\n      </span><span class="s1">} &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// ~1.2.3 == &gt;=1.2.3 &lt;1.3.0-0</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.${m}.${p</span><span class="s3">\n      </span><span class="s1">} &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">debug('tilde return', ret)</span><span class="s3">\n    </span><span class="s1">return ret</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// ^ --&gt; * (any, kinda silly)</span><span class="s3">\n</span><span class="s1">// ^2, ^2.x, ^2.x.x --&gt; &gt;=2.0.0 &lt;3.0.0-0</span><span class="s3">\n</span><span class="s1">// ^2.0, ^2.0.x --&gt; &gt;=2.0.0 &lt;3.0.0-0</span><span class="s3">\n</span><span class="s1">// ^1.2, ^1.2.x --&gt; &gt;=1.2.0 &lt;2.0.0-0</span><span class="s3">\n</span><span class="s1">// ^1.2.3 --&gt; &gt;=1.2.3 &lt;2.0.0-0</span><span class="s3">\n</span><span class="s1">// ^1.2.0 --&gt; &gt;=1.2.0 &lt;2.0.0-0</span><span class="s3">\n</span><span class="s1">// ^0.0.1 --&gt; &gt;=0.0.1 &lt;0.0.2-0</span><span class="s3">\n</span><span class="s1">// ^0.1.0 --&gt; &gt;=0.1.0 &lt;0.2.0-0</span><span class="s3">\n</span><span class="s1">const replaceCarets = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">return comp</span><span class="s3">\n    </span><span class="s1">.trim()</span><span class="s3">\n    </span><span class="s1">.split(/</span><span class="s3">\\</span><span class="s1">s+/)</span><span class="s3">\n    </span><span class="s1">.map((c) =&gt; replaceCaret(c, options))</span><span class="s3">\n    </span><span class="s1">.join(' ')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const replaceCaret = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">debug('caret', comp, options)</span><span class="s3">\n  </span><span class="s1">const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]</span><span class="s3">\n  </span><span class="s1">const z = options.includePrerelease ? '-0' : ''</span><span class="s3">\n  </span><span class="s1">return comp.replace(r, (_, M, m, p, pr) =&gt; {</span><span class="s3">\n    </span><span class="s1">debug('caret', comp, _, M, m, p, pr)</span><span class="s3">\n    </span><span class="s1">let ret</span><span class="s3">\n\n    </span><span class="s1">if (isX(M)) {</span><span class="s3">\n      </span><span class="s1">ret = ''</span><span class="s3">\n    </span><span class="s1">} else if (isX(m)) {</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.0.0${z} &lt;${+M + 1}.0.0-0`</span><span class="s3">\n    </span><span class="s1">} else if (isX(p)) {</span><span class="s3">\n      </span><span class="s1">if (M === '0') {</span><span class="s3">\n        </span><span class="s1">ret = `&gt;=${M}.${m}.0${z} &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">ret = `&gt;=${M}.${m}.0${z} &lt;${+M + 1}.0.0-0`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (pr) {</span><span class="s3">\n      </span><span class="s1">debug('replaceCaret pr', pr)</span><span class="s3">\n      </span><span class="s1">if (M === '0') {</span><span class="s3">\n        </span><span class="s1">if (m === '0') {</span><span class="s3">\n          </span><span class="s1">ret = `&gt;=${M}.${m}.${p}-${pr</span><span class="s3">\n          </span><span class="s1">} &lt;${M}.${m}.${+p + 1}-0`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">ret = `&gt;=${M}.${m}.${p}-${pr</span><span class="s3">\n          </span><span class="s1">} &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">ret = `&gt;=${M}.${m}.${p}-${pr</span><span class="s3">\n        </span><span class="s1">} &lt;${+M + 1}.0.0-0`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug('no pr')</span><span class="s3">\n      </span><span class="s1">if (M === '0') {</span><span class="s3">\n        </span><span class="s1">if (m === '0') {</span><span class="s3">\n          </span><span class="s1">ret = `&gt;=${M}.${m}.${p</span><span class="s3">\n          </span><span class="s1">}${z} &lt;${M}.${m}.${+p + 1}-0`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">ret = `&gt;=${M}.${m}.${p</span><span class="s3">\n          </span><span class="s1">}${z} &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">ret = `&gt;=${M}.${m}.${p</span><span class="s3">\n        </span><span class="s1">} &lt;${+M + 1}.0.0-0`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">debug('caret return', ret)</span><span class="s3">\n    </span><span class="s1">return ret</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const replaceXRanges = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">debug('replaceXRanges', comp, options)</span><span class="s3">\n  </span><span class="s1">return comp</span><span class="s3">\n    </span><span class="s1">.split(/</span><span class="s3">\\</span><span class="s1">s+/)</span><span class="s3">\n    </span><span class="s1">.map((c) =&gt; replaceXRange(c, options))</span><span class="s3">\n    </span><span class="s1">.join(' ')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const replaceXRange = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">comp = comp.trim()</span><span class="s3">\n  </span><span class="s1">const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]</span><span class="s3">\n  </span><span class="s1">return comp.replace(r, (ret, gtlt, M, m, p, pr) =&gt; {</span><span class="s3">\n    </span><span class="s1">debug('xRange', comp, ret, gtlt, M, m, p, pr)</span><span class="s3">\n    </span><span class="s1">const xM = isX(M)</span><span class="s3">\n    </span><span class="s1">const xm = xM || isX(m)</span><span class="s3">\n    </span><span class="s1">const xp = xm || isX(p)</span><span class="s3">\n    </span><span class="s1">const anyX = xp</span><span class="s3">\n\n    </span><span class="s1">if (gtlt === '=' &amp;&amp; anyX) {</span><span class="s3">\n      </span><span class="s1">gtlt = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if we're including prereleases in the match, then we need</span><span class="s3">\n    </span><span class="s1">// to fix this to -0, the lowest possible prerelease value</span><span class="s3">\n    </span><span class="s1">pr = options.includePrerelease ? '-0' : ''</span><span class="s3">\n\n    </span><span class="s1">if (xM) {</span><span class="s3">\n      </span><span class="s1">if (gtlt === '&gt;' || gtlt === '&lt;') {</span><span class="s3">\n        </span><span class="s1">// nothing is allowed</span><span class="s3">\n        </span><span class="s1">ret = '&lt;0.0.0-0'</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// nothing is forbidden</span><span class="s3">\n        </span><span class="s1">ret = '*'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (gtlt &amp;&amp; anyX) {</span><span class="s3">\n      </span><span class="s1">// we know patch is an x, because we have any x at all.</span><span class="s3">\n      </span><span class="s1">// replace X with 0</span><span class="s3">\n      </span><span class="s1">if (xm) {</span><span class="s3">\n        </span><span class="s1">m = 0</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">p = 0</span><span class="s3">\n\n      </span><span class="s1">if (gtlt === '&gt;') {</span><span class="s3">\n        </span><span class="s1">// &gt;1 =&gt; &gt;=2.0.0</span><span class="s3">\n        </span><span class="s1">// &gt;1.2 =&gt; &gt;=1.3.0</span><span class="s3">\n        </span><span class="s1">gtlt = '&gt;='</span><span class="s3">\n        </span><span class="s1">if (xm) {</span><span class="s3">\n          </span><span class="s1">M = +M + 1</span><span class="s3">\n          </span><span class="s1">m = 0</span><span class="s3">\n          </span><span class="s1">p = 0</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">m = +m + 1</span><span class="s3">\n          </span><span class="s1">p = 0</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (gtlt === '&lt;=') {</span><span class="s3">\n        </span><span class="s1">// &lt;=0.7.x is actually &lt;0.8.0, since any 0.7.x should</span><span class="s3">\n        </span><span class="s1">// pass.  Similarly, &lt;=7.x is actually &lt;8.0.0, etc.</span><span class="s3">\n        </span><span class="s1">gtlt = '&lt;'</span><span class="s3">\n        </span><span class="s1">if (xm) {</span><span class="s3">\n          </span><span class="s1">M = +M + 1</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">m = +m + 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (gtlt === '&lt;') {</span><span class="s3">\n        </span><span class="s1">pr = '-0'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">ret = `${gtlt + M}.${m}.${p}${pr}`</span><span class="s3">\n    </span><span class="s1">} else if (xm) {</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.0.0${pr} &lt;${+M + 1}.0.0-0`</span><span class="s3">\n    </span><span class="s1">} else if (xp) {</span><span class="s3">\n      </span><span class="s1">ret = `&gt;=${M}.${m}.0${pr</span><span class="s3">\n      </span><span class="s1">} &lt;${M}.${+m + 1}.0-0`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">debug('xRange return', ret)</span><span class="s3">\n\n    </span><span class="s1">return ret</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Because * is AND-ed with everything else in the comparator,</span><span class="s3">\n</span><span class="s1">// and '' means </span><span class="s3">\&quot;</span><span class="s1">any version</span><span class="s3">\&quot;</span><span class="s1">, just remove the *s entirely.</span><span class="s3">\n</span><span class="s1">const replaceStars = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">debug('replaceStars', comp, options)</span><span class="s3">\n  </span><span class="s1">// Looseness is ignored here.  star is always as loose as it gets!</span><span class="s3">\n  </span><span class="s1">return comp</span><span class="s3">\n    </span><span class="s1">.trim()</span><span class="s3">\n    </span><span class="s1">.replace(re[t.STAR], '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const replaceGTE0 = (comp, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">debug('replaceGTE0', comp, options)</span><span class="s3">\n  </span><span class="s1">return comp</span><span class="s3">\n    </span><span class="s1">.trim()</span><span class="s3">\n    </span><span class="s1">.replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This function is passed to string.replace(re[t.HYPHENRANGE])</span><span class="s3">\n</span><span class="s1">// M, m, patch, prerelease, build</span><span class="s3">\n</span><span class="s1">// 1.2 - 3.4.5 =&gt; &gt;=1.2.0 &lt;=3.4.5</span><span class="s3">\n</span><span class="s1">// 1.2.3 - 3.4 =&gt; &gt;=1.2.0 &lt;3.5.0-0 Any 3.4.x will do</span><span class="s3">\n</span><span class="s1">// 1.2 - 3.4 =&gt; &gt;=1.2.0 &lt;3.5.0-0</span><span class="s3">\n</span><span class="s1">// TODO build?</span><span class="s3">\n</span><span class="s1">const hyphenReplace = incPr =&gt; ($0,</span><span class="s3">\n  </span><span class="s1">from, fM, fm, fp, fpr, fb,</span><span class="s3">\n  </span><span class="s1">to, tM, tm, tp, tpr) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (isX(fM)) {</span><span class="s3">\n    </span><span class="s1">from = ''</span><span class="s3">\n  </span><span class="s1">} else if (isX(fm)) {</span><span class="s3">\n    </span><span class="s1">from = `&gt;=${fM}.0.0${incPr ? '-0' : ''}`</span><span class="s3">\n  </span><span class="s1">} else if (isX(fp)) {</span><span class="s3">\n    </span><span class="s1">from = `&gt;=${fM}.${fm}.0${incPr ? '-0' : ''}`</span><span class="s3">\n  </span><span class="s1">} else if (fpr) {</span><span class="s3">\n    </span><span class="s1">from = `&gt;=${from}`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">from = `&gt;=${from}${incPr ? '-0' : ''}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isX(tM)) {</span><span class="s3">\n    </span><span class="s1">to = ''</span><span class="s3">\n  </span><span class="s1">} else if (isX(tm)) {</span><span class="s3">\n    </span><span class="s1">to = `&lt;${+tM + 1}.0.0-0`</span><span class="s3">\n  </span><span class="s1">} else if (isX(tp)) {</span><span class="s3">\n    </span><span class="s1">to = `&lt;${tM}.${+tm + 1}.0-0`</span><span class="s3">\n  </span><span class="s1">} else if (tpr) {</span><span class="s3">\n    </span><span class="s1">to = `&lt;=${tM}.${tm}.${tp}-${tpr}`</span><span class="s3">\n  </span><span class="s1">} else if (incPr) {</span><span class="s3">\n    </span><span class="s1">to = `&lt;${tM}.${tm}.${+tp + 1}-0`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">to = `&lt;=${to}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return `${from} ${to}`.trim()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const testSet = (set, version, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; set.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!set[i].test(version)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (version.prerelease.length &amp;&amp; !options.includePrerelease) {</span><span class="s3">\n    </span><span class="s1">// Find the set of versions that are allowed to have prereleases</span><span class="s3">\n    </span><span class="s1">// For example, ^1.2.3-pr.1 desugars to &gt;=1.2.3-pr.1 &lt;2.0.0</span><span class="s3">\n    </span><span class="s1">// That should allow `1.2.3-pr.2` to pass.</span><span class="s3">\n    </span><span class="s1">// However, `1.2.4-alpha.notready` should NOT be allowed,</span><span class="s3">\n    </span><span class="s1">// even though it's within the range set by the comparators.</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; set.length; i++) {</span><span class="s3">\n      </span><span class="s1">debug(set[i].semver)</span><span class="s3">\n      </span><span class="s1">if (set[i].semver === Comparator.ANY) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (set[i].semver.prerelease.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">const allowed = set[i].semver</span><span class="s3">\n        </span><span class="s1">if (allowed.major === version.major &amp;&amp;</span><span class="s3">\n            </span><span class="s1">allowed.minor === version.minor &amp;&amp;</span><span class="s3">\n            </span><span class="s1">allowed.patch === version.patch) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Version has a -pre, but it's not one of the ones we like.</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const debug = require('../internal/debug')</span><span class="s3">\n</span><span class="s1">const { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')</span><span class="s3">\n</span><span class="s1">const { safeRe: re, t } = require('../internal/re')</span><span class="s3">\n\n</span><span class="s1">const parseOptions = require('../internal/parse-options')</span><span class="s3">\n</span><span class="s1">const { compareIdentifiers } = require('../internal/identifiers')</span><span class="s3">\n</span><span class="s1">class SemVer {</span><span class="s3">\n  </span><span class="s1">constructor (version, options) {</span><span class="s3">\n    </span><span class="s1">options = parseOptions(options)</span><span class="s3">\n\n    </span><span class="s1">if (version instanceof SemVer) {</span><span class="s3">\n      </span><span class="s1">if (version.loose === !!options.loose &amp;&amp;</span><span class="s3">\n          </span><span class="s1">version.includePrerelease === !!options.includePrerelease) {</span><span class="s3">\n        </span><span class="s1">return version</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">version = version.version</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (typeof version !== 'string') {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(`Invalid version. Must be a string. Got type </span><span class="s3">\&quot;</span><span class="s1">${typeof version}</span><span class="s3">\&quot;</span><span class="s1">.`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (version.length &gt; MAX_LENGTH) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`version is longer than ${MAX_LENGTH} characters`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">debug('SemVer', version, options)</span><span class="s3">\n    </span><span class="s1">this.options = options</span><span class="s3">\n    </span><span class="s1">this.loose = !!options.loose</span><span class="s3">\n    </span><span class="s1">// this isn't actually relevant for versions, but keep it so that we</span><span class="s3">\n    </span><span class="s1">// don't run into trouble passing this.options around.</span><span class="s3">\n    </span><span class="s1">this.includePrerelease = !!options.includePrerelease</span><span class="s3">\n\n    </span><span class="s1">const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])</span><span class="s3">\n\n    </span><span class="s1">if (!m) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(`Invalid Version: ${version}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.raw = version</span><span class="s3">\n\n    </span><span class="s1">// these are actually numbers</span><span class="s3">\n    </span><span class="s1">this.major = +m[1]</span><span class="s3">\n    </span><span class="s1">this.minor = +m[2]</span><span class="s3">\n    </span><span class="s1">this.patch = +m[3]</span><span class="s3">\n\n    </span><span class="s1">if (this.major &gt; MAX_SAFE_INTEGER || this.major &lt; 0) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('Invalid major version')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.minor &gt; MAX_SAFE_INTEGER || this.minor &lt; 0) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('Invalid minor version')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.patch &gt; MAX_SAFE_INTEGER || this.patch &lt; 0) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('Invalid patch version')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// numberify any prerelease numeric ids</span><span class="s3">\n    </span><span class="s1">if (!m[4]) {</span><span class="s3">\n      </span><span class="s1">this.prerelease = []</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.prerelease = m[4].split('.').map((id) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (/^[0-9]+$/.test(id)) {</span><span class="s3">\n          </span><span class="s1">const num = +id</span><span class="s3">\n          </span><span class="s1">if (num &gt;= 0 &amp;&amp; num &lt; MAX_SAFE_INTEGER) {</span><span class="s3">\n            </span><span class="s1">return num</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return id</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.build = m[5] ? m[5].split('.') : []</span><span class="s3">\n    </span><span class="s1">this.format()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">format () {</span><span class="s3">\n    </span><span class="s1">this.version = `${this.major}.${this.minor}.${this.patch}`</span><span class="s3">\n    </span><span class="s1">if (this.prerelease.length) {</span><span class="s3">\n      </span><span class="s1">this.version += `-${this.prerelease.join('.')}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.version</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">return this.version</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">compare (other) {</span><span class="s3">\n    </span><span class="s1">debug('SemVer.compare', this.version, this.options, other)</span><span class="s3">\n    </span><span class="s1">if (!(other instanceof SemVer)) {</span><span class="s3">\n      </span><span class="s1">if (typeof other === 'string' &amp;&amp; other === this.version) {</span><span class="s3">\n        </span><span class="s1">return 0</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">other = new SemVer(other, this.options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (other.version === this.version) {</span><span class="s3">\n      </span><span class="s1">return 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.compareMain(other) || this.comparePre(other)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">compareMain (other) {</span><span class="s3">\n    </span><span class="s1">if (!(other instanceof SemVer)) {</span><span class="s3">\n      </span><span class="s1">other = new SemVer(other, this.options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">compareIdentifiers(this.major, other.major) ||</span><span class="s3">\n      </span><span class="s1">compareIdentifiers(this.minor, other.minor) ||</span><span class="s3">\n      </span><span class="s1">compareIdentifiers(this.patch, other.patch)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">comparePre (other) {</span><span class="s3">\n    </span><span class="s1">if (!(other instanceof SemVer)) {</span><span class="s3">\n      </span><span class="s1">other = new SemVer(other, this.options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// NOT having a prerelease is &gt; having one</span><span class="s3">\n    </span><span class="s1">if (this.prerelease.length &amp;&amp; !other.prerelease.length) {</span><span class="s3">\n      </span><span class="s1">return -1</span><span class="s3">\n    </span><span class="s1">} else if (!this.prerelease.length &amp;&amp; other.prerelease.length) {</span><span class="s3">\n      </span><span class="s1">return 1</span><span class="s3">\n    </span><span class="s1">} else if (!this.prerelease.length &amp;&amp; !other.prerelease.length) {</span><span class="s3">\n      </span><span class="s1">return 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let i = 0</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">const a = this.prerelease[i]</span><span class="s3">\n      </span><span class="s1">const b = other.prerelease[i]</span><span class="s3">\n      </span><span class="s1">debug('prerelease compare', i, a, b)</span><span class="s3">\n      </span><span class="s1">if (a === undefined &amp;&amp; b === undefined) {</span><span class="s3">\n        </span><span class="s1">return 0</span><span class="s3">\n      </span><span class="s1">} else if (b === undefined) {</span><span class="s3">\n        </span><span class="s1">return 1</span><span class="s3">\n      </span><span class="s1">} else if (a === undefined) {</span><span class="s3">\n        </span><span class="s1">return -1</span><span class="s3">\n      </span><span class="s1">} else if (a === b) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return compareIdentifiers(a, b)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while (++i)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">compareBuild (other) {</span><span class="s3">\n    </span><span class="s1">if (!(other instanceof SemVer)) {</span><span class="s3">\n      </span><span class="s1">other = new SemVer(other, this.options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let i = 0</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">const a = this.build[i]</span><span class="s3">\n      </span><span class="s1">const b = other.build[i]</span><span class="s3">\n      </span><span class="s1">debug('build compare', i, a, b)</span><span class="s3">\n      </span><span class="s1">if (a === undefined &amp;&amp; b === undefined) {</span><span class="s3">\n        </span><span class="s1">return 0</span><span class="s3">\n      </span><span class="s1">} else if (b === undefined) {</span><span class="s3">\n        </span><span class="s1">return 1</span><span class="s3">\n      </span><span class="s1">} else if (a === undefined) {</span><span class="s3">\n        </span><span class="s1">return -1</span><span class="s3">\n      </span><span class="s1">} else if (a === b) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return compareIdentifiers(a, b)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while (++i)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// preminor will bump the version up to the next minor release, and immediately</span><span class="s3">\n  </span><span class="s1">// down to pre-release. premajor and prepatch work the same way.</span><span class="s3">\n  </span><span class="s1">inc (release, identifier, identifierBase) {</span><span class="s3">\n    </span><span class="s1">switch (release) {</span><span class="s3">\n      </span><span class="s1">case 'premajor':</span><span class="s3">\n        </span><span class="s1">this.prerelease.length = 0</span><span class="s3">\n        </span><span class="s1">this.patch = 0</span><span class="s3">\n        </span><span class="s1">this.minor = 0</span><span class="s3">\n        </span><span class="s1">this.major++</span><span class="s3">\n        </span><span class="s1">this.inc('pre', identifier, identifierBase)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'preminor':</span><span class="s3">\n        </span><span class="s1">this.prerelease.length = 0</span><span class="s3">\n        </span><span class="s1">this.patch = 0</span><span class="s3">\n        </span><span class="s1">this.minor++</span><span class="s3">\n        </span><span class="s1">this.inc('pre', identifier, identifierBase)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'prepatch':</span><span class="s3">\n        </span><span class="s1">// If this is already a prerelease, it will bump to the next version</span><span class="s3">\n        </span><span class="s1">// drop any prereleases that might already exist, since they are not</span><span class="s3">\n        </span><span class="s1">// relevant at this point.</span><span class="s3">\n        </span><span class="s1">this.prerelease.length = 0</span><span class="s3">\n        </span><span class="s1">this.inc('patch', identifier, identifierBase)</span><span class="s3">\n        </span><span class="s1">this.inc('pre', identifier, identifierBase)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">// If the input is a non-prerelease version, this acts the same as</span><span class="s3">\n      </span><span class="s1">// prepatch.</span><span class="s3">\n      </span><span class="s1">case 'prerelease':</span><span class="s3">\n        </span><span class="s1">if (this.prerelease.length === 0) {</span><span class="s3">\n          </span><span class="s1">this.inc('patch', identifier, identifierBase)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.inc('pre', identifier, identifierBase)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n\n      </span><span class="s1">case 'major':</span><span class="s3">\n        </span><span class="s1">// If this is a pre-major version, bump up to the same major version.</span><span class="s3">\n        </span><span class="s1">// Otherwise increment major.</span><span class="s3">\n        </span><span class="s1">// 1.0.0-5 bumps to 1.0.0</span><span class="s3">\n        </span><span class="s1">// 1.1.0 bumps to 2.0.0</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">this.minor !== 0 ||</span><span class="s3">\n          </span><span class="s1">this.patch !== 0 ||</span><span class="s3">\n          </span><span class="s1">this.prerelease.length === 0</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.major++</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.minor = 0</span><span class="s3">\n        </span><span class="s1">this.patch = 0</span><span class="s3">\n        </span><span class="s1">this.prerelease = []</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'minor':</span><span class="s3">\n        </span><span class="s1">// If this is a pre-minor version, bump up to the same minor version.</span><span class="s3">\n        </span><span class="s1">// Otherwise increment minor.</span><span class="s3">\n        </span><span class="s1">// 1.2.0-5 bumps to 1.2.0</span><span class="s3">\n        </span><span class="s1">// 1.2.1 bumps to 1.3.0</span><span class="s3">\n        </span><span class="s1">if (this.patch !== 0 || this.prerelease.length === 0) {</span><span class="s3">\n          </span><span class="s1">this.minor++</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.patch = 0</span><span class="s3">\n        </span><span class="s1">this.prerelease = []</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'patch':</span><span class="s3">\n        </span><span class="s1">// If this is not a pre-release version, it will increment the patch.</span><span class="s3">\n        </span><span class="s1">// If it is a pre-release it will bump up to the same patch version.</span><span class="s3">\n        </span><span class="s1">// 1.2.0-5 patches to 1.2.0</span><span class="s3">\n        </span><span class="s1">// 1.2.0 patches to 1.2.1</span><span class="s3">\n        </span><span class="s1">if (this.prerelease.length === 0) {</span><span class="s3">\n          </span><span class="s1">this.patch++</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.prerelease = []</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">// This probably shouldn't be used publicly.</span><span class="s3">\n      </span><span class="s1">// 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.</span><span class="s3">\n      </span><span class="s1">case 'pre': {</span><span class="s3">\n        </span><span class="s1">const base = Number(identifierBase) ? 1 : 0</span><span class="s3">\n\n        </span><span class="s1">if (!identifier &amp;&amp; identifierBase === false) {</span><span class="s3">\n          </span><span class="s1">throw new Error('invalid increment argument: identifier is empty')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (this.prerelease.length === 0) {</span><span class="s3">\n          </span><span class="s1">this.prerelease = [base]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">let i = this.prerelease.length</span><span class="s3">\n          </span><span class="s1">while (--i &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">if (typeof this.prerelease[i] === 'number') {</span><span class="s3">\n              </span><span class="s1">this.prerelease[i]++</span><span class="s3">\n              </span><span class="s1">i = -2</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (i === -1) {</span><span class="s3">\n            </span><span class="s1">// didn't increment anything</span><span class="s3">\n            </span><span class="s1">if (identifier === this.prerelease.join('.') &amp;&amp; identifierBase === false) {</span><span class="s3">\n              </span><span class="s1">throw new Error('invalid increment argument: identifier already exists')</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.prerelease.push(base)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (identifier) {</span><span class="s3">\n          </span><span class="s1">// 1.2.0-beta.1 bumps to 1.2.0-beta.2,</span><span class="s3">\n          </span><span class="s1">// 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0</span><span class="s3">\n          </span><span class="s1">let prerelease = [identifier, base]</span><span class="s3">\n          </span><span class="s1">if (identifierBase === false) {</span><span class="s3">\n            </span><span class="s1">prerelease = [identifier]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (compareIdentifiers(this.prerelease[0], identifier) === 0) {</span><span class="s3">\n            </span><span class="s1">if (isNaN(this.prerelease[1])) {</span><span class="s3">\n              </span><span class="s1">this.prerelease = prerelease</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">this.prerelease = prerelease</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(`invalid increment argument: ${release}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.raw = this.format()</span><span class="s3">\n    </span><span class="s1">if (this.build.length) {</span><span class="s3">\n      </span><span class="s1">this.raw += `+${this.build.join('.')}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = SemVer</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const parse = require('./parse')</span><span class="s3">\n</span><span class="s1">const clean = (version, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">const s = parse(version.trim().replace(/^[=v]+/, ''), options)</span><span class="s3">\n  </span><span class="s1">return s ? s.version : null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = clean</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const eq = require('./eq')</span><span class="s3">\n</span><span class="s1">const neq = require('./neq')</span><span class="s3">\n</span><span class="s1">const gt = require('./gt')</span><span class="s3">\n</span><span class="s1">const gte = require('./gte')</span><span class="s3">\n</span><span class="s1">const lt = require('./lt')</span><span class="s3">\n</span><span class="s1">const lte = require('./lte')</span><span class="s3">\n\n</span><span class="s1">const cmp = (a, op, b, loose) =&gt; {</span><span class="s3">\n  </span><span class="s1">switch (op) {</span><span class="s3">\n    </span><span class="s1">case '===':</span><span class="s3">\n      </span><span class="s1">if (typeof a === 'object') {</span><span class="s3">\n        </span><span class="s1">a = a.version</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (typeof b === 'object') {</span><span class="s3">\n        </span><span class="s1">b = b.version</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return a === b</span><span class="s3">\n\n    </span><span class="s1">case '!==':</span><span class="s3">\n      </span><span class="s1">if (typeof a === 'object') {</span><span class="s3">\n        </span><span class="s1">a = a.version</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (typeof b === 'object') {</span><span class="s3">\n        </span><span class="s1">b = b.version</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return a !== b</span><span class="s3">\n\n    </span><span class="s1">case '':</span><span class="s3">\n    </span><span class="s1">case '=':</span><span class="s3">\n    </span><span class="s1">case '==':</span><span class="s3">\n      </span><span class="s1">return eq(a, b, loose)</span><span class="s3">\n\n    </span><span class="s1">case '!=':</span><span class="s3">\n      </span><span class="s1">return neq(a, b, loose)</span><span class="s3">\n\n    </span><span class="s1">case '&gt;':</span><span class="s3">\n      </span><span class="s1">return gt(a, b, loose)</span><span class="s3">\n\n    </span><span class="s1">case '&gt;=':</span><span class="s3">\n      </span><span class="s1">return gte(a, b, loose)</span><span class="s3">\n\n    </span><span class="s1">case '&lt;':</span><span class="s3">\n      </span><span class="s1">return lt(a, b, loose)</span><span class="s3">\n\n    </span><span class="s1">case '&lt;=':</span><span class="s3">\n      </span><span class="s1">return lte(a, b, loose)</span><span class="s3">\n\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new TypeError(`Invalid operator: ${op}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = cmp</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const parse = require('./parse')</span><span class="s3">\n</span><span class="s1">const { safeRe: re, t } = require('../internal/re')</span><span class="s3">\n\n</span><span class="s1">const coerce = (version, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (version instanceof SemVer) {</span><span class="s3">\n    </span><span class="s1">return version</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof version === 'number') {</span><span class="s3">\n    </span><span class="s1">version = String(version)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof version !== 'string') {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">options = options || {}</span><span class="s3">\n\n  </span><span class="s1">let match = null</span><span class="s3">\n  </span><span class="s1">if (!options.rtl) {</span><span class="s3">\n    </span><span class="s1">match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Find the right-most coercible string that does not share</span><span class="s3">\n    </span><span class="s1">// a terminus with a more left-ward coercible string.</span><span class="s3">\n    </span><span class="s1">// Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'</span><span class="s3">\n    </span><span class="s1">// With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Walk through the string checking with a /g regexp</span><span class="s3">\n    </span><span class="s1">// Manually set the index so as to pick up overlapping matches.</span><span class="s3">\n    </span><span class="s1">// Stop when we get a match that ends at the string end, since no</span><span class="s3">\n    </span><span class="s1">// coercible string can be more right-ward without the same terminus.</span><span class="s3">\n    </span><span class="s1">const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]</span><span class="s3">\n    </span><span class="s1">let next</span><span class="s3">\n    </span><span class="s1">while ((next = coerceRtlRegex.exec(version)) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!match || match.index + match[0].length !== version.length)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (!match ||</span><span class="s3">\n            </span><span class="s1">next.index + next[0].length !== match.index + match[0].length) {</span><span class="s3">\n        </span><span class="s1">match = next</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// leave it in a clean state</span><span class="s3">\n    </span><span class="s1">coerceRtlRegex.lastIndex = -1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (match === null) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const major = match[2]</span><span class="s3">\n  </span><span class="s1">const minor = match[3] || '0'</span><span class="s3">\n  </span><span class="s1">const patch = match[4] || '0'</span><span class="s3">\n  </span><span class="s1">const prerelease = options.includePrerelease &amp;&amp; match[5] ? `-${match[5]}` : ''</span><span class="s3">\n  </span><span class="s1">const build = options.includePrerelease &amp;&amp; match[6] ? `+${match[6]}` : ''</span><span class="s3">\n\n  </span><span class="s1">return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = coerce</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const compareBuild = (a, b, loose) =&gt; {</span><span class="s3">\n  </span><span class="s1">const versionA = new SemVer(a, loose)</span><span class="s3">\n  </span><span class="s1">const versionB = new SemVer(b, loose)</span><span class="s3">\n  </span><span class="s1">return versionA.compare(versionB) || versionA.compareBuild(versionB)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = compareBuild</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const compareLoose = (a, b) =&gt; compare(a, b, true)</span><span class="s3">\n</span><span class="s1">module.exports = compareLoose</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const compare = (a, b, loose) =&gt;</span><span class="s3">\n  </span><span class="s1">new SemVer(a, loose).compare(new SemVer(b, loose))</span><span class="s3">\n\n</span><span class="s1">module.exports = compare</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const parse = require('./parse.js')</span><span class="s3">\n\n</span><span class="s1">const diff = (version1, version2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const v1 = parse(version1, null, true)</span><span class="s3">\n  </span><span class="s1">const v2 = parse(version2, null, true)</span><span class="s3">\n  </span><span class="s1">const comparison = v1.compare(v2)</span><span class="s3">\n\n  </span><span class="s1">if (comparison === 0) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const v1Higher = comparison &gt; 0</span><span class="s3">\n  </span><span class="s1">const highVersion = v1Higher ? v1 : v2</span><span class="s3">\n  </span><span class="s1">const lowVersion = v1Higher ? v2 : v1</span><span class="s3">\n  </span><span class="s1">const highHasPre = !!highVersion.prerelease.length</span><span class="s3">\n  </span><span class="s1">const lowHasPre = !!lowVersion.prerelease.length</span><span class="s3">\n\n  </span><span class="s1">if (lowHasPre &amp;&amp; !highHasPre) {</span><span class="s3">\n    </span><span class="s1">// Going from prerelease -&gt; no prerelease requires some special casing</span><span class="s3">\n\n    </span><span class="s1">// If the low version has only a major, then it will always be a major</span><span class="s3">\n    </span><span class="s1">// Some examples:</span><span class="s3">\n    </span><span class="s1">// 1.0.0-1 -&gt; 1.0.0</span><span class="s3">\n    </span><span class="s1">// 1.0.0-1 -&gt; 1.1.1</span><span class="s3">\n    </span><span class="s1">// 1.0.0-1 -&gt; 2.0.0</span><span class="s3">\n    </span><span class="s1">if (!lowVersion.patch &amp;&amp; !lowVersion.minor) {</span><span class="s3">\n      </span><span class="s1">return 'major'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Otherwise it can be determined by checking the high version</span><span class="s3">\n\n    </span><span class="s1">if (highVersion.patch) {</span><span class="s3">\n      </span><span class="s1">// anything higher than a patch bump would result in the wrong version</span><span class="s3">\n      </span><span class="s1">return 'patch'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (highVersion.minor) {</span><span class="s3">\n      </span><span class="s1">// anything higher than a minor bump would result in the wrong version</span><span class="s3">\n      </span><span class="s1">return 'minor'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// bumping major/minor/patch all have same result</span><span class="s3">\n    </span><span class="s1">return 'major'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add the `pre` prefix if we are going to a prerelease version</span><span class="s3">\n  </span><span class="s1">const prefix = highHasPre ? 'pre' : ''</span><span class="s3">\n\n  </span><span class="s1">if (v1.major !== v2.major) {</span><span class="s3">\n    </span><span class="s1">return prefix + 'major'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (v1.minor !== v2.minor) {</span><span class="s3">\n    </span><span class="s1">return prefix + 'minor'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (v1.patch !== v2.patch) {</span><span class="s3">\n    </span><span class="s1">return prefix + 'patch'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// high and low are preleases</span><span class="s3">\n  </span><span class="s1">return 'prerelease'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = diff</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const eq = (a, b, loose) =&gt; compare(a, b, loose) === 0</span><span class="s3">\n</span><span class="s1">module.exports = eq</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const gt = (a, b, loose) =&gt; compare(a, b, loose) &gt; 0</span><span class="s3">\n</span><span class="s1">module.exports = gt</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const gte = (a, b, loose) =&gt; compare(a, b, loose) &gt;= 0</span><span class="s3">\n</span><span class="s1">module.exports = gte</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n\n</span><span class="s1">const inc = (version, release, options, identifier, identifierBase) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof (options) === 'string') {</span><span class="s3">\n    </span><span class="s1">identifierBase = identifier</span><span class="s3">\n    </span><span class="s1">identifier = options</span><span class="s3">\n    </span><span class="s1">options = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return new SemVer(</span><span class="s3">\n      </span><span class="s1">version instanceof SemVer ? version.version : version,</span><span class="s3">\n      </span><span class="s1">options</span><span class="s3">\n    </span><span class="s1">).inc(release, identifier, identifierBase).version</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = inc</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const lt = (a, b, loose) =&gt; compare(a, b, loose) &lt; 0</span><span class="s3">\n</span><span class="s1">module.exports = lt</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const lte = (a, b, loose) =&gt; compare(a, b, loose) &lt;= 0</span><span class="s3">\n</span><span class="s1">module.exports = lte</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const major = (a, loose) =&gt; new SemVer(a, loose).major</span><span class="s3">\n</span><span class="s1">module.exports = major</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const minor = (a, loose) =&gt; new SemVer(a, loose).minor</span><span class="s3">\n</span><span class="s1">module.exports = minor</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const neq = (a, b, loose) =&gt; compare(a, b, loose) !== 0</span><span class="s3">\n</span><span class="s1">module.exports = neq</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const parse = (version, options, throwErrors = false) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (version instanceof SemVer) {</span><span class="s3">\n    </span><span class="s1">return version</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return new SemVer(version, options)</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">if (!throwErrors) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw er</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = parse</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const patch = (a, loose) =&gt; new SemVer(a, loose).patch</span><span class="s3">\n</span><span class="s1">module.exports = patch</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const parse = require('./parse')</span><span class="s3">\n</span><span class="s1">const prerelease = (version, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">const parsed = parse(version, options)</span><span class="s3">\n  </span><span class="s1">return (parsed &amp;&amp; parsed.prerelease.length) ? parsed.prerelease : null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = prerelease</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compare = require('./compare')</span><span class="s3">\n</span><span class="s1">const rcompare = (a, b, loose) =&gt; compare(b, a, loose)</span><span class="s3">\n</span><span class="s1">module.exports = rcompare</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compareBuild = require('./compare-build')</span><span class="s3">\n</span><span class="s1">const rsort = (list, loose) =&gt; list.sort((a, b) =&gt; compareBuild(b, a, loose))</span><span class="s3">\n</span><span class="s1">module.exports = rsort</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const Range = require('../classes/range')</span><span class="s3">\n</span><span class="s1">const satisfies = (version, range, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">range = new Range(range, options)</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return range.test(version)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = satisfies</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const compareBuild = require('./compare-build')</span><span class="s3">\n</span><span class="s1">const sort = (list, loose) =&gt; list.sort((a, b) =&gt; compareBuild(a, b, loose))</span><span class="s3">\n</span><span class="s1">module.exports = sort</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const parse = require('./parse')</span><span class="s3">\n</span><span class="s1">const valid = (version, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">const v = parse(version, options)</span><span class="s3">\n  </span><span class="s1">return v ? v.version : null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = valid</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// just pre-load all the stuff that index.js lazily exports</span><span class="s3">\n</span><span class="s1">const internalRe = require('./internal/re')</span><span class="s3">\n</span><span class="s1">const constants = require('./internal/constants')</span><span class="s3">\n</span><span class="s1">const SemVer = require('./classes/semver')</span><span class="s3">\n</span><span class="s1">const identifiers = require('./internal/identifiers')</span><span class="s3">\n</span><span class="s1">const parse = require('./functions/parse')</span><span class="s3">\n</span><span class="s1">const valid = require('./functions/valid')</span><span class="s3">\n</span><span class="s1">const clean = require('./functions/clean')</span><span class="s3">\n</span><span class="s1">const inc = require('./functions/inc')</span><span class="s3">\n</span><span class="s1">const diff = require('./functions/diff')</span><span class="s3">\n</span><span class="s1">const major = require('./functions/major')</span><span class="s3">\n</span><span class="s1">const minor = require('./functions/minor')</span><span class="s3">\n</span><span class="s1">const patch = require('./functions/patch')</span><span class="s3">\n</span><span class="s1">const prerelease = require('./functions/prerelease')</span><span class="s3">\n</span><span class="s1">const compare = require('./functions/compare')</span><span class="s3">\n</span><span class="s1">const rcompare = require('./functions/rcompare')</span><span class="s3">\n</span><span class="s1">const compareLoose = require('./functions/compare-loose')</span><span class="s3">\n</span><span class="s1">const compareBuild = require('./functions/compare-build')</span><span class="s3">\n</span><span class="s1">const sort = require('./functions/sort')</span><span class="s3">\n</span><span class="s1">const rsort = require('./functions/rsort')</span><span class="s3">\n</span><span class="s1">const gt = require('./functions/gt')</span><span class="s3">\n</span><span class="s1">const lt = require('./functions/lt')</span><span class="s3">\n</span><span class="s1">const eq = require('./functions/eq')</span><span class="s3">\n</span><span class="s1">const neq = require('./functions/neq')</span><span class="s3">\n</span><span class="s1">const gte = require('./functions/gte')</span><span class="s3">\n</span><span class="s1">const lte = require('./functions/lte')</span><span class="s3">\n</span><span class="s1">const cmp = require('./functions/cmp')</span><span class="s3">\n</span><span class="s1">const coerce = require('./functions/coerce')</span><span class="s3">\n</span><span class="s1">const Comparator = require('./classes/comparator')</span><span class="s3">\n</span><span class="s1">const Range = require('./classes/range')</span><span class="s3">\n</span><span class="s1">const satisfies = require('./functions/satisfies')</span><span class="s3">\n</span><span class="s1">const toComparators = require('./ranges/to-comparators')</span><span class="s3">\n</span><span class="s1">const maxSatisfying = require('./ranges/max-satisfying')</span><span class="s3">\n</span><span class="s1">const minSatisfying = require('./ranges/min-satisfying')</span><span class="s3">\n</span><span class="s1">const minVersion = require('./ranges/min-version')</span><span class="s3">\n</span><span class="s1">const validRange = require('./ranges/valid')</span><span class="s3">\n</span><span class="s1">const outside = require('./ranges/outside')</span><span class="s3">\n</span><span class="s1">const gtr = require('./ranges/gtr')</span><span class="s3">\n</span><span class="s1">const ltr = require('./ranges/ltr')</span><span class="s3">\n</span><span class="s1">const intersects = require('./ranges/intersects')</span><span class="s3">\n</span><span class="s1">const simplifyRange = require('./ranges/simplify')</span><span class="s3">\n</span><span class="s1">const subset = require('./ranges/subset')</span><span class="s3">\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">parse,</span><span class="s3">\n  </span><span class="s1">valid,</span><span class="s3">\n  </span><span class="s1">clean,</span><span class="s3">\n  </span><span class="s1">inc,</span><span class="s3">\n  </span><span class="s1">diff,</span><span class="s3">\n  </span><span class="s1">major,</span><span class="s3">\n  </span><span class="s1">minor,</span><span class="s3">\n  </span><span class="s1">patch,</span><span class="s3">\n  </span><span class="s1">prerelease,</span><span class="s3">\n  </span><span class="s1">compare,</span><span class="s3">\n  </span><span class="s1">rcompare,</span><span class="s3">\n  </span><span class="s1">compareLoose,</span><span class="s3">\n  </span><span class="s1">compareBuild,</span><span class="s3">\n  </span><span class="s1">sort,</span><span class="s3">\n  </span><span class="s1">rsort,</span><span class="s3">\n  </span><span class="s1">gt,</span><span class="s3">\n  </span><span class="s1">lt,</span><span class="s3">\n  </span><span class="s1">eq,</span><span class="s3">\n  </span><span class="s1">neq,</span><span class="s3">\n  </span><span class="s1">gte,</span><span class="s3">\n  </span><span class="s1">lte,</span><span class="s3">\n  </span><span class="s1">cmp,</span><span class="s3">\n  </span><span class="s1">coerce,</span><span class="s3">\n  </span><span class="s1">Comparator,</span><span class="s3">\n  </span><span class="s1">Range,</span><span class="s3">\n  </span><span class="s1">satisfies,</span><span class="s3">\n  </span><span class="s1">toComparators,</span><span class="s3">\n  </span><span class="s1">maxSatisfying,</span><span class="s3">\n  </span><span class="s1">minSatisfying,</span><span class="s3">\n  </span><span class="s1">minVersion,</span><span class="s3">\n  </span><span class="s1">validRange,</span><span class="s3">\n  </span><span class="s1">outside,</span><span class="s3">\n  </span><span class="s1">gtr,</span><span class="s3">\n  </span><span class="s1">ltr,</span><span class="s3">\n  </span><span class="s1">intersects,</span><span class="s3">\n  </span><span class="s1">simplifyRange,</span><span class="s3">\n  </span><span class="s1">subset,</span><span class="s3">\n  </span><span class="s1">SemVer,</span><span class="s3">\n  </span><span class="s1">re: internalRe.re,</span><span class="s3">\n  </span><span class="s1">src: internalRe.src,</span><span class="s3">\n  </span><span class="s1">tokens: internalRe.t,</span><span class="s3">\n  </span><span class="s1">SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,</span><span class="s3">\n  </span><span class="s1">RELEASE_TYPES: constants.RELEASE_TYPES,</span><span class="s3">\n  </span><span class="s1">compareIdentifiers: identifiers.compareIdentifiers,</span><span class="s3">\n  </span><span class="s1">rcompareIdentifiers: identifiers.rcompareIdentifiers,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Note: this is the semver.org version of the spec that it implements</span><span class="s3">\n</span><span class="s1">// Not necessarily the package version of this code.</span><span class="s3">\n</span><span class="s1">const SEMVER_SPEC_VERSION = '2.0.0'</span><span class="s3">\n\n</span><span class="s1">const MAX_LENGTH = 256</span><span class="s3">\n</span><span class="s1">const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||</span><span class="s3">\n</span><span class="s1">/* istanbul ignore next */ 9007199254740991</span><span class="s3">\n\n</span><span class="s1">// Max safe segment length for coercion.</span><span class="s3">\n</span><span class="s1">const MAX_SAFE_COMPONENT_LENGTH = 16</span><span class="s3">\n\n</span><span class="s1">// Max safe length for a build identifier. The max length minus 6 characters for</span><span class="s3">\n</span><span class="s1">// the shortest version with a build 0.0.0+BUILD.</span><span class="s3">\n</span><span class="s1">const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6</span><span class="s3">\n\n</span><span class="s1">const RELEASE_TYPES = [</span><span class="s3">\n  </span><span class="s1">'major',</span><span class="s3">\n  </span><span class="s1">'premajor',</span><span class="s3">\n  </span><span class="s1">'minor',</span><span class="s3">\n  </span><span class="s1">'preminor',</span><span class="s3">\n  </span><span class="s1">'patch',</span><span class="s3">\n  </span><span class="s1">'prepatch',</span><span class="s3">\n  </span><span class="s1">'prerelease',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">MAX_LENGTH,</span><span class="s3">\n  </span><span class="s1">MAX_SAFE_COMPONENT_LENGTH,</span><span class="s3">\n  </span><span class="s1">MAX_SAFE_BUILD_LENGTH,</span><span class="s3">\n  </span><span class="s1">MAX_SAFE_INTEGER,</span><span class="s3">\n  </span><span class="s1">RELEASE_TYPES,</span><span class="s3">\n  </span><span class="s1">SEMVER_SPEC_VERSION,</span><span class="s3">\n  </span><span class="s1">FLAG_INCLUDE_PRERELEASE: 0b001,</span><span class="s3">\n  </span><span class="s1">FLAG_LOOSE: 0b010,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const debug = (</span><span class="s3">\n  </span><span class="s1">typeof process === 'object' &amp;&amp;</span><span class="s3">\n  </span><span class="s1">process.env &amp;&amp;</span><span class="s3">\n  </span><span class="s1">process.env.NODE_DEBUG &amp;&amp;</span><span class="s3">\n  </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">bsemver</span><span class="s3">\\</span><span class="s1">b/i.test(process.env.NODE_DEBUG)</span><span class="s3">\n</span><span class="s1">) ? (...args) =&gt; console.error('SEMVER', ...args)</span><span class="s3">\n  </span><span class="s1">: () =&gt; {}</span><span class="s3">\n\n</span><span class="s1">module.exports = debug</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const numeric = /^[0-9]+$/</span><span class="s3">\n</span><span class="s1">const compareIdentifiers = (a, b) =&gt; {</span><span class="s3">\n  </span><span class="s1">const anum = numeric.test(a)</span><span class="s3">\n  </span><span class="s1">const bnum = numeric.test(b)</span><span class="s3">\n\n  </span><span class="s1">if (anum &amp;&amp; bnum) {</span><span class="s3">\n    </span><span class="s1">a = +a</span><span class="s3">\n    </span><span class="s1">b = +b</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return a === b ? 0</span><span class="s3">\n    </span><span class="s1">: (anum &amp;&amp; !bnum) ? -1</span><span class="s3">\n    </span><span class="s1">: (bnum &amp;&amp; !anum) ? 1</span><span class="s3">\n    </span><span class="s1">: a &lt; b ? -1</span><span class="s3">\n    </span><span class="s1">: 1</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const rcompareIdentifiers = (a, b) =&gt; compareIdentifiers(b, a)</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">compareIdentifiers,</span><span class="s3">\n  </span><span class="s1">rcompareIdentifiers,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;class LRUCache {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.max = 1000</span><span class="s3">\n    </span><span class="s1">this.map = new Map()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get (key) {</span><span class="s3">\n    </span><span class="s1">const value = this.map.get(key)</span><span class="s3">\n    </span><span class="s1">if (value === undefined) {</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Remove the key from the map and add it to the end</span><span class="s3">\n      </span><span class="s1">this.map.delete(key)</span><span class="s3">\n      </span><span class="s1">this.map.set(key, value)</span><span class="s3">\n      </span><span class="s1">return value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">delete (key) {</span><span class="s3">\n    </span><span class="s1">return this.map.delete(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set (key, value) {</span><span class="s3">\n    </span><span class="s1">const deleted = this.delete(key)</span><span class="s3">\n\n    </span><span class="s1">if (!deleted &amp;&amp; value !== undefined) {</span><span class="s3">\n      </span><span class="s1">// If cache is full, delete the least recently used item</span><span class="s3">\n      </span><span class="s1">if (this.map.size &gt;= this.max) {</span><span class="s3">\n        </span><span class="s1">const firstKey = this.map.keys().next().value</span><span class="s3">\n        </span><span class="s1">this.delete(firstKey)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.map.set(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = LRUCache</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// parse out just the options we care about</span><span class="s3">\n</span><span class="s1">const looseOption = Object.freeze({ loose: true })</span><span class="s3">\n</span><span class="s1">const emptyOpts = Object.freeze({ })</span><span class="s3">\n</span><span class="s1">const parseOptions = options =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!options) {</span><span class="s3">\n    </span><span class="s1">return emptyOpts</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof options !== 'object') {</span><span class="s3">\n    </span><span class="s1">return looseOption</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return options</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = parseOptions</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const {</span><span class="s3">\n  </span><span class="s1">MAX_SAFE_COMPONENT_LENGTH,</span><span class="s3">\n  </span><span class="s1">MAX_SAFE_BUILD_LENGTH,</span><span class="s3">\n  </span><span class="s1">MAX_LENGTH,</span><span class="s3">\n</span><span class="s1">} = require('./constants')</span><span class="s3">\n</span><span class="s1">const debug = require('./debug')</span><span class="s3">\n</span><span class="s1">exports = module.exports = {}</span><span class="s3">\n\n</span><span class="s1">// The actual regexps go on exports.re</span><span class="s3">\n</span><span class="s1">const re = exports.re = []</span><span class="s3">\n</span><span class="s1">const safeRe = exports.safeRe = []</span><span class="s3">\n</span><span class="s1">const src = exports.src = []</span><span class="s3">\n</span><span class="s1">const t = exports.t = {}</span><span class="s3">\n</span><span class="s1">let R = 0</span><span class="s3">\n\n</span><span class="s1">const LETTERDASHNUMBER = '[a-zA-Z0-9-]'</span><span class="s3">\n\n</span><span class="s1">// Replace some greedy regex tokens to prevent regex dos issues. These regex are</span><span class="s3">\n</span><span class="s1">// used internally via the safeRe object since all inputs in this library get</span><span class="s3">\n</span><span class="s1">// normalized first to trim and collapse all extra whitespace. The original</span><span class="s3">\n</span><span class="s1">// regexes are exported for userland consumption and lower level usage. A</span><span class="s3">\n</span><span class="s1">// future breaking change could export the safer regex only with a note that</span><span class="s3">\n</span><span class="s1">// all input should have extra whitespace removed.</span><span class="s3">\n</span><span class="s1">const safeRegexReplacements = [</span><span class="s3">\n  </span><span class="s1">['</span><span class="s3">\\\\</span><span class="s1">s', 1],</span><span class="s3">\n  </span><span class="s1">['</span><span class="s3">\\\\</span><span class="s1">d', MAX_LENGTH],</span><span class="s3">\n  </span><span class="s1">[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">const makeSafeRegex = (value) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const [token, max] of safeRegexReplacements) {</span><span class="s3">\n    </span><span class="s1">value = value</span><span class="s3">\n      </span><span class="s1">.split(`${token}*`).join(`${token}{0,${max}}`)</span><span class="s3">\n      </span><span class="s1">.split(`${token}+`).join(`${token}{1,${max}}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const createToken = (name, value, isGlobal) =&gt; {</span><span class="s3">\n  </span><span class="s1">const safe = makeSafeRegex(value)</span><span class="s3">\n  </span><span class="s1">const index = R++</span><span class="s3">\n  </span><span class="s1">debug(name, index, value)</span><span class="s3">\n  </span><span class="s1">t[name] = index</span><span class="s3">\n  </span><span class="s1">src[index] = value</span><span class="s3">\n  </span><span class="s1">re[index] = new RegExp(value, isGlobal ? 'g' : undefined)</span><span class="s3">\n  </span><span class="s1">safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The following Regular Expressions can be used for tokenizing,</span><span class="s3">\n</span><span class="s1">// validating, and parsing SemVer version strings.</span><span class="s3">\n\n</span><span class="s1">// ## Numeric Identifier</span><span class="s3">\n</span><span class="s1">// A single `0`, or a non-zero digit followed by zero or more digits.</span><span class="s3">\n\n</span><span class="s1">createToken('NUMERICIDENTIFIER', '0|[1-9]</span><span class="s3">\\\\</span><span class="s1">d*')</span><span class="s3">\n</span><span class="s1">createToken('NUMERICIDENTIFIERLOOSE', '</span><span class="s3">\\\\</span><span class="s1">d+')</span><span class="s3">\n\n</span><span class="s1">// ## Non-numeric Identifier</span><span class="s3">\n</span><span class="s1">// Zero or more digits, followed by a letter or hyphen, and then zero or</span><span class="s3">\n</span><span class="s1">// more letters, digits, or hyphens.</span><span class="s3">\n\n</span><span class="s1">createToken('NONNUMERICIDENTIFIER', `</span><span class="s3">\\\\</span><span class="s1">d*[a-zA-Z-]${LETTERDASHNUMBER}*`)</span><span class="s3">\n\n</span><span class="s1">// ## Main Version</span><span class="s3">\n</span><span class="s1">// Three dot-separated numeric identifiers.</span><span class="s3">\n\n</span><span class="s1">createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})</span><span class="s3">\\\\</span><span class="s1">.` +</span><span class="s3">\n                   </span><span class="s1">`(${src[t.NUMERICIDENTIFIER]})</span><span class="s3">\\\\</span><span class="s1">.` +</span><span class="s3">\n                   </span><span class="s1">`(${src[t.NUMERICIDENTIFIER]})`)</span><span class="s3">\n\n</span><span class="s1">createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})</span><span class="s3">\\\\</span><span class="s1">.` +</span><span class="s3">\n                        </span><span class="s1">`(${src[t.NUMERICIDENTIFIERLOOSE]})</span><span class="s3">\\\\</span><span class="s1">.` +</span><span class="s3">\n                        </span><span class="s1">`(${src[t.NUMERICIDENTIFIERLOOSE]})`)</span><span class="s3">\n\n</span><span class="s1">// ## Pre-release Version Identifier</span><span class="s3">\n</span><span class="s1">// A numeric identifier, or a non-numeric identifier.</span><span class="s3">\n\n</span><span class="s1">createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]</span><span class="s3">\n</span><span class="s1">}|${src[t.NONNUMERICIDENTIFIER]})`)</span><span class="s3">\n\n</span><span class="s1">createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]</span><span class="s3">\n</span><span class="s1">}|${src[t.NONNUMERICIDENTIFIER]})`)</span><span class="s3">\n\n</span><span class="s1">// ## Pre-release Version</span><span class="s3">\n</span><span class="s1">// Hyphen, followed by one or more dot-separated pre-release version</span><span class="s3">\n</span><span class="s1">// identifiers.</span><span class="s3">\n\n</span><span class="s1">createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]</span><span class="s3">\n</span><span class="s1">}(?:</span><span class="s3">\\\\</span><span class="s1">.${src[t.PRERELEASEIDENTIFIER]})*))`)</span><span class="s3">\n\n</span><span class="s1">createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]</span><span class="s3">\n</span><span class="s1">}(?:</span><span class="s3">\\\\</span><span class="s1">.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)</span><span class="s3">\n\n</span><span class="s1">// ## Build Metadata Identifier</span><span class="s3">\n</span><span class="s1">// Any combination of digits, letters, or hyphens.</span><span class="s3">\n\n</span><span class="s1">createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)</span><span class="s3">\n\n</span><span class="s1">// ## Build Metadata</span><span class="s3">\n</span><span class="s1">// Plus sign, followed by one or more period-separated build metadata</span><span class="s3">\n</span><span class="s1">// identifiers.</span><span class="s3">\n\n</span><span class="s1">createToken('BUILD', `(?:</span><span class="s3">\\\\</span><span class="s1">+(${src[t.BUILDIDENTIFIER]</span><span class="s3">\n</span><span class="s1">}(?:</span><span class="s3">\\\\</span><span class="s1">.${src[t.BUILDIDENTIFIER]})*))`)</span><span class="s3">\n\n</span><span class="s1">// ## Full Version String</span><span class="s3">\n</span><span class="s1">// A main version, followed optionally by a pre-release version and</span><span class="s3">\n</span><span class="s1">// build metadata.</span><span class="s3">\n\n</span><span class="s1">// Note that the only major, minor, patch, and pre-release sections of</span><span class="s3">\n</span><span class="s1">// the version string are capturing groups.  The build metadata is not a</span><span class="s3">\n</span><span class="s1">// capturing group, because it should not ever be used in version</span><span class="s3">\n</span><span class="s1">// comparison.</span><span class="s3">\n\n</span><span class="s1">createToken('FULLPLAIN', `v?${src[t.MAINVERSION]</span><span class="s3">\n</span><span class="s1">}${src[t.PRERELEASE]}?${</span><span class="s3">\n  </span><span class="s1">src[t.BUILD]}?`)</span><span class="s3">\n\n</span><span class="s1">createToken('FULL', `^${src[t.FULLPLAIN]}$`)</span><span class="s3">\n\n</span><span class="s1">// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.</span><span class="s3">\n</span><span class="s1">// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty</span><span class="s3">\n</span><span class="s1">// common in the npm registry.</span><span class="s3">\n</span><span class="s1">createToken('LOOSEPLAIN', `[v=</span><span class="s3">\\\\</span><span class="s1">s]*${src[t.MAINVERSIONLOOSE]</span><span class="s3">\n</span><span class="s1">}${src[t.PRERELEASELOOSE]}?${</span><span class="s3">\n  </span><span class="s1">src[t.BUILD]}?`)</span><span class="s3">\n\n</span><span class="s1">createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)</span><span class="s3">\n\n</span><span class="s1">createToken('GTLT', '((?:&lt;|&gt;)?=?)')</span><span class="s3">\n\n</span><span class="s1">// Something like </span><span class="s3">\&quot;</span><span class="s1">2.*</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">1.2.x</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n</span><span class="s1">// Note that </span><span class="s3">\&quot;</span><span class="s1">x.x</span><span class="s3">\&quot; </span><span class="s1">is a valid xRange identifer, meaning </span><span class="s3">\&quot;</span><span class="s1">any version</span><span class="s3">\&quot;\n</span><span class="s1">// Only the first item is strictly required.</span><span class="s3">\n</span><span class="s1">createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|</span><span class="s3">\\\\</span><span class="s1">*`)</span><span class="s3">\n</span><span class="s1">createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|</span><span class="s3">\\\\</span><span class="s1">*`)</span><span class="s3">\n\n</span><span class="s1">createToken('XRANGEPLAIN', `[v=</span><span class="s3">\\\\</span><span class="s1">s]*(${src[t.XRANGEIDENTIFIER]})` +</span><span class="s3">\n                   </span><span class="s1">`(?:</span><span class="s3">\\\\</span><span class="s1">.(${src[t.XRANGEIDENTIFIER]})` +</span><span class="s3">\n                   </span><span class="s1">`(?:</span><span class="s3">\\\\</span><span class="s1">.(${src[t.XRANGEIDENTIFIER]})` +</span><span class="s3">\n                   </span><span class="s1">`(?:${src[t.PRERELEASE]})?${</span><span class="s3">\n                     </span><span class="s1">src[t.BUILD]}?` +</span><span class="s3">\n                   </span><span class="s1">`)?)?`)</span><span class="s3">\n\n</span><span class="s1">createToken('XRANGEPLAINLOOSE', `[v=</span><span class="s3">\\\\</span><span class="s1">s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +</span><span class="s3">\n                        </span><span class="s1">`(?:</span><span class="s3">\\\\</span><span class="s1">.(${src[t.XRANGEIDENTIFIERLOOSE]})` +</span><span class="s3">\n                        </span><span class="s1">`(?:</span><span class="s3">\\\\</span><span class="s1">.(${src[t.XRANGEIDENTIFIERLOOSE]})` +</span><span class="s3">\n                        </span><span class="s1">`(?:${src[t.PRERELEASELOOSE]})?${</span><span class="s3">\n                          </span><span class="s1">src[t.BUILD]}?` +</span><span class="s3">\n                        </span><span class="s1">`)?)?`)</span><span class="s3">\n\n</span><span class="s1">createToken('XRANGE', `^${src[t.GTLT]}</span><span class="s3">\\\\</span><span class="s1">s*${src[t.XRANGEPLAIN]}$`)</span><span class="s3">\n</span><span class="s1">createToken('XRANGELOOSE', `^${src[t.GTLT]}</span><span class="s3">\\\\</span><span class="s1">s*${src[t.XRANGEPLAINLOOSE]}$`)</span><span class="s3">\n\n</span><span class="s1">// Coercion.</span><span class="s3">\n</span><span class="s1">// Extract anything that could conceivably be a part of a valid semver</span><span class="s3">\n</span><span class="s1">createToken('COERCEPLAIN', `${'(^|[^</span><span class="s3">\\\\</span><span class="s1">d])' +</span><span class="s3">\n              </span><span class="s1">'(</span><span class="s3">\\\\</span><span class="s1">d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +</span><span class="s3">\n              </span><span class="s1">`(?:</span><span class="s3">\\\\</span><span class="s1">.(</span><span class="s3">\\\\</span><span class="s1">d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +</span><span class="s3">\n              </span><span class="s1">`(?:</span><span class="s3">\\\\</span><span class="s1">.(</span><span class="s3">\\\\</span><span class="s1">d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)</span><span class="s3">\n</span><span class="s1">createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^</span><span class="s3">\\\\</span><span class="s1">d])`)</span><span class="s3">\n</span><span class="s1">createToken('COERCEFULL', src[t.COERCEPLAIN] +</span><span class="s3">\n              </span><span class="s1">`(?:${src[t.PRERELEASE]})?` +</span><span class="s3">\n              </span><span class="s1">`(?:${src[t.BUILD]})?` +</span><span class="s3">\n              </span><span class="s1">`(?:$|[^</span><span class="s3">\\\\</span><span class="s1">d])`)</span><span class="s3">\n</span><span class="s1">createToken('COERCERTL', src[t.COERCE], true)</span><span class="s3">\n</span><span class="s1">createToken('COERCERTLFULL', src[t.COERCEFULL], true)</span><span class="s3">\n\n</span><span class="s1">// Tilde ranges.</span><span class="s3">\n</span><span class="s1">// Meaning is </span><span class="s3">\&quot;</span><span class="s1">reasonably at or greater than</span><span class="s3">\&quot;\n</span><span class="s1">createToken('LONETILDE', '(?:~&gt;?)')</span><span class="s3">\n\n</span><span class="s1">createToken('TILDETRIM', `(</span><span class="s3">\\\\</span><span class="s1">s*)${src[t.LONETILDE]}</span><span class="s3">\\\\</span><span class="s1">s+`, true)</span><span class="s3">\n</span><span class="s1">exports.tildeTrimReplace = '$1~'</span><span class="s3">\n\n</span><span class="s1">createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)</span><span class="s3">\n</span><span class="s1">createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)</span><span class="s3">\n\n</span><span class="s1">// Caret ranges.</span><span class="s3">\n</span><span class="s1">// Meaning is </span><span class="s3">\&quot;</span><span class="s1">at least and backwards compatible with</span><span class="s3">\&quot;\n</span><span class="s1">createToken('LONECARET', '(?:</span><span class="s3">\\\\</span><span class="s1">^)')</span><span class="s3">\n\n</span><span class="s1">createToken('CARETTRIM', `(</span><span class="s3">\\\\</span><span class="s1">s*)${src[t.LONECARET]}</span><span class="s3">\\\\</span><span class="s1">s+`, true)</span><span class="s3">\n</span><span class="s1">exports.caretTrimReplace = '$1^'</span><span class="s3">\n\n</span><span class="s1">createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)</span><span class="s3">\n</span><span class="s1">createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)</span><span class="s3">\n\n</span><span class="s1">// A simple gt/lt/eq thing, or just </span><span class="s3">\&quot;\&quot; </span><span class="s1">to indicate </span><span class="s3">\&quot;</span><span class="s1">any version</span><span class="s3">\&quot;\n</span><span class="s1">createToken('COMPARATORLOOSE', `^${src[t.GTLT]}</span><span class="s3">\\\\</span><span class="s1">s*(${src[t.LOOSEPLAIN]})$|^$`)</span><span class="s3">\n</span><span class="s1">createToken('COMPARATOR', `^${src[t.GTLT]}</span><span class="s3">\\\\</span><span class="s1">s*(${src[t.FULLPLAIN]})$|^$`)</span><span class="s3">\n\n</span><span class="s1">// An expression to strip any whitespace between the gtlt and the thing</span><span class="s3">\n</span><span class="s1">// it modifies, so that `&gt; 1.2.3` ==&gt; `&gt;1.2.3`</span><span class="s3">\n</span><span class="s1">createToken('COMPARATORTRIM', `(</span><span class="s3">\\\\</span><span class="s1">s*)${src[t.GTLT]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)</span><span class="s3">\n</span><span class="s1">exports.comparatorTrimReplace = '$1$2$3'</span><span class="s3">\n\n</span><span class="s1">// Something like `1.2.3 - 1.2.4`</span><span class="s3">\n</span><span class="s1">// Note that these all use the loose form, because they'll be</span><span class="s3">\n</span><span class="s1">// checked against either the strict or loose comparator form</span><span class="s3">\n</span><span class="s1">// later.</span><span class="s3">\n</span><span class="s1">createToken('HYPHENRANGE', `^</span><span class="s3">\\\\</span><span class="s1">s*(${src[t.XRANGEPLAIN]})` +</span><span class="s3">\n                   </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">s+-</span><span class="s3">\\\\</span><span class="s1">s+` +</span><span class="s3">\n                   </span><span class="s1">`(${src[t.XRANGEPLAIN]})` +</span><span class="s3">\n                   </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">s*$`)</span><span class="s3">\n\n</span><span class="s1">createToken('HYPHENRANGELOOSE', `^</span><span class="s3">\\\\</span><span class="s1">s*(${src[t.XRANGEPLAINLOOSE]})` +</span><span class="s3">\n                        </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">s+-</span><span class="s3">\\\\</span><span class="s1">s+` +</span><span class="s3">\n                        </span><span class="s1">`(${src[t.XRANGEPLAINLOOSE]})` +</span><span class="s3">\n                        </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">s*$`)</span><span class="s3">\n\n</span><span class="s1">// Star ranges basically just allow anything at all.</span><span class="s3">\n</span><span class="s1">createToken('STAR', '(&lt;|&gt;)?=?</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">*')</span><span class="s3">\n</span><span class="s1">// &gt;=0.0.0 is like a star</span><span class="s3">\n</span><span class="s1">createToken('GTE0', '^</span><span class="s3">\\\\</span><span class="s1">s*&gt;=</span><span class="s3">\\\\</span><span class="s1">s*0</span><span class="s3">\\\\</span><span class="s1">.0</span><span class="s3">\\\\</span><span class="s1">.0</span><span class="s3">\\\\</span><span class="s1">s*$')</span><span class="s3">\n</span><span class="s1">createToken('GTE0PRE', '^</span><span class="s3">\\\\</span><span class="s1">s*&gt;=</span><span class="s3">\\\\</span><span class="s1">s*0</span><span class="s3">\\\\</span><span class="s1">.0</span><span class="s3">\\\\</span><span class="s1">.0-0</span><span class="s3">\\\\</span><span class="s1">s*$')</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Determine if version is greater than all the versions possible in the range.</span><span class="s3">\n</span><span class="s1">const outside = require('./outside')</span><span class="s3">\n</span><span class="s1">const gtr = (version, range, options) =&gt; outside(version, range, '&gt;', options)</span><span class="s3">\n</span><span class="s1">module.exports = gtr</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const Range = require('../classes/range')</span><span class="s3">\n</span><span class="s1">const intersects = (r1, r2, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">r1 = new Range(r1, options)</span><span class="s3">\n  </span><span class="s1">r2 = new Range(r2, options)</span><span class="s3">\n  </span><span class="s1">return r1.intersects(r2, options)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = intersects</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const outside = require('./outside')</span><span class="s3">\n</span><span class="s1">// Determine if version is less than all the versions possible in the range</span><span class="s3">\n</span><span class="s1">const ltr = (version, range, options) =&gt; outside(version, range, '&lt;', options)</span><span class="s3">\n</span><span class="s1">module.exports = ltr</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const Range = require('../classes/range')</span><span class="s3">\n\n</span><span class="s1">const maxSatisfying = (versions, range, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">let max = null</span><span class="s3">\n  </span><span class="s1">let maxSV = null</span><span class="s3">\n  </span><span class="s1">let rangeObj = null</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">rangeObj = new Range(range, options)</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">versions.forEach((v) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (rangeObj.test(v)) {</span><span class="s3">\n      </span><span class="s1">// satisfies(v, range, options)</span><span class="s3">\n      </span><span class="s1">if (!max || maxSV.compare(v) === -1) {</span><span class="s3">\n        </span><span class="s1">// compare(max, v, true)</span><span class="s3">\n        </span><span class="s1">max = v</span><span class="s3">\n        </span><span class="s1">maxSV = new SemVer(max, options)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return max</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = maxSatisfying</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const Range = require('../classes/range')</span><span class="s3">\n</span><span class="s1">const minSatisfying = (versions, range, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">let min = null</span><span class="s3">\n  </span><span class="s1">let minSV = null</span><span class="s3">\n  </span><span class="s1">let rangeObj = null</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">rangeObj = new Range(range, options)</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">versions.forEach((v) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (rangeObj.test(v)) {</span><span class="s3">\n      </span><span class="s1">// satisfies(v, range, options)</span><span class="s3">\n      </span><span class="s1">if (!min || minSV.compare(v) === 1) {</span><span class="s3">\n        </span><span class="s1">// compare(min, v, true)</span><span class="s3">\n        </span><span class="s1">min = v</span><span class="s3">\n        </span><span class="s1">minSV = new SemVer(min, options)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return min</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = minSatisfying</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const Range = require('../classes/range')</span><span class="s3">\n</span><span class="s1">const gt = require('../functions/gt')</span><span class="s3">\n\n</span><span class="s1">const minVersion = (range, loose) =&gt; {</span><span class="s3">\n  </span><span class="s1">range = new Range(range, loose)</span><span class="s3">\n\n  </span><span class="s1">let minver = new SemVer('0.0.0')</span><span class="s3">\n  </span><span class="s1">if (range.test(minver)) {</span><span class="s3">\n    </span><span class="s1">return minver</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">minver = new SemVer('0.0.0-0')</span><span class="s3">\n  </span><span class="s1">if (range.test(minver)) {</span><span class="s3">\n    </span><span class="s1">return minver</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">minver = null</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; range.set.length; ++i) {</span><span class="s3">\n    </span><span class="s1">const comparators = range.set[i]</span><span class="s3">\n\n    </span><span class="s1">let setMin = null</span><span class="s3">\n    </span><span class="s1">comparators.forEach((comparator) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Clone to avoid manipulating the comparator's semver object.</span><span class="s3">\n      </span><span class="s1">const compver = new SemVer(comparator.semver.version)</span><span class="s3">\n      </span><span class="s1">switch (comparator.operator) {</span><span class="s3">\n        </span><span class="s1">case '&gt;':</span><span class="s3">\n          </span><span class="s1">if (compver.prerelease.length === 0) {</span><span class="s3">\n            </span><span class="s1">compver.patch++</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">compver.prerelease.push(0)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">compver.raw = compver.format()</span><span class="s3">\n          </span><span class="s1">/* fallthrough */</span><span class="s3">\n        </span><span class="s1">case '':</span><span class="s3">\n        </span><span class="s1">case '&gt;=':</span><span class="s3">\n          </span><span class="s1">if (!setMin || gt(compver, setMin)) {</span><span class="s3">\n            </span><span class="s1">setMin = compver</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case '&lt;':</span><span class="s3">\n        </span><span class="s1">case '&lt;=':</span><span class="s3">\n          </span><span class="s1">/* Ignore maximum versions */</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">throw new Error(`Unexpected operation: ${comparator.operator}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">if (setMin &amp;&amp; (!minver || gt(minver, setMin))) {</span><span class="s3">\n      </span><span class="s1">minver = setMin</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (minver &amp;&amp; range.test(minver)) {</span><span class="s3">\n    </span><span class="s1">return minver</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = minVersion</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const SemVer = require('../classes/semver')</span><span class="s3">\n</span><span class="s1">const Comparator = require('../classes/comparator')</span><span class="s3">\n</span><span class="s1">const { ANY } = Comparator</span><span class="s3">\n</span><span class="s1">const Range = require('../classes/range')</span><span class="s3">\n</span><span class="s1">const satisfies = require('../functions/satisfies')</span><span class="s3">\n</span><span class="s1">const gt = require('../functions/gt')</span><span class="s3">\n</span><span class="s1">const lt = require('../functions/lt')</span><span class="s3">\n</span><span class="s1">const lte = require('../functions/lte')</span><span class="s3">\n</span><span class="s1">const gte = require('../functions/gte')</span><span class="s3">\n\n</span><span class="s1">const outside = (version, range, hilo, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">version = new SemVer(version, options)</span><span class="s3">\n  </span><span class="s1">range = new Range(range, options)</span><span class="s3">\n\n  </span><span class="s1">let gtfn, ltefn, ltfn, comp, ecomp</span><span class="s3">\n  </span><span class="s1">switch (hilo) {</span><span class="s3">\n    </span><span class="s1">case '&gt;':</span><span class="s3">\n      </span><span class="s1">gtfn = gt</span><span class="s3">\n      </span><span class="s1">ltefn = lte</span><span class="s3">\n      </span><span class="s1">ltfn = lt</span><span class="s3">\n      </span><span class="s1">comp = '&gt;'</span><span class="s3">\n      </span><span class="s1">ecomp = '&gt;='</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '&lt;':</span><span class="s3">\n      </span><span class="s1">gtfn = lt</span><span class="s3">\n      </span><span class="s1">ltefn = gte</span><span class="s3">\n      </span><span class="s1">ltfn = gt</span><span class="s3">\n      </span><span class="s1">comp = '&lt;'</span><span class="s3">\n      </span><span class="s1">ecomp = '&lt;='</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new TypeError('Must provide a hilo val of </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If it satisfies the range it is not outside</span><span class="s3">\n  </span><span class="s1">if (satisfies(version, range, options)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// From now on, variable terms are as if we're in </span><span class="s3">\&quot;</span><span class="s1">gtr</span><span class="s3">\&quot; </span><span class="s1">mode.</span><span class="s3">\n  </span><span class="s1">// but note that everything is flipped for the </span><span class="s3">\&quot;</span><span class="s1">ltr</span><span class="s3">\&quot; </span><span class="s1">function.</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; range.set.length; ++i) {</span><span class="s3">\n    </span><span class="s1">const comparators = range.set[i]</span><span class="s3">\n\n    </span><span class="s1">let high = null</span><span class="s3">\n    </span><span class="s1">let low = null</span><span class="s3">\n\n    </span><span class="s1">comparators.forEach((comparator) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (comparator.semver === ANY) {</span><span class="s3">\n        </span><span class="s1">comparator = new Comparator('&gt;=0.0.0')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">high = high || comparator</span><span class="s3">\n      </span><span class="s1">low = low || comparator</span><span class="s3">\n      </span><span class="s1">if (gtfn(comparator.semver, high.semver, options)) {</span><span class="s3">\n        </span><span class="s1">high = comparator</span><span class="s3">\n      </span><span class="s1">} else if (ltfn(comparator.semver, low.semver, options)) {</span><span class="s3">\n        </span><span class="s1">low = comparator</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// If the edge version comparator has a operator then our version</span><span class="s3">\n    </span><span class="s1">// isn't outside it</span><span class="s3">\n    </span><span class="s1">if (high.operator === comp || high.operator === ecomp) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the lowest version comparator has an operator and our version</span><span class="s3">\n    </span><span class="s1">// is less than it then it isn't higher than the range</span><span class="s3">\n    </span><span class="s1">if ((!low.operator || low.operator === comp) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">ltefn(version, low.semver)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">} else if (low.operator === ecomp &amp;&amp; ltfn(version, low.semver)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = outside</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// given a set of versions and a range, create a </span><span class="s3">\&quot;</span><span class="s1">simplified</span><span class="s3">\&quot; </span><span class="s1">range</span><span class="s3">\n</span><span class="s1">// that includes the same versions that the original range does</span><span class="s3">\n</span><span class="s1">// If the original range is shorter than the simplified one, return that.</span><span class="s3">\n</span><span class="s1">const satisfies = require('../functions/satisfies.js')</span><span class="s3">\n</span><span class="s1">const compare = require('../functions/compare.js')</span><span class="s3">\n</span><span class="s1">module.exports = (versions, range, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">const set = []</span><span class="s3">\n  </span><span class="s1">let first = null</span><span class="s3">\n  </span><span class="s1">let prev = null</span><span class="s3">\n  </span><span class="s1">const v = versions.sort((a, b) =&gt; compare(a, b, options))</span><span class="s3">\n  </span><span class="s1">for (const version of v) {</span><span class="s3">\n    </span><span class="s1">const included = satisfies(version, range, options)</span><span class="s3">\n    </span><span class="s1">if (included) {</span><span class="s3">\n      </span><span class="s1">prev = version</span><span class="s3">\n      </span><span class="s1">if (!first) {</span><span class="s3">\n        </span><span class="s1">first = version</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (prev) {</span><span class="s3">\n        </span><span class="s1">set.push([first, prev])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">prev = null</span><span class="s3">\n      </span><span class="s1">first = null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (first) {</span><span class="s3">\n    </span><span class="s1">set.push([first, null])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const ranges = []</span><span class="s3">\n  </span><span class="s1">for (const [min, max] of set) {</span><span class="s3">\n    </span><span class="s1">if (min === max) {</span><span class="s3">\n      </span><span class="s1">ranges.push(min)</span><span class="s3">\n    </span><span class="s1">} else if (!max &amp;&amp; min === v[0]) {</span><span class="s3">\n      </span><span class="s1">ranges.push('*')</span><span class="s3">\n    </span><span class="s1">} else if (!max) {</span><span class="s3">\n      </span><span class="s1">ranges.push(`&gt;=${min}`)</span><span class="s3">\n    </span><span class="s1">} else if (min === v[0]) {</span><span class="s3">\n      </span><span class="s1">ranges.push(`&lt;=${max}`)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">ranges.push(`${min} - ${max}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const simplified = ranges.join(' || ')</span><span class="s3">\n  </span><span class="s1">const original = typeof range.raw === 'string' ? range.raw : String(range)</span><span class="s3">\n  </span><span class="s1">return simplified.length &lt; original.length ? simplified : range</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const Range = require('../classes/range.js')</span><span class="s3">\n</span><span class="s1">const Comparator = require('../classes/comparator.js')</span><span class="s3">\n</span><span class="s1">const { ANY } = Comparator</span><span class="s3">\n</span><span class="s1">const satisfies = require('../functions/satisfies.js')</span><span class="s3">\n</span><span class="s1">const compare = require('../functions/compare.js')</span><span class="s3">\n\n</span><span class="s1">// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:</span><span class="s3">\n</span><span class="s1">// - Every simple range `r1, r2, ...` is a null set, OR</span><span class="s3">\n</span><span class="s1">// - Every simple range `r1, r2, ...` which is not a null set is a subset of</span><span class="s3">\n</span><span class="s1">//   some `R1, R2, ...`</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:</span><span class="s3">\n</span><span class="s1">// - If c is only the ANY comparator</span><span class="s3">\n</span><span class="s1">//   - If C is only the ANY comparator, return true</span><span class="s3">\n</span><span class="s1">//   - Else if in prerelease mode, return false</span><span class="s3">\n</span><span class="s1">//   - else replace c with `[&gt;=0.0.0]`</span><span class="s3">\n</span><span class="s1">// - If C is only the ANY comparator</span><span class="s3">\n</span><span class="s1">//   - if in prerelease mode, return true</span><span class="s3">\n</span><span class="s1">//   - else replace C with `[&gt;=0.0.0]`</span><span class="s3">\n</span><span class="s1">// - Let EQ be the set of = comparators in c</span><span class="s3">\n</span><span class="s1">// - If EQ is more than one, return true (null set)</span><span class="s3">\n</span><span class="s1">// - Let GT be the highest &gt; or &gt;= comparator in c</span><span class="s3">\n</span><span class="s1">// - Let LT be the lowest &lt; or &lt;= comparator in c</span><span class="s3">\n</span><span class="s1">// - If GT and LT, and GT.semver &gt; LT.semver, return true (null set)</span><span class="s3">\n</span><span class="s1">// - If any C is a = range, and GT or LT are set, return false</span><span class="s3">\n</span><span class="s1">// - If EQ</span><span class="s3">\n</span><span class="s1">//   - If GT, and EQ does not satisfy GT, return true (null set)</span><span class="s3">\n</span><span class="s1">//   - If LT, and EQ does not satisfy LT, return true (null set)</span><span class="s3">\n</span><span class="s1">//   - If EQ satisfies every C, return true</span><span class="s3">\n</span><span class="s1">//   - Else return false</span><span class="s3">\n</span><span class="s1">// - If GT</span><span class="s3">\n</span><span class="s1">//   - If GT.semver is lower than any &gt; or &gt;= comp in C, return false</span><span class="s3">\n</span><span class="s1">//   - If GT is &gt;=, and GT.semver does not satisfy every C, return false</span><span class="s3">\n</span><span class="s1">//   - If GT.semver has a prerelease, and not in prerelease mode</span><span class="s3">\n</span><span class="s1">//     - If no C has a prerelease and the GT.semver tuple, return false</span><span class="s3">\n</span><span class="s1">// - If LT</span><span class="s3">\n</span><span class="s1">//   - If LT.semver is greater than any &lt; or &lt;= comp in C, return false</span><span class="s3">\n</span><span class="s1">//   - If LT is &lt;=, and LT.semver does not satisfy every C, return false</span><span class="s3">\n</span><span class="s1">//   - If GT.semver has a prerelease, and not in prerelease mode</span><span class="s3">\n</span><span class="s1">//     - If no C has a prerelease and the LT.semver tuple, return false</span><span class="s3">\n</span><span class="s1">// - Else return true</span><span class="s3">\n\n</span><span class="s1">const subset = (sub, dom, options = {}) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (sub === dom) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sub = new Range(sub, options)</span><span class="s3">\n  </span><span class="s1">dom = new Range(dom, options)</span><span class="s3">\n  </span><span class="s1">let sawNonNull = false</span><span class="s3">\n\n  </span><span class="s1">OUTER: for (const simpleSub of sub.set) {</span><span class="s3">\n    </span><span class="s1">for (const simpleDom of dom.set) {</span><span class="s3">\n      </span><span class="s1">const isSub = simpleSubset(simpleSub, simpleDom, options)</span><span class="s3">\n      </span><span class="s1">sawNonNull = sawNonNull || isSub !== null</span><span class="s3">\n      </span><span class="s1">if (isSub) {</span><span class="s3">\n        </span><span class="s1">continue OUTER</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// the null set is a subset of everything, but null simple ranges in</span><span class="s3">\n    </span><span class="s1">// a complex range should be ignored.  so if we saw a non-null range,</span><span class="s3">\n    </span><span class="s1">// then we know this isn't a subset, but if EVERY simple range was null,</span><span class="s3">\n    </span><span class="s1">// then it is a subset.</span><span class="s3">\n    </span><span class="s1">if (sawNonNull) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const minimumVersionWithPreRelease = [new Comparator('&gt;=0.0.0-0')]</span><span class="s3">\n</span><span class="s1">const minimumVersion = [new Comparator('&gt;=0.0.0')]</span><span class="s3">\n\n</span><span class="s1">const simpleSubset = (sub, dom, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (sub === dom) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (sub.length === 1 &amp;&amp; sub[0].semver === ANY) {</span><span class="s3">\n    </span><span class="s1">if (dom.length === 1 &amp;&amp; dom[0].semver === ANY) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else if (options.includePrerelease) {</span><span class="s3">\n      </span><span class="s1">sub = minimumVersionWithPreRelease</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">sub = minimumVersion</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (dom.length === 1 &amp;&amp; dom[0].semver === ANY) {</span><span class="s3">\n    </span><span class="s1">if (options.includePrerelease) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">dom = minimumVersion</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const eqSet = new Set()</span><span class="s3">\n  </span><span class="s1">let gt, lt</span><span class="s3">\n  </span><span class="s1">for (const c of sub) {</span><span class="s3">\n    </span><span class="s1">if (c.operator === '&gt;' || c.operator === '&gt;=') {</span><span class="s3">\n      </span><span class="s1">gt = higherGT(gt, c, options)</span><span class="s3">\n    </span><span class="s1">} else if (c.operator === '&lt;' || c.operator === '&lt;=') {</span><span class="s3">\n      </span><span class="s1">lt = lowerLT(lt, c, options)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">eqSet.add(c.semver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (eqSet.size &gt; 1) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let gtltComp</span><span class="s3">\n  </span><span class="s1">if (gt &amp;&amp; lt) {</span><span class="s3">\n    </span><span class="s1">gtltComp = compare(gt.semver, lt.semver, options)</span><span class="s3">\n    </span><span class="s1">if (gtltComp &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">} else if (gtltComp === 0 &amp;&amp; (gt.operator !== '&gt;=' || lt.operator !== '&lt;=')) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// will iterate one or zero times</span><span class="s3">\n  </span><span class="s1">for (const eq of eqSet) {</span><span class="s3">\n    </span><span class="s1">if (gt &amp;&amp; !satisfies(eq, String(gt), options)) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (lt &amp;&amp; !satisfies(eq, String(lt), options)) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const c of dom) {</span><span class="s3">\n      </span><span class="s1">if (!satisfies(eq, String(c), options)) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let higher, lower</span><span class="s3">\n  </span><span class="s1">let hasDomLT, hasDomGT</span><span class="s3">\n  </span><span class="s1">// if the subset has a prerelease, we need a comparator in the superset</span><span class="s3">\n  </span><span class="s1">// with the same tuple and a prerelease, or it's not a subset</span><span class="s3">\n  </span><span class="s1">let needDomLTPre = lt &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!options.includePrerelease &amp;&amp;</span><span class="s3">\n    </span><span class="s1">lt.semver.prerelease.length ? lt.semver : false</span><span class="s3">\n  </span><span class="s1">let needDomGTPre = gt &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!options.includePrerelease &amp;&amp;</span><span class="s3">\n    </span><span class="s1">gt.semver.prerelease.length ? gt.semver : false</span><span class="s3">\n  </span><span class="s1">// exception: &lt;1.2.3-0 is the same as &lt;1.2.3</span><span class="s3">\n  </span><span class="s1">if (needDomLTPre &amp;&amp; needDomLTPre.prerelease.length === 1 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">lt.operator === '&lt;' &amp;&amp; needDomLTPre.prerelease[0] === 0) {</span><span class="s3">\n    </span><span class="s1">needDomLTPre = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const c of dom) {</span><span class="s3">\n    </span><span class="s1">hasDomGT = hasDomGT || c.operator === '&gt;' || c.operator === '&gt;='</span><span class="s3">\n    </span><span class="s1">hasDomLT = hasDomLT || c.operator === '&lt;' || c.operator === '&lt;='</span><span class="s3">\n    </span><span class="s1">if (gt) {</span><span class="s3">\n      </span><span class="s1">if (needDomGTPre) {</span><span class="s3">\n        </span><span class="s1">if (c.semver.prerelease &amp;&amp; c.semver.prerelease.length &amp;&amp;</span><span class="s3">\n            </span><span class="s1">c.semver.major === needDomGTPre.major &amp;&amp;</span><span class="s3">\n            </span><span class="s1">c.semver.minor === needDomGTPre.minor &amp;&amp;</span><span class="s3">\n            </span><span class="s1">c.semver.patch === needDomGTPre.patch) {</span><span class="s3">\n          </span><span class="s1">needDomGTPre = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c.operator === '&gt;' || c.operator === '&gt;=') {</span><span class="s3">\n        </span><span class="s1">higher = higherGT(gt, c, options)</span><span class="s3">\n        </span><span class="s1">if (higher === c &amp;&amp; higher !== gt) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (gt.operator === '&gt;=' &amp;&amp; !satisfies(gt.semver, String(c), options)) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (lt) {</span><span class="s3">\n      </span><span class="s1">if (needDomLTPre) {</span><span class="s3">\n        </span><span class="s1">if (c.semver.prerelease &amp;&amp; c.semver.prerelease.length &amp;&amp;</span><span class="s3">\n            </span><span class="s1">c.semver.major === needDomLTPre.major &amp;&amp;</span><span class="s3">\n            </span><span class="s1">c.semver.minor === needDomLTPre.minor &amp;&amp;</span><span class="s3">\n            </span><span class="s1">c.semver.patch === needDomLTPre.patch) {</span><span class="s3">\n          </span><span class="s1">needDomLTPre = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c.operator === '&lt;' || c.operator === '&lt;=') {</span><span class="s3">\n        </span><span class="s1">lower = lowerLT(lt, c, options)</span><span class="s3">\n        </span><span class="s1">if (lower === c &amp;&amp; lower !== lt) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (lt.operator === '&lt;=' &amp;&amp; !satisfies(lt.semver, String(c), options)) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!c.operator &amp;&amp; (lt || gt) &amp;&amp; gtltComp !== 0) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if there was a &lt; or &gt;, and nothing in the dom, then must be false</span><span class="s3">\n  </span><span class="s1">// UNLESS it was limited by another range in the other direction.</span><span class="s3">\n  </span><span class="s1">// Eg, &gt;1.0.0 &lt;1.0.1 is still a subset of &lt;2.0.0</span><span class="s3">\n  </span><span class="s1">if (gt &amp;&amp; hasDomLT &amp;&amp; !lt &amp;&amp; gtltComp !== 0) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (lt &amp;&amp; hasDomGT &amp;&amp; !gt &amp;&amp; gtltComp !== 0) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we needed a prerelease range in a specific tuple, but didn't get one</span><span class="s3">\n  </span><span class="s1">// then this isn't a subset.  eg &gt;=1.2.3-pre is not a subset of &gt;=1.0.0,</span><span class="s3">\n  </span><span class="s1">// because it includes prereleases in the 1.2.3 tuple</span><span class="s3">\n  </span><span class="s1">if (needDomGTPre || needDomLTPre) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// &gt;=1.2.3 is lower than &gt;1.2.3</span><span class="s3">\n</span><span class="s1">const higherGT = (a, b, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!a) {</span><span class="s3">\n    </span><span class="s1">return b</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const comp = compare(a.semver, b.semver, options)</span><span class="s3">\n  </span><span class="s1">return comp &gt; 0 ? a</span><span class="s3">\n    </span><span class="s1">: comp &lt; 0 ? b</span><span class="s3">\n    </span><span class="s1">: b.operator === '&gt;' &amp;&amp; a.operator === '&gt;=' ? b</span><span class="s3">\n    </span><span class="s1">: a</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// &lt;=1.2.3 is higher than &lt;1.2.3</span><span class="s3">\n</span><span class="s1">const lowerLT = (a, b, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!a) {</span><span class="s3">\n    </span><span class="s1">return b</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const comp = compare(a.semver, b.semver, options)</span><span class="s3">\n  </span><span class="s1">return comp &lt; 0 ? a</span><span class="s3">\n    </span><span class="s1">: comp &gt; 0 ? b</span><span class="s3">\n    </span><span class="s1">: b.operator === '&lt;' &amp;&amp; a.operator === '&lt;=' ? b</span><span class="s3">\n    </span><span class="s1">: a</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = subset</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const Range = require('../classes/range')</span><span class="s3">\n\n</span><span class="s1">// Mostly just for testing and legacy API reasons</span><span class="s3">\n</span><span class="s1">const toComparators = (range, options) =&gt;</span><span class="s3">\n  </span><span class="s1">new Range(range, options).set</span><span class="s3">\n    </span><span class="s1">.map(comp =&gt; comp.map(c =&gt; c.value).join(' ').trim().split(' '))</span><span class="s3">\n\n</span><span class="s1">module.exports = toComparators</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const Range = require('../classes/range')</span><span class="s3">\n</span><span class="s1">const validRange = (range, options) =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// Return '*' instead of '' so that truthiness works.</span><span class="s3">\n    </span><span class="s1">// This will throw if it's invalid anyway</span><span class="s3">\n    </span><span class="s1">return new Range(range, options).range || '*'</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = validRange</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>