<html>
<head>
<title>9442.e301e4179b7c69c125d7.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
9442.e301e4179b7c69c125d7.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;9442.e301e4179b7c69c125d7.js?v=e301e4179b7c69c125d7&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnB6B;;AAE7B;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA,kCAAkC,GAAG;AACrC;AACA;;;ACtBe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjBe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnBe;AACf;AACA;AACA;AACA;;;ACJuC;AACJ;AACE;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf,sCAAsC;AACtC,eAAe;AACf,kBAAkB;AAClB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,QAAQ;AAC1E;;AAEA;AACA,qEAAqE,QAAQ;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qEAAqE,QAAQ;AAC7E;;AAEA;AACA,qEAAqE,QAAQ;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,MAAM;AACpC;AACA;AACA,qBAAqB,GAAG,2BAA2B,GAAG;AACtD;AACA;AACA;;AAEA,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,MAAM;AACpC,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,GAAG,iDAAiD,GAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,yBAAyB;AACtD;AACA,kBAAkB,SAAS,cAAc;AACzC;AACA;AACA,kBAAkB,SAAS,cAAc;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AChXA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,+CAAe,IAAI,EAAC;;;ACjIb;;;ACAP,6BAAe,sBAAS;AACxB;AACA;AACA;AACA;;;ACJO,SAAS,OAAC;AACjB;AACA;;AAEO,SAAS,OAAC;AACjB;AACA;;;ACN6B;AACK;AACI;AACe;AACT;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,SAAI;AACb;AACA;AACA,UAAU,OAAM;AAChB,UAAU,OAAM;AAChB;;AAEA;AACA,uBAAuB,KAAK;AAC5B,qCAAqC,QAAI;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAiE,YAAQ;AACzE;;AAEA;AACA,iEAAiE,YAAQ;AACzE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,SAAI;AACb;;AAEO;AACP,SAAS,SAAI;AACb;;AAEO;AACP,UAAU,SAAI;AACd;AACA;AACA;AACA;;;ACnFwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAAe,gCAAW;AAC1B,SAAS,cAAc;AACvB;AACA;AACA;;;ACD8B;;AAE9B;AACA;AACA,0BAA0B,iCAAM;AAChC,sBAAsB,gBAAgB,KAAK;AAC3C;AACA,GAAG;AACH;AACA,2BAA2B,iCAAM;AACjC,KAAK;AACL,UAAU;AACV,gBAAgB,+TAA+T;AAC/U,kBAAkB,uLAAuL;AACzM;AACA,mCAAmC,iCAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,iBAAiB,IAAI,QAAQ,IAAI,WAAW,IAAI,mDAAmD,IAAI,+BAA+B,mBAAmB,mBAAmB,KAAK,aAAa,oCAAoC,aAAa,qBAAqB,WAAW,IAAI,WAAW,oBAAoB,oDAAoD,IAAI,wCAAwC,IAAI,aAAa,oBAAoB,aAAa,qBAAqB,wCAAwC;AAC/gB,sBAAsB,wBAAwB;AAC9C,gCAAgC,iCAAM;AACtC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,iCAAM;AACjC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iCAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iCAAM;AACZ,iEAAiE;AACjE;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kCAAkC,iCAAM;AACxC;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,gCAAgC,iCAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B,iCAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B,iCAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4BAA4B,iCAAM;AAClC;AACA;AACA,OAAO;AACP;AACA,8BAA8B,iCAAM;AACpC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA,4BAA4B,iCAAM;AAClC;AACA,OAAO;AACP;AACA,iCAAiC,iCAAM;AACvC;AACA;AACA,OAAO;AACP;AACA,qCAAqC,iCAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,iCAAM;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,iCAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4BAA4B,iCAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,2BAA2B,iCAAM;AACjC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,6BAA6B,iCAAM;AACnC;AACA,OAAO;AACP;AACA,gCAAgC,iCAAM;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,qCAAqC,iCAAM;AAC3C;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,4DAA4D;AAC5D,gCAAgC,iCAAM;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,iCAAiC,iCAAM;AACvC;AACA,OAAO;AACP;AACA,sCAAsC,iCAAM;AAC5C;AACA,OAAO;AACP,iBAAiB,0BAA0B;AAC3C,qCAAqC,iCAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oBAAoB,SAAS,oDAAoD,oBAAoB,qCAAqC,eAAe;AACzJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,iCAAM;AACR;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,iCAAM;AACnC;AACA;AACA;AACA,EAAE,gCAAK;AACP,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iCAAM;AACV;AACA;AACA,8BAA8B,iCAAM;AACpC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,IAAI,iCAAM;AACV;AACA;AACA,uCAAuC,iCAAM;AAC7C,OAAO,qCAAc,kBAAkB,qCAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,+BAA+B,iCAAM;AACrC,+BAA+B,iCAAM;AACrC,+BAA+B,iCAAM;AACrC,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,6BAA6B,iCAAM,OAAO,qCAAS;AACnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,mBAAmB;AACnB,mBAAmB;AACnB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;;AAEA;AAKY;AAQO;;AAEnB;AACA;AACA;AACA,IAAI,iCAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,GAAG;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,IAAY;AACpB,SAAS,KAAa;AACtB,UAAU,MAAc;AACxB,WAAW,OAAe;AAC1B;AACA,2BAA2B,iCAAM;AACjC,UAAU,8BAA8B,EAAE,qCAAS;AACnD,8BAA8B,qCAAa;AAC3C;AACA;AACA,qBAAqB,sBAAQ;AAC7B;AACA,6CAA6C,sBAAQ,mDAAmD,sBAAQ;AAChH,gEAAgE,GAAG,OAAO,sBAAQ,SAAS,GAAG;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAQ;AACzB;AACA;AACA;AACA;AACA,sBAAsB,6BAAc,CAAC,4BAAiB;AACtD;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,kCAAkC,iCAAM,IAAI,gBAAgB;AAC5D;AACA;AACA;AACA,cAAc;AACd,EAAE,OAAO,EAAE,8BAA8B,EAAE,OAAO;AAClD,GAAG;AACH,iOAAiO,0BAA0B;AAC3P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iCAAM;AACvC;AACA;AACA,iCAAiC,iCAAM;AACvC;AACA;AACA,iCAAiC,iCAAM;AACvC;AACA;AACA;AACA;AACA,gCAAgC,oBAAsB;AACtD,EAAE,4CAAiB;AACnB,CAAC;AACD;AACA;AACA;;AAEA;AACA,4CAA4C,iCAAM;AAClD;AACA;AACA,CAAC;;AAED;AACA,gCAAgC,iCAAM;AACtC,qBAAqB;AACrB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-array/src/min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/src/align.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-array/src/sum.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-array/src/max.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/src/constant.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/src/sankey.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-path/src/path.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-shape/src/array.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-shape/src/constant.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-shape/src/point.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/node_modules/d3-shape/src/link/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/d3-sankey/src/sankeyLinkHorizontal.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/mermaid/dist/chunks/mermaid.core/sankeyDiagram-QLVOVGJD.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export default function min(values, valueof) {</span><span class="s3">\n  </span><span class="s1">let min;</span><span class="s3">\n  </span><span class="s1">if (valueof === undefined) {</span><span class="s3">\n    </span><span class="s1">for (const value of values) {</span><span class="s3">\n      </span><span class="s1">if (value != null</span><span class="s3">\n          </span><span class="s1">&amp;&amp; (min &gt; value || (min === undefined &amp;&amp; value &gt;= value))) {</span><span class="s3">\n        </span><span class="s1">min = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let index = -1;</span><span class="s3">\n    </span><span class="s1">for (let value of values) {</span><span class="s3">\n      </span><span class="s1">if ((value = valueof(value, ++index, values)) != null</span><span class="s3">\n          </span><span class="s1">&amp;&amp; (min &gt; value || (min === undefined &amp;&amp; value &gt;= value))) {</span><span class="s3">\n        </span><span class="s1">min = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return min;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {min} from </span><span class="s3">\&quot;</span><span class="s1">d3-array</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function targetDepth(d) {</span><span class="s3">\n  </span><span class="s1">return d.target.depth;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function left(node) {</span><span class="s3">\n  </span><span class="s1">return node.depth;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function right(node, n) {</span><span class="s3">\n  </span><span class="s1">return n - 1 - node.height;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function justify(node, n) {</span><span class="s3">\n  </span><span class="s1">return node.sourceLinks.length ? node.depth : n - 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function center(node) {</span><span class="s3">\n  </span><span class="s1">return node.targetLinks.length ? node.depth</span><span class="s3">\n      </span><span class="s1">: node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1</span><span class="s3">\n      </span><span class="s1">: 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function sum(values, valueof) {</span><span class="s3">\n  </span><span class="s1">let sum = 0;</span><span class="s3">\n  </span><span class="s1">if (valueof === undefined) {</span><span class="s3">\n    </span><span class="s1">for (let value of values) {</span><span class="s3">\n      </span><span class="s1">if (value = +value) {</span><span class="s3">\n        </span><span class="s1">sum += value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let index = -1;</span><span class="s3">\n    </span><span class="s1">for (let value of values) {</span><span class="s3">\n      </span><span class="s1">if (value = +valueof(value, ++index, values)) {</span><span class="s3">\n        </span><span class="s1">sum += value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return sum;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function max(values, valueof) {</span><span class="s3">\n  </span><span class="s1">let max;</span><span class="s3">\n  </span><span class="s1">if (valueof === undefined) {</span><span class="s3">\n    </span><span class="s1">for (const value of values) {</span><span class="s3">\n      </span><span class="s1">if (value != null</span><span class="s3">\n          </span><span class="s1">&amp;&amp; (max &lt; value || (max === undefined &amp;&amp; value &gt;= value))) {</span><span class="s3">\n        </span><span class="s1">max = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let index = -1;</span><span class="s3">\n    </span><span class="s1">for (let value of values) {</span><span class="s3">\n      </span><span class="s1">if ((value = valueof(value, ++index, values)) != null</span><span class="s3">\n          </span><span class="s1">&amp;&amp; (max &lt; value || (max === undefined &amp;&amp; value &gt;= value))) {</span><span class="s3">\n        </span><span class="s1">max = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return max;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function constant(x) {</span><span class="s3">\n  </span><span class="s1">return function() {</span><span class="s3">\n    </span><span class="s1">return x;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {max, min, sum} from </span><span class="s3">\&quot;</span><span class="s1">d3-array</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {justify} from </span><span class="s3">\&quot;</span><span class="s1">./align.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import constant from </span><span class="s3">\&quot;</span><span class="s1">./constant.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function ascendingSourceBreadth(a, b) {</span><span class="s3">\n  </span><span class="s1">return ascendingBreadth(a.source, b.source) || a.index - b.index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ascendingTargetBreadth(a, b) {</span><span class="s3">\n  </span><span class="s1">return ascendingBreadth(a.target, b.target) || a.index - b.index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ascendingBreadth(a, b) {</span><span class="s3">\n  </span><span class="s1">return a.y0 - b.y0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function value(d) {</span><span class="s3">\n  </span><span class="s1">return d.value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function defaultId(d) {</span><span class="s3">\n  </span><span class="s1">return d.index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function defaultNodes(graph) {</span><span class="s3">\n  </span><span class="s1">return graph.nodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function defaultLinks(graph) {</span><span class="s3">\n  </span><span class="s1">return graph.links;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function find(nodeById, id) {</span><span class="s3">\n  </span><span class="s1">const node = nodeById.get(id);</span><span class="s3">\n  </span><span class="s1">if (!node) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">missing: </span><span class="s3">\&quot; </span><span class="s1">+ id);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeLinkBreadths({nodes}) {</span><span class="s3">\n  </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n    </span><span class="s1">let y0 = node.y0;</span><span class="s3">\n    </span><span class="s1">let y1 = y0;</span><span class="s3">\n    </span><span class="s1">for (const link of node.sourceLinks) {</span><span class="s3">\n      </span><span class="s1">link.y0 = y0 + link.width / 2;</span><span class="s3">\n      </span><span class="s1">y0 += link.width;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const link of node.targetLinks) {</span><span class="s3">\n      </span><span class="s1">link.y1 = y1 + link.width / 2;</span><span class="s3">\n      </span><span class="s1">y1 += link.width;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function Sankey() {</span><span class="s3">\n  </span><span class="s1">let x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent</span><span class="s3">\n  </span><span class="s1">let dx = 24; // nodeWidth</span><span class="s3">\n  </span><span class="s1">let dy = 8, py; // nodePadding</span><span class="s3">\n  </span><span class="s1">let id = defaultId;</span><span class="s3">\n  </span><span class="s1">let align = justify;</span><span class="s3">\n  </span><span class="s1">let sort;</span><span class="s3">\n  </span><span class="s1">let linkSort;</span><span class="s3">\n  </span><span class="s1">let nodes = defaultNodes;</span><span class="s3">\n  </span><span class="s1">let links = defaultLinks;</span><span class="s3">\n  </span><span class="s1">let iterations = 6;</span><span class="s3">\n\n  </span><span class="s1">function sankey() {</span><span class="s3">\n    </span><span class="s1">const graph = {nodes: nodes.apply(null, arguments), links: links.apply(null, arguments)};</span><span class="s3">\n    </span><span class="s1">computeNodeLinks(graph);</span><span class="s3">\n    </span><span class="s1">computeNodeValues(graph);</span><span class="s3">\n    </span><span class="s1">computeNodeDepths(graph);</span><span class="s3">\n    </span><span class="s1">computeNodeHeights(graph);</span><span class="s3">\n    </span><span class="s1">computeNodeBreadths(graph);</span><span class="s3">\n    </span><span class="s1">computeLinkBreadths(graph);</span><span class="s3">\n    </span><span class="s1">return graph;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sankey.update = function(graph) {</span><span class="s3">\n    </span><span class="s1">computeLinkBreadths(graph);</span><span class="s3">\n    </span><span class="s1">return graph;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.nodeId = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (id = typeof _ === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? _ : constant(_), sankey) : id;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.nodeAlign = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (align = typeof _ === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? _ : constant(_), sankey) : align;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.nodeSort = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (sort = _, sankey) : sort;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.nodeWidth = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (dx = +_, sankey) : dx;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.nodePadding = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (dy = py = +_, sankey) : dy;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.nodes = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (nodes = typeof _ === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? _ : constant(_), sankey) : nodes;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.links = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (links = typeof _ === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? _ : constant(_), sankey) : links;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.linkSort = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (linkSort = _, sankey) : linkSort;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.size = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.extent = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">sankey.iterations = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (iterations = +_, sankey) : iterations;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">function computeNodeLinks({nodes, links}) {</span><span class="s3">\n    </span><span class="s1">for (const [i, node] of nodes.entries()) {</span><span class="s3">\n      </span><span class="s1">node.index = i;</span><span class="s3">\n      </span><span class="s1">node.sourceLinks = [];</span><span class="s3">\n      </span><span class="s1">node.targetLinks = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const nodeById = new Map(nodes.map((d, i) =&gt; [id(d, i, nodes), d]));</span><span class="s3">\n    </span><span class="s1">for (const [i, link] of links.entries()) {</span><span class="s3">\n      </span><span class="s1">link.index = i;</span><span class="s3">\n      </span><span class="s1">let {source, target} = link;</span><span class="s3">\n      </span><span class="s1">if (typeof source !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) source = link.source = find(nodeById, source);</span><span class="s3">\n      </span><span class="s1">if (typeof target !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) target = link.target = find(nodeById, target);</span><span class="s3">\n      </span><span class="s1">source.sourceLinks.push(link);</span><span class="s3">\n      </span><span class="s1">target.targetLinks.push(link);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (linkSort != null) {</span><span class="s3">\n      </span><span class="s1">for (const {sourceLinks, targetLinks} of nodes) {</span><span class="s3">\n        </span><span class="s1">sourceLinks.sort(linkSort);</span><span class="s3">\n        </span><span class="s1">targetLinks.sort(linkSort);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function computeNodeValues({nodes}) {</span><span class="s3">\n    </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n      </span><span class="s1">node.value = node.fixedValue === undefined</span><span class="s3">\n          </span><span class="s1">? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value))</span><span class="s3">\n          </span><span class="s1">: node.fixedValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function computeNodeDepths({nodes}) {</span><span class="s3">\n    </span><span class="s1">const n = nodes.length;</span><span class="s3">\n    </span><span class="s1">let current = new Set(nodes);</span><span class="s3">\n    </span><span class="s1">let next = new Set;</span><span class="s3">\n    </span><span class="s1">let x = 0;</span><span class="s3">\n    </span><span class="s1">while (current.size) {</span><span class="s3">\n      </span><span class="s1">for (const node of current) {</span><span class="s3">\n        </span><span class="s1">node.depth = x;</span><span class="s3">\n        </span><span class="s1">for (const {target} of node.sourceLinks) {</span><span class="s3">\n          </span><span class="s1">next.add(target);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (++x &gt; n) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">circular link</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">current = next;</span><span class="s3">\n      </span><span class="s1">next = new Set;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function computeNodeHeights({nodes}) {</span><span class="s3">\n    </span><span class="s1">const n = nodes.length;</span><span class="s3">\n    </span><span class="s1">let current = new Set(nodes);</span><span class="s3">\n    </span><span class="s1">let next = new Set;</span><span class="s3">\n    </span><span class="s1">let x = 0;</span><span class="s3">\n    </span><span class="s1">while (current.size) {</span><span class="s3">\n      </span><span class="s1">for (const node of current) {</span><span class="s3">\n        </span><span class="s1">node.height = x;</span><span class="s3">\n        </span><span class="s1">for (const {source} of node.targetLinks) {</span><span class="s3">\n          </span><span class="s1">next.add(source);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (++x &gt; n) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">circular link</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">current = next;</span><span class="s3">\n      </span><span class="s1">next = new Set;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function computeNodeLayers({nodes}) {</span><span class="s3">\n    </span><span class="s1">const x = max(nodes, d =&gt; d.depth) + 1;</span><span class="s3">\n    </span><span class="s1">const kx = (x1 - x0 - dx) / (x - 1);</span><span class="s3">\n    </span><span class="s1">const columns = new Array(x);</span><span class="s3">\n    </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n      </span><span class="s1">const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));</span><span class="s3">\n      </span><span class="s1">node.layer = i;</span><span class="s3">\n      </span><span class="s1">node.x0 = x0 + i * kx;</span><span class="s3">\n      </span><span class="s1">node.x1 = node.x0 + dx;</span><span class="s3">\n      </span><span class="s1">if (columns[i]) columns[i].push(node);</span><span class="s3">\n      </span><span class="s1">else columns[i] = [node];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (sort) for (const column of columns) {</span><span class="s3">\n      </span><span class="s1">column.sort(sort);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return columns;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function initializeNodeBreadths(columns) {</span><span class="s3">\n    </span><span class="s1">const ky = min(columns, c =&gt; (y1 - y0 - (c.length - 1) * py) / sum(c, value));</span><span class="s3">\n    </span><span class="s1">for (const nodes of columns) {</span><span class="s3">\n      </span><span class="s1">let y = y0;</span><span class="s3">\n      </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n        </span><span class="s1">node.y0 = y;</span><span class="s3">\n        </span><span class="s1">node.y1 = y + node.value * ky;</span><span class="s3">\n        </span><span class="s1">y = node.y1 + py;</span><span class="s3">\n        </span><span class="s1">for (const link of node.sourceLinks) {</span><span class="s3">\n          </span><span class="s1">link.width = link.value * ky;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">y = (y1 - y + py) / (nodes.length + 1);</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; nodes.length; ++i) {</span><span class="s3">\n        </span><span class="s1">const node = nodes[i];</span><span class="s3">\n        </span><span class="s1">node.y0 += y * (i + 1);</span><span class="s3">\n        </span><span class="s1">node.y1 += y * (i + 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">reorderLinks(nodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function computeNodeBreadths(graph) {</span><span class="s3">\n    </span><span class="s1">const columns = computeNodeLayers(graph);</span><span class="s3">\n    </span><span class="s1">py = Math.min(dy, (y1 - y0) / (max(columns, c =&gt; c.length) - 1));</span><span class="s3">\n    </span><span class="s1">initializeNodeBreadths(columns);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; iterations; ++i) {</span><span class="s3">\n      </span><span class="s1">const alpha = Math.pow(0.99, i);</span><span class="s3">\n      </span><span class="s1">const beta = Math.max(1 - alpha, (i + 1) / iterations);</span><span class="s3">\n      </span><span class="s1">relaxRightToLeft(columns, alpha, beta);</span><span class="s3">\n      </span><span class="s1">relaxLeftToRight(columns, alpha, beta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Reposition each node based on its incoming (target) links.</span><span class="s3">\n  </span><span class="s1">function relaxLeftToRight(columns, alpha, beta) {</span><span class="s3">\n    </span><span class="s1">for (let i = 1, n = columns.length; i &lt; n; ++i) {</span><span class="s3">\n      </span><span class="s1">const column = columns[i];</span><span class="s3">\n      </span><span class="s1">for (const target of column) {</span><span class="s3">\n        </span><span class="s1">let y = 0;</span><span class="s3">\n        </span><span class="s1">let w = 0;</span><span class="s3">\n        </span><span class="s1">for (const {source, value} of target.targetLinks) {</span><span class="s3">\n          </span><span class="s1">let v = value * (target.layer - source.layer);</span><span class="s3">\n          </span><span class="s1">y += targetTop(source, target) * v;</span><span class="s3">\n          </span><span class="s1">w += v;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!(w &gt; 0)) continue;</span><span class="s3">\n        </span><span class="s1">let dy = (y / w - target.y0) * alpha;</span><span class="s3">\n        </span><span class="s1">target.y0 += dy;</span><span class="s3">\n        </span><span class="s1">target.y1 += dy;</span><span class="s3">\n        </span><span class="s1">reorderNodeLinks(target);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (sort === undefined) column.sort(ascendingBreadth);</span><span class="s3">\n      </span><span class="s1">resolveCollisions(column, beta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Reposition each node based on its outgoing (source) links.</span><span class="s3">\n  </span><span class="s1">function relaxRightToLeft(columns, alpha, beta) {</span><span class="s3">\n    </span><span class="s1">for (let n = columns.length, i = n - 2; i &gt;= 0; --i) {</span><span class="s3">\n      </span><span class="s1">const column = columns[i];</span><span class="s3">\n      </span><span class="s1">for (const source of column) {</span><span class="s3">\n        </span><span class="s1">let y = 0;</span><span class="s3">\n        </span><span class="s1">let w = 0;</span><span class="s3">\n        </span><span class="s1">for (const {target, value} of source.sourceLinks) {</span><span class="s3">\n          </span><span class="s1">let v = value * (target.layer - source.layer);</span><span class="s3">\n          </span><span class="s1">y += sourceTop(source, target) * v;</span><span class="s3">\n          </span><span class="s1">w += v;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!(w &gt; 0)) continue;</span><span class="s3">\n        </span><span class="s1">let dy = (y / w - source.y0) * alpha;</span><span class="s3">\n        </span><span class="s1">source.y0 += dy;</span><span class="s3">\n        </span><span class="s1">source.y1 += dy;</span><span class="s3">\n        </span><span class="s1">reorderNodeLinks(source);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (sort === undefined) column.sort(ascendingBreadth);</span><span class="s3">\n      </span><span class="s1">resolveCollisions(column, beta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function resolveCollisions(nodes, alpha) {</span><span class="s3">\n    </span><span class="s1">const i = nodes.length &gt;&gt; 1;</span><span class="s3">\n    </span><span class="s1">const subject = nodes[i];</span><span class="s3">\n    </span><span class="s1">resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);</span><span class="s3">\n    </span><span class="s1">resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);</span><span class="s3">\n    </span><span class="s1">resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);</span><span class="s3">\n    </span><span class="s1">resolveCollisionsTopToBottom(nodes, y0, 0, alpha);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Push any overlapping nodes down.</span><span class="s3">\n  </span><span class="s1">function resolveCollisionsTopToBottom(nodes, y, i, alpha) {</span><span class="s3">\n    </span><span class="s1">for (; i &lt; nodes.length; ++i) {</span><span class="s3">\n      </span><span class="s1">const node = nodes[i];</span><span class="s3">\n      </span><span class="s1">const dy = (y - node.y0) * alpha;</span><span class="s3">\n      </span><span class="s1">if (dy &gt; 1e-6) node.y0 += dy, node.y1 += dy;</span><span class="s3">\n      </span><span class="s1">y = node.y1 + py;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Push any overlapping nodes up.</span><span class="s3">\n  </span><span class="s1">function resolveCollisionsBottomToTop(nodes, y, i, alpha) {</span><span class="s3">\n    </span><span class="s1">for (; i &gt;= 0; --i) {</span><span class="s3">\n      </span><span class="s1">const node = nodes[i];</span><span class="s3">\n      </span><span class="s1">const dy = (node.y1 - y) * alpha;</span><span class="s3">\n      </span><span class="s1">if (dy &gt; 1e-6) node.y0 -= dy, node.y1 -= dy;</span><span class="s3">\n      </span><span class="s1">y = node.y0 - py;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function reorderNodeLinks({sourceLinks, targetLinks}) {</span><span class="s3">\n    </span><span class="s1">if (linkSort === undefined) {</span><span class="s3">\n      </span><span class="s1">for (const {source: {sourceLinks}} of targetLinks) {</span><span class="s3">\n        </span><span class="s1">sourceLinks.sort(ascendingTargetBreadth);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const {target: {targetLinks}} of sourceLinks) {</span><span class="s3">\n        </span><span class="s1">targetLinks.sort(ascendingSourceBreadth);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function reorderLinks(nodes) {</span><span class="s3">\n    </span><span class="s1">if (linkSort === undefined) {</span><span class="s3">\n      </span><span class="s1">for (const {sourceLinks, targetLinks} of nodes) {</span><span class="s3">\n        </span><span class="s1">sourceLinks.sort(ascendingTargetBreadth);</span><span class="s3">\n        </span><span class="s1">targetLinks.sort(ascendingSourceBreadth);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Returns the target.y0 that would produce an ideal link from source to target.</span><span class="s3">\n  </span><span class="s1">function targetTop(source, target) {</span><span class="s3">\n    </span><span class="s1">let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;</span><span class="s3">\n    </span><span class="s1">for (const {target: node, width} of source.sourceLinks) {</span><span class="s3">\n      </span><span class="s1">if (node === target) break;</span><span class="s3">\n      </span><span class="s1">y += width + py;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const {source: node, width} of target.targetLinks) {</span><span class="s3">\n      </span><span class="s1">if (node === source) break;</span><span class="s3">\n      </span><span class="s1">y -= width;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Returns the source.y0 that would produce an ideal link from source to target.</span><span class="s3">\n  </span><span class="s1">function sourceTop(source, target) {</span><span class="s3">\n    </span><span class="s1">let y = target.y0 - (target.targetLinks.length - 1) * py / 2;</span><span class="s3">\n    </span><span class="s1">for (const {source: node, width} of target.targetLinks) {</span><span class="s3">\n      </span><span class="s1">if (node === source) break;</span><span class="s3">\n      </span><span class="s1">y += width + py;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const {target: node, width} of source.sourceLinks) {</span><span class="s3">\n      </span><span class="s1">if (node === target) break;</span><span class="s3">\n      </span><span class="s1">y -= width;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return sankey;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var pi = Math.PI,</span><span class="s3">\n    </span><span class="s1">tau = 2 * pi,</span><span class="s3">\n    </span><span class="s1">epsilon = 1e-6,</span><span class="s3">\n    </span><span class="s1">tauEpsilon = tau - epsilon;</span><span class="s3">\n\n</span><span class="s1">function Path() {</span><span class="s3">\n  </span><span class="s1">this._x0 = this._y0 = // start of current subpath</span><span class="s3">\n  </span><span class="s1">this._x1 = this._y1 = null; // end of current subpath</span><span class="s3">\n  </span><span class="s1">this._ = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function path() {</span><span class="s3">\n  </span><span class="s1">return new Path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Path.prototype = path.prototype = {</span><span class="s3">\n  </span><span class="s1">constructor: Path,</span><span class="s3">\n  </span><span class="s1">moveTo: function(x, y) {</span><span class="s3">\n    </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">M</span><span class="s3">\&quot; </span><span class="s1">+ (this._x0 = this._x1 = +x) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y0 = this._y1 = +y);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">closePath: function() {</span><span class="s3">\n    </span><span class="s1">if (this._x1 !== null) {</span><span class="s3">\n      </span><span class="s1">this._x1 = this._x0, this._y1 = this._y0;</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">Z</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">lineTo: function(x, y) {</span><span class="s3">\n    </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = +x) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = +y);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">quadraticCurveTo: function(x1, y1, x, y) {</span><span class="s3">\n    </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">Q</span><span class="s3">\&quot; </span><span class="s1">+ (+x1) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (+y1) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = +x) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = +y);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">bezierCurveTo: function(x1, y1, x2, y2, x, y) {</span><span class="s3">\n    </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">C</span><span class="s3">\&quot; </span><span class="s1">+ (+x1) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (+y1) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (+x2) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (+y2) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = +x) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = +y);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">arcTo: function(x1, y1, x2, y2, r) {</span><span class="s3">\n    </span><span class="s1">x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;</span><span class="s3">\n    </span><span class="s1">var x0 = this._x1,</span><span class="s3">\n        </span><span class="s1">y0 = this._y1,</span><span class="s3">\n        </span><span class="s1">x21 = x2 - x1,</span><span class="s3">\n        </span><span class="s1">y21 = y2 - y1,</span><span class="s3">\n        </span><span class="s1">x01 = x0 - x1,</span><span class="s3">\n        </span><span class="s1">y01 = y0 - y1,</span><span class="s3">\n        </span><span class="s1">l01_2 = x01 * x01 + y01 * y01;</span><span class="s3">\n\n    </span><span class="s1">// Is the radius negative? Error.</span><span class="s3">\n    </span><span class="s1">if (r &lt; 0) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">negative radius: </span><span class="s3">\&quot; </span><span class="s1">+ r);</span><span class="s3">\n\n    </span><span class="s1">// Is this path empty? Move to (x1,y1).</span><span class="s3">\n    </span><span class="s1">if (this._x1 === null) {</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">M</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = x1) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = y1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Or, is (x1,y1) coincident with (x0,y0)? Do nothing.</span><span class="s3">\n    </span><span class="s1">else if (!(l01_2 &gt; epsilon));</span><span class="s3">\n\n    </span><span class="s1">// Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?</span><span class="s3">\n    </span><span class="s1">// Equivalently, is (x1,y1) coincident with (x2,y2)?</span><span class="s3">\n    </span><span class="s1">// Or, is the radius zero? Line to (x1,y1).</span><span class="s3">\n    </span><span class="s1">else if (!(Math.abs(y01 * x21 - y21 * x01) &gt; epsilon) || !r) {</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = x1) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = y1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Otherwise, draw an arc!</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">var x20 = x2 - x0,</span><span class="s3">\n          </span><span class="s1">y20 = y2 - y0,</span><span class="s3">\n          </span><span class="s1">l21_2 = x21 * x21 + y21 * y21,</span><span class="s3">\n          </span><span class="s1">l20_2 = x20 * x20 + y20 * y20,</span><span class="s3">\n          </span><span class="s1">l21 = Math.sqrt(l21_2),</span><span class="s3">\n          </span><span class="s1">l01 = Math.sqrt(l01_2),</span><span class="s3">\n          </span><span class="s1">l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),</span><span class="s3">\n          </span><span class="s1">t01 = l / l01,</span><span class="s3">\n          </span><span class="s1">t21 = l / l21;</span><span class="s3">\n\n      </span><span class="s1">// If the start tangent is not coincident with (x0,y0), line to.</span><span class="s3">\n      </span><span class="s1">if (Math.abs(t01 - 1) &gt; epsilon) {</span><span class="s3">\n        </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">+ (x1 + t01 * x01) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (y1 + t01 * y01);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">A</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,0,0,</span><span class="s3">\&quot; </span><span class="s1">+ (+(y01 * x20 &gt; x01 * y20)) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = x1 + t21 * x21) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = y1 + t21 * y21);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">arc: function(x, y, r, a0, a1, ccw) {</span><span class="s3">\n    </span><span class="s1">x = +x, y = +y, r = +r, ccw = !!ccw;</span><span class="s3">\n    </span><span class="s1">var dx = r * Math.cos(a0),</span><span class="s3">\n        </span><span class="s1">dy = r * Math.sin(a0),</span><span class="s3">\n        </span><span class="s1">x0 = x + dx,</span><span class="s3">\n        </span><span class="s1">y0 = y + dy,</span><span class="s3">\n        </span><span class="s1">cw = 1 ^ ccw,</span><span class="s3">\n        </span><span class="s1">da = ccw ? a0 - a1 : a1 - a0;</span><span class="s3">\n\n    </span><span class="s1">// Is the radius negative? Error.</span><span class="s3">\n    </span><span class="s1">if (r &lt; 0) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">negative radius: </span><span class="s3">\&quot; </span><span class="s1">+ r);</span><span class="s3">\n\n    </span><span class="s1">// Is this path empty? Move to (x0,y0).</span><span class="s3">\n    </span><span class="s1">if (this._x1 === null) {</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">M</span><span class="s3">\&quot; </span><span class="s1">+ x0 + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ y0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).</span><span class="s3">\n    </span><span class="s1">else if (Math.abs(this._x1 - x0) &gt; epsilon || Math.abs(this._y1 - y0) &gt; epsilon) {</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">+ x0 + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ y0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Is this arc empty? We’re done.</span><span class="s3">\n    </span><span class="s1">if (!r) return;</span><span class="s3">\n\n    </span><span class="s1">// Does the angle go the wrong way? Flip the direction.</span><span class="s3">\n    </span><span class="s1">if (da &lt; 0) da = da % tau + tau;</span><span class="s3">\n\n    </span><span class="s1">// Is this a complete circle? Draw two arcs to complete the circle.</span><span class="s3">\n    </span><span class="s1">if (da &gt; tauEpsilon) {</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">A</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,0,1,</span><span class="s3">\&quot; </span><span class="s1">+ cw + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (x - dx) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (y - dy) + </span><span class="s3">\&quot;</span><span class="s1">A</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,0,1,</span><span class="s3">\&quot; </span><span class="s1">+ cw + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = x0) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = y0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Is this arc non-empty? Draw an arc!</span><span class="s3">\n    </span><span class="s1">else if (da &gt; epsilon) {</span><span class="s3">\n      </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">A</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ r + </span><span class="s3">\&quot;</span><span class="s1">,0,</span><span class="s3">\&quot; </span><span class="s1">+ (+(da &gt;= pi)) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ cw + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._x1 = x + r * Math.cos(a1)) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y1 = y + r * Math.sin(a1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">rect: function(x, y, w, h) {</span><span class="s3">\n    </span><span class="s1">this._ += </span><span class="s3">\&quot;</span><span class="s1">M</span><span class="s3">\&quot; </span><span class="s1">+ (this._x0 = this._x1 = +x) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (this._y0 = this._y1 = +y) + </span><span class="s3">\&quot;</span><span class="s1">h</span><span class="s3">\&quot; </span><span class="s1">+ (+w) + </span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot; </span><span class="s1">+ (+h) + </span><span class="s3">\&quot;</span><span class="s1">h</span><span class="s3">\&quot; </span><span class="s1">+ (-w) + </span><span class="s3">\&quot;</span><span class="s1">Z</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">toString: function() {</span><span class="s3">\n    </span><span class="s1">return this._;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default path;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export var slice = Array.prototype.slice;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function(x) {</span><span class="s3">\n  </span><span class="s1">return function constant() {</span><span class="s3">\n    </span><span class="s1">return x;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function x(p) {</span><span class="s3">\n  </span><span class="s1">return p[0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function y(p) {</span><span class="s3">\n  </span><span class="s1">return p[1];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {path} from </span><span class="s3">\&quot;</span><span class="s1">d3-path</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {slice} from </span><span class="s3">\&quot;</span><span class="s1">../array.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import constant from </span><span class="s3">\&quot;</span><span class="s1">../constant.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {x as pointX, y as pointY} from </span><span class="s3">\&quot;</span><span class="s1">../point.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import pointRadial from </span><span class="s3">\&quot;</span><span class="s1">../pointRadial.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function linkSource(d) {</span><span class="s3">\n  </span><span class="s1">return d.source;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function linkTarget(d) {</span><span class="s3">\n  </span><span class="s1">return d.target;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function link(curve) {</span><span class="s3">\n  </span><span class="s1">var source = linkSource,</span><span class="s3">\n      </span><span class="s1">target = linkTarget,</span><span class="s3">\n      </span><span class="s1">x = pointX,</span><span class="s3">\n      </span><span class="s1">y = pointY,</span><span class="s3">\n      </span><span class="s1">context = null;</span><span class="s3">\n\n  </span><span class="s1">function link() {</span><span class="s3">\n    </span><span class="s1">var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);</span><span class="s3">\n    </span><span class="s1">if (!context) context = buffer = path();</span><span class="s3">\n    </span><span class="s1">curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));</span><span class="s3">\n    </span><span class="s1">if (buffer) return context = null, buffer + </span><span class="s3">\&quot;\&quot; </span><span class="s1">|| null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">link.source = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (source = _, link) : source;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">link.target = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (target = _, link) : target;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">link.x = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (x = typeof _ === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? _ : constant(+_), link) : x;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">link.y = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? (y = typeof _ === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? _ : constant(+_), link) : y;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">link.context = function(_) {</span><span class="s3">\n    </span><span class="s1">return arguments.length ? ((context = _ == null ? null : _), link) : context;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">return link;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function curveHorizontal(context, x0, y0, x1, y1) {</span><span class="s3">\n  </span><span class="s1">context.moveTo(x0, y0);</span><span class="s3">\n  </span><span class="s1">context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function curveVertical(context, x0, y0, x1, y1) {</span><span class="s3">\n  </span><span class="s1">context.moveTo(x0, y0);</span><span class="s3">\n  </span><span class="s1">context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function curveRadial(context, x0, y0, x1, y1) {</span><span class="s3">\n  </span><span class="s1">var p0 = pointRadial(x0, y0),</span><span class="s3">\n      </span><span class="s1">p1 = pointRadial(x0, y0 = (y0 + y1) / 2),</span><span class="s3">\n      </span><span class="s1">p2 = pointRadial(x1, y0),</span><span class="s3">\n      </span><span class="s1">p3 = pointRadial(x1, y1);</span><span class="s3">\n  </span><span class="s1">context.moveTo(p0[0], p0[1]);</span><span class="s3">\n  </span><span class="s1">context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function linkHorizontal() {</span><span class="s3">\n  </span><span class="s1">return link(curveHorizontal);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function linkVertical() {</span><span class="s3">\n  </span><span class="s1">return link(curveVertical);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function linkRadial() {</span><span class="s3">\n  </span><span class="s1">var l = link(curveRadial);</span><span class="s3">\n  </span><span class="s1">l.angle = l.x, delete l.x;</span><span class="s3">\n  </span><span class="s1">l.radius = l.y, delete l.y;</span><span class="s3">\n  </span><span class="s1">return l;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {linkHorizontal} from </span><span class="s3">\&quot;</span><span class="s1">d3-shape</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function horizontalSource(d) {</span><span class="s3">\n  </span><span class="s1">return [d.source.x1, d.y0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function horizontalTarget(d) {</span><span class="s3">\n  </span><span class="s1">return [d.target.x0, d.y1];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function() {</span><span class="s3">\n  </span><span class="s1">return linkHorizontal()</span><span class="s3">\n      </span><span class="s1">.source(horizontalSource)</span><span class="s3">\n      </span><span class="s1">.target(horizontalTarget);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">__name,</span><span class="s3">\n  </span><span class="s1">clear,</span><span class="s3">\n  </span><span class="s1">common_default,</span><span class="s3">\n  </span><span class="s1">defaultConfig2 as defaultConfig,</span><span class="s3">\n  </span><span class="s1">getAccDescription,</span><span class="s3">\n  </span><span class="s1">getAccTitle,</span><span class="s3">\n  </span><span class="s1">getConfig2 as getConfig,</span><span class="s3">\n  </span><span class="s1">getDiagramTitle,</span><span class="s3">\n  </span><span class="s1">setAccDescription,</span><span class="s3">\n  </span><span class="s1">setAccTitle,</span><span class="s3">\n  </span><span class="s1">setDiagramTitle,</span><span class="s3">\n  </span><span class="s1">setupGraphViewbox</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-YTJNT7DU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/parser/sankey.jison</span><span class="s3">\n</span><span class="s1">var parser = function() {</span><span class="s3">\n  </span><span class="s1">var o = /* @__PURE__ */ __name(function(k, v, o2, l) {</span><span class="s3">\n    </span><span class="s1">for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;</span><span class="s3">\n    </span><span class="s1">return o2;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">o</span><span class="s3">\&quot;</span><span class="s1">), $V0 = [1, 9], $V1 = [1, 10], $V2 = [1, 5, 10, 12];</span><span class="s3">\n  </span><span class="s1">var parser2 = {</span><span class="s3">\n    </span><span class="s1">trace: /* @__PURE__ */ __name(function trace() {</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">trace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">yy: {},</span><span class="s3">\n    </span><span class="s1">symbols_: { </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">: 2, </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">: 3, </span><span class="s3">\&quot;</span><span class="s1">SANKEY</span><span class="s3">\&quot;</span><span class="s1">: 4, </span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">: 5, </span><span class="s3">\&quot;</span><span class="s1">csv</span><span class="s3">\&quot;</span><span class="s1">: 6, </span><span class="s3">\&quot;</span><span class="s1">opt_eof</span><span class="s3">\&quot;</span><span class="s1">: 7, </span><span class="s3">\&quot;</span><span class="s1">record</span><span class="s3">\&quot;</span><span class="s1">: 8, </span><span class="s3">\&quot;</span><span class="s1">csv_tail</span><span class="s3">\&quot;</span><span class="s1">: 9, </span><span class="s3">\&quot;</span><span class="s1">EOF</span><span class="s3">\&quot;</span><span class="s1">: 10, </span><span class="s3">\&quot;</span><span class="s1">field[source]</span><span class="s3">\&quot;</span><span class="s1">: 11, </span><span class="s3">\&quot;</span><span class="s1">COMMA</span><span class="s3">\&quot;</span><span class="s1">: 12, </span><span class="s3">\&quot;</span><span class="s1">field[target]</span><span class="s3">\&quot;</span><span class="s1">: 13, </span><span class="s3">\&quot;</span><span class="s1">field[value]</span><span class="s3">\&quot;</span><span class="s1">: 14, </span><span class="s3">\&quot;</span><span class="s1">field</span><span class="s3">\&quot;</span><span class="s1">: 15, </span><span class="s3">\&quot;</span><span class="s1">escaped</span><span class="s3">\&quot;</span><span class="s1">: 16, </span><span class="s3">\&quot;</span><span class="s1">non_escaped</span><span class="s3">\&quot;</span><span class="s1">: 17, </span><span class="s3">\&quot;</span><span class="s1">DQUOTE</span><span class="s3">\&quot;</span><span class="s1">: 18, </span><span class="s3">\&quot;</span><span class="s1">ESCAPED_TEXT</span><span class="s3">\&quot;</span><span class="s1">: 19, </span><span class="s3">\&quot;</span><span class="s1">NON_ESCAPED_TEXT</span><span class="s3">\&quot;</span><span class="s1">: 20, </span><span class="s3">\&quot;</span><span class="s1">$accept</span><span class="s3">\&quot;</span><span class="s1">: 0, </span><span class="s3">\&quot;</span><span class="s1">$end</span><span class="s3">\&quot;</span><span class="s1">: 1 },</span><span class="s3">\n    </span><span class="s1">terminals_: { 2: </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">, 4: </span><span class="s3">\&quot;</span><span class="s1">SANKEY</span><span class="s3">\&quot;</span><span class="s1">, 5: </span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">, 10: </span><span class="s3">\&quot;</span><span class="s1">EOF</span><span class="s3">\&quot;</span><span class="s1">, 11: </span><span class="s3">\&quot;</span><span class="s1">field[source]</span><span class="s3">\&quot;</span><span class="s1">, 12: </span><span class="s3">\&quot;</span><span class="s1">COMMA</span><span class="s3">\&quot;</span><span class="s1">, 13: </span><span class="s3">\&quot;</span><span class="s1">field[target]</span><span class="s3">\&quot;</span><span class="s1">, 14: </span><span class="s3">\&quot;</span><span class="s1">field[value]</span><span class="s3">\&quot;</span><span class="s1">, 18: </span><span class="s3">\&quot;</span><span class="s1">DQUOTE</span><span class="s3">\&quot;</span><span class="s1">, 19: </span><span class="s3">\&quot;</span><span class="s1">ESCAPED_TEXT</span><span class="s3">\&quot;</span><span class="s1">, 20: </span><span class="s3">\&quot;</span><span class="s1">NON_ESCAPED_TEXT</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">productions_: [0, [3, 4], [6, 2], [9, 2], [9, 0], [7, 1], [7, 0], [8, 5], [15, 1], [15, 1], [16, 3], [17, 1]],</span><span class="s3">\n    </span><span class="s1">performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {</span><span class="s3">\n      </span><span class="s1">var $0 = $$.length - 1;</span><span class="s3">\n      </span><span class="s1">switch (yystate) {</span><span class="s3">\n        </span><span class="s1">case 7:</span><span class="s3">\n          </span><span class="s1">const source = yy.findOrCreateNode($$[$0 - 4].trim().replaceAll('</span><span class="s3">\&quot;\&quot;</span><span class="s1">', '</span><span class="s3">\&quot;</span><span class="s1">'));</span><span class="s3">\n          </span><span class="s1">const target = yy.findOrCreateNode($$[$0 - 2].trim().replaceAll('</span><span class="s3">\&quot;\&quot;</span><span class="s1">', '</span><span class="s3">\&quot;</span><span class="s1">'));</span><span class="s3">\n          </span><span class="s1">const value = parseFloat($$[$0].trim());</span><span class="s3">\n          </span><span class="s1">yy.addLink(source, target, value);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 8:</span><span class="s3">\n        </span><span class="s1">case 9:</span><span class="s3">\n        </span><span class="s1">case 11:</span><span class="s3">\n          </span><span class="s1">this.$ = $$[$0];</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 10:</span><span class="s3">\n          </span><span class="s1">this.$ = $$[$0 - 1];</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">anonymous</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, { 5: [1, 3] }, { 6: 4, 8: 5, 15: 6, 16: 7, 17: 8, 18: $V0, 20: $V1 }, { 1: [2, 6], 7: 11, 10: [1, 12] }, o($V1, [2, 4], { 9: 13, 5: [1, 14] }), { 12: [1, 15] }, o($V2, [2, 8]), o($V2, [2, 9]), { 19: [1, 16] }, o($V2, [2, 11]), { 1: [2, 1] }, { 1: [2, 5] }, o($V1, [2, 2]), { 6: 17, 8: 5, 15: 6, 16: 7, 17: 8, 18: $V0, 20: $V1 }, { 15: 18, 16: 7, 17: 8, 18: $V0, 20: $V1 }, { 18: [1, 19] }, o($V1, [2, 3]), { 12: [1, 20] }, o($V2, [2, 10]), { 15: 21, 16: 7, 17: 8, 18: $V0, 20: $V1 }, o([1, 5, 10], [2, 7])],</span><span class="s3">\n    </span><span class="s1">defaultActions: { 11: [2, 1], 12: [2, 5] },</span><span class="s3">\n    </span><span class="s1">parseError: /* @__PURE__ */ __name(function parseError(str, hash) {</span><span class="s3">\n      </span><span class="s1">if (hash.recoverable) {</span><span class="s3">\n        </span><span class="s1">this.trace(str);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var error = new Error(str);</span><span class="s3">\n        </span><span class="s1">error.hash = hash;</span><span class="s3">\n        </span><span class="s1">throw error;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parseError</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">parse: /* @__PURE__ */ __name(function parse(input) {</span><span class="s3">\n      </span><span class="s1">var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;</span><span class="s3">\n      </span><span class="s1">var args = lstack.slice.call(arguments, 1);</span><span class="s3">\n      </span><span class="s1">var lexer2 = Object.create(this.lexer);</span><span class="s3">\n      </span><span class="s1">var sharedState = { yy: {} };</span><span class="s3">\n      </span><span class="s1">for (var k in this.yy) {</span><span class="s3">\n        </span><span class="s1">if (Object.prototype.hasOwnProperty.call(this.yy, k)) {</span><span class="s3">\n          </span><span class="s1">sharedState.yy[k] = this.yy[k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">lexer2.setInput(input, sharedState.yy);</span><span class="s3">\n      </span><span class="s1">sharedState.yy.lexer = lexer2;</span><span class="s3">\n      </span><span class="s1">sharedState.yy.parser = this;</span><span class="s3">\n      </span><span class="s1">if (typeof lexer2.yylloc == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">lexer2.yylloc = {};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var yyloc = lexer2.yylloc;</span><span class="s3">\n      </span><span class="s1">lstack.push(yyloc);</span><span class="s3">\n      </span><span class="s1">var ranges = lexer2.options &amp;&amp; lexer2.options.ranges;</span><span class="s3">\n      </span><span class="s1">if (typeof sharedState.yy.parseError === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.parseError = sharedState.yy.parseError;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.parseError = Object.getPrototypeOf(this).parseError;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">function popStack(n) {</span><span class="s3">\n        </span><span class="s1">stack.length = stack.length - 2 * n;</span><span class="s3">\n        </span><span class="s1">vstack.length = vstack.length - n;</span><span class="s3">\n        </span><span class="s1">lstack.length = lstack.length - n;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">__name(popStack, </span><span class="s3">\&quot;</span><span class="s1">popStack</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">function lex() {</span><span class="s3">\n        </span><span class="s1">var token;</span><span class="s3">\n        </span><span class="s1">token = tstack.pop() || lexer2.lex() || EOF;</span><span class="s3">\n        </span><span class="s1">if (typeof token !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (token instanceof Array) {</span><span class="s3">\n            </span><span class="s1">tstack = token;</span><span class="s3">\n            </span><span class="s1">token = tstack.pop();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">token = self.symbols_[token] || token;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return token;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">__name(lex, </span><span class="s3">\&quot;</span><span class="s1">lex</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">state = stack[stack.length - 1];</span><span class="s3">\n        </span><span class="s1">if (this.defaultActions[state]) {</span><span class="s3">\n          </span><span class="s1">action = this.defaultActions[state];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (symbol === null || typeof symbol == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">symbol = lex();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">action = table[state] &amp;&amp; table[state][symbol];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof action === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">|| !action.length || !action[0]) {</span><span class="s3">\n          </span><span class="s1">var errStr = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">expected = [];</span><span class="s3">\n          </span><span class="s1">for (p in table[state]) {</span><span class="s3">\n            </span><span class="s1">if (this.terminals_[p] &amp;&amp; p &gt; TERROR) {</span><span class="s3">\n              </span><span class="s1">expected.push(</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">+ this.terminals_[p] + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (lexer2.showPosition) {</span><span class="s3">\n            </span><span class="s1">errStr = </span><span class="s3">\&quot;</span><span class="s1">Parse error on line </span><span class="s3">\&quot; </span><span class="s1">+ (yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ lexer2.showPosition() + </span><span class="s3">\&quot;\\</span><span class="s1">nExpecting </span><span class="s3">\&quot; </span><span class="s1">+ expected.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">, got '</span><span class="s3">\&quot; </span><span class="s1">+ (this.terminals_[symbol] || symbol) + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">errStr = </span><span class="s3">\&quot;</span><span class="s1">Parse error on line </span><span class="s3">\&quot; </span><span class="s1">+ (yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">: Unexpected </span><span class="s3">\&quot; </span><span class="s1">+ (symbol == EOF ? </span><span class="s3">\&quot;</span><span class="s1">end of input</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">+ (this.terminals_[symbol] || symbol) + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.parseError(errStr, {</span><span class="s3">\n            </span><span class="s1">text: lexer2.match,</span><span class="s3">\n            </span><span class="s1">token: this.terminals_[symbol] || symbol,</span><span class="s3">\n            </span><span class="s1">line: lexer2.yylineno,</span><span class="s3">\n            </span><span class="s1">loc: yyloc,</span><span class="s3">\n            </span><span class="s1">expected</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (action[0] instanceof Array &amp;&amp; action.length &gt; 1) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Parse Error: multiple actions possible at state: </span><span class="s3">\&quot; </span><span class="s1">+ state + </span><span class="s3">\&quot;</span><span class="s1">, token: </span><span class="s3">\&quot; </span><span class="s1">+ symbol);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (action[0]) {</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">stack.push(symbol);</span><span class="s3">\n            </span><span class="s1">vstack.push(lexer2.yytext);</span><span class="s3">\n            </span><span class="s1">lstack.push(lexer2.yylloc);</span><span class="s3">\n            </span><span class="s1">stack.push(action[1]);</span><span class="s3">\n            </span><span class="s1">symbol = null;</span><span class="s3">\n            </span><span class="s1">if (!preErrorSymbol) {</span><span class="s3">\n              </span><span class="s1">yyleng = lexer2.yyleng;</span><span class="s3">\n              </span><span class="s1">yytext = lexer2.yytext;</span><span class="s3">\n              </span><span class="s1">yylineno = lexer2.yylineno;</span><span class="s3">\n              </span><span class="s1">yyloc = lexer2.yylloc;</span><span class="s3">\n              </span><span class="s1">if (recovering &gt; 0) {</span><span class="s3">\n                </span><span class="s1">recovering--;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">symbol = preErrorSymbol;</span><span class="s3">\n              </span><span class="s1">preErrorSymbol = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">len = this.productions_[action[1]][1];</span><span class="s3">\n            </span><span class="s1">yyval.$ = vstack[vstack.length - len];</span><span class="s3">\n            </span><span class="s1">yyval._$ = {</span><span class="s3">\n              </span><span class="s1">first_line: lstack[lstack.length - (len || 1)].first_line,</span><span class="s3">\n              </span><span class="s1">last_line: lstack[lstack.length - 1].last_line,</span><span class="s3">\n              </span><span class="s1">first_column: lstack[lstack.length - (len || 1)].first_column,</span><span class="s3">\n              </span><span class="s1">last_column: lstack[lstack.length - 1].last_column</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">if (ranges) {</span><span class="s3">\n              </span><span class="s1">yyval._$.range = [</span><span class="s3">\n                </span><span class="s1">lstack[lstack.length - (len || 1)].range[0],</span><span class="s3">\n                </span><span class="s1">lstack[lstack.length - 1].range[1]</span><span class="s3">\n              </span><span class="s1">];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">r = this.performAction.apply(yyval, [</span><span class="s3">\n              </span><span class="s1">yytext,</span><span class="s3">\n              </span><span class="s1">yyleng,</span><span class="s3">\n              </span><span class="s1">yylineno,</span><span class="s3">\n              </span><span class="s1">sharedState.yy,</span><span class="s3">\n              </span><span class="s1">action[1],</span><span class="s3">\n              </span><span class="s1">vstack,</span><span class="s3">\n              </span><span class="s1">lstack</span><span class="s3">\n            </span><span class="s1">].concat(args));</span><span class="s3">\n            </span><span class="s1">if (typeof r !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">return r;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (len) {</span><span class="s3">\n              </span><span class="s1">stack = stack.slice(0, -1 * len * 2);</span><span class="s3">\n              </span><span class="s1">vstack = vstack.slice(0, -1 * len);</span><span class="s3">\n              </span><span class="s1">lstack = lstack.slice(0, -1 * len);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">stack.push(this.productions_[action[1]][0]);</span><span class="s3">\n            </span><span class="s1">vstack.push(yyval.$);</span><span class="s3">\n            </span><span class="s1">lstack.push(yyval._$);</span><span class="s3">\n            </span><span class="s1">newState = table[stack[stack.length - 2]][stack[stack.length - 1]];</span><span class="s3">\n            </span><span class="s1">stack.push(newState);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parse</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var lexer = /* @__PURE__ */ function() {</span><span class="s3">\n    </span><span class="s1">var lexer2 = {</span><span class="s3">\n      </span><span class="s1">EOF: 1,</span><span class="s3">\n      </span><span class="s1">parseError: /* @__PURE__ */ __name(function parseError(str, hash) {</span><span class="s3">\n        </span><span class="s1">if (this.yy.parser) {</span><span class="s3">\n          </span><span class="s1">this.yy.parser.parseError(str, hash);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw new Error(str);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parseError</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// resets the lexer, sets new input</span><span class="s3">\n      </span><span class="s1">setInput: /* @__PURE__ */ __name(function(input, yy) {</span><span class="s3">\n        </span><span class="s1">this.yy = yy || this.yy || {};</span><span class="s3">\n        </span><span class="s1">this._input = input;</span><span class="s3">\n        </span><span class="s1">this._more = this._backtrack = this.done = false;</span><span class="s3">\n        </span><span class="s1">this.yylineno = this.yyleng = 0;</span><span class="s3">\n        </span><span class="s1">this.yytext = this.matched = this.match = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.conditionStack = [</span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">this.yylloc = {</span><span class="s3">\n          </span><span class="s1">first_line: 1,</span><span class="s3">\n          </span><span class="s1">first_column: 0,</span><span class="s3">\n          </span><span class="s1">last_line: 1,</span><span class="s3">\n          </span><span class="s1">last_column: 0</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range = [0, 0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.offset = 0;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">setInput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// consumes and returns one char from the input</span><span class="s3">\n      </span><span class="s1">input: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var ch = this._input[0];</span><span class="s3">\n        </span><span class="s1">this.yytext += ch;</span><span class="s3">\n        </span><span class="s1">this.yyleng++;</span><span class="s3">\n        </span><span class="s1">this.offset++;</span><span class="s3">\n        </span><span class="s1">this.match += ch;</span><span class="s3">\n        </span><span class="s1">this.matched += ch;</span><span class="s3">\n        </span><span class="s1">var lines = ch.match(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n).*/g);</span><span class="s3">\n        </span><span class="s1">if (lines) {</span><span class="s3">\n          </span><span class="s1">this.yylineno++;</span><span class="s3">\n          </span><span class="s1">this.yylloc.last_line++;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this.yylloc.last_column++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range[1]++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._input = this._input.slice(1);</span><span class="s3">\n        </span><span class="s1">return ch;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// unshifts one char (or a string) into the input</span><span class="s3">\n      </span><span class="s1">unput: /* @__PURE__ */ __name(function(ch) {</span><span class="s3">\n        </span><span class="s1">var len = ch.length;</span><span class="s3">\n        </span><span class="s1">var lines = ch.split(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n)/g);</span><span class="s3">\n        </span><span class="s1">this._input = ch + this._input;</span><span class="s3">\n        </span><span class="s1">this.yytext = this.yytext.substr(0, this.yytext.length - len);</span><span class="s3">\n        </span><span class="s1">this.offset -= len;</span><span class="s3">\n        </span><span class="s1">var oldLines = this.match.split(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n)/g);</span><span class="s3">\n        </span><span class="s1">this.match = this.match.substr(0, this.match.length - 1);</span><span class="s3">\n        </span><span class="s1">this.matched = this.matched.substr(0, this.matched.length - 1);</span><span class="s3">\n        </span><span class="s1">if (lines.length - 1) {</span><span class="s3">\n          </span><span class="s1">this.yylineno -= lines.length - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var r = this.yylloc.range;</span><span class="s3">\n        </span><span class="s1">this.yylloc = {</span><span class="s3">\n          </span><span class="s1">first_line: this.yylloc.first_line,</span><span class="s3">\n          </span><span class="s1">last_line: this.yylineno + 1,</span><span class="s3">\n          </span><span class="s1">first_column: this.yylloc.first_column,</span><span class="s3">\n          </span><span class="s1">last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range = [r[0], r[0] + this.yyleng - len];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.yyleng = this.yytext.length;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">unput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// When called from action, caches matched text and appends it on next action</span><span class="s3">\n      </span><span class="s1">more: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">this._more = true;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">more</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.</span><span class="s3">\n      </span><span class="s1">reject: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">if (this.options.backtrack_lexer) {</span><span class="s3">\n          </span><span class="s1">this._backtrack = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.parseError(</span><span class="s3">\&quot;</span><span class="s1">Lexical error on line </span><span class="s3">\&quot; </span><span class="s1">+ (this.yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ this.showPosition(), {</span><span class="s3">\n            </span><span class="s1">text: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">token: null,</span><span class="s3">\n            </span><span class="s1">line: this.yylineno</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">reject</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// retain first n characters of the match</span><span class="s3">\n      </span><span class="s1">less: /* @__PURE__ */ __name(function(n) {</span><span class="s3">\n        </span><span class="s1">this.unput(this.match.slice(n));</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">less</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// displays already matched input, i.e. for error messages</span><span class="s3">\n      </span><span class="s1">pastInput: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var past = this.matched.substr(0, this.matched.length - this.match.length);</span><span class="s3">\n        </span><span class="s1">return (past.length &gt; 20 ? </span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + past.substr(-20).replace(/</span><span class="s3">\\</span><span class="s1">n/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">pastInput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// displays upcoming input, i.e. for error messages</span><span class="s3">\n      </span><span class="s1">upcomingInput: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var next = this.match;</span><span class="s3">\n        </span><span class="s1">if (next.length &lt; 20) {</span><span class="s3">\n          </span><span class="s1">next += this._input.substr(0, 20 - next.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (next.substr(0, 20) + (next.length &gt; 20 ? </span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">)).replace(/</span><span class="s3">\\</span><span class="s1">n/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">upcomingInput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// displays the character position where the lexing error occurred, i.e. for error messages</span><span class="s3">\n      </span><span class="s1">showPosition: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var pre = this.pastInput();</span><span class="s3">\n        </span><span class="s1">var c = new Array(pre.length + 1).join(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return pre + this.upcomingInput() + </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ c + </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">showPosition</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// test the lexed token: return FALSE when not a match, otherwise return token</span><span class="s3">\n      </span><span class="s1">test_match: /* @__PURE__ */ __name(function(match, indexed_rule) {</span><span class="s3">\n        </span><span class="s1">var token, lines, backup;</span><span class="s3">\n        </span><span class="s1">if (this.options.backtrack_lexer) {</span><span class="s3">\n          </span><span class="s1">backup = {</span><span class="s3">\n            </span><span class="s1">yylineno: this.yylineno,</span><span class="s3">\n            </span><span class="s1">yylloc: {</span><span class="s3">\n              </span><span class="s1">first_line: this.yylloc.first_line,</span><span class="s3">\n              </span><span class="s1">last_line: this.last_line,</span><span class="s3">\n              </span><span class="s1">first_column: this.yylloc.first_column,</span><span class="s3">\n              </span><span class="s1">last_column: this.yylloc.last_column</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">yytext: this.yytext,</span><span class="s3">\n            </span><span class="s1">match: this.match,</span><span class="s3">\n            </span><span class="s1">matches: this.matches,</span><span class="s3">\n            </span><span class="s1">matched: this.matched,</span><span class="s3">\n            </span><span class="s1">yyleng: this.yyleng,</span><span class="s3">\n            </span><span class="s1">offset: this.offset,</span><span class="s3">\n            </span><span class="s1">_more: this._more,</span><span class="s3">\n            </span><span class="s1">_input: this._input,</span><span class="s3">\n            </span><span class="s1">yy: this.yy,</span><span class="s3">\n            </span><span class="s1">conditionStack: this.conditionStack.slice(0),</span><span class="s3">\n            </span><span class="s1">done: this.done</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n            </span><span class="s1">backup.yylloc.range = this.yylloc.range.slice(0);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">lines = match[0].match(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n).*/g);</span><span class="s3">\n        </span><span class="s1">if (lines) {</span><span class="s3">\n          </span><span class="s1">this.yylineno += lines.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.yylloc = {</span><span class="s3">\n          </span><span class="s1">first_line: this.yylloc.last_line,</span><span class="s3">\n          </span><span class="s1">last_line: this.yylineno + 1,</span><span class="s3">\n          </span><span class="s1">first_column: this.yylloc.last_column,</span><span class="s3">\n          </span><span class="s1">last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n?/)[0].length : this.yylloc.last_column + match[0].length</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.yytext += match[0];</span><span class="s3">\n        </span><span class="s1">this.match += match[0];</span><span class="s3">\n        </span><span class="s1">this.matches = match;</span><span class="s3">\n        </span><span class="s1">this.yyleng = this.yytext.length;</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range = [this.offset, this.offset += this.yyleng];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._more = false;</span><span class="s3">\n        </span><span class="s1">this._backtrack = false;</span><span class="s3">\n        </span><span class="s1">this._input = this._input.slice(match[0].length);</span><span class="s3">\n        </span><span class="s1">this.matched += match[0];</span><span class="s3">\n        </span><span class="s1">token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);</span><span class="s3">\n        </span><span class="s1">if (this.done &amp;&amp; this._input) {</span><span class="s3">\n          </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (token) {</span><span class="s3">\n          </span><span class="s1">return token;</span><span class="s3">\n        </span><span class="s1">} else if (this._backtrack) {</span><span class="s3">\n          </span><span class="s1">for (var k in backup) {</span><span class="s3">\n            </span><span class="s1">this[k] = backup[k];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">test_match</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return next match in input</span><span class="s3">\n      </span><span class="s1">next: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">if (this.done) {</span><span class="s3">\n          </span><span class="s1">return this.EOF;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this._input) {</span><span class="s3">\n          </span><span class="s1">this.done = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var token, match, tempMatch, index;</span><span class="s3">\n        </span><span class="s1">if (!this._more) {</span><span class="s3">\n          </span><span class="s1">this.yytext = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">this.match = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var rules = this._currentRules();</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; rules.length; i++) {</span><span class="s3">\n          </span><span class="s1">tempMatch = this._input.match(this.rules[rules[i]]);</span><span class="s3">\n          </span><span class="s1">if (tempMatch &amp;&amp; (!match || tempMatch[0].length &gt; match[0].length)) {</span><span class="s3">\n            </span><span class="s1">match = tempMatch;</span><span class="s3">\n            </span><span class="s1">index = i;</span><span class="s3">\n            </span><span class="s1">if (this.options.backtrack_lexer) {</span><span class="s3">\n              </span><span class="s1">token = this.test_match(tempMatch, rules[i]);</span><span class="s3">\n              </span><span class="s1">if (token !== false) {</span><span class="s3">\n                </span><span class="s1">return token;</span><span class="s3">\n              </span><span class="s1">} else if (this._backtrack) {</span><span class="s3">\n                </span><span class="s1">match = false;</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else if (!this.options.flex) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (match) {</span><span class="s3">\n          </span><span class="s1">token = this.test_match(match, rules[index]);</span><span class="s3">\n          </span><span class="s1">if (token !== false) {</span><span class="s3">\n            </span><span class="s1">return token;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._input === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return this.EOF;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.parseError(</span><span class="s3">\&quot;</span><span class="s1">Lexical error on line </span><span class="s3">\&quot; </span><span class="s1">+ (this.yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">. Unrecognized text.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ this.showPosition(), {</span><span class="s3">\n            </span><span class="s1">text: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">token: null,</span><span class="s3">\n            </span><span class="s1">line: this.yylineno</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return next match that has a token</span><span class="s3">\n      </span><span class="s1">lex: /* @__PURE__ */ __name(function lex() {</span><span class="s3">\n        </span><span class="s1">var r = this.next();</span><span class="s3">\n        </span><span class="s1">if (r) {</span><span class="s3">\n          </span><span class="s1">return r;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.lex();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">lex</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)</span><span class="s3">\n      </span><span class="s1">begin: /* @__PURE__ */ __name(function begin(condition) {</span><span class="s3">\n        </span><span class="s1">this.conditionStack.push(condition);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">begin</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// pop the previously active lexer condition state off the condition stack</span><span class="s3">\n      </span><span class="s1">popState: /* @__PURE__ */ __name(function popState() {</span><span class="s3">\n        </span><span class="s1">var n = this.conditionStack.length - 1;</span><span class="s3">\n        </span><span class="s1">if (n &gt; 0) {</span><span class="s3">\n          </span><span class="s1">return this.conditionStack.pop();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.conditionStack[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">popState</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// produce the lexer rule set which is active for the currently active lexer condition state</span><span class="s3">\n      </span><span class="s1">_currentRules: /* @__PURE__ */ __name(function _currentRules() {</span><span class="s3">\n        </span><span class="s1">if (this.conditionStack.length &amp;&amp; this.conditionStack[this.conditionStack.length - 1]) {</span><span class="s3">\n          </span><span class="s1">return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.conditions[</span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">].rules;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">_currentRules</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available</span><span class="s3">\n      </span><span class="s1">topState: /* @__PURE__ */ __name(function topState(n) {</span><span class="s3">\n        </span><span class="s1">n = this.conditionStack.length - 1 - Math.abs(n || 0);</span><span class="s3">\n        </span><span class="s1">if (n &gt;= 0) {</span><span class="s3">\n          </span><span class="s1">return this.conditionStack[n];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">topState</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// alias for begin(condition)</span><span class="s3">\n      </span><span class="s1">pushState: /* @__PURE__ */ __name(function pushState(condition) {</span><span class="s3">\n        </span><span class="s1">this.begin(condition);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">pushState</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return the number of states currently on the stack</span><span class="s3">\n      </span><span class="s1">stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {</span><span class="s3">\n        </span><span class="s1">return this.conditionStack.length;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">stateStackSize</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">options: { </span><span class="s3">\&quot;</span><span class="s1">case-insensitive</span><span class="s3">\&quot;</span><span class="s1">: true },</span><span class="s3">\n      </span><span class="s1">performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {</span><span class="s3">\n        </span><span class="s1">var YYSTATE = YY_START;</span><span class="s3">\n        </span><span class="s1">switch ($avoiding_name_collisions) {</span><span class="s3">\n          </span><span class="s1">case 0:</span><span class="s3">\n            </span><span class="s1">this.pushState(</span><span class="s3">\&quot;</span><span class="s1">csv</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 4;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">return 10;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">return 5;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">return 12;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 4:</span><span class="s3">\n            </span><span class="s1">this.pushState(</span><span class="s3">\&quot;</span><span class="s1">escaped_text</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 18;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 5:</span><span class="s3">\n            </span><span class="s1">return 20;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 6:</span><span class="s3">\n            </span><span class="s1">this.popState(</span><span class="s3">\&quot;</span><span class="s1">escaped_text</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 18;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 7:</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">anonymous</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">rules: [/^(?:sankey-beta</span><span class="s3">\\</span><span class="s1">b)/i, /^(?:$)/i, /^(?:((</span><span class="s3">\\</span><span class="s1">u000D</span><span class="s3">\\</span><span class="s1">u000A)|(</span><span class="s3">\\</span><span class="s1">u000A)))/i, /^(?:(</span><span class="s3">\\</span><span class="s1">u002C))/i, /^(?:(</span><span class="s3">\\</span><span class="s1">u0022))/i, /^(?:([</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u0021</span><span class="s3">\\</span><span class="s1">u0023-</span><span class="s3">\\</span><span class="s1">u002B</span><span class="s3">\\</span><span class="s1">u002D-</span><span class="s3">\\</span><span class="s1">u007E])*)/i, /^(?:(</span><span class="s3">\\</span><span class="s1">u0022)(?!(</span><span class="s3">\\</span><span class="s1">u0022)))/i, /^(?:(([</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u0021</span><span class="s3">\\</span><span class="s1">u0023-</span><span class="s3">\\</span><span class="s1">u002B</span><span class="s3">\\</span><span class="s1">u002D-</span><span class="s3">\\</span><span class="s1">u007E])|(</span><span class="s3">\\</span><span class="s1">u002C)|(</span><span class="s3">\\</span><span class="s1">u000D)|(</span><span class="s3">\\</span><span class="s1">u000A)|(</span><span class="s3">\\</span><span class="s1">u0022)(</span><span class="s3">\\</span><span class="s1">u0022))*)/i],</span><span class="s3">\n      </span><span class="s1">conditions: { </span><span class="s3">\&quot;</span><span class="s1">csv</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [1, 2, 3, 4, 5, 6, 7], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">escaped_text</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [6, 7], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [0, 1, 2, 3, 4, 5, 6, 7], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: true } }</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return lexer2;</span><span class="s3">\n  </span><span class="s1">}();</span><span class="s3">\n  </span><span class="s1">parser2.lexer = lexer;</span><span class="s3">\n  </span><span class="s1">function Parser() {</span><span class="s3">\n    </span><span class="s1">this.yy = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">__name(Parser, </span><span class="s3">\&quot;</span><span class="s1">Parser</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">Parser.prototype = parser2;</span><span class="s3">\n  </span><span class="s1">parser2.Parser = Parser;</span><span class="s3">\n  </span><span class="s1">return new Parser();</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">parser.parser = parser;</span><span class="s3">\n</span><span class="s1">var sankey_default = parser;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/sankeyDB.ts</span><span class="s3">\n</span><span class="s1">var links = [];</span><span class="s3">\n</span><span class="s1">var nodes = [];</span><span class="s3">\n</span><span class="s1">var nodesMap = /* @__PURE__ */ new Map();</span><span class="s3">\n</span><span class="s1">var clear2 = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">links = [];</span><span class="s3">\n  </span><span class="s1">nodes = [];</span><span class="s3">\n  </span><span class="s1">nodesMap = /* @__PURE__ */ new Map();</span><span class="s3">\n  </span><span class="s1">clear();</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">clear</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var SankeyLink = class {</span><span class="s3">\n  </span><span class="s1">constructor(source, target, value = 0) {</span><span class="s3">\n    </span><span class="s1">this.source = source;</span><span class="s3">\n    </span><span class="s1">this.target = target;</span><span class="s3">\n    </span><span class="s1">this.value = value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">SankeyLink</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var addLink = /* @__PURE__ */ __name((source, target, value) =&gt; {</span><span class="s3">\n  </span><span class="s1">links.push(new SankeyLink(source, target, value));</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">addLink</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var SankeyNode = class {</span><span class="s3">\n  </span><span class="s1">constructor(ID) {</span><span class="s3">\n    </span><span class="s1">this.ID = ID;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">SankeyNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var findOrCreateNode = /* @__PURE__ */ __name((ID) =&gt; {</span><span class="s3">\n  </span><span class="s1">ID = common_default.sanitizeText(ID, getConfig());</span><span class="s3">\n  </span><span class="s1">let node = nodesMap.get(ID);</span><span class="s3">\n  </span><span class="s1">if (node === void 0) {</span><span class="s3">\n    </span><span class="s1">node = new SankeyNode(ID);</span><span class="s3">\n    </span><span class="s1">nodesMap.set(ID, node);</span><span class="s3">\n    </span><span class="s1">nodes.push(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">findOrCreateNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getNodes = /* @__PURE__ */ __name(() =&gt; nodes, </span><span class="s3">\&quot;</span><span class="s1">getNodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getLinks = /* @__PURE__ */ __name(() =&gt; links, </span><span class="s3">\&quot;</span><span class="s1">getLinks</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getGraph = /* @__PURE__ */ __name(() =&gt; ({</span><span class="s3">\n  </span><span class="s1">nodes: nodes.map((node) =&gt; ({ id: node.ID })),</span><span class="s3">\n  </span><span class="s1">links: links.map((link) =&gt; ({</span><span class="s3">\n    </span><span class="s1">source: link.source.ID,</span><span class="s3">\n    </span><span class="s1">target: link.target.ID,</span><span class="s3">\n    </span><span class="s1">value: link.value</span><span class="s3">\n  </span><span class="s1">}))</span><span class="s3">\n</span><span class="s1">}), </span><span class="s3">\&quot;</span><span class="s1">getGraph</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var sankeyDB_default = {</span><span class="s3">\n  </span><span class="s1">nodesMap,</span><span class="s3">\n  </span><span class="s1">getConfig: /* @__PURE__ */ __name(() =&gt; getConfig().sankey, </span><span class="s3">\&quot;</span><span class="s1">getConfig</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">getNodes,</span><span class="s3">\n  </span><span class="s1">getLinks,</span><span class="s3">\n  </span><span class="s1">getGraph,</span><span class="s3">\n  </span><span class="s1">addLink,</span><span class="s3">\n  </span><span class="s1">findOrCreateNode,</span><span class="s3">\n  </span><span class="s1">getAccTitle,</span><span class="s3">\n  </span><span class="s1">setAccTitle,</span><span class="s3">\n  </span><span class="s1">getAccDescription,</span><span class="s3">\n  </span><span class="s1">setAccDescription,</span><span class="s3">\n  </span><span class="s1">getDiagramTitle,</span><span class="s3">\n  </span><span class="s1">setDiagramTitle,</span><span class="s3">\n  </span><span class="s1">clear: clear2</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/sankeyRenderer.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">select as d3select,</span><span class="s3">\n  </span><span class="s1">scaleOrdinal as d3scaleOrdinal,</span><span class="s3">\n  </span><span class="s1">schemeTableau10 as d3schemeTableau10</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">d3</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">sankey as d3Sankey,</span><span class="s3">\n  </span><span class="s1">sankeyLinkHorizontal as d3SankeyLinkHorizontal,</span><span class="s3">\n  </span><span class="s1">sankeyLeft as d3SankeyLeft,</span><span class="s3">\n  </span><span class="s1">sankeyRight as d3SankeyRight,</span><span class="s3">\n  </span><span class="s1">sankeyCenter as d3SankeyCenter,</span><span class="s3">\n  </span><span class="s1">sankeyJustify as d3SankeyJustify</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">d3-sankey</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/rendering-util/uid.ts</span><span class="s3">\n</span><span class="s1">var Uid = class _Uid {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">Uid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">this.count = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">static next(name) {</span><span class="s3">\n    </span><span class="s1">return new _Uid(name + ++_Uid.count);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor(id) {</span><span class="s3">\n    </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">this.href = `#${id}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">url(</span><span class="s3">\&quot; </span><span class="s1">+ this.href + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/sankeyRenderer.ts</span><span class="s3">\n</span><span class="s1">var alignmentsMap = {</span><span class="s3">\n  </span><span class="s1">left: d3SankeyLeft,</span><span class="s3">\n  </span><span class="s1">right: d3SankeyRight,</span><span class="s3">\n  </span><span class="s1">center: d3SankeyCenter,</span><span class="s3">\n  </span><span class="s1">justify: d3SankeyJustify</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var draw = /* @__PURE__ */ __name(function(text, id, _version, diagObj) {</span><span class="s3">\n  </span><span class="s1">const { securityLevel, sankey: conf } = getConfig();</span><span class="s3">\n  </span><span class="s1">const defaultSankeyConfig = defaultConfig.sankey;</span><span class="s3">\n  </span><span class="s1">let sandboxElement;</span><span class="s3">\n  </span><span class="s1">if (securityLevel === </span><span class="s3">\&quot;</span><span class="s1">sandbox</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">sandboxElement = d3select(</span><span class="s3">\&quot;</span><span class="s1">#i</span><span class="s3">\&quot; </span><span class="s1">+ id);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const root = securityLevel === </span><span class="s3">\&quot;</span><span class="s1">sandbox</span><span class="s3">\&quot; </span><span class="s1">? d3select(sandboxElement.nodes()[0].contentDocument.body) : d3select(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const svg = securityLevel === </span><span class="s3">\&quot;</span><span class="s1">sandbox</span><span class="s3">\&quot; </span><span class="s1">? root.select(`[id=</span><span class="s3">\&quot;</span><span class="s1">${id}</span><span class="s3">\&quot;</span><span class="s1">]`) : d3select(`[id=</span><span class="s3">\&quot;</span><span class="s1">${id}</span><span class="s3">\&quot;</span><span class="s1">]`);</span><span class="s3">\n  </span><span class="s1">const width = conf?.width ?? defaultSankeyConfig.width;</span><span class="s3">\n  </span><span class="s1">const height = conf?.height ?? defaultSankeyConfig.width;</span><span class="s3">\n  </span><span class="s1">const useMaxWidth = conf?.useMaxWidth ?? defaultSankeyConfig.useMaxWidth;</span><span class="s3">\n  </span><span class="s1">const nodeAlignment = conf?.nodeAlignment ?? defaultSankeyConfig.nodeAlignment;</span><span class="s3">\n  </span><span class="s1">const prefix = conf?.prefix ?? defaultSankeyConfig.prefix;</span><span class="s3">\n  </span><span class="s1">const suffix = conf?.suffix ?? defaultSankeyConfig.suffix;</span><span class="s3">\n  </span><span class="s1">const showValues = conf?.showValues ?? defaultSankeyConfig.showValues;</span><span class="s3">\n  </span><span class="s1">const graph = diagObj.db.getGraph();</span><span class="s3">\n  </span><span class="s1">const nodeAlign = alignmentsMap[nodeAlignment];</span><span class="s3">\n  </span><span class="s1">const nodeWidth = 10;</span><span class="s3">\n  </span><span class="s1">const sankey = d3Sankey().nodeId((d) =&gt; d.id).nodeWidth(nodeWidth).nodePadding(10 + (showValues ? 15 : 0)).nodeAlign(nodeAlign).extent([</span><span class="s3">\n    </span><span class="s1">[0, 0],</span><span class="s3">\n    </span><span class="s1">[width, height]</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">sankey(graph);</span><span class="s3">\n  </span><span class="s1">const colorScheme = d3scaleOrdinal(d3schemeTableau10);</span><span class="s3">\n  </span><span class="s1">svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">).selectAll(</span><span class="s3">\&quot;</span><span class="s1">.node</span><span class="s3">\&quot;</span><span class="s1">).data(graph.nodes).join(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; (d.uid = Uid.next(</span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot;</span><span class="s1">)).id).attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, function(d) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ d.x0 + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ d.y0 + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}).attr(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.x0).attr(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.y0).append(</span><span class="s3">\&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; {</span><span class="s3">\n    </span><span class="s1">return d.y1 - d.y0;</span><span class="s3">\n  </span><span class="s1">}).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.x1 - d.x0).attr(</span><span class="s3">\&quot;</span><span class="s1">fill</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; colorScheme(d.id));</span><span class="s3">\n  </span><span class="s1">const getText = /* @__PURE__ */ __name(({ id: id2, value }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!showValues) {</span><span class="s3">\n      </span><span class="s1">return id2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return `${id2}</span><span class="s3">\n</span><span class="s1">${prefix}${Math.round(value * 100) / 100}${suffix}`;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getText</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-labels</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">font-size</span><span class="s3">\&quot;</span><span class="s1">, 14).selectAll(</span><span class="s3">\&quot;</span><span class="s1">text</span><span class="s3">\&quot;</span><span class="s1">).data(graph.nodes).join(</span><span class="s3">\&quot;</span><span class="s1">text</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.x0 &lt; width / 2 ? d.x1 + 6 : d.x0 - 6).attr(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; (d.y1 + d.y0) / 2).attr(</span><span class="s3">\&quot;</span><span class="s1">dy</span><span class="s3">\&quot;</span><span class="s1">, `${showValues ? </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">0.35</span><span class="s3">\&quot;</span><span class="s1">}em`).attr(</span><span class="s3">\&quot;</span><span class="s1">text-anchor</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.x0 &lt; width / 2 ? </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">).text(getText);</span><span class="s3">\n  </span><span class="s1">const link = svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">links</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">fill</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">stroke-opacity</span><span class="s3">\&quot;</span><span class="s1">, 0.5).selectAll(</span><span class="s3">\&quot;</span><span class="s1">.link</span><span class="s3">\&quot;</span><span class="s1">).data(graph.links).join(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">link</span><span class="s3">\&quot;</span><span class="s1">).style(</span><span class="s3">\&quot;</span><span class="s1">mix-blend-mode</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">multiply</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const linkColor = conf?.linkColor ?? </span><span class="s3">\&quot;</span><span class="s1">gradient</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (linkColor === </span><span class="s3">\&quot;</span><span class="s1">gradient</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const gradient = link.append(</span><span class="s3">\&quot;</span><span class="s1">linearGradient</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; (d.uid = Uid.next(</span><span class="s3">\&quot;</span><span class="s1">linearGradient-</span><span class="s3">\&quot;</span><span class="s1">)).id).attr(</span><span class="s3">\&quot;</span><span class="s1">gradientUnits</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">userSpaceOnUse</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">x1</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.source.x1).attr(</span><span class="s3">\&quot;</span><span class="s1">x2</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; d.target.x0);</span><span class="s3">\n    </span><span class="s1">gradient.append(</span><span class="s3">\&quot;</span><span class="s1">stop</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">offset</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">0%</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">stop-color</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; colorScheme(d.source.id));</span><span class="s3">\n    </span><span class="s1">gradient.append(</span><span class="s3">\&quot;</span><span class="s1">stop</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">offset</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">stop-color</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; colorScheme(d.target.id));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let coloring;</span><span class="s3">\n  </span><span class="s1">switch (linkColor) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">gradient</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">coloring = /* @__PURE__ */ __name((d) =&gt; d.uid, </span><span class="s3">\&quot;</span><span class="s1">coloring</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">coloring = /* @__PURE__ */ __name((d) =&gt; colorScheme(d.source.id), </span><span class="s3">\&quot;</span><span class="s1">coloring</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">coloring = /* @__PURE__ */ __name((d) =&gt; colorScheme(d.target.id), </span><span class="s3">\&quot;</span><span class="s1">coloring</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">coloring = linkColor;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">link.append(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">, d3SankeyLinkHorizontal()).attr(</span><span class="s3">\&quot;</span><span class="s1">stroke</span><span class="s3">\&quot;</span><span class="s1">, coloring).attr(</span><span class="s3">\&quot;</span><span class="s1">stroke-width</span><span class="s3">\&quot;</span><span class="s1">, (d) =&gt; Math.max(1, d.width));</span><span class="s3">\n  </span><span class="s1">setupGraphViewbox(void 0, svg, 0, useMaxWidth);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">draw</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var sankeyRenderer_default = {</span><span class="s3">\n  </span><span class="s1">draw</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/sankeyUtils.ts</span><span class="s3">\n</span><span class="s1">var prepareTextForParsing = /* @__PURE__ */ __name((text) =&gt; {</span><span class="s3">\n  </span><span class="s1">const textToParse = text.replaceAll(/^[^</span><span class="s3">\\</span><span class="s1">S</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]+|[^</span><span class="s3">\\</span><span class="s1">S</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]+$/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).replaceAll(/([</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r])+/g, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).trim();</span><span class="s3">\n  </span><span class="s1">return textToParse;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">prepareTextForParsing</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/styles.js</span><span class="s3">\n</span><span class="s1">var getStyles = /* @__PURE__ */ __name((options) =&gt; `.label {</span><span class="s3">\n      </span><span class="s1">font-family: ${options.fontFamily};</span><span class="s3">\n    </span><span class="s1">}`, </span><span class="s3">\&quot;</span><span class="s1">getStyles</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var styles_default = getStyles;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/sankey/sankeyDiagram.ts</span><span class="s3">\n</span><span class="s1">var originalParse = sankey_default.parse.bind(sankey_default);</span><span class="s3">\n</span><span class="s1">sankey_default.parse = (text) =&gt; originalParse(prepareTextForParsing(text));</span><span class="s3">\n</span><span class="s1">var diagram = {</span><span class="s3">\n  </span><span class="s1">styles: styles_default,</span><span class="s3">\n  </span><span class="s1">parser: sankey_default,</span><span class="s3">\n  </span><span class="s1">db: sankeyDB_default,</span><span class="s3">\n  </span><span class="s1">renderer: sankeyRenderer_default</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">diagram</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>