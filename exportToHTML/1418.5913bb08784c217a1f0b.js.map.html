<html>
<head>
<title>1418.5913bb08784c217a1f0b.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
1418.5913bb08784c217a1f0b.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;1418.5913bb08784c217a1f0b.js?v=5913bb08784c217a1f0b&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,EAAE;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD,yCAAyC;AACzC;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,0BAA0B,QAAQ,uCAAuC;AACzE;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,QAAQ;AAC5B;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/mathematica.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// used pattern building blocks</span><span class="s3">\n</span><span class="s1">var Identifier = '[a-zA-Z</span><span class="s3">\\\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\\\</span><span class="s1">$]*';</span><span class="s3">\n</span><span class="s1">var pBase      = </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\</span><span class="s1">d+)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var pFloat     = </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">d+|</span><span class="s3">\\\\</span><span class="s1">d+</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">d*|</span><span class="s3">\\\\</span><span class="s1">d+)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var pFloatBase = </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">w+|</span><span class="s3">\\\\</span><span class="s1">w+</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">w*|</span><span class="s3">\\\\</span><span class="s1">w+)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var pPrecision = </span><span class="s3">\&quot;</span><span class="s1">(?:`(?:`?</span><span class="s3">\&quot;</span><span class="s1">+pFloat+</span><span class="s3">\&quot;</span><span class="s1">)?)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// regular expressions</span><span class="s3">\n</span><span class="s1">var reBaseForm        = new RegExp('(?:'+pBase+'(?:</span><span class="s3">\\\\</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">^'+pFloatBase+pPrecision+'?(?:</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">^[+-]?</span><span class="s3">\\\\</span><span class="s1">d+)?))');</span><span class="s3">\n</span><span class="s1">var reFloatForm       = new RegExp('(?:' + pFloat + pPrecision + '?(?:</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">^[+-]?</span><span class="s3">\\\\</span><span class="s1">d+)?)');</span><span class="s3">\n</span><span class="s1">var reIdInContext     = new RegExp('(?:`?)(?:' + Identifier + ')(?:`(?:' + Identifier + '))*(?:`?)');</span><span class="s3">\n\n</span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n\n  </span><span class="s1">// get next character</span><span class="s3">\n  </span><span class="s1">ch = stream.next();</span><span class="s3">\n\n  </span><span class="s1">// string</span><span class="s3">\n  </span><span class="s1">if (ch === '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenString;</span><span class="s3">\n    </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// comment</span><span class="s3">\n  </span><span class="s1">if (ch === '(') {</span><span class="s3">\n    </span><span class="s1">if (stream.eat('*')) {</span><span class="s3">\n      </span><span class="s1">state.commentLevel++;</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenComment;</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// go back one character</span><span class="s3">\n  </span><span class="s1">stream.backUp(1);</span><span class="s3">\n\n  </span><span class="s1">// look for numbers</span><span class="s3">\n  </span><span class="s1">// Numbers in a baseform</span><span class="s3">\n  </span><span class="s1">if (stream.match(reBaseForm, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'number';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Mathematica numbers. Floats (1.2, .2, 1.) can have optionally a precision (`float) or an accuracy definition</span><span class="s3">\n  </span><span class="s1">// (``float). Note: while 1.2` is possible 1.2`` is not. At the end an exponent (float*^+12) can follow.</span><span class="s3">\n  </span><span class="s1">if (stream.match(reFloatForm, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'number';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* In[23] and Out[34] */</span><span class="s3">\n  </span><span class="s1">if (stream.match(/(?:In|Out)</span><span class="s3">\\</span><span class="s1">[[0-9]*</span><span class="s3">\\</span><span class="s1">]/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'atom';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// usage</span><span class="s3">\n  </span><span class="s1">if (stream.match(/([a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*(?:`[a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]+)*::usage)/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'meta';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// message</span><span class="s3">\n  </span><span class="s1">if (stream.match(/([a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*(?:`[a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]+)*::[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*):?/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'string.special';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// this makes a look-ahead match for something like variable:{_Integer}</span><span class="s3">\n  </span><span class="s1">// the match is then forwarded to the mma-patterns tokenizer.</span><span class="s3">\n  </span><span class="s1">if (stream.match(/([a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*</span><span class="s3">\\</span><span class="s1">s*:)(?:(?:[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*)|(?:[^:=&gt;~@</span><span class="s3">\\</span><span class="s1">^</span><span class="s3">\\</span><span class="s1">&amp;</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]'</span><span class="s3">\\</span><span class="s1">?,</span><span class="s3">\\</span><span class="s1">|])).*/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'variableName.special';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// catch variables which are used together with Blank (_), BlankSequence (__) or BlankNullSequence (___)</span><span class="s3">\n  </span><span class="s1">// Cannot start with a number, but can have numbers at any other position. Examples</span><span class="s3">\n  </span><span class="s1">// blub__Integer, a1_, b34_Integer32</span><span class="s3">\n  </span><span class="s1">if (stream.match(/[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*_+[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'variableName.special';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (stream.match(/[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*_+/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'variableName.special';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (stream.match(/_+[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'variableName.special';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Named characters in Mathematica, like </span><span class="s3">\\</span><span class="s1">[Gamma].</span><span class="s3">\n  </span><span class="s1">if (stream.match(/</span><span class="s3">\\\\\\</span><span class="s1">[[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*</span><span class="s3">\\</span><span class="s1">]/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'character';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Match all braces separately</span><span class="s3">\n  </span><span class="s1">if (stream.match(/(?:</span><span class="s3">\\</span><span class="s1">[|</span><span class="s3">\\</span><span class="s1">]|{|}|</span><span class="s3">\\</span><span class="s1">(|</span><span class="s3">\\</span><span class="s1">))/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'bracket';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Catch Slots (#, ##, #3, ##9 and the V10 named slots #name). I have never seen someone using more than one digit after #, so we match</span><span class="s3">\n  </span><span class="s1">// only one.</span><span class="s3">\n  </span><span class="s1">if (stream.match(/(?:#[a-zA-Z</span><span class="s3">\\</span><span class="s1">$][a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">$]*|#+[0-9]?)/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'variableName.constant';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Literals like variables, keywords, functions</span><span class="s3">\n  </span><span class="s1">if (stream.match(reIdInContext, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'keyword';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// operators. Note that operators like @@ or /; are matched separately for each symbol.</span><span class="s3">\n  </span><span class="s1">if (stream.match(/(?:</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">-|</span><span class="s3">\\</span><span class="s1">*|</span><span class="s3">\\</span><span class="s1">/|,|;|</span><span class="s3">\\</span><span class="s1">.|:|@|~|=|&gt;|&lt;|&amp;|</span><span class="s3">\\</span><span class="s1">||_|`|'|</span><span class="s3">\\</span><span class="s1">^|</span><span class="s3">\\</span><span class="s1">?|!|%)/, true, false)) {</span><span class="s3">\n    </span><span class="s1">return 'operator';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// everything else is an error</span><span class="s3">\n  </span><span class="s1">stream.next(); // advance the stream.</span><span class="s3">\n  </span><span class="s1">return 'error';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenString(stream, state) {</span><span class="s3">\n  </span><span class="s1">var next, end = false, escaped = false;</span><span class="s3">\n  </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n    </span><span class="s1">if (next === '</span><span class="s3">\&quot;</span><span class="s1">' &amp;&amp; !escaped) {</span><span class="s3">\n      </span><span class="s1">end = true;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">escaped = !escaped &amp;&amp; next === '</span><span class="s3">\\\\</span><span class="s1">';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (end &amp;&amp; !escaped) {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 'string';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">var prev, next;</span><span class="s3">\n  </span><span class="s1">while(state.commentLevel &gt; 0 &amp;&amp; (next = stream.next()) != null) {</span><span class="s3">\n    </span><span class="s1">if (prev === '(' &amp;&amp; next === '*') state.commentLevel++;</span><span class="s3">\n    </span><span class="s1">if (prev === '*' &amp;&amp; next === ')') state.commentLevel--;</span><span class="s3">\n    </span><span class="s1">prev = next;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (state.commentLevel &lt;= 0) {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 'comment';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const mathematica = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">mathematica</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">startState: function() {return {tokenize: tokenBase, commentLevel: 0};},</span><span class="s3">\n  </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n    </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">commentTokens: {block: {open: </span><span class="s3">\&quot;</span><span class="s1">(*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*)</span><span class="s3">\&quot;</span><span class="s1">}}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>