<html>
<head>
<title>1871.c375ee093b7e51966390.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
1871.c375ee093b7e51966390.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;1871.c375ee093b7e51966390.js?v=c375ee093b7e51966390&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;AAEqD;;AAErD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEiE;;;ACvEpB;AACd;AACkI;AAC3H;AACZ;AACU;AACV;AACG;AAChC;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC,oBAAoB,cAAc;AAClC;AACA,gBAAgB,8BAAY,YAAY,sCAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA,4BAA4B,aAAG;AAC/B;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,kBAAkB;AAClC,eAAe,aAAG,UAAU,uBAAS,YAAY,aAAG,UAAU,uBAAS,kCAAkC,gCAAkB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C,cAAc,UAAU,EAAE,8BAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAG;AACvB;AACA;AACA,oBAAoB,aAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,gBAAgB,+BAA+B;AAC/C,cAAc,uBAAS;AACvB,8BAA8B,8BAAY;AAC1C,6CAA6C,6BAAW;AACxD,oBAAoB,mBAAI,6BAA6B,4DAA4D,gCAAkB,oCAAoC;AACvK;AACA;AACA;AACA;AACA;AACA,YAAY,gCAAc;AAC1B;AACA;AACA,YAAY,8BAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB,6KAA6K;AAClN,gBAAgB,gBAAgB;AAChC;AACA,gBAAgB,2BAA2B;AAC3C,0BAA0B,8BAAY;AACtC,6BAA6B,kBAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,GAAG,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAAW;AACpC,eAAe,mBAAI,aAAa,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAgB,iMAAiM;AACjN,gBAAgB,qDAAqD;AACrE,gBAAgB,qCAAqC,EAAE,8BAAY;AACnE,uBAAuB,2BAAS;AAChC;AACA;AACA,gBAAgB,mBAAI,WAAW,iaAAia;AAChc;AACA;AACA;AACA;AACA;AACA,gBAAgB,sLAAsL;AACtM,gBAAgB,qDAAqD;AACrE;AACA,4BAA4B,6BAAW;AACvC,gBAAgB,gDAAgD,EAAE,8BAAY;AAC9E,uBAAuB,2BAAS;AAChC;AACA;AACA,gBAAgB,mBAAI,WAAW,0HAA0H,yBAAyB,4QAA4Q;AAC9b;AACA;AACA;AACA;AACA;AACA,gBAAgB,yKAAyK;AACzL,gBAAgB,qDAAqD;AACrE,gBAAgB,+CAA+C,EAAE,8BAAY;AAC7E,uBAAuB,2BAAS;AAChC;AACA;AACA,gBAAgB,mBAAI,WAAW,iXAAiX;AAChZ;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB,4LAA4L;AACjO,gBAAgB,gBAAgB;AAChC,cAAc,uBAAuB;AACrC;AACA,0BAA0B,8BAAY;AACtC,gBAAgB,2BAA2B;AAC3C,6BAA6B,kBAAQ;AACrC;AACA,iCAAiC,kBAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,kDAAkD,kBAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,GAAG,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAAW;AACpC,eAAe,mBAAI,aAAa,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4LAA4L;AAC5M,gBAAgB,wFAAwF;AACxG,gBAAgB,UAAU,+BAA+B,qBAAqB;AAC9E;AACA,gBAAgB,uDAAuD,EAAE,8BAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAI,oBAAoB,2cAA2c;AAC1f;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAe,UAAU,EAAC;AAC1B;;ACrlBgD;AACwC;AACjD;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kJAAkJ;AAC9J,YAAY,QAAQ;AACpB,YAAY,yDAAyD;AACrE,YAAY;AACZ;AACA,6CAA6C,EAAE,8BAAY;AAC3D,mBAAmB,2BAAS;AAC5B,gCAAgC,gCAAkB;AAClD,+BAA+B,gCAAkB;AACjD;AACA;AACA;AACA,sBAAsB,6BAAW;AACjC;AACA;AACA,oBAAoB,kBAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B,6BAAW;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,mBAAI,WAAW,WAAW,yBAAyB,+VAA+V;AAC9Z;AACA,0DAAe,YAAY,EAAC;AAC5B;;;;;AC/D+D;AAC7B;AACL;AACQ;AACN;AACmH;AAClJ;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD,oBAAoB,+BAA+B;AACnD,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA,gBAAgB,+BAA+B,aAAa,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C,gBAAgB,iBAAiB;AACjC;AACA,aAAa,4BAAU;AACvB,oBAAoB,YAAY,aAAa,IAAI;AACjD;AACA;AACA,yBAAyB;AACzB;AACA,aAAa,4BAAU;AACvB,oBAAoB,mBAAmB;AACvC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB,aAAa,IAAI;AACrD,8BAA8B,iDAA+B;AAC7D;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,kBAAkB,aAAa,EAAE,mDAAmD;AACpF;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC,8DAA8D;AACtH,gBAAgB,iEAAiE;AACjF,gBAAgB,4BAA4B;AAC5C,gBAAgB,mCAAmC;AACnD,gBAAgB,8FAA8F,EAAE,8BAAY;AAC5H,uBAAuB,2BAAS,GAAG,gBAAgB;AACnD,0BAA0B,aAAG,cAAc,wBAAU;AACrD,iCAAiC,cAAI,eAAe,wBAAU;AAC9D;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,sCAAsC,8BAAY,GAAG,UAAU;AAC/D;AACA;AACA,cAAc,gCAAkB;AAChC,cAAc,gCAAkB;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,oBAAK,UAAU,wDAAwD,mBAAI,UAAU,mCAAmC,mBAAI,WAAW,gCAAgC,KAAK,EAAE,mDAAmD,aAAa,4BAA4B,yFAAyF,iBAAO,yJAAyJ,2BAA2B,gNAAgN,GAAG,sBAAsB,mBAAI,iBAAiB,qCAAqC,IAAI;AACr1B;AACA;AACA,uDAAe,UAAU,EAAC;AAC1B;;AC9HgD;AACF;AACP;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAoD;AAChE,sCAAsC,sBAAQ;AAC9C,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAW;AACpC;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,cAAc,0BAAQ;AACtB,cAAc,0BAAQ;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAI,gBAAgB,mDAAmD;AAClF;AACA,yDAAe,WAAW,EAAC;AAC3B;;ACrEwB,aAAa,wDAAwD,YAAY,mBAAmB,KAAK,mBAAmB,sEAAsE,SAAS,yBAAyB,kCAAkC,0jBAA0jB,MAAM,aAAa,uFAAuF,SAAS,GAAG,+hBAA+hB,gCAAgC,KAAK,iDAAiD,qGAAqG,SAAS,GAAG,IAAI,IAAI,MAAM,2BAA2B,GAAG,uFAAuF,GAAG,sBAAsB,IAAI,uBAAuB,IAAI,KAAK,GAAG,GAAG,GAAG,uDAAuD,EAAE,8GAA8G,GAAG,oHAAoH,IAAI,iDAAiD,IAAI,8DAA8D,IAAI,8KAA8K,IAAI,eAAe,IAAI,EAAE,mJAAmJ,IAAI,iCAAiC,mRAAmR,GAAG,IAAI,GAAG,qLAAqL,EAAE,uCAAuC,EAAE,kCAAkC,EAAE,2BAA2B,EAAE,uMAAuM,eAAe,kCAAkC,wBAAwB,eAAe,qCAAqC,wBAAwB,eAAe,mGAAmG,wBAAwB,eAAe,oBAAoB,iDAAiD,GAAG,8CAA8C,wBAAwB,iBAAiB,4CAA4C,OAAO,uBAAuB,+BAA+B,+DAA+D,uBAAuB,uDAAuD,SAAS,OAAO,0BAA0B,6CAA6C,QAAQ,wFAAwF,IAAI,0BAA0B,MAAM,+DAA+D,eAAe,6BAA6B,qBAAqB,wCAAwC,sDAAsD,2BAA2B,eAAe,MAAM,SAAS,IAAI,uRAAuR,GAAG,UAAU,eAAe,eAAe,KAAK,iBAAiB,KAAK,oBAAoB,eAAe,6SAA6S,eAAe,kEAAkE,qBAAqB,kBAAkB,aAAa,gBAAgB,aAAa,aAAa,sBAAsB,4BAA4B,6EAA6E,+DAA+D,oBAAoB,mBAAmB,YAAY,6EAA6E,4CAA4C,oBAAoB,EAAE,wCAAwC,6BAA6B,sCAAsC,EAAE,6BAA6B,iBAAiB,0BAA0B,EAAE,sBAAsB,eAAe,oBAAoB,eAAe,wBAAwB,+BAA+B,EAAE,eAAe,wBAAwB,yCAAyC,EAAE,eAAe,qBAAqB,0CAA0C,eAAe,sBAAsB,iBAAiB,EAAE,iBAAiB,kCAAkC,SAAS,4EAA4E,cAAc,wBAAwB,eAAe,IAAI,uHAAuH,SAAS,YAAY,SAAS,eAAe,0BAA0B,mBAAmB,oCAAoC,wBAAwB,eAAe,+BAA+B,mBAAmB,oCAAoC,wBAAwB,eAAe,+BAA+B,mBAAmB,qBAAqB,YAAY,eAAe,oBAAoB,oBAAoB,sBAAsB,EAAE,cAAc,SAAS,cAAc,YAAY,kBAAkB,mCAAmC,mBAAmB,QAAQ,qBAAqB,KAAK,iCAAiC,WAAW,YAAY,qBAAqB,EAAE,qBAAqB,0BAA0B,EAAE,UAAU,EAAE,qCAAqC,gBAAgB,0EAA0E,EAAE,iBAAiB,oBAAoB,MAAM,6DAA6D,QAAQ,cAAc,kBAAkB,SAAS,oDAAoD,qBAAqB,qBAAqB,OAAO,SAAS,GAAG,KAAK,sDAAsD,SAAS,6BAA6B,oCAAoC,MAAM,kCAAkC,KAAK,2DAA2D,YAAY,MAAM,OAAO,0BAA0B,YAAY,IAAI,gBAAgB,mBAAmB,gCAAgC,uBAAuB,WAAW,oBAAoB,2EAA2E,uBAAuB,KAAK,oCAAoC,aAAa,yEAAyE,gCAAgC,sBAAsB,+BAA+B,4BAA4B,2BAA2B,kCAAkC,2FAA2F,GAAG,oGAAoG,oBAAoB,+DAA+D,iCAAiC,SAAS,GAAG,OAAO,2BAA2B,qGAAqG,6DAA6D,uBAAe,CAAC,eAAe,IAAI,gBAAgB,iCAAiC,wCAAwC,OAAO,yBAAyB,eAAe,SAAS,WAAW,uGAAuG,QAAQ,YAAY,yBAAyB,gDAAgD,sCAAsC,gBAAgB,qDAAqD,UAAU,EAAE,oBAAoB,qDAAqD,UAAU,EAAE,gBAAgB,+BAA+B,qCAAqC,EAAE,0BAA0B,2BAA2B,UAAU,cAAc,UAAU,yBAAyB,OAAO,KAAK,WAAW,iBAAiB,+BAA+B,uFAAuF,EAAE,iBAAiB,+BAA+B,2BAA2B,4BAA4B,UAAU,SAAS,eAAe,sCAAsC,8BAA8B,IAAI,YAAY,wBAAwB,+BAA+B,WAAW,mBAAmB,YAAY,yBAAyB,gDAAgD,UAAU,UAAU,UAAU,cAAc,+BAA+B,mCAAmC,6BAA6B,0DAA0D,EAAE,cAAc,4DAA4D,8DAA8D,wBAAwB,QAAQ,GAAG,kBAAkB,kBAAkB,oBAAoB,qCAAqC,0DAA0D,EAAE,gBAAgB,iCAAiC,0CAA0C,EAAE,iEAAiE,MAAM,sEAAsE,sCAAsC,wFAAwF,4BAA4B,UAAU,mDAAmD,sBAAsB,6BAA6B,oBAAoB,OAAO,2BAA2B,6BAA6B,UAAU,UAAU,GAAG,kBAAkB,iCAAiC,YAAY,YAAY,gCAAgC,oCAAoC,2BAA2B,wFAAwF,EAAE,WAAW,sCAAsC,iDAAiD,yBAAyB,8DAA8D,kBAAkB,kCAAkC,+BAA+B,WAAW,sBAAsB,0BAA0B,EAAE,0BAA0B,kFAAkF,WAAW,sBAAsB,uCAAuC,EAAE,yBAAyB,6BAA6B,kBAAkB,mCAAmC,WAAW,yCAAyC,yBAAyB,yEAAyE,6CAA6C,gBAAgB,qDAAqD,UAAU,kBAAkB,UAAU,uCAAuC,uBAAuB,GAAG,YAAY,eAAe,+BAA+B,0BAA0B,oCAAoC,sFAAsF,OAAO,cAAc,qCAAqC,kDAAkD,kCAAkC,4EAA4E,4BAA4B,UAAU,qBAAqB,YAAY,2CAA2C,UAAU,kBAAkB,UAAU,uDAAuD,eAAe,oBAAoB,SAAS,6CAA6C,eAAe,MAAM,qBAAqB,eAAe,oBAAoB,SAAS,GAAG,KAAK,WAAW,gCAAgC,gFAAgF,mBAAmB,iBAAiB,qCAAqC,mBAAmB,8BAA8B,UAAU,kBAAkB,qBAAqB,qCAAqC,mBAAmB,0BAA0B,UAAU,kBAAkB,kBAAkB,gCAAgC,sBAAsB,EAAE,iBAAiB,uDAAuD,UAAU,kBAAkB,0BAA0B,sDAAsD,UAAU,oBAAoB,kFAAkF,qBAAqB,qBAAqB,gBAAgB,uBAAuB,oCAAoC,EAAE,EAAE,QAAQ,KAAK,WAAW,EAAE,4CAA4C,IAAI,SAAS,qBAAqB,MAAM,oGAAoG,MAAM,KAAK,0BAA0B,4BAA4B,8BAA8B,0BAA0B,gBAAgB,qBAAqB,yDAAyD,QAAQ,yBAAyB,uBAAuB,yBAAyB,yCAAyC,kCAAkC,EAAE,qBAAqB,mBAAmB,SAAS,YAAY,WAAW,KAAK,QAAQ,uCAAuC,8CAA8C,iBAAiB,iBAAiB,EAAE,OAAO,cAAc,4CAA4C,aAAa,mBAAmB,gBAAgB,+CAA+C,gCAAgC,UAAU,IAAI,OAAO,mDAAe,IAAI,IAAI,wBAAwB,mBAAmB,oBAAoB,YAAY,kBAAkB,QAAQ,WAAW,sCAAsC,SAAS,MAAM,OAAO,sBAAc,YAAY,EAAoE;AACjmf;;;;;;;;;ACD+D;AAC7B;AACuI;AAClI;AACV;AACA;AACU;AACV;AACI;AACjC;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAS;AACnC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C,yCAAyC;AACzC,gBAAgB,eAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,oBAAoB,oCAAoC,EAAE,8BAAY;AACtE;AACA;AACA,mBAAmB,aAAG;AACtB,4BAA4B,aAAa,EAAE,4BAA4B,EAAE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,6BAA6B;AAC7B,iBAAiB;AACjB,mDAAmD;AACnD,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD,kCAAkC;AAClC;AACA,gBAAgB,kBAAQ;AACxB;AACA;AACA,oBAAoB,qBAAO;AAC3B,4BAA4B,cAAc;AAC1C,4DAA4D,eAAe,qBAAO,GAAG;AACrF;AACA;AACA,8BAA8B,wBAAU,gBAAgB,wBAAU;AAClE;AACA;AACA;AACA;AACA;AACA,YAAY,aAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY,iBAAiB,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC,8JAA8J;AAC9M,gBAAgB,qEAAqE;AACrF,gBAAgB,cAAc;AAC9B;AACA,0BAA0B,8BAAY;AACtC,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAe;AAC/C;AACA;AACA,oBAAoB,oBAAK,UAAU,WAAW,mBAAI,QAAQ,oCAAoC,cAAc,YAAY,mBAAI,CAAC,YAAQ,IAAI,0BAA0B,gCAAkB,qDAAqD,GAAG,GAAG,mBAAI,UAAU,kCAAkC,IAAI;AACpS;AACA,yBAAyB,6BAAW;AACpC;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAG,UAAU,4BAAc,QAAQ,sCAAwB;AAC/G;AACA,+BAA+B,8BAAY;AAC3C,sCAAsC,aAAG,qBAAqB;AAC9D;AACA,8BAA8B,mBAAI,gBAAgB,qDAAqD,aAAG,UAAU,4BAAc,WAAW,yCAAyC,aAAG,sGAAsG,aAAG,mXAAmX;AACrpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAI,aAAa,mDAAmD;AACnF;AACA;AACA,yDAAe,WAAW,EAAC;AAC3B;;ACrOsF;AACvC;AACwI;AAChJ;AACR;AACQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAAW;AACxD,oBAAoB,mBAAI,6BAA6B,4DAA4D,gCAAkB,+DAA+D;AAClM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sMAAsM;AAClN,YAAY,4CAA4C;AACxD,sBAAsB,8BAAY;AAClC,0BAA0B,6BAAW;AACrC,qCAAqC,6BAAW;AAChD,8BAA8B,6BAAW;AACzC,+BAA+B,6BAAW;AAC1C;AACA,8BAA8B,oBAAM;AACpC,qBAAqB,8BAAY;AACjC;AACA;AACA;AACA,uCAAuC,yBAAW;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA,0BAA0B,cAAI;AAC9B,QAAQ,4BAAc;AACtB,sBAAsB,4BAAc,IAAI,cAAI,eAAe,4BAAc;AACzE;AACA,mBAAmB,mBAAI,mBAAmB,+QAA+Q;AACzT,wBAAwB,oBAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAwB;AACxC;AACA;AACA,oEAAoE,mBAAI,CAAC,YAAQ,IAAI,uBAAuB;AAC5G;AACA;AACA,wDAAwD,+BAAa,SAAS;AAC9E;AACA;AACA;AACA;AACA,YAAY,KAAqC,EAAE,EAE1C;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAI,sBAAsB,kJAAkJ;AACvM;AACA;AACA;AACA;AACA,0HAA0H,mBAAI,uBAAuB,wHAAwH;AAC7Q;AACA,sBAAsB,mBAAI,6BAA6B,IAAI,+BAAa,4FAA4F;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAI,kBAAkB,yBAAyB,oBAAK,CAAC,oBAAS,IAAI,8FAA8F,mBAAI,gBAAgB,8VAA8V,kBAAQ,wBAAwB,sEAAsE,gFAAgF,mBAAI,gBAAgB,8VAA8V,kBAAQ,wBAAwB,sEAAsE,KAAK,GAAG;AACprC;AACA;AACA;AACA;AACA,0BAA0B,mBAAS;AACnC;AACA,gBAAgB,4BAAU;AAC1B;AACA;AACA,eAAe,mBAAI,sBAAsB,eAAe;AACxD;AACA;AACA,yDAAe,WAAW,EAAC;AAC3B;;AC3KgD;AAC+B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0KAA0K;AACtL,YAAY,gBAAgB;AAC5B,YAAY,qDAAqD;AACjE,uDAAuD,6BAAW;AAClE;AACA,kBAAkB,2BAAS;AAC3B;AACA;AACA,YAAY,uEAAuE,EAAE,8BAAY;AACjG;AACA;AACA,mBAAmB,2BAAS;AAC5B,YAAY,mBAAI,WAAW,WAAW,yBAAyB,yXAAyX;AACxb;AACA,yDAAe,WAAW,EAAC;AAC3B;;ACvBkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,IAAI,uBAAS;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uDAAe,SAAS,EAAC;AACzB;;AChBsC;AACI;AACQ;AACV;AACA;AACA;AACA;AACJ;AACpC;AACA;AACA,oBAAoB,gBAAgB;AACpC,oBAAoB,iBAAU;AAC9B;AACA,oBAAoB;AACpB,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB,gBAAgB;AACpC,mBAAmB;AACnB,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA,wDAAe,MAAM,EAAC;AACtB;;ACvBgD;AACwB;AACxE;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,oDAAoD;AAChE,oBAAoB,8BAAY;AAChC,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,qCAAqC,6BAAW;AAChD,YAAY,mBAAI,6BAA6B,IAAI,+BAAa,8FAA8F;AAC5J;AACA;;ACjB+D;AAC/D;AACA;AACA;AACA;AACe;AACf,YAAY,kLAAkL;AAC9L,YAAY,yDAAyD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAK,UAAU,iCAAiC,mBAAI,UAAU,sEAAsE,kBAAkB,mBAAI,UAAU,oDAAoD,oBAAK,UAAU;AACnP;AACA;AACA,qBAAqB,4CAA4C,mBAAI,iBAAiB,kJAAkJ,mCAAmC,mBAAI,mBAAmB,oJAAoJ,gBAAgB,mBAAI,eAAe,2HAA2H,kBAAkB,mBAAI,iBAAiB,2HAA2H,KAAK,GAAG,KAAK;AACnwB;AACA;;ACnB+D;AACN;AACzD;AACA;AACA;AACA;AACe;AACf,YAAY,mHAAmH;AAC/H,sBAAsB,8BAAY;AAClC,0CAA0C,6BAAW;AACrD,mCAAmC,6BAAW;AAC9C,oCAAoC,6BAAW;AAC/C;AACA,YAAY,mBAAmB,WAAW,IAAI;AAC9C,YAAY,oBAAK,eAAe,mDAAmD,mBAAI,4BAA4B,iIAAiI,GAAG,mBAAI,kCAAkC,sIAAsI,GAAG,mBAAI,UAAU;AACpb,iCAAiC,mBAAmB,MAAM,mBAAI,2BAA2B,cAAc,UAAU,cAAc,mBAAI,cAAc,0HAA0H,KAAK;AAChR;AACA;;ACjBgD;AACkB;AAClE;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,wDAAwD;AACpE,oBAAoB,8BAAY;AAChC,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,+BAA+B,6BAAW;AAC1C,YAAY,mBAAI,uBAAuB,IAAI,yBAAO,sGAAsG;AACxJ;AACA;;ACjBsF;AAClD;AACyC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACe;AACf,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA,WAAW,+BAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAW,IAAI,UAAU,SAAS;AACxD,oBAAoB,yBAAW,IAAI,UAAU,SAAS;AACtD,qBAAqB,yBAAW,IAAI,UAAU,SAAS;AACvD,YAAY,oBAAK,CAAC,oBAAS,IAAI,WAAW,mBAAI,YAAY,qKAAqK,4BAAU,mHAAmH,oCAAkB,yBAAyB,sCAAsC,mBAAI,eAAe,IAAI,4BAAU;AAC9c;AACA;AACA,2BAA2B,mBAAI,aAAa,gBAAgB;AAC5D,iBAAiB,GAAG,cAAc,GAAG,MAAM;AAC3C;AACA;;ACxCgD;AACK;AACrD;AACA;AACe,wBAAwB,UAAU;AACjD,YAAY,sDAAsD,EAAE,wCAAsB;AAC1F;AACA;AACA;AACA,YAAY,mBAAI,UAAU,UAAU,mBAAI,aAAa,iEAAiE,kCAAkC,yBAAyB,GAAG;AACpL;AACA;;ACXgD;AACC;AAClC;AACf,YAAY,2EAA2E;AACvF,YAAY,mBAAI,aAAa,sCAAsC,UAAU,EAAE,UAAU,4BAA4B,mBAAI,QAAQ,kCAAkC,KAAK,GAAG,GAAG;AAC9K;AACO;AACP,YAAY,YAAY,iBAAiB,IAAI;AAC7C,YAAY,mBAAI,eAAe,uBAAuB,gCAAkB,oEAAoE;AAC5I;AACO;AACP,YAAY,YAAY,iBAAiB,IAAI;AAC7C,YAAY,mBAAI,eAAe,uBAAuB,gCAAkB,mFAAmF;AAC3J;AACO;AACP,YAAY,YAAY,iBAAiB,IAAI;AAC7C,YAAY,mBAAI,eAAe,uBAAuB,gCAAkB,6EAA6E;AACrJ;AACO;AACP,YAAY,YAAY,iBAAiB,IAAI;AAC7C,YAAY,mBAAI,eAAe,uBAAuB,gCAAkB,8FAA8F;AACtK;AACA;;ACtBgD;AACC;AACX;AACtC;AACA;AACe,qBAAqB,yCAAyC;AAC7E,YAAY,kBAAkB;AAC9B,YAAY,mBAAI,UAAU,4BAA4B,mBAAI,QAAQ,kDAAkD,UAAU,aAAa,mBAAI,CAAC,UAAU,IAAI,uFAAuF,gCAAkB,uEAAuE,GAAG,GAAG;AACpV;AACA;;ACT0C;AACN;AACkD;AACtF;AACA;AACA,oBAAoB;AACpB,iBAAiB;AACjB,kBAAkB;AAClB,sBAAsB;AACtB,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA,sDAAe,eAAe,EAAC;AAC/B;;ACdgD;AAChD;AACA;AACA;AACA;AACe;AACf,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,mBAAI,QAAQ,+DAA+D;AAC3F;AACA;AACA,gBAAgB,mBAAI,UAAU,+DAA+D;AAC7F;AACA;AACA;;ACjB+D;AACb;AAClD;AACA;AACA;AACA;AACe,qBAAqB,mBAAmB;AACvD,YAAY,kBAAkB;AAC9B,YAAY,oBAAK,UAAU,mDAAmD,mBAAI,UAAU,sCAAsC,mBAAI,SAAS,oDAAoD,gCAAkB,eAAe,GAAG,GAAG,mBAAI,SAAS;AACvP,4BAA4B,mBAAI,SAAS,iEAAiE;AAC1G,iBAAiB,GAAG,IAAI;AACxB;AACA;;ACZ+D;AAC/D;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,sBAAsB;AAClC;AACA;AACA;AACA,YAAY,oBAAK,YAAY,uEAAuE,mBAAI,WAAW,wDAAwD,IAAI;AAC/K;AACA;;ACb+D;AACN;AAC7B;AAC5B;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,qGAAqG;AACjH,sBAAsB,8BAAY;AAClC,qCAAqC,6BAAW;AAChD;AACA,eAAe,mBAAI,UAAU,yCAAyC;AACtE;AACA,YAAY,oBAAK,6BAA6B,qCAAqC,mBAAI,CAAC,KAAK,IAAI,0CAA0C,8EAA8E;AACzN;AACA;;ACjB4C;AAC5C,8DAAe,aAAa,EAAC;AAC7B;;ACFgD;AACV;AACtC;AACA;AACA;AACA;AACe;AACf,YAAY,wBAAwB;AACpC;AACA;AACA;AACA,eAAe,yBAAO;AACtB,YAAY,mBAAI,UAAU,UAAU,mBAAI,SAAS;AACjD;AACA;AACA,wBAAwB,mBAAI,SAAS,2CAA2C;AAChF,aAAa,GAAG,GAAG;AACnB;AACA;;AClBgD;AACX;AACrC;AACA;AACA;AACA;AACe;AACf,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,eAAe,wBAAM;AACrB;AACA,gBAAgB,mBAAI,QAAQ,iDAAiD;AAC7E;AACA,YAAY,mBAAI,UAAU,iDAAiD;AAC3E;AACA;;ACjB+D;AAC6B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,4HAA4H;AACxI,oBAAoB,8BAAY;AAChC,+BAA+B,6BAAW;AAC1C,qCAAqC,6BAAW;AAChD;AACA,YAAY,mBAAmB,WAAW,IAAI;AAC9C,YAAY,oBAAK,eAAe,uCAAuC,mBAAI,uBAAuB,IAAI,yBAAO,sGAAsG,oBAAoB,mBAAI,6BAA6B,IAAI,+BAAa,8FAA8F,4CAA4C,2BAAS,iCAAiC,mBAAI,cAAc,0IAA0I,KAAK;AAC9mB;AACA;;ACjB+D;AAC/D,MAAM,gCAAqB;AAC3B;AACA;AACA;AACA;AACe;AACf,YAAY,sBAAsB;AAClC,YAAY,oBAAK,aAAa,sCAAsC,mBAAI,WAAW,iCAAiC,gCAAqB,EAAE,IAAI;AAC/I;AACA;;ACV+D;AACd;AACV;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD,YAAY,kBAAkB;AAC9B,wBAAwB,gCAAkB;AAC1C;AACA;AACA,wBAAwB,gCAAkB;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,gCAAkB;AAChD,kBAAkB,gCAAkB;AACpC,kBAAkB,gCAAkB;AACpC;AACA;AACA,YAAY,oBAAK,UAAU,2CAA2C,mBAAI,QAAQ,UAAU,mBAAI,CAAC,YAAQ,IAAI,2DAA2D,GAAG,aAAa,mBAAI,UAAU,2CAA2C,IAAI;AACrP;AACA,iEAAe,gBAAgB,EAAC;AAChC;;AC3B+D;AACa;AAClC;AAC1C;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,sIAAsI;AAClJ,YAAY,6BAA6B;AACzC;AACA,YAAY,eAAe;AAC3B,qCAAqC,gCAAkB;AACvD,uBAAuB,sCAAwB;AAC/C;AACA,gBAAgB,mBAAI,UAAU,yDAAyD;AACvF;AACA,YAAY,mBAAI,UAAU,+CAA+C,oBAAK,UAAU,6BAA6B,mBAAI,UAAU,iDAAiD,oBAAK,UAAU,oCAAoC,mBAAI,CAAC,KAAK,IAAI,4CAA4C,GAAG,OAAO,GAAG,mBAAI,YAAY,gDAAgD,GAAG,gFAAgF,IAAI,GAAG,GAAG,mBAAI,UAAU,sEAAsE,GAAG,mBAAI,UAAU,iCAAiC,mBAAI,iBAAiB,mDAAmD,aAAa,+GAA+G,GAAG,IAAI,GAAG;AAC/xB;AACA;;ACpB4E;AACd;AACR;AACU;AACZ;AACJ;AACE;AACd;AACQ;AACU;AACF;AACI;AAClB;AACY;AACgB;AAClE;AACA;AACA,qCAAqC;AACrC,8BAA8B;AAC9B,0BAA0B;AAC1B,+BAA+B;AAC/B,yBAAyB,eAAe;AACxC,yBAAyB;AACzB,kCAAkC,gBAAgB;AAClD,2BAA2B,SAAS;AACpC,qBAAqB;AACrB,0BAA0B;AAC1B,yBAAyB;AACzB,2BAA2B;AAC3B,4BAA4B,UAAU;AACtC,kCAAkC,0BAAgB;AAClD,gCAAgC;AAChC;AACA;AACA,2DAAe,SAAS,EAAC;AACzB;;ACnC+D;AACM;AACqC;AAC1G;AACA;AACA,wBAAwB,WAAW;AACnC,uBAAuB,iBAAiB,qBAAG,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,UAAU,6CAA6C;AACvD,UAAU,yCAAyC;AACnD;AACA;AACA,oBAAoB,2CAA2C,IAAI,+CAA+C,IAAI,+CAA+C;AACrK;AACA;AACA;AACA,uBAAuB,qGAAqG;AAC5H;AACA,YAAY,eAAe;AAC3B,YAAY,mBAAI,iBAAiB,UAAU,iBAAiB,4DAA4D,+CAA+C,gOAAgO,oCAAkB,UAAU;AACna;AACA;AACA;AACA;AACA,yBAAyB,qIAAqI;AAC9J,YAAY,kBAAkB;AAC9B,sCAAsC,sBAAQ;AAC9C,8BAA8B,wBAAU;AACxC,iBAAiB;AACjB,KAAK,EAAE,iCAAe;AACtB,IAAI,uBAAS;AACb,2BAA2B,8BAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAe;AACpC;AACA,KAAK;AACL,yBAAyB,yBAAW;AACpC,mBAAmB,mBAAmB;AACtC,KAAK;AACL,yBAAyB,yBAAW;AACpC;AACA;AACA;AACA;AACA,0BAA0B,iCAAe;AACzC,iBAAiB,8BAAY;AAC7B,KAAK;AACL,wBAAwB,yBAAW;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,oBAAK,SAAS,8GAA8G,mBAAI,SAAS,yCAAyC,mBAAI,gBAAgB,2LAA2L,GAAG,oFAAoF,mBAAI,SAAS,yCAAyC,mBAAI,QAAQ,+FAA+F,gCAAkB,YAAY,GAAG,oFAAoF,mBAAI,SAAS,yCAAyC,mBAAI,QAAQ,mGAAmG,gCAAkB,cAAc,GAAG,KAAK;AACv8B;AACA,4DAAe,aAAa,EAAC;AAC7B;;AC5EgD;AAChD;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD,YAAY,gBAAgB;AAC5B,WAAW,mBAAI,kBAAkB,sBAAsB;AACvD;AACA,gEAAe,iBAAiB,EAAC;AACjC;;ACX+D;AAC3B;AAC+E;AACnH;AACA;AACA;AACA;AACA;AACA,0BAA0B,qIAAqI;AAC/J;AACA,qCAAqC,6BAAW;AAChD;AACA;AACA;AACA,qBAAqB,yCAAuB;AAC5C,yBAAyB,yBAAW;AACpC,uBAAuB,yBAAW;AAClC,wBAAwB,yBAAW;AACnC;AACA,YAAY,oBAAK,UAAU,uBAAuB,uCAAuC,8CAA8C,mBAAI,6BAA6B,IAAI,+BAAa,wFAAwF,IAAI,oBAAK,YAAY,WAAW,mBAAI,YAAY,2PAA2P,oCAAkB,MAAM,GAAG,4BAAU,CAAC,mBAAI,WAAW,iBAAiB,gBAAgB,IAAI;AACtpB;AACA,6DAAe,cAAc,EAAC;AAC9B;;ACtB+D;AAC3B;AAC2H;AAC/J;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB,uDAAuD,kEAAkE;AAC9K;AACA,uBAAuB,yBAAW,IAAI,UAAU,SAAS,gBAAgB,0CAAwB;AACjG,wBAAwB,yBAAW,IAAI,UAAU,SAAS,iBAAiB,0CAAwB;AACnG,YAAY,mBAAI,UAAU;AAC1B;AACA,gCAAgC,uCAAqB;AACrD;AACA;AACA;AACA;AACA,iCAAiC,wCAAsB;AACvD;AACA;AACA,iCAAiC,0CAAwB;AACzD;AACA;AACA,kCAAkC,oBAAK,WAAW,WAAW,mBAAI,YAAY,sBAAsB,0BAAQ,0OAA0O,oCAAkB,MAAM,GAAG,mBAAI,WAAW,wBAAwB,IAAI;AAC3Z,iCAAiC,mBAAI,YAAY,8BAA8B,YAAY,uBAAuB,aAAa,mBAAI,UAAU,uBAAuB,YAAY,aAAa,mBAAI,YAAY,oBAAoB,GAAG;AACpO,aAAa,GAAG;AAChB;AACA,+DAAe,gBAAgB,EAAC;AAChC;;AC9BgD;AACN;AAC1C;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,wCAAwC;AACpD,8BAA8B,6BAAW;AACzC,WAAW,mBAAI,sBAAsB,yDAAyD;AAC9F;AACA;;ACZgD;AACZ;AACM;AAC1C;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,8BAA8B;AAC1C,8BAA8B,6BAAW;AACzC,yBAAyB,yBAAW;AACpC,WAAW,mBAAI,sBAAsB,gDAAgD;AACrF;AACA;;ACdgD;AACmB;AACnE;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,qCAAqC;AACjD,8BAA8B,6BAAW;AACzC,YAAY,mBAAI,sBAAsB,yCAAyC,4BAAU,uCAAuC,4BAAU,UAAU;AACpJ;AACA;;ACZgD;AACN;AAC1C;AACA;AACA;AACA;AACe;AACf,YAAY,oBAAoB;AAChC,8BAA8B,6BAAW;AACzC,WAAW,mBAAI,sBAAsB,yBAAyB;AAC9D;AACA;;ACXsF;AACxC;AACgC;AACvC;AACvC;AACA;AACA;AACA;AACA,6BAA6B,WAAW,OAAO,0BAA0B;AACzE;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD,YAAY,kBAAkB;AAC9B,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA,eAAe,mBAAI,UAAU,uBAAuB,kBAAkB,6BAA6B;AACnG;AACA,YAAY,oBAAK,CAAC,oBAAS,IAAI,gBAAgB,mBAAI,QAAQ,qBAAqB,KAAK,wEAAwE,gCAAkB,gBAAgB,IAAI;AACnM;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,mBAAI,SAAS;AACzB,oBAAoB,mBAAmB;AACvC,oBAAoB,oBAAK,SAAS,WAAW,mBAAI,CAAC,YAAQ,IAAI,0BAA0B,gCAAkB,yCAAyC,cAAc,mBAAI,oBAAoB,wCAAwC,IAAI;AACrO,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa,EAAE,+BAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAA6E;AACzF,8BAA8B,6BAAW;AACzC,sCAAsC,sBAAQ;AAC9C,yBAAyB,yBAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,YAAY,oBAAK,UAAU,WAAW,mBAAI,sBAAsB,oMAAoM,GAAG,mBAAI,cAAc,wEAAwE,IAAI;AACrW;AACA,yDAAe,UAAU,EAAC;AAC1B;;ACxGgD;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC,WAAW,mBAAI,YAAY,oFAAoF;AAC/G;AACA,2DAAe,YAAY,EAAC;AAC5B;;ACVgD;AACN;AAC1C;AACA;AACA;AACA;AACe;AACf,YAAY,oBAAoB;AAChC,8BAA8B,6BAAW;AACzC,WAAW,mBAAI,sBAAsB,4BAA4B;AACjE;AACA;;ACX+D;AAC3B;AACyE;AAC7G;AACA;AACA;AACA;AACA;AACA,uBAAuB,iGAAiG;AACxH,YAAY,gDAAgD;AAC5D,uBAAuB,yBAAW,IAAI,UAAU,SAAS,gBAAgB,0CAAwB;AACjG,wBAAwB,yBAAW,IAAI,UAAU,SAAS,iBAAiB,0CAAwB;AACnG,YAAY,mBAAI,UAAU;AAC1B;AACA,gCAAgC,uCAAqB;AACrD;AACA;AACA;AACA,+BAA+B,oBAAK,WAAW,WAAW,mBAAI,YAAY,mBAAmB,0BAAQ,kPAAkP,oCAAkB,MAAM,GAAG,mBAAI,WAAW,wBAAwB,IAAI;AAC7Z,iCAAiC,mBAAI,YAAY,2BAA2B,YAAY,oBAAoB,SAAS,mBAAI,UAAU,oBAAoB,YAAY,aAAa,mBAAI,YAAY,iBAAiB,GAAG;AACpN,aAAa,GAAG;AAChB;AACA,0DAAe,WAAW,EAAC;AAC3B;;ACvB+D;AAC/D;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,mBAAmB,aAAa,mBAAmB,GAAG,IAAI;AACtE,YAAY,oBAAK,UAAU,6CAA6C,mBAAI,sBAAsB,yBAAyB,GAAG,mBAAI,WAAW,0CAA0C,IAAI;AAC3L;AACA;;ACV+D;AAC3B;AACkE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wIAAwI;AAChK,YAAY,qDAAqD;AACjE;AACA,wBAAwB,yBAAW;AACnC;AACA,2BAA2B,0CAAwB;AACnD,KAAK;AACL,uBAAuB,yBAAW;AAClC;AACA,0BAA0B,0CAAwB;AAClD,KAAK;AACL,yBAAyB,yBAAW;AACpC;AACA,wBAAwB,0CAAwB;AAChD,KAAK;AACL,4BAA4B,0CAAwB;AACpD,YAAY,oBAAK,aAAa,+SAA+S,oCAAkB,8DAA8D,mBAAI,aAAa,kCAAkC;AAChd,mCAAmC,cAAc;AACjD;AACA,4BAA4B,mBAAI,aAAa,uDAAuD;AACpG,iBAAiB,IAAI;AACrB;AACA,2DAAe,YAAY,EAAC;AAC5B;;ACxCgD;AACZ;AACa;AACjD;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB,mGAAmG;AAC7I,yBAAyB,yBAAW,IAAI,UAAU,SAAS;AAC3D,uBAAuB,yBAAW,IAAI,UAAU,SAAS;AACzD,wBAAwB,yBAAW,IAAI,UAAU,SAAS;AAC1D,YAAY,mBAAI,eAAe,8RAA8R,oCAAkB,MAAM;AACrV;AACA;AACA;AACA,eAAe;AACf;AACA,6DAAe,cAAc,EAAC;AAC9B;;AClBgD;AACN;AAC1C;AACA;AACA;AACA;AACe;AACf,YAAY,oBAAoB;AAChC,8BAA8B,6BAAW;AACzC,WAAW,mBAAI,sBAAsB,UAAU;AAC/C;AACA;;ACXgD;AACZ;AACM;AAC1C;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,8BAA8B;AAC1C,8BAA8B,6BAAW;AACzC,yBAAyB,yBAAW,gCAAgC,MAAM;AAC1E,WAAW,mBAAI,sBAAsB,gDAAgD;AACrF;AACA;;ACdgD;AACN;AAC1C;AACA;AACA;AACA;AACe;AACf,YAAY,oBAAoB;AAChC,8BAA8B,6BAAW;AACzC,WAAW,mBAAI,sBAAsB,uBAAuB;AAC5D;AACA;;ACXgD;AACN;AAC1C;AACA;AACA;AACA;AACe;AACf,YAAY,oBAAoB;AAChC,8BAA8B,6BAAW;AACzC,WAAW,mBAAI,sBAAsB,0BAA0B;AAC/D;AACA;;ACX4C;AACQ;AACN;AACI;AACV;AACF;AACQ;AACN;AACF;AACI;AACI;AACN;AACA;AACE;AACI;AACR;AACA;AACF;AACM;AAC1C;AACA;AACA,qBAAqB;AACrB,yBAAyB;AACzB,sBAAsB;AACtB,wBAAwB;AACxB,mBAAmB;AACnB,kBAAkB;AAClB,sBAAsB;AACtB,mBAAmB;AACnB,kBAAkB;AAClB,oBAAoB;AACpB,sBAAsB;AACtB,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB;AACpB,kBAAkB;AAClB,sBAAsB;AACtB,kBAAkB;AAClB,oBAAoB;AACpB,iBAAiB;AACjB;AACA;AACA,yDAAe,OAAO,EAAC;AACvB;;AC3CsD;AACb;AACM;AACJ;AAC3C;AACA;AACA;AACA;AACe;AACf;AACA,gBAAgB,iBAAM;AACtB,mBAAmB,oBAAS;AAC5B,iBAAiB,kBAAO;AACxB,sBAAsB;AACtB,uBAAuB;AACvB,yBAAyB,qCAAuB;AAChD;AACA;AACA;;AClB+D;AAClB;AAC4N;AAC3O;AACQ;AACN;AACI;AACmB;AACvD;AACe,MAAM,SAAI,SAAS,mBAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAA8B,eAAe,sBAAQ;AAC3F,+CAA+C,sBAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAQ;AAC7C;AACA,8CAA8C,aAAI;AAClD;AACA;AACA;AACA,gCAAgC,iBAAQ;AACxC;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2EAA2E;AAC/F,oBAAoB,uCAAuC;AAC3D,gBAAgB,0BAAQ;AACxB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAAY;AAClC;AACA;AACA;AACA;AACA,4BAA4B,6BAAW;AACvC;AACA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,+CAA+C;AAC/C;AACA,8DAA8D,yBAAyB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAmD;AACvE,kBAAkB,wBAAwB;AAC1C,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAAW;AACxD;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,iBAAiB;AACjB;AACA,mCAAmC,2DAA2D;AAC9F;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4BAAU;AAC9C;AACA;AACA,2BAA2B,uBAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAAU;AACvB;AACA,kCAAkC,4BAAU;AAC5C,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,iBAAiB,4BAAU;AAC3B,iBAAiB,4BAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAAmB,GAAG,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD,gBAAgB,cAAc;AAC9B,wBAAwB,8BAAY;AACpC,kCAAkC,6BAAW;AAC7C;AACA,oBAAoB,mBAAI,sBAAsB,8CAA8C,oFAAoF;AAChL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAwD;AACxE,gBAAgB,cAAc;AAC9B,gBAAgB,2DAA2D,EAAE,kBAAkB;AAC/F;AACA,sBAAsB,iCAAiC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA,sCAAsC,mCAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,gBAAgB,WAAW;AAC3B,qBAAqB,gBAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,UAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAkE;AAClF,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,+CAA+C;AAC/C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2PAA2P;AAC3Q,gBAAgB,oDAAoD;AACpE;AACA,gBAAgB,4BAA4B;AAC5C,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,cAAc,CAAC,oCAAsB,wBAAwB,EAAE,8BAAY;AAC3E;AACA,8BAA8B,2BAA2B;AACzD;AACA,iCAAiC,CAAC,4BAAc,KAAK,CAAC,oCAAsB;AAC5E,gBAAgB,oBAAK,YAAY,mVAAmV,mBAAI,iBAAiB,yTAAyT,yBAAyB,mBAAI,iBAAiB,8CAA8C,+DAA+D;AAC71B;AACA;AACA;;ACphBgD;AACb;AACE;AACrC;AACe;AACf,yBAAyB,4CAA4C;AACrE;AACA,mBAAmB;AACnB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6BAA6B,iGAAiG;AAC9H,KAAK;AACL;AACA;;ACpBqC;AACD;AACkB;AACb;AACzC,0CAAe,SAAI,EAAC;AACpB;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,GAAG,MAAM;AAC/B;AACA,cAAc,IAAI,GAAG,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,KAAK;AACL,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,EAAE,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA,oBAAoB,0BAA0B;AAC9C,oBAAoB,IAAI,IAAI,MAAM;AAClC;AACA,yCAAyC,IAAI,IAAI,IAAI;AACrD;AACA;AACA,iBAAiB,iCAAiC;AAClD,qDAAqD,IAAI,IAAI,SAAS,IAAI,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB,EAAE,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,EAAE,WAAW,EAAE,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,QAAQ,IAA6D;AACrE;AACA,cAAc,oBAAoB,GAAG,IAAI;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAqC,QAAQ,CAAU,CAAC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,EAAE,KAAqC,QAAQ,CAAU,CAAC;AAC9F,kDAAkD,IAAI,IAAI,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,0BAA0B;AACvD;AACA;;;;;;;ACjZA,iBAAiB,mBAAO,CAAC,KAAe;AACxC,YAAY,mBAAO,CAAC,KAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;AClBA,cAAc,mBAAO,CAAC,KAAY;AAClC,cAAc,mBAAO,CAAC,KAAY;AAClC,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,KAAa;AACpC,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,sBAAsB;AACjC,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,CAAC;;AAED;;;;;;;;ACxBA,gBAAgB,mBAAO,CAAC,KAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,QAAQ,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA,WAAW,QAAQ,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACjCa;;AAEb,QAAQ,mBAAO,CAAC,KAAW;AAC3B,IAAI,IAAqC;AACzC,EAAE,SAAkB;AACpB,EAAE,yBAAmB;AACrB,EAAE,KAAK,UAkBN;;;;;;;;;;ACxBY;AACb,6BAA6C,EAAE,aAAa,CAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAsB;AAChD,yBAAiB;AACjB;AACA;AACA;AACA,YAAY,mBAAO,CAAC,KAAS;AAC7B,yBAAa;AACb;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,KAAsB;AAChD,yBAAc;AACd,yBAAe;AACf,yBAAa;AACb;AACA,qCAAqC,uBAAuB;AAC5D;AACA,yBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAc;AACd;AACA;AACA;AACA,yBAAe;AACf;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAgB;AAChB;AACA;AACA;AACA,yBAAiB;AACjB;AACA;AACA;AACA,yBAAiB;AACjB;AACA;AACA;AACA,yBAAc;AACd;AACA;AACA;AACA,UAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA,yBAAuB;;;;;;;;;AC9EV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;AC7Cb;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,IAAY;AACpC,mBAAmB,mBAAO,CAAC,KAAc;AACzC,kBAAkB,mBAAO,CAAC,KAAa;AACvC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mCAAmC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;;;;;;;;;AChMJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,4BAA4B,wEAAwE,yBAAyB,UAAU;AACvI,0CAA0C,6BAA6B;AACvE,+BAA+B,aAAa;AAC5C;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,WAAW,aAAa,GAAG,YAAY;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5Ga;AACb,8CAA6C,EAAE,aAAa,EAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/nanoid/index.browser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/ArrayField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/BooleanField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/NumberField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/markdown-to-jsx/dist/index.modern.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/ObjectField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/SchemaField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/StringField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/NullField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/fields/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/DescriptionField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ErrorList.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/TitleField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/templates/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/DateWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/FileWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/TextWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/URLWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/widgets/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/getDefaultRegistry.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/components/Form.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/withTheme.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/core/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/free-style/dist.es2015/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_basePick.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_basePickBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/pick.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/unset.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/react-dom/client.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/typestyle/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/typestyle/lib/internal/formatting.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/typestyle/lib/internal/typestyle.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/typestyle/lib/internal/utilities.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/typestyle/lib/types.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file replaces `index.js` in bundlers like webpack or Rollup,</span><span class="s3">\n</span><span class="s1">// according to `browser` config in `package.json`.</span><span class="s3">\n\n</span><span class="s1">import { urlAlphabet } from './url-alphabet/index.js'</span><span class="s3">\n\n</span><span class="s1">let random = bytes =&gt; crypto.getRandomValues(new Uint8Array(bytes))</span><span class="s3">\n\n</span><span class="s1">let customRandom = (alphabet, defaultSize, getRandom) =&gt; {</span><span class="s3">\n  </span><span class="s1">// First, a bitmask is necessary to generate the ID. The bitmask makes bytes</span><span class="s3">\n  </span><span class="s1">// values closer to the alphabet size. The bitmask calculates the closest</span><span class="s3">\n  </span><span class="s1">// `2^31 - 1` number, which exceeds the alphabet size.</span><span class="s3">\n  </span><span class="s1">// For example, the bitmask for the alphabet size 30 is 31 (00011111).</span><span class="s3">\n  </span><span class="s1">// `Math.clz32` is not used, because it is not available in browsers.</span><span class="s3">\n  </span><span class="s1">let mask = (2 &lt;&lt; (Math.log(alphabet.length - 1) / Math.LN2)) - 1</span><span class="s3">\n  </span><span class="s1">// Though, the bitmask solution is not perfect since the bytes exceeding</span><span class="s3">\n  </span><span class="s1">// the alphabet size are refused. Therefore, to reliably generate the ID,</span><span class="s3">\n  </span><span class="s1">// the random bytes redundancy has to be satisfied.</span><span class="s3">\n\n  </span><span class="s1">// Note: every hardware random generator call is performance expensive,</span><span class="s3">\n  </span><span class="s1">// because the system call for entropy collection takes a lot of time.</span><span class="s3">\n  </span><span class="s1">// So, to avoid additional system calls, extra bytes are requested in advance.</span><span class="s3">\n\n  </span><span class="s1">// Next, a step determines how many random bytes to generate.</span><span class="s3">\n  </span><span class="s1">// The number of random bytes gets decided upon the ID size, mask,</span><span class="s3">\n  </span><span class="s1">// alphabet size, and magic number 1.6 (using 1.6 peaks at performance</span><span class="s3">\n  </span><span class="s1">// according to benchmarks).</span><span class="s3">\n\n  </span><span class="s1">// `-~f =&gt; Math.ceil(f)` if f is a float</span><span class="s3">\n  </span><span class="s1">// `-~i =&gt; i + 1` if i is an integer</span><span class="s3">\n  </span><span class="s1">let step = -~((1.6 * mask * defaultSize) / alphabet.length)</span><span class="s3">\n\n  </span><span class="s1">return (size = defaultSize) =&gt; {</span><span class="s3">\n    </span><span class="s1">let id = ''</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">let bytes = getRandom(step)</span><span class="s3">\n      </span><span class="s1">// A compact alternative for `for (var i = 0; i &lt; step; i++)`.</span><span class="s3">\n      </span><span class="s1">let j = step | 0</span><span class="s3">\n      </span><span class="s1">while (j--) {</span><span class="s3">\n        </span><span class="s1">// Adding `|| ''` refuses a random byte that exceeds the alphabet size.</span><span class="s3">\n        </span><span class="s1">id += alphabet[bytes[j] &amp; mask] || ''</span><span class="s3">\n        </span><span class="s1">if (id.length === size) return id</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let customAlphabet = (alphabet, size = 21) =&gt;</span><span class="s3">\n  </span><span class="s1">customRandom(alphabet, size, random)</span><span class="s3">\n\n</span><span class="s1">let nanoid = (size = 21) =&gt;</span><span class="s3">\n  </span><span class="s1">crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) =&gt; {</span><span class="s3">\n    </span><span class="s1">// It is incorrect to use bytes exceeding the alphabet size.</span><span class="s3">\n    </span><span class="s1">// The following mask reduces the random byte in the 0-255 value</span><span class="s3">\n    </span><span class="s1">// range to the 0-63 value range. Therefore, adding hacks, such</span><span class="s3">\n    </span><span class="s1">// as empty string fallback or magic numbers, is unneccessary because</span><span class="s3">\n    </span><span class="s1">// the bitmask trims bytes down to the alphabet size.</span><span class="s3">\n    </span><span class="s1">byte &amp;= 63</span><span class="s3">\n    </span><span class="s1">if (byte &lt; 36) {</span><span class="s3">\n      </span><span class="s1">// `0-9a-z`</span><span class="s3">\n      </span><span class="s1">id += byte.toString(36)</span><span class="s3">\n    </span><span class="s1">} else if (byte &lt; 62) {</span><span class="s3">\n      </span><span class="s1">// `A-Z`</span><span class="s3">\n      </span><span class="s1">id += (byte - 26).toString(36).toUpperCase()</span><span class="s3">\n    </span><span class="s1">} else if (byte &gt; 62) {</span><span class="s3">\n      </span><span class="s1">id += '-'</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">id += '_'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return id</span><span class="s3">\n  </span><span class="s1">}, '')</span><span class="s3">\n\n</span><span class="s1">export { nanoid, customAlphabet, customRandom, urlAlphabet, random }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Component } from 'react';</span><span class="s3">\n</span><span class="s1">import { getTemplate, getWidget, getUiOptions, isFixedItems, allowAdditionalItems, isCustomWidget, optionsList, TranslatableString, ITEMS_KEY, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import cloneDeep from 'lodash/cloneDeep';</span><span class="s3">\n</span><span class="s1">import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">import set from 'lodash/set';</span><span class="s3">\n</span><span class="s1">import { nanoid } from 'nanoid';</span><span class="s3">\n</span><span class="s1">/** Used to generate a unique ID for an element in a row */</span><span class="s3">\n</span><span class="s1">function generateRowId() {</span><span class="s3">\n    </span><span class="s1">return nanoid();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Converts the `formData` into `KeyedFormDataType` data, using the `generateRowId()` function to create the key</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param formData - The data for the form</span><span class="s3">\n </span><span class="s1">* @returns - The `formData` converted into a `KeyedFormDataType` element</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function generateKeyedFormData(formData) {</span><span class="s3">\n    </span><span class="s1">return !Array.isArray(formData)</span><span class="s3">\n        </span><span class="s1">? []</span><span class="s3">\n        </span><span class="s1">: formData.map((item) =&gt; {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">key: generateRowId(),</span><span class="s3">\n                </span><span class="s1">item,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Converts `KeyedFormDataType` data into the inner `formData`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param keyedFormData - The `KeyedFormDataType` to be converted</span><span class="s3">\n </span><span class="s1">* @returns - The inner `formData` item(s) in the `keyedFormData`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function keyedToPlainFormData(keyedFormData) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(keyedFormData)) {</span><span class="s3">\n        </span><span class="s1">return keyedFormData.map((keyedItem) =&gt; keyedItem.item);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** The `ArrayField` component is used to render a field in the schema that is of type `array`. It supports both normal</span><span class="s3">\n </span><span class="s1">* and fixed array, allowing user to add and remove elements from the array data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ArrayField extends Component {</span><span class="s3">\n    </span><span class="s1">/** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(props) {</span><span class="s3">\n        </span><span class="s1">super(props);</span><span class="s3">\n        </span><span class="s1">/** Returns the default form information for an item based on the schema for that item. Deals with the possibility</span><span class="s3">\n         </span><span class="s1">* that the schema is fixed and allows additional items.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._getNewFormDataRow = () =&gt; {</span><span class="s3">\n            </span><span class="s1">const { schema, registry } = this.props;</span><span class="s3">\n            </span><span class="s1">const { schemaUtils } = registry;</span><span class="s3">\n            </span><span class="s1">let itemSchema = schema.items;</span><span class="s3">\n            </span><span class="s1">if (isFixedItems(schema) &amp;&amp; allowAdditionalItems(schema)) {</span><span class="s3">\n                </span><span class="s1">itemSchema = schema.additionalItems;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Cast this as a T to work around schema utils being for T[] caused by the FieldProps&lt;T[], S, F&gt; call on the class</span><span class="s3">\n            </span><span class="s1">return schemaUtils.getDefaultFormState(itemSchema);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of</span><span class="s3">\n         </span><span class="s1">* the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the</span><span class="s3">\n         </span><span class="s1">* keyed data</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param event - The event for the click</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onAddClick = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">this._handleAddClick(event);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of</span><span class="s3">\n         </span><span class="s1">* keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain</span><span class="s3">\n         </span><span class="s1">* form data converted from the keyed data</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index at which the add button is clicked</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onAddIndexClick = (index) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">this._handleAddClick(event, index);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of</span><span class="s3">\n         </span><span class="s1">* keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain</span><span class="s3">\n         </span><span class="s1">* form data converted from the keyed data</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index at which the copy button is clicked</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onCopyIndexClick = (index) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (event) {</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { onChange, errorSchema } = this.props;</span><span class="s3">\n                </span><span class="s1">const { keyedFormData } = this.state;</span><span class="s3">\n                </span><span class="s1">// refs #195: revalidate to ensure properly reindexing errors</span><span class="s3">\n                </span><span class="s1">let newErrorSchema;</span><span class="s3">\n                </span><span class="s1">if (errorSchema) {</span><span class="s3">\n                    </span><span class="s1">newErrorSchema = {};</span><span class="s3">\n                    </span><span class="s1">for (const idx in errorSchema) {</span><span class="s3">\n                        </span><span class="s1">const i = parseInt(idx);</span><span class="s3">\n                        </span><span class="s1">if (i &lt;= index) {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [i], errorSchema[idx]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else if (i &gt; index) {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [i + 1], errorSchema[idx]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const newKeyedFormDataRow = {</span><span class="s3">\n                    </span><span class="s1">key: generateRowId(),</span><span class="s3">\n                    </span><span class="s1">item: cloneDeep(keyedFormData[index].item),</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">const newKeyedFormData = [...keyedFormData];</span><span class="s3">\n                </span><span class="s1">if (index !== undefined) {</span><span class="s3">\n                    </span><span class="s1">newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">newKeyedFormData.push(newKeyedFormDataRow);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.setState({</span><span class="s3">\n                    </span><span class="s1">keyedFormData: newKeyedFormData,</span><span class="s3">\n                    </span><span class="s1">updatedKeyedFormData: true,</span><span class="s3">\n                </span><span class="s1">}, () =&gt; onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of</span><span class="s3">\n         </span><span class="s1">* keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted</span><span class="s3">\n         </span><span class="s1">* from the keyed data</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index at which the remove button is clicked</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onDropIndexClick = (index) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (event) {</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { onChange, errorSchema } = this.props;</span><span class="s3">\n                </span><span class="s1">const { keyedFormData } = this.state;</span><span class="s3">\n                </span><span class="s1">// refs #195: revalidate to ensure properly reindexing errors</span><span class="s3">\n                </span><span class="s1">let newErrorSchema;</span><span class="s3">\n                </span><span class="s1">if (errorSchema) {</span><span class="s3">\n                    </span><span class="s1">newErrorSchema = {};</span><span class="s3">\n                    </span><span class="s1">for (const idx in errorSchema) {</span><span class="s3">\n                        </span><span class="s1">const i = parseInt(idx);</span><span class="s3">\n                        </span><span class="s1">if (i &lt; index) {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [i], errorSchema[idx]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else if (i &gt; index) {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [i - 1], errorSchema[idx]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const newKeyedFormData = keyedFormData.filter((_, i) =&gt; i !== index);</span><span class="s3">\n                </span><span class="s1">this.setState({</span><span class="s3">\n                    </span><span class="s1">keyedFormData: newKeyedFormData,</span><span class="s3">\n                    </span><span class="s1">updatedKeyedFormData: true,</span><span class="s3">\n                </span><span class="s1">}, () =&gt; onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the</span><span class="s3">\n         </span><span class="s1">* row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the</span><span class="s3">\n         </span><span class="s1">* plain form data converted from the keyed data</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index of the item to move</span><span class="s3">\n         </span><span class="s1">* @param newIndex - The index to where the item is to be moved</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onReorderClick = (index, newIndex) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (event) {</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                    </span><span class="s1">event.currentTarget.blur();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { onChange, errorSchema } = this.props;</span><span class="s3">\n                </span><span class="s1">let newErrorSchema;</span><span class="s3">\n                </span><span class="s1">if (errorSchema) {</span><span class="s3">\n                    </span><span class="s1">newErrorSchema = {};</span><span class="s3">\n                    </span><span class="s1">for (const idx in errorSchema) {</span><span class="s3">\n                        </span><span class="s1">const i = parseInt(idx);</span><span class="s3">\n                        </span><span class="s1">if (i == index) {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [newIndex], errorSchema[index]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else if (i == newIndex) {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [index], errorSchema[newIndex]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">set(newErrorSchema, [idx], errorSchema[i]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { keyedFormData } = this.state;</span><span class="s3">\n                </span><span class="s1">function reOrderArray() {</span><span class="s3">\n                    </span><span class="s1">// Copy item</span><span class="s3">\n                    </span><span class="s1">const _newKeyedFormData = keyedFormData.slice();</span><span class="s3">\n                    </span><span class="s1">// Moves item from index to newIndex</span><span class="s3">\n                    </span><span class="s1">_newKeyedFormData.splice(index, 1);</span><span class="s3">\n                    </span><span class="s1">_newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);</span><span class="s3">\n                    </span><span class="s1">return _newKeyedFormData;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const newKeyedFormData = reOrderArray();</span><span class="s3">\n                </span><span class="s1">this.setState({</span><span class="s3">\n                    </span><span class="s1">keyedFormData: newKeyedFormData,</span><span class="s3">\n                </span><span class="s1">}, () =&gt; onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the</span><span class="s3">\n         </span><span class="s1">* `onChange` callback with the updated form data</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index of the item being changed</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onChangeForIndex = (index) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (value, newErrorSchema, id) =&gt; {</span><span class="s3">\n                </span><span class="s1">const { formData, onChange, errorSchema } = this.props;</span><span class="s3">\n                </span><span class="s1">const arrayData = Array.isArray(formData) ? formData : [];</span><span class="s3">\n                </span><span class="s1">const newFormData = arrayData.map((item, i) =&gt; {</span><span class="s3">\n                    </span><span class="s1">// We need to treat undefined items as nulls to have validation.</span><span class="s3">\n                    </span><span class="s1">// See https://github.com/tdegrunt/jsonschema/issues/206</span><span class="s3">\n                    </span><span class="s1">const jsonValue = typeof value === 'undefined' ? null : value;</span><span class="s3">\n                    </span><span class="s1">return index === i ? jsonValue : item;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">onChange(newFormData, errorSchema &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">errorSchema &amp;&amp; {</span><span class="s3">\n                    </span><span class="s1">...errorSchema,</span><span class="s3">\n                    </span><span class="s1">[index]: newErrorSchema,</span><span class="s3">\n                </span><span class="s1">}, id);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback handler used to change the value for a checkbox */</span><span class="s3">\n        </span><span class="s1">this.onSelectChange = (value) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { onChange, idSchema } = this.props;</span><span class="s3">\n            </span><span class="s1">onChange(value, undefined, idSchema &amp;&amp; idSchema.$id);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const { formData = [] } = props;</span><span class="s3">\n        </span><span class="s1">const keyedFormData = generateKeyedFormData(formData);</span><span class="s3">\n        </span><span class="s1">this.state = {</span><span class="s3">\n            </span><span class="s1">keyedFormData,</span><span class="s3">\n            </span><span class="s1">updatedKeyedFormData: false,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** React lifecycle method that is called when the props are about to change allowing the state to be updated. It</span><span class="s3">\n     </span><span class="s1">* regenerates the keyed form data and returns it</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param nextProps - The next set of props data</span><span class="s3">\n     </span><span class="s1">* @param prevState - The previous set of state data</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static getDerivedStateFromProps(nextProps, prevState) {</span><span class="s3">\n        </span><span class="s1">// Don't call getDerivedStateFromProps if keyed formdata was just updated.</span><span class="s3">\n        </span><span class="s1">if (prevState.updatedKeyedFormData) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">updatedKeyedFormData: false,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const nextFormData = Array.isArray(nextProps.formData) ? nextProps.formData : [];</span><span class="s3">\n        </span><span class="s1">const previousKeyedFormData = prevState.keyedFormData || [];</span><span class="s3">\n        </span><span class="s1">const newKeyedFormData = nextFormData.length === previousKeyedFormData.length</span><span class="s3">\n            </span><span class="s1">? previousKeyedFormData.map((previousKeyedFormDatum, index) =&gt; {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">key: previousKeyedFormDatum.key,</span><span class="s3">\n                    </span><span class="s1">item: nextFormData[index],</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">: generateKeyedFormData(nextFormData);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">keyedFormData: newKeyedFormData,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to</span><span class="s3">\n     </span><span class="s1">* the description from the schema.items, and finally the string </span><span class="s3">\&quot;</span><span class="s1">Item</span><span class="s3">\&quot;\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get itemTitle() {</span><span class="s3">\n        </span><span class="s1">const { schema, registry } = this.props;</span><span class="s3">\n        </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n        </span><span class="s1">return get(schema, [ITEMS_KEY, 'title'], get(schema, [ITEMS_KEY, 'description'], translateString(TranslatableString.ArrayItemTitle)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Determines whether the item described in the schema is always required, which is determined by whether any item</span><span class="s3">\n     </span><span class="s1">* may be null.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param itemSchema - The schema for the item</span><span class="s3">\n     </span><span class="s1">* @return - True if the item schema type does not contain the </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot; </span><span class="s1">type</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isItemRequired(itemSchema) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(itemSchema.type)) {</span><span class="s3">\n            </span><span class="s1">// While we don't yet support composite/nullable jsonschema types, it's</span><span class="s3">\n            </span><span class="s1">// future-proof to check for requirement against these.</span><span class="s3">\n            </span><span class="s1">return !itemSchema.type.includes('null');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// All non-null array item types are inherently required by design</span><span class="s3">\n        </span><span class="s1">return itemSchema.type !== 'null';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding</span><span class="s3">\n     </span><span class="s1">* then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the</span><span class="s3">\n     </span><span class="s1">* `formData` matches that value, then false is returned, otherwise true is returned.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formItems - The list of items in the form</span><span class="s3">\n     </span><span class="s1">* @returns - True if the item is addable otherwise false</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">canAddItem(formItems) {</span><span class="s3">\n        </span><span class="s1">const { schema, uiSchema, registry } = this.props;</span><span class="s3">\n        </span><span class="s1">let { addable } = getUiOptions(uiSchema, registry.globalUiOptions);</span><span class="s3">\n        </span><span class="s1">if (addable !== false) {</span><span class="s3">\n            </span><span class="s1">// if ui:options.addable was not explicitly set to false, we can add</span><span class="s3">\n            </span><span class="s1">// another item if we have not exceeded maxItems yet</span><span class="s3">\n            </span><span class="s1">if (schema.maxItems !== undefined) {</span><span class="s3">\n                </span><span class="s1">addable = formItems.length &lt; schema.maxItems;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">addable = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return addable;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data</span><span class="s3">\n     </span><span class="s1">* either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into</span><span class="s3">\n     </span><span class="s1">* the state, and then returning `onChange()` with the plain form data converted from the keyed data</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The event for the click</span><span class="s3">\n     </span><span class="s1">* @param [index] - The optional index at which to add the new data</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_handleAddClick(event, index) {</span><span class="s3">\n        </span><span class="s1">if (event) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const { onChange, errorSchema } = this.props;</span><span class="s3">\n        </span><span class="s1">const { keyedFormData } = this.state;</span><span class="s3">\n        </span><span class="s1">// refs #195: revalidate to ensure properly reindexing errors</span><span class="s3">\n        </span><span class="s1">let newErrorSchema;</span><span class="s3">\n        </span><span class="s1">if (errorSchema) {</span><span class="s3">\n            </span><span class="s1">newErrorSchema = {};</span><span class="s3">\n            </span><span class="s1">for (const idx in errorSchema) {</span><span class="s3">\n                </span><span class="s1">const i = parseInt(idx);</span><span class="s3">\n                </span><span class="s1">if (index === undefined || i &lt; index) {</span><span class="s3">\n                    </span><span class="s1">set(newErrorSchema, [i], errorSchema[idx]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (i &gt;= index) {</span><span class="s3">\n                    </span><span class="s1">set(newErrorSchema, [i + 1], errorSchema[idx]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const newKeyedFormDataRow = {</span><span class="s3">\n            </span><span class="s1">key: generateRowId(),</span><span class="s3">\n            </span><span class="s1">item: this._getNewFormDataRow(),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const newKeyedFormData = [...keyedFormData];</span><span class="s3">\n        </span><span class="s1">if (index !== undefined) {</span><span class="s3">\n            </span><span class="s1">newKeyedFormData.splice(index, 0, newKeyedFormDataRow);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">newKeyedFormData.push(newKeyedFormDataRow);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.setState({</span><span class="s3">\n            </span><span class="s1">keyedFormData: newKeyedFormData,</span><span class="s3">\n            </span><span class="s1">updatedKeyedFormData: true,</span><span class="s3">\n        </span><span class="s1">}, () =&gt; onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">render() {</span><span class="s3">\n        </span><span class="s1">const { schema, uiSchema, idSchema, registry } = this.props;</span><span class="s3">\n        </span><span class="s1">const { schemaUtils, translateString } = registry;</span><span class="s3">\n        </span><span class="s1">if (!(ITEMS_KEY in schema)) {</span><span class="s3">\n            </span><span class="s1">const uiOptions = getUiOptions(uiSchema);</span><span class="s3">\n            </span><span class="s1">const UnsupportedFieldTemplate = getTemplate('UnsupportedFieldTemplate', registry, uiOptions);</span><span class="s3">\n            </span><span class="s1">return (_jsx(UnsupportedFieldTemplate, { schema: schema, idSchema: idSchema, reason: translateString(TranslatableString.MissingItems), registry: registry }));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (schemaUtils.isMultiSelect(schema)) {</span><span class="s3">\n            </span><span class="s1">// If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.</span><span class="s3">\n            </span><span class="s1">return this.renderMultiSelect();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isCustomWidget(uiSchema)) {</span><span class="s3">\n            </span><span class="s1">return this.renderCustomWidget();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isFixedItems(schema)) {</span><span class="s3">\n            </span><span class="s1">return this.renderFixedArray();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (schemaUtils.isFilesArray(schema, uiSchema)) {</span><span class="s3">\n            </span><span class="s1">return this.renderFiles();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.renderNormalArray();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders a normal array without any limitations of length</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">renderNormalArray() {</span><span class="s3">\n        </span><span class="s1">const { schema, uiSchema = {}, errorSchema, idSchema, name, disabled = false, readonly = false, autofocus = false, required = false, registry, onBlur, onFocus, idPrefix, idSeparator = '_', rawErrors, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { keyedFormData } = this.state;</span><span class="s3">\n        </span><span class="s1">const title = schema.title === undefined ? name : schema.title;</span><span class="s3">\n        </span><span class="s1">const { schemaUtils, formContext } = registry;</span><span class="s3">\n        </span><span class="s1">const uiOptions = getUiOptions(uiSchema);</span><span class="s3">\n        </span><span class="s1">const _schemaItems = isObject(schema.items) ? schema.items : {};</span><span class="s3">\n        </span><span class="s1">const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);</span><span class="s3">\n        </span><span class="s1">const formData = keyedToPlainFormData(this.state.keyedFormData);</span><span class="s3">\n        </span><span class="s1">const canAdd = this.canAddItem(formData);</span><span class="s3">\n        </span><span class="s1">const arrayProps = {</span><span class="s3">\n            </span><span class="s1">canAdd,</span><span class="s3">\n            </span><span class="s1">items: keyedFormData.map((keyedItem, index) =&gt; {</span><span class="s3">\n                </span><span class="s1">const { key, item } = keyedItem;</span><span class="s3">\n                </span><span class="s1">// While we are actually dealing with a single item of type T, the types require a T[], so cast</span><span class="s3">\n                </span><span class="s1">const itemCast = item;</span><span class="s3">\n                </span><span class="s1">const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);</span><span class="s3">\n                </span><span class="s1">const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;</span><span class="s3">\n                </span><span class="s1">const itemIdPrefix = idSchema.$id + idSeparator + index;</span><span class="s3">\n                </span><span class="s1">const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);</span><span class="s3">\n                </span><span class="s1">return this.renderArrayFieldItem({</span><span class="s3">\n                    </span><span class="s1">key,</span><span class="s3">\n                    </span><span class="s1">index,</span><span class="s3">\n                    </span><span class="s1">name: name &amp;&amp; `${name}-${index}`,</span><span class="s3">\n                    </span><span class="s1">canAdd,</span><span class="s3">\n                    </span><span class="s1">canMoveUp: index &gt; 0,</span><span class="s3">\n                    </span><span class="s1">canMoveDown: index &lt; formData.length - 1,</span><span class="s3">\n                    </span><span class="s1">itemSchema,</span><span class="s3">\n                    </span><span class="s1">itemIdSchema,</span><span class="s3">\n                    </span><span class="s1">itemErrorSchema,</span><span class="s3">\n                    </span><span class="s1">itemData: itemCast,</span><span class="s3">\n                    </span><span class="s1">itemUiSchema: uiSchema.items,</span><span class="s3">\n                    </span><span class="s1">autofocus: autofocus &amp;&amp; index === 0,</span><span class="s3">\n                    </span><span class="s1">onBlur,</span><span class="s3">\n                    </span><span class="s1">onFocus,</span><span class="s3">\n                    </span><span class="s1">rawErrors,</span><span class="s3">\n                    </span><span class="s1">totalItems: keyedFormData.length,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">className: `field field-array field-array-of-${itemsSchema.type}`,</span><span class="s3">\n            </span><span class="s1">disabled,</span><span class="s3">\n            </span><span class="s1">idSchema,</span><span class="s3">\n            </span><span class="s1">uiSchema,</span><span class="s3">\n            </span><span class="s1">onAddClick: this.onAddClick,</span><span class="s3">\n            </span><span class="s1">readonly,</span><span class="s3">\n            </span><span class="s1">required,</span><span class="s3">\n            </span><span class="s1">schema,</span><span class="s3">\n            </span><span class="s1">title,</span><span class="s3">\n            </span><span class="s1">formContext,</span><span class="s3">\n            </span><span class="s1">formData,</span><span class="s3">\n            </span><span class="s1">rawErrors,</span><span class="s3">\n            </span><span class="s1">registry,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const Template = getTemplate('ArrayFieldTemplate', registry, uiOptions);</span><span class="s3">\n        </span><span class="s1">return _jsx(Template, { ...arrayProps });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders an array using the custom widget provided by the user in the `uiSchema`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">renderCustomWidget() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const { schema, idSchema, uiSchema, disabled = false, readonly = false, autofocus = false, required = false, hideError, placeholder, onBlur, onFocus, formData: items = [], registry, rawErrors, name, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { widgets, formContext, globalUiOptions, schemaUtils } = registry;</span><span class="s3">\n        </span><span class="s1">const { widget, title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const Widget = getWidget(schema, widget, widgets);</span><span class="s3">\n        </span><span class="s1">const label = (_a = uiTitle !== null &amp;&amp; uiTitle !== void 0 ? uiTitle : schema.title) !== null &amp;&amp; _a !== void 0 ? _a : name;</span><span class="s3">\n        </span><span class="s1">const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">return (_jsx(Widget, { id: idSchema.$id, name: name, multiple: true, onChange: this.onSelectChange, onBlur: onBlur, onFocus: onFocus, options: options, schema: schema, uiSchema: uiSchema, registry: registry, value: items, disabled: disabled, readonly: readonly, hideError: hideError, required: required, label: label, hideLabel: !displayLabel, placeholder: placeholder, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders an array as a set of checkboxes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">renderMultiSelect() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const { schema, idSchema, uiSchema, formData: items = [], disabled = false, readonly = false, autofocus = false, required = false, placeholder, onBlur, onFocus, registry, rawErrors, name, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { widgets, schemaUtils, formContext, globalUiOptions } = registry;</span><span class="s3">\n        </span><span class="s1">const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);</span><span class="s3">\n        </span><span class="s1">const enumOptions = optionsList(itemsSchema);</span><span class="s3">\n        </span><span class="s1">const { widget = 'select', title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const Widget = getWidget(schema, widget, widgets);</span><span class="s3">\n        </span><span class="s1">const label = (_a = uiTitle !== null &amp;&amp; uiTitle !== void 0 ? uiTitle : schema.title) !== null &amp;&amp; _a !== void 0 ? _a : name;</span><span class="s3">\n        </span><span class="s1">const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">return (_jsx(Widget, { id: idSchema.$id, name: name, multiple: true, onChange: this.onSelectChange, onBlur: onBlur, onFocus: onFocus, options: { ...options, enumOptions }, schema: schema, uiSchema: uiSchema, registry: registry, value: items, disabled: disabled, readonly: readonly, required: required, label: label, hideLabel: !displayLabel, placeholder: placeholder, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders an array of files using the `FileWidget`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">renderFiles() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const { schema, uiSchema, idSchema, name, disabled = false, readonly = false, autofocus = false, required = false, onBlur, onFocus, registry, formData: items = [], rawErrors, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { widgets, formContext, globalUiOptions, schemaUtils } = registry;</span><span class="s3">\n        </span><span class="s1">const { widget = 'files', title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const Widget = getWidget(schema, widget, widgets);</span><span class="s3">\n        </span><span class="s1">const label = (_a = uiTitle !== null &amp;&amp; uiTitle !== void 0 ? uiTitle : schema.title) !== null &amp;&amp; _a !== void 0 ? _a : name;</span><span class="s3">\n        </span><span class="s1">const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">return (_jsx(Widget, { options: options, id: idSchema.$id, name: name, multiple: true, onChange: this.onSelectChange, onBlur: onBlur, onFocus: onFocus, schema: schema, uiSchema: uiSchema, value: items, disabled: disabled, readonly: readonly, required: required, registry: registry, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors, label: label, hideLabel: !displayLabel }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders an array that has a maximum limit of items</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">renderFixedArray() {</span><span class="s3">\n        </span><span class="s1">const { schema, uiSchema = {}, formData = [], errorSchema, idPrefix, idSeparator = '_', idSchema, name, disabled = false, readonly = false, autofocus = false, required = false, registry, onBlur, onFocus, rawErrors, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { keyedFormData } = this.state;</span><span class="s3">\n        </span><span class="s1">let { formData: items = [] } = this.props;</span><span class="s3">\n        </span><span class="s1">const title = schema.title || name;</span><span class="s3">\n        </span><span class="s1">const uiOptions = getUiOptions(uiSchema);</span><span class="s3">\n        </span><span class="s1">const { schemaUtils, formContext } = registry;</span><span class="s3">\n        </span><span class="s1">const _schemaItems = isObject(schema.items) ? schema.items : [];</span><span class="s3">\n        </span><span class="s1">const itemSchemas = _schemaItems.map((item, index) =&gt; schemaUtils.retrieveSchema(item, formData[index]));</span><span class="s3">\n        </span><span class="s1">const additionalSchema = isObject(schema.additionalItems)</span><span class="s3">\n            </span><span class="s1">? schemaUtils.retrieveSchema(schema.additionalItems, formData)</span><span class="s3">\n            </span><span class="s1">: null;</span><span class="s3">\n        </span><span class="s1">if (!items || items.length &lt; itemSchemas.length) {</span><span class="s3">\n            </span><span class="s1">// to make sure at least all fixed items are generated</span><span class="s3">\n            </span><span class="s1">items = items || [];</span><span class="s3">\n            </span><span class="s1">items = items.concat(new Array(itemSchemas.length - items.length));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// These are the props passed into the render function</span><span class="s3">\n        </span><span class="s1">const canAdd = this.canAddItem(items) &amp;&amp; !!additionalSchema;</span><span class="s3">\n        </span><span class="s1">const arrayProps = {</span><span class="s3">\n            </span><span class="s1">canAdd,</span><span class="s3">\n            </span><span class="s1">className: 'field field-array field-array-fixed-items',</span><span class="s3">\n            </span><span class="s1">disabled,</span><span class="s3">\n            </span><span class="s1">idSchema,</span><span class="s3">\n            </span><span class="s1">formData,</span><span class="s3">\n            </span><span class="s1">items: keyedFormData.map((keyedItem, index) =&gt; {</span><span class="s3">\n                </span><span class="s1">const { key, item } = keyedItem;</span><span class="s3">\n                </span><span class="s1">// While we are actually dealing with a single item of type T, the types require a T[], so cast</span><span class="s3">\n                </span><span class="s1">const itemCast = item;</span><span class="s3">\n                </span><span class="s1">const additional = index &gt;= itemSchemas.length;</span><span class="s3">\n                </span><span class="s1">const itemSchema = (additional &amp;&amp; isObject(schema.additionalItems)</span><span class="s3">\n                    </span><span class="s1">? schemaUtils.retrieveSchema(schema.additionalItems, itemCast)</span><span class="s3">\n                    </span><span class="s1">: itemSchemas[index]) || {};</span><span class="s3">\n                </span><span class="s1">const itemIdPrefix = idSchema.$id + idSeparator + index;</span><span class="s3">\n                </span><span class="s1">const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);</span><span class="s3">\n                </span><span class="s1">const itemUiSchema = additional</span><span class="s3">\n                    </span><span class="s1">? uiSchema.additionalItems || {}</span><span class="s3">\n                    </span><span class="s1">: Array.isArray(uiSchema.items)</span><span class="s3">\n                        </span><span class="s1">? uiSchema.items[index]</span><span class="s3">\n                        </span><span class="s1">: uiSchema.items || {};</span><span class="s3">\n                </span><span class="s1">const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;</span><span class="s3">\n                </span><span class="s1">return this.renderArrayFieldItem({</span><span class="s3">\n                    </span><span class="s1">key,</span><span class="s3">\n                    </span><span class="s1">index,</span><span class="s3">\n                    </span><span class="s1">name: name &amp;&amp; `${name}-${index}`,</span><span class="s3">\n                    </span><span class="s1">canAdd,</span><span class="s3">\n                    </span><span class="s1">canRemove: additional,</span><span class="s3">\n                    </span><span class="s1">canMoveUp: index &gt;= itemSchemas.length + 1,</span><span class="s3">\n                    </span><span class="s1">canMoveDown: additional &amp;&amp; index &lt; items.length - 1,</span><span class="s3">\n                    </span><span class="s1">itemSchema,</span><span class="s3">\n                    </span><span class="s1">itemData: itemCast,</span><span class="s3">\n                    </span><span class="s1">itemUiSchema,</span><span class="s3">\n                    </span><span class="s1">itemIdSchema,</span><span class="s3">\n                    </span><span class="s1">itemErrorSchema,</span><span class="s3">\n                    </span><span class="s1">autofocus: autofocus &amp;&amp; index === 0,</span><span class="s3">\n                    </span><span class="s1">onBlur,</span><span class="s3">\n                    </span><span class="s1">onFocus,</span><span class="s3">\n                    </span><span class="s1">rawErrors,</span><span class="s3">\n                    </span><span class="s1">totalItems: keyedFormData.length,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">onAddClick: this.onAddClick,</span><span class="s3">\n            </span><span class="s1">readonly,</span><span class="s3">\n            </span><span class="s1">required,</span><span class="s3">\n            </span><span class="s1">registry,</span><span class="s3">\n            </span><span class="s1">schema,</span><span class="s3">\n            </span><span class="s1">uiSchema,</span><span class="s3">\n            </span><span class="s1">title,</span><span class="s3">\n            </span><span class="s1">formContext,</span><span class="s3">\n            </span><span class="s1">rawErrors,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const Template = getTemplate('ArrayFieldTemplate', registry, uiOptions);</span><span class="s3">\n        </span><span class="s1">return _jsx(Template, { ...arrayProps });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders the individual array item using a `SchemaField` along with the additional properties required to be send</span><span class="s3">\n     </span><span class="s1">* back to the `ArrayFieldItemTemplate`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param props - The props for the individual array item to be rendered</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">renderArrayFieldItem(props) {</span><span class="s3">\n        </span><span class="s1">const { key, index, name, canAdd, canRemove = true, canMoveUp, canMoveDown, itemSchema, itemData, itemUiSchema, itemIdSchema, itemErrorSchema, autofocus, onBlur, onFocus, rawErrors, totalItems, } = props;</span><span class="s3">\n        </span><span class="s1">const { disabled, hideError, idPrefix, idSeparator, readonly, uiSchema, registry, formContext } = this.props;</span><span class="s3">\n        </span><span class="s1">const { fields: { ArraySchemaField, SchemaField }, globalUiOptions, } = registry;</span><span class="s3">\n        </span><span class="s1">const ItemSchemaField = ArraySchemaField || SchemaField;</span><span class="s3">\n        </span><span class="s1">const { orderable = true, removable = true, copyable = false } = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const has = {</span><span class="s3">\n            </span><span class="s1">moveUp: orderable &amp;&amp; canMoveUp,</span><span class="s3">\n            </span><span class="s1">moveDown: orderable &amp;&amp; canMoveDown,</span><span class="s3">\n            </span><span class="s1">copy: copyable &amp;&amp; canAdd,</span><span class="s3">\n            </span><span class="s1">remove: removable &amp;&amp; canRemove,</span><span class="s3">\n            </span><span class="s1">toolbar: false,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">has.toolbar = Object.keys(has).some((key) =&gt; has[key]);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">children: (_jsx(ItemSchemaField, { name: name, index: index, schema: itemSchema, uiSchema: itemUiSchema, formData: itemData, formContext: formContext, errorSchema: itemErrorSchema, idPrefix: idPrefix, idSeparator: idSeparator, idSchema: itemIdSchema, required: this.isItemRequired(itemSchema), onChange: this.onChangeForIndex(index), onBlur: onBlur, onFocus: onFocus, registry: registry, disabled: disabled, readonly: readonly, hideError: hideError, autofocus: autofocus, rawErrors: rawErrors })),</span><span class="s3">\n            </span><span class="s1">className: 'array-item',</span><span class="s3">\n            </span><span class="s1">disabled,</span><span class="s3">\n            </span><span class="s1">canAdd,</span><span class="s3">\n            </span><span class="s1">hasCopy: has.copy,</span><span class="s3">\n            </span><span class="s1">hasToolbar: has.toolbar,</span><span class="s3">\n            </span><span class="s1">hasMoveUp: has.moveUp,</span><span class="s3">\n            </span><span class="s1">hasMoveDown: has.moveDown,</span><span class="s3">\n            </span><span class="s1">hasRemove: has.remove,</span><span class="s3">\n            </span><span class="s1">index,</span><span class="s3">\n            </span><span class="s1">totalItems,</span><span class="s3">\n            </span><span class="s1">key,</span><span class="s3">\n            </span><span class="s1">onAddIndexClick: this.onAddIndexClick,</span><span class="s3">\n            </span><span class="s1">onCopyIndexClick: this.onCopyIndexClick,</span><span class="s3">\n            </span><span class="s1">onDropIndexClick: this.onDropIndexClick,</span><span class="s3">\n            </span><span class="s1">onReorderClick: this.onReorderClick,</span><span class="s3">\n            </span><span class="s1">readonly,</span><span class="s3">\n            </span><span class="s1">registry,</span><span class="s3">\n            </span><span class="s1">schema: itemSchema,</span><span class="s3">\n            </span><span class="s1">uiSchema: itemUiSchema,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** `ArrayField` is `React.ComponentType&lt;FieldProps&lt;T[], S, F&gt;&gt;` (necessarily) but the `registry` requires things to be a</span><span class="s3">\n </span><span class="s1">* `Field` which is defined as `React.ComponentType&lt;FieldProps&lt;T, S, F&gt;&gt;`, so cast it to make `registry` happy.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default ArrayField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ArrayField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getWidget, getUiOptions, optionsList, TranslatableString, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">/** The `BooleanField` component is used to render a field in the schema is boolean. It constructs `enumOptions` for the</span><span class="s3">\n </span><span class="s1">* two boolean values based on the various alternatives in the schema.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function BooleanField(props) {</span><span class="s3">\n    </span><span class="s1">var _a, _b;</span><span class="s3">\n    </span><span class="s1">const { schema, name, uiSchema, idSchema, formData, registry, required, disabled, readonly, hideError, autofocus, onChange, onFocus, onBlur, rawErrors, } = props;</span><span class="s3">\n    </span><span class="s1">const { title } = schema;</span><span class="s3">\n    </span><span class="s1">const { widgets, formContext, translateString, globalUiOptions } = registry;</span><span class="s3">\n    </span><span class="s1">const { widget = 'checkbox', title: uiTitle, </span><span class="s3">\n    </span><span class="s1">// Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type</span><span class="s3">\n    </span><span class="s1">label: displayLabel = true, ...options } = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n    </span><span class="s1">const Widget = getWidget(schema, widget, widgets);</span><span class="s3">\n    </span><span class="s1">const yes = translateString(TranslatableString.YesLabel);</span><span class="s3">\n    </span><span class="s1">const no = translateString(TranslatableString.NoLabel);</span><span class="s3">\n    </span><span class="s1">let enumOptions;</span><span class="s3">\n    </span><span class="s1">const label = (_a = uiTitle !== null &amp;&amp; uiTitle !== void 0 ? uiTitle : title) !== null &amp;&amp; _a !== void 0 ? _a : name;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(schema.oneOf)) {</span><span class="s3">\n        </span><span class="s1">enumOptions = optionsList({</span><span class="s3">\n            </span><span class="s1">oneOf: schema.oneOf</span><span class="s3">\n                </span><span class="s1">.map((option) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (isObject(option)) {</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">...option,</span><span class="s3">\n                        </span><span class="s1">title: option.title || (option.const === true ? yes : no),</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return undefined;</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">.filter((o) =&gt; o), // cast away the error that typescript can't grok is fixed</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// We deprecated enumNames in v5. It's intentionally omitted from RSJFSchema type, so we need to cast here.</span><span class="s3">\n        </span><span class="s1">const schemaWithEnumNames = schema;</span><span class="s3">\n        </span><span class="s1">const enums = (_b = schema.enum) !== null &amp;&amp; _b !== void 0 ? _b : [true, false];</span><span class="s3">\n        </span><span class="s1">if (!schemaWithEnumNames.enumNames &amp;&amp; enums.length === 2 &amp;&amp; enums.every((v) =&gt; typeof v === 'boolean')) {</span><span class="s3">\n            </span><span class="s1">enumOptions = [</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">value: enums[0],</span><span class="s3">\n                    </span><span class="s1">label: enums[0] ? yes : no,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">value: enums[1],</span><span class="s3">\n                    </span><span class="s1">label: enums[1] ? yes : no,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">enumOptions = optionsList({</span><span class="s3">\n                </span><span class="s1">enum: enums,</span><span class="s3">\n                </span><span class="s1">// NOTE: enumNames is deprecated, but still supported for now.</span><span class="s3">\n                </span><span class="s1">enumNames: schemaWithEnumNames.enumNames,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsx(Widget, { options: { ...options, enumOptions }, schema: schema, uiSchema: uiSchema, id: idSchema.$id, name: name, onChange: onChange, onFocus: onFocus, onBlur: onBlur, label: label, hideLabel: !displayLabel, value: formData, required: required, disabled: disabled, readonly: readonly, hideError: hideError, registry: registry, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default BooleanField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=BooleanField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Component } from 'react';</span><span class="s3">\n</span><span class="s1">import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEmpty from 'lodash/isEmpty';</span><span class="s3">\n</span><span class="s1">import omit from 'lodash/omit';</span><span class="s3">\n</span><span class="s1">import { deepEquals, ERRORS_KEY, getDiscriminatorFieldFromSchema, getUiOptions, getWidget, mergeSchemas, TranslatableString, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `AnyOfField` component is used to render a field in the schema that is an `anyOf`, `allOf` or `oneOf`. It tracks</span><span class="s3">\n </span><span class="s1">* the currently selected option and cleans up any irrelevant data in `formData`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class AnyOfField extends Component {</span><span class="s3">\n    </span><span class="s1">/** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(props) {</span><span class="s3">\n        </span><span class="s1">super(props);</span><span class="s3">\n        </span><span class="s1">/** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated</span><span class="s3">\n         </span><span class="s1">* to remove properties that are not part of the newly selected option schema, and then the updated data is passed to</span><span class="s3">\n         </span><span class="s1">* the `onChange` handler.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param option - The new option value being selected</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onOptionChange = (option) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { selectedOption, retrievedOptions } = this.state;</span><span class="s3">\n            </span><span class="s1">const { formData, onChange, registry } = this.props;</span><span class="s3">\n            </span><span class="s1">const { schemaUtils } = registry;</span><span class="s3">\n            </span><span class="s1">const intOption = option !== undefined ? parseInt(option, 10) : -1;</span><span class="s3">\n            </span><span class="s1">if (intOption === selectedOption) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const newOption = intOption &gt;= 0 ? retrievedOptions[intOption] : undefined;</span><span class="s3">\n            </span><span class="s1">const oldOption = selectedOption &gt;= 0 ? retrievedOptions[selectedOption] : undefined;</span><span class="s3">\n            </span><span class="s1">let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);</span><span class="s3">\n            </span><span class="s1">if (newFormData &amp;&amp; newOption) {</span><span class="s3">\n                </span><span class="s1">// Call getDefaultFormState to make sure defaults are populated on change. Pass </span><span class="s3">\&quot;</span><span class="s1">excludeObjectChildren</span><span class="s3">\&quot;\n                </span><span class="s1">// so that only the root objects themselves are created without adding undefined children properties</span><span class="s3">\n                </span><span class="s1">newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, 'excludeObjectChildren');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">onChange(newFormData, undefined, this.getFieldId());</span><span class="s3">\n            </span><span class="s1">this.setState({ selectedOption: intOption });</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const { formData, options, registry: { schemaUtils }, } = this.props;</span><span class="s3">\n        </span><span class="s1">// cache the retrieved options in state in case they have $refs to save doing it later</span><span class="s3">\n        </span><span class="s1">const retrievedOptions = options.map((opt) =&gt; schemaUtils.retrieveSchema(opt, formData));</span><span class="s3">\n        </span><span class="s1">this.state = {</span><span class="s3">\n            </span><span class="s1">retrievedOptions,</span><span class="s3">\n            </span><span class="s1">selectedOption: this.getMatchingOption(0, formData, retrievedOptions),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the</span><span class="s3">\n     </span><span class="s1">* currently selected option based on the overall `formData`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param prevProps - The previous `FieldProps` for this template</span><span class="s3">\n     </span><span class="s1">* @param prevState - The previous `AnyOfFieldState` for this template</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">componentDidUpdate(prevProps, prevState) {</span><span class="s3">\n        </span><span class="s1">const { formData, options, idSchema } = this.props;</span><span class="s3">\n        </span><span class="s1">const { selectedOption } = this.state;</span><span class="s3">\n        </span><span class="s1">let newState = this.state;</span><span class="s3">\n        </span><span class="s1">if (!deepEquals(prevProps.options, options)) {</span><span class="s3">\n            </span><span class="s1">const { registry: { schemaUtils }, } = this.props;</span><span class="s3">\n            </span><span class="s1">// re-cache the retrieved options in state in case they have $refs to save doing it later</span><span class="s3">\n            </span><span class="s1">const retrievedOptions = options.map((opt) =&gt; schemaUtils.retrieveSchema(opt, formData));</span><span class="s3">\n            </span><span class="s1">newState = { selectedOption, retrievedOptions };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!deepEquals(formData, prevProps.formData) &amp;&amp; idSchema.$id === prevProps.idSchema.$id) {</span><span class="s3">\n            </span><span class="s1">const { retrievedOptions } = newState;</span><span class="s3">\n            </span><span class="s1">const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);</span><span class="s3">\n            </span><span class="s1">if (prevState &amp;&amp; matchingOption !== selectedOption) {</span><span class="s3">\n                </span><span class="s1">newState = { selectedOption: matchingOption, retrievedOptions };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (newState !== this.state) {</span><span class="s3">\n            </span><span class="s1">this.setState(newState);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Determines the best matching option for the given `formData` and `options`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The new formData</span><span class="s3">\n     </span><span class="s1">* @param options - The list of options to choose from</span><span class="s3">\n     </span><span class="s1">* @return - The index of the `option` that best matches the `formData`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getMatchingOption(selectedOption, formData, options) {</span><span class="s3">\n        </span><span class="s1">const { schema, registry: { schemaUtils }, } = this.props;</span><span class="s3">\n        </span><span class="s1">const discriminator = getDiscriminatorFieldFromSchema(schema);</span><span class="s3">\n        </span><span class="s1">const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);</span><span class="s3">\n        </span><span class="s1">return option;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getFieldId() {</span><span class="s3">\n        </span><span class="s1">const { idSchema, schema } = this.props;</span><span class="s3">\n        </span><span class="s1">return `${idSchema.$id}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">render() {</span><span class="s3">\n        </span><span class="s1">const { name, disabled = false, errorSchema = {}, formContext, onBlur, onFocus, registry, schema, uiSchema, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { widgets, fields, translateString, globalUiOptions, schemaUtils } = registry;</span><span class="s3">\n        </span><span class="s1">const { SchemaField: _SchemaField } = fields;</span><span class="s3">\n        </span><span class="s1">const { selectedOption, retrievedOptions } = this.state;</span><span class="s3">\n        </span><span class="s1">const { widget = 'select', placeholder, autofocus, autocomplete, title = schema.title, ...uiOptions } = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const Widget = getWidget({ type: 'number' }, widget, widgets);</span><span class="s3">\n        </span><span class="s1">const rawErrors = get(errorSchema, ERRORS_KEY, []);</span><span class="s3">\n        </span><span class="s1">const fieldErrorSchema = omit(errorSchema, [ERRORS_KEY]);</span><span class="s3">\n        </span><span class="s1">const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const option = selectedOption &gt;= 0 ? retrievedOptions[selectedOption] || null : null;</span><span class="s3">\n        </span><span class="s1">let optionSchema;</span><span class="s3">\n        </span><span class="s1">if (option) {</span><span class="s3">\n            </span><span class="s1">// merge top level required field</span><span class="s3">\n            </span><span class="s1">const { required } = schema;</span><span class="s3">\n            </span><span class="s1">// Merge in all the non-oneOf/anyOf properties and also skip the special ADDITIONAL_PROPERTY_FLAG property</span><span class="s3">\n            </span><span class="s1">optionSchema = required ? mergeSchemas({ required }, option) : option;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const translateEnum = title</span><span class="s3">\n            </span><span class="s1">? TranslatableString.TitleOptionPrefix</span><span class="s3">\n            </span><span class="s1">: TranslatableString.OptionPrefix;</span><span class="s3">\n        </span><span class="s1">const translateParams = title ? [title] : [];</span><span class="s3">\n        </span><span class="s1">const enumOptions = retrievedOptions.map((opt, index) =&gt; ({</span><span class="s3">\n            </span><span class="s1">label: opt.title || translateString(translateEnum, translateParams.concat(String(index + 1))),</span><span class="s3">\n            </span><span class="s1">value: index,</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'panel panel-default panel-body', children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'form-group', children: _jsx(Widget, { id: this.getFieldId(), name: `${name}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`, schema: { type: 'number', default: 0 }, onChange: this.onOptionChange, onBlur: onBlur, onFocus: onFocus, disabled: disabled || isEmpty(enumOptions), multiple: false, rawErrors: rawErrors, errorSchema: fieldErrorSchema, value: selectedOption &gt;= 0 ? selectedOption : undefined, options: { enumOptions, ...uiOptions }, registry: registry, formContext: formContext, placeholder: placeholder, autocomplete: autocomplete, autofocus: autofocus, label: title !== null &amp;&amp; title !== void 0 ? title : name, hideLabel: !displayLabel }) }), option !== null &amp;&amp; _jsx(_SchemaField, { ...this.props, schema: optionSchema })] }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default AnyOfField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=MultiSchemaField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useState, useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { asNumber } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">// Matches a string that ends in a . character, optionally followed by a sequence of</span><span class="s3">\n</span><span class="s1">// digits followed by any number of 0 characters up until the end of the line.</span><span class="s3">\n</span><span class="s1">// Ensuring that there is at least one prefixed character is important so that</span><span class="s3">\n</span><span class="s1">// you don't incorrectly match against </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n</span><span class="s1">const trailingCharMatcherWithPrefix = /</span><span class="s3">\\</span><span class="s1">.([0-9]*0)*$/;</span><span class="s3">\n</span><span class="s1">// This is used for trimming the trailing 0 and . characters without affecting</span><span class="s3">\n</span><span class="s1">// the rest of the string. Its possible to use one RegEx with groups for this</span><span class="s3">\n</span><span class="s1">// functionality, but it is fairly complex compared to simply defining two</span><span class="s3">\n</span><span class="s1">// different matchers.</span><span class="s3">\n</span><span class="s1">const trailingCharMatcher = /[0.]0*$/;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The NumberField class has some special handling for dealing with trailing</span><span class="s3">\n </span><span class="s1">* decimal points and/or zeroes. This logic is designed to allow trailing values</span><span class="s3">\n </span><span class="s1">* to be visible in the input element, but not be represented in the</span><span class="s3">\n </span><span class="s1">* corresponding form data.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The algorithm is as follows:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* 1. When the input value changes the value is cached in the component state</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* 2. The value is then normalized, removing trailing decimal points and zeros,</span><span class="s3">\n </span><span class="s1">*    then passed to the </span><span class="s3">\&quot;</span><span class="s1">onChange</span><span class="s3">\&quot; </span><span class="s1">callback</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* 3. When the component is rendered, the formData value is checked against the</span><span class="s3">\n </span><span class="s1">*    value cached in the state. If it matches the cached value, the cached</span><span class="s3">\n </span><span class="s1">*    value is passed to the input instead of the formData value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function NumberField(props) {</span><span class="s3">\n    </span><span class="s1">const { registry, onChange, formData, value: initialValue } = props;</span><span class="s3">\n    </span><span class="s1">const [lastValue, setLastValue] = useState(initialValue);</span><span class="s3">\n    </span><span class="s1">const { StringField } = registry.fields;</span><span class="s3">\n    </span><span class="s1">let value = formData;</span><span class="s3">\n    </span><span class="s1">/** Handle the change from the `StringField` to properly convert to a number</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value - The current value for the change occurring</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((value) =&gt; {</span><span class="s3">\n        </span><span class="s1">// Cache the original value in component state</span><span class="s3">\n        </span><span class="s1">setLastValue(value);</span><span class="s3">\n        </span><span class="s1">// Normalize decimals that don't start with a zero character in advance so</span><span class="s3">\n        </span><span class="s1">// that the rest of the normalization logic is simpler</span><span class="s3">\n        </span><span class="s1">if (`${value}`.charAt(0) === '.') {</span><span class="s3">\n            </span><span class="s1">value = `0${value}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Check that the value is a string (this can happen if the widget used is a</span><span class="s3">\n        </span><span class="s1">// &lt;select&gt;, due to an enum declaration etc) then, if the value ends in a</span><span class="s3">\n        </span><span class="s1">// trailing decimal point or multiple zeroes, strip the trailing values</span><span class="s3">\n        </span><span class="s1">const processed = typeof value === 'string' &amp;&amp; value.match(trailingCharMatcherWithPrefix)</span><span class="s3">\n            </span><span class="s1">? asNumber(value.replace(trailingCharMatcher, ''))</span><span class="s3">\n            </span><span class="s1">: asNumber(value);</span><span class="s3">\n        </span><span class="s1">onChange(processed);</span><span class="s3">\n    </span><span class="s1">}, [onChange]);</span><span class="s3">\n    </span><span class="s1">if (typeof lastValue === 'string' &amp;&amp; typeof value === 'number') {</span><span class="s3">\n        </span><span class="s1">// Construct a regular expression that checks for a string that consists</span><span class="s3">\n        </span><span class="s1">// of the formData value suffixed with zero or one '.' characters and zero</span><span class="s3">\n        </span><span class="s1">// or more '0' characters</span><span class="s3">\n        </span><span class="s1">const re = new RegExp(`${value}`.replace('.', '</span><span class="s3">\\\\</span><span class="s1">.') + '</span><span class="s3">\\\\</span><span class="s1">.?0*$');</span><span class="s3">\n        </span><span class="s1">// If the cached </span><span class="s3">\&quot;</span><span class="s1">lastValue</span><span class="s3">\&quot; </span><span class="s1">is a match, use that instead of the formData</span><span class="s3">\n        </span><span class="s1">// value to prevent the input value from changing in the UI</span><span class="s3">\n        </span><span class="s1">if (lastValue.match(re)) {</span><span class="s3">\n            </span><span class="s1">value = lastValue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _jsx(StringField, { ...props, formData: value, onChange: handleChange });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default NumberField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=NumberField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import*as e from</span><span class="s3">\&quot;</span><span class="s1">react</span><span class="s3">\&quot;</span><span class="s1">;function t(){return t=Object.assign?Object.assign.bind():function(e){for(var t=1;t&lt;arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&amp;&amp;(e[r]=n[r])}return e},t.apply(this,arguments)}const n=[</span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">options</span><span class="s3">\&quot;</span><span class="s1">],r={blockQuote:</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,breakLine:</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot;</span><span class="s1">,breakThematic:</span><span class="s3">\&quot;</span><span class="s1">2</span><span class="s3">\&quot;</span><span class="s1">,codeBlock:</span><span class="s3">\&quot;</span><span class="s1">3</span><span class="s3">\&quot;</span><span class="s1">,codeFenced:</span><span class="s3">\&quot;</span><span class="s1">4</span><span class="s3">\&quot;</span><span class="s1">,codeInline:</span><span class="s3">\&quot;</span><span class="s1">5</span><span class="s3">\&quot;</span><span class="s1">,footnote:</span><span class="s3">\&quot;</span><span class="s1">6</span><span class="s3">\&quot;</span><span class="s1">,footnoteReference:</span><span class="s3">\&quot;</span><span class="s1">7</span><span class="s3">\&quot;</span><span class="s1">,gfmTask:</span><span class="s3">\&quot;</span><span class="s1">8</span><span class="s3">\&quot;</span><span class="s1">,heading:</span><span class="s3">\&quot;</span><span class="s1">9</span><span class="s3">\&quot;</span><span class="s1">,headingSetext:</span><span class="s3">\&quot;</span><span class="s1">10</span><span class="s3">\&quot;</span><span class="s1">,htmlBlock:</span><span class="s3">\&quot;</span><span class="s1">11</span><span class="s3">\&quot;</span><span class="s1">,htmlComment:</span><span class="s3">\&quot;</span><span class="s1">12</span><span class="s3">\&quot;</span><span class="s1">,htmlSelfClosing:</span><span class="s3">\&quot;</span><span class="s1">13</span><span class="s3">\&quot;</span><span class="s1">,image:</span><span class="s3">\&quot;</span><span class="s1">14</span><span class="s3">\&quot;</span><span class="s1">,link:</span><span class="s3">\&quot;</span><span class="s1">15</span><span class="s3">\&quot;</span><span class="s1">,linkAngleBraceStyleDetector:</span><span class="s3">\&quot;</span><span class="s1">16</span><span class="s3">\&quot;</span><span class="s1">,linkBareUrlDetector:</span><span class="s3">\&quot;</span><span class="s1">17</span><span class="s3">\&quot;</span><span class="s1">,linkMailtoDetector:</span><span class="s3">\&quot;</span><span class="s1">18</span><span class="s3">\&quot;</span><span class="s1">,newlineCoalescer:</span><span class="s3">\&quot;</span><span class="s1">19</span><span class="s3">\&quot;</span><span class="s1">,orderedList:</span><span class="s3">\&quot;</span><span class="s1">20</span><span class="s3">\&quot;</span><span class="s1">,paragraph:</span><span class="s3">\&quot;</span><span class="s1">21</span><span class="s3">\&quot;</span><span class="s1">,ref:</span><span class="s3">\&quot;</span><span class="s1">22</span><span class="s3">\&quot;</span><span class="s1">,refImage:</span><span class="s3">\&quot;</span><span class="s1">23</span><span class="s3">\&quot;</span><span class="s1">,refLink:</span><span class="s3">\&quot;</span><span class="s1">24</span><span class="s3">\&quot;</span><span class="s1">,table:</span><span class="s3">\&quot;</span><span class="s1">25</span><span class="s3">\&quot;</span><span class="s1">,tableSeparator:</span><span class="s3">\&quot;</span><span class="s1">26</span><span class="s3">\&quot;</span><span class="s1">,text:</span><span class="s3">\&quot;</span><span class="s1">27</span><span class="s3">\&quot;</span><span class="s1">,textBolded:</span><span class="s3">\&quot;</span><span class="s1">28</span><span class="s3">\&quot;</span><span class="s1">,textEmphasized:</span><span class="s3">\&quot;</span><span class="s1">29</span><span class="s3">\&quot;</span><span class="s1">,textEscaped:</span><span class="s3">\&quot;</span><span class="s1">30</span><span class="s3">\&quot;</span><span class="s1">,textMarked:</span><span class="s3">\&quot;</span><span class="s1">31</span><span class="s3">\&quot;</span><span class="s1">,textStrikethroughed:</span><span class="s3">\&quot;</span><span class="s1">32</span><span class="s3">\&quot;</span><span class="s1">,unorderedList:</span><span class="s3">\&quot;</span><span class="s1">33</span><span class="s3">\&quot;</span><span class="s1">};var i;!function(e){e[e.MAX=0]=</span><span class="s3">\&quot;</span><span class="s1">MAX</span><span class="s3">\&quot;</span><span class="s1">,e[e.HIGH=1]=</span><span class="s3">\&quot;</span><span class="s1">HIGH</span><span class="s3">\&quot;</span><span class="s1">,e[e.MED=2]=</span><span class="s3">\&quot;</span><span class="s1">MED</span><span class="s3">\&quot;</span><span class="s1">,e[e.LOW=3]=</span><span class="s3">\&quot;</span><span class="s1">LOW</span><span class="s3">\&quot;</span><span class="s1">,e[e.MIN=4]=</span><span class="s3">\&quot;</span><span class="s1">MIN</span><span class="s3">\&quot;</span><span class="s1">}(i||(i={}));const l=[</span><span class="s3">\&quot;</span><span class="s1">allowFullScreen</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">allowTransparency</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">autoComplete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">autoFocus</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">autoPlay</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">cellPadding</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">cellSpacing</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">charSet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">classId</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">colSpan</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">contentEditable</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">contextMenu</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">crossOrigin</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">encType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">formAction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">formEncType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">formMethod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">formNoValidate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">formTarget</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">frameBorder</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hrefLang</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">inputMode</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">keyParams</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">keyType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">marginHeight</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">marginWidth</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">maxLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">mediaGroup</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">minLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">noValidate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">radioGroup</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">readOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rowSpan</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">spellCheck</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">srcDoc</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">srcLang</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">srcSet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">tabIndex</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">useMap</span><span class="s3">\&quot;</span><span class="s1">].reduce((e,t)=&gt;(e[t.toLowerCase()]=t,e),{class:</span><span class="s3">\&quot;</span><span class="s1">className</span><span class="s3">\&quot;</span><span class="s1">,for:</span><span class="s3">\&quot;</span><span class="s1">htmlFor</span><span class="s3">\&quot;</span><span class="s1">}),a={amp:</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">,apos:</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">,gt:</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">,lt:</span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">,nbsp:</span><span class="s3">\&quot;</span><span class="s1"> </span><span class="s3">\&quot;</span><span class="s1">,quot:</span><span class="s3">\&quot;</span><span class="s1">“</span><span class="s3">\&quot;</span><span class="s1">},o=[</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot;</span><span class="s1">],c=/([-A-Z0-9_:]+)(?:</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*(?:(?:</span><span class="s3">\&quot;</span><span class="s1">((?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\&quot;</span><span class="s1">])*)</span><span class="s3">\&quot;</span><span class="s1">)|(?:'((?:</span><span class="s3">\\\\</span><span class="s1">.|[^'])*)')|(?:</span><span class="s3">\\</span><span class="s1">{((?:</span><span class="s3">\\\\</span><span class="s1">.|{[^}]*?}|[^}])*)</span><span class="s3">\\</span><span class="s1">})))?/gi,s=/mailto:/i,d=/</span><span class="s3">\\</span><span class="s1">n{2,}$/,u=/^(</span><span class="s3">\\</span><span class="s1">s*&gt;[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?)(?=</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n|$)/,p=/^ *&gt; ?/gm,f=/^(?:</span><span class="s3">\\</span><span class="s1">[!([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">n)?([</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*)/,h=/^ {2,}</span><span class="s3">\\</span><span class="s1">n/,m=/^(?:( *[-*_])){3,} *(?:</span><span class="s3">\\</span><span class="s1">n *)+</span><span class="s3">\\</span><span class="s1">n/,g=/^(?: {1,3})?(`{3,}|~{3,}) *(</span><span class="s3">\\</span><span class="s1">S+)? *([^</span><span class="s3">\\</span><span class="s1">n]*?)?</span><span class="s3">\\</span><span class="s1">n([</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?)(?:</span><span class="s3">\\</span><span class="s1">1</span><span class="s3">\\</span><span class="s1">n?|$)/,y=/^(?: {4}[^</span><span class="s3">\\</span><span class="s1">n]+</span><span class="s3">\\</span><span class="s1">n*)+(?:</span><span class="s3">\\</span><span class="s1">n *)+</span><span class="s3">\\</span><span class="s1">n?/,k=/^(`+)((?:</span><span class="s3">\\\\</span><span class="s1">`|[^`])+)</span><span class="s3">\\</span><span class="s1">1/,x=/^(?:</span><span class="s3">\\</span><span class="s1">n *)*</span><span class="s3">\\</span><span class="s1">n/,b=/</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?/g,v=/^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">^([^</span><span class="s3">\\</span><span class="s1">]]+)](:(.*)((</span><span class="s3">\\</span><span class="s1">n+ {4,}.*)|(</span><span class="s3">\\</span><span class="s1">n(?!</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">^).+))*)/,C=/^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">^([^</span><span class="s3">\\</span><span class="s1">]]+)]/,$=/</span><span class="s3">\\</span><span class="s1">f/g,S=/^---[ </span><span class="s3">\\</span><span class="s1">t]*</span><span class="s3">\\</span><span class="s1">n(.|</span><span class="s3">\\</span><span class="s1">n)*</span><span class="s3">\\</span><span class="s1">n---[ </span><span class="s3">\\</span><span class="s1">t]*</span><span class="s3">\\</span><span class="s1">n/,w=/^</span><span class="s3">\\</span><span class="s1">s*?</span><span class="s3">\\</span><span class="s1">[(x|</span><span class="s3">\\</span><span class="s1">s)</span><span class="s3">\\</span><span class="s1">]/,E=/^ *(#{1,6}) *([^</span><span class="s3">\\</span><span class="s1">n]+?)(?: +#*)?(?:</span><span class="s3">\\</span><span class="s1">n *)*(?:</span><span class="s3">\\</span><span class="s1">n|$)/,z=/^ *(#{1,6}) +([^</span><span class="s3">\\</span><span class="s1">n]+?)(?: +#*)?(?:</span><span class="s3">\\</span><span class="s1">n *)*(?:</span><span class="s3">\\</span><span class="s1">n|$)/,L=/^([^</span><span class="s3">\\</span><span class="s1">n]+)</span><span class="s3">\\</span><span class="s1">n *(=|-){3,} *(?:</span><span class="s3">\\</span><span class="s1">n *)+</span><span class="s3">\\</span><span class="s1">n/,A=/^ *(?!&lt;[a-z][^ &gt;/]* ?</span><span class="s3">\\</span><span class="s1">/&gt;)&lt;([a-z][^ &gt;/]*) ?((?:[^&gt;]*[^/])?)&gt;</span><span class="s3">\\</span><span class="s1">n?(</span><span class="s3">\\</span><span class="s1">s*(?:&lt;</span><span class="s3">\\</span><span class="s1">1[^&gt;]*?&gt;[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?&lt;</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">1&gt;|(?!&lt;</span><span class="s3">\\</span><span class="s1">1</span><span class="s3">\\</span><span class="s1">b)[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S])*?)&lt;</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">1&gt;(?!&lt;</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">1&gt;)</span><span class="s3">\\</span><span class="s1">n*/i,T=/&amp;([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi,B=/^&lt;!--[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?(?:--&gt;)/,O=/^(data|aria|x)-[a-z_][a-z</span><span class="s3">\\</span><span class="s1">d_.-]*$/,M=/^ *&lt;([a-z][a-z0-9:]*)(?:</span><span class="s3">\\</span><span class="s1">s+((?:&lt;.*?&gt;|[^&gt;])*))?</span><span class="s3">\\</span><span class="s1">/?&gt;(?!&lt;</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">1&gt;)(</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">n)?/i,R=/^</span><span class="s3">\\</span><span class="s1">{.*</span><span class="s3">\\</span><span class="s1">}$/,I=/^(https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/[^</span><span class="s3">\\</span><span class="s1">s&lt;]+[^&lt;.,:;</span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">s])/,U=/^&lt;([^ &gt;]+@[^ &gt;]+)&gt;/,D=/^&lt;([^ &gt;]+:</span><span class="s3">\\</span><span class="s1">/[^ &gt;]+)&gt;/,N=/-([a-z])?/gi,j=/^(</span><span class="s3">\\</span><span class="s1">|.*)</span><span class="s3">\\</span><span class="s1">n(?: *(</span><span class="s3">\\</span><span class="s1">|? *[-:]+ *</span><span class="s3">\\</span><span class="s1">|[-| :]*)</span><span class="s3">\\</span><span class="s1">n((?:.*</span><span class="s3">\\</span><span class="s1">|.*</span><span class="s3">\\</span><span class="s1">n)*))?</span><span class="s3">\\</span><span class="s1">n?/,H=/^</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">]:</span><span class="s3">\\</span><span class="s1">s+&lt;?([^</span><span class="s3">\\</span><span class="s1">s&gt;]+)&gt;?</span><span class="s3">\\</span><span class="s1">s*(</span><span class="s3">\&quot;</span><span class="s1">([^</span><span class="s3">\&quot;</span><span class="s1">]*)</span><span class="s3">\&quot;</span><span class="s1">)?/,P=/^!</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">] ?</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">]/,_=/^</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">] ?</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">]/,F=/(</span><span class="s3">\\</span><span class="s1">n|^[-*]</span><span class="s3">\\</span><span class="s1">s|^#|^ {2,}|^-{2,}|^&gt;</span><span class="s3">\\</span><span class="s1">s)/,G=/</span><span class="s3">\\</span><span class="s1">t/g,W=/(^ *</span><span class="s3">\\</span><span class="s1">||</span><span class="s3">\\</span><span class="s1">| *$)/g,Z=/^ *:-+: *$/,q=/^ *:-+ *$/,Q=/^ *-+: *$/,V=</span><span class="s3">\&quot;</span><span class="s1">((?:</span><span class="s3">\\\\</span><span class="s1">[.*?</span><span class="s3">\\\\</span><span class="s1">][([].*?[)</span><span class="s3">\\\\</span><span class="s1">]]|&lt;.*?&gt;(?:.*?&lt;.*?&gt;)?|`.*?`|</span><span class="s3">\\\\\\\\\\\\</span><span class="s1">1|[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S])+?)</span><span class="s3">\&quot;</span><span class="s1">,X=new RegExp(`^([*_])</span><span class="s3">\\\\</span><span class="s1">1${V}</span><span class="s3">\\\\</span><span class="s1">1</span><span class="s3">\\\\</span><span class="s1">1(?!</span><span class="s3">\\\\</span><span class="s1">1)`),J=new RegExp(`^([*_])${V}</span><span class="s3">\\\\</span><span class="s1">1(?!</span><span class="s3">\\\\</span><span class="s1">1)`),K=new RegExp(`^(==)${V}</span><span class="s3">\\\\</span><span class="s1">1`),Y=new RegExp(`^(~~)${V}</span><span class="s3">\\\\</span><span class="s1">1`),ee=/^</span><span class="s3">\\\\</span><span class="s1">([^0-9A-Za-z</span><span class="s3">\\</span><span class="s1">s])/,te=/</span><span class="s3">\\\\</span><span class="s1">([^0-9A-Za-z</span><span class="s3">\\</span><span class="s1">s])/g,ne=/^([</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S](?:(?!  |[0-9]</span><span class="s3">\\</span><span class="s1">.)[^*_~</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">n&lt;`</span><span class="s3">\\\\\\</span><span class="s1">[!])*)/,re=/^</span><span class="s3">\\</span><span class="s1">n+/,ie=/^([ </span><span class="s3">\\</span><span class="s1">t]*)/,le=/</span><span class="s3">\\\\</span><span class="s1">([^</span><span class="s3">\\\\</span><span class="s1">])/g,ae=/(?:^|</span><span class="s3">\\</span><span class="s1">n)( *)$/,oe=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\</span><span class="s1">d+</span><span class="s3">\\\\</span><span class="s1">.)</span><span class="s3">\&quot;</span><span class="s1">,ce=</span><span class="s3">\&quot;</span><span class="s1">(?:[*+-])</span><span class="s3">\&quot;</span><span class="s1">;function se(e){return</span><span class="s3">\&quot;</span><span class="s1">( *)(</span><span class="s3">\&quot;</span><span class="s1">+(1===e?oe:ce)+</span><span class="s3">\&quot;</span><span class="s1">) +</span><span class="s3">\&quot;</span><span class="s1">}const de=se(1),ue=se(2);function pe(e){return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">+(1===e?de:ue))}const fe=pe(1),he=pe(2);function me(e){return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">+(1===e?de:ue)+</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">n]*(?:</span><span class="s3">\\\\</span><span class="s1">n(?!</span><span class="s3">\\\\</span><span class="s1">1</span><span class="s3">\&quot;</span><span class="s1">+(1===e?oe:ce)+</span><span class="s3">\&quot; </span><span class="s1">)[^</span><span class="s3">\\\\</span><span class="s1">n]*)*(</span><span class="s3">\\\\</span><span class="s1">n|$)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">gm</span><span class="s3">\&quot;</span><span class="s1">)}const ge=me(1),ye=me(2);function ke(e){const t=1===e?oe:ce;return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^( *)(</span><span class="s3">\&quot;</span><span class="s1">+t+</span><span class="s3">\&quot;</span><span class="s1">) [</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]+?(?:</span><span class="s3">\\\\</span><span class="s1">n{2,}(?! )(?!</span><span class="s3">\\\\</span><span class="s1">1</span><span class="s3">\&quot;</span><span class="s1">+t+</span><span class="s3">\&quot; </span><span class="s1">(?!</span><span class="s3">\&quot;</span><span class="s1">+t+</span><span class="s3">\&quot; </span><span class="s1">))</span><span class="s3">\\\\</span><span class="s1">n*|</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">n*$)</span><span class="s3">\&quot;</span><span class="s1">)}const xe=ke(1),be=ke(2);function ve(e,t){const n=1===t,i=n?xe:be,l=n?ge:ye,a=n?fe:he;return{match:Oe(function(e,t){const n=ae.exec(t.prevCapture);return n&amp;&amp;(t.list||!t.inline&amp;&amp;!t.simple)?i.exec(e=n[1]+e):null}),order:1,parse(e,t,r){const i=n?+e[2]:void 0,o=e[0].replace(d,</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).match(l);let c=!1;return{items:o.map(function(e,n){const i=a.exec(e)[0].length,l=new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^ {1,</span><span class="s3">\&quot;</span><span class="s1">+i+</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">gm</span><span class="s3">\&quot;</span><span class="s1">),s=e.replace(l,</span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(a,</span><span class="s3">\&quot;\&quot;</span><span class="s1">),d=n===o.length-1,u=-1!==s.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">)||d&amp;&amp;c;c=u;const p=r.inline,f=r.list;let h;r.list=!0,u?(r.inline=!1,h=Ee(s)+</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">):(r.inline=!0,h=Ee(s));const m=t(h,r);return r.inline=p,r.list=f,m}),ordered:n,start:i}},render:(t,n,i)=&gt;e(t.ordered?</span><span class="s3">\&quot;</span><span class="s1">ol</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">,{key:i.key,start:t.type===r.orderedList?t.start:void 0},t.items.map(function(t,r){return e(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">,{key:r},n(t,i))}))}}const Ce=new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">[((?:</span><span class="s3">\\\\</span><span class="s1">[[^</span><span class="s3">\\\\</span><span class="s1">]]*</span><span class="s3">\\\\</span><span class="s1">]|[^</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]]|</span><span class="s3">\\\\</span><span class="s1">](?=[^</span><span class="s3">\\\\</span><span class="s1">[]*</span><span class="s3">\\\\</span><span class="s1">]))*)</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">s*&lt;?((?:</span><span class="s3">\\\\</span><span class="s1">([^)]*</span><span class="s3">\\\\</span><span class="s1">)|[^</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\\\\\</span><span class="s1">]|</span><span class="s3">\\\\\\\\</span><span class="s1">.)*?)&gt;?(?:</span><span class="s3">\\\\</span><span class="s1">s+['</span><span class="s3">\\\&quot;</span><span class="s1">]([</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?)['</span><span class="s3">\\\&quot;</span><span class="s1">])?</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),$e=/^!</span><span class="s3">\\</span><span class="s1">[(.*?)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">( *((?:</span><span class="s3">\\</span><span class="s1">([^)]*</span><span class="s3">\\</span><span class="s1">)|[^() ])*) *</span><span class="s3">\&quot;</span><span class="s1">?([^)</span><span class="s3">\&quot;</span><span class="s1">]*)?</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\</span><span class="s1">)/,Se=[u,g,y,E,L,z,j,xe,be],we=[...Se,/^[^</span><span class="s3">\\</span><span class="s1">n]+(?:  </span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">n{2,})/,A,B,M];function Ee(e){let t=e.length;for(;t&gt;0&amp;&amp;e[t-1]&lt;=</span><span class="s3">\&quot; \&quot;</span><span class="s1">;)t--;return e.slice(0,t)}function ze(e){return e.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g,</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">).replace(/[çÇ]/g,</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">).replace(/[ðÐ]/g,</span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">).replace(/[ÈÉÊËéèêë]/g,</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot;</span><span class="s1">).replace(/[ÏïÎîÍíÌì]/g,</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">).replace(/[Ññ]/g,</span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).replace(/[øØœŒÕõÔôÓóÒò]/g,</span><span class="s3">\&quot;</span><span class="s1">o</span><span class="s3">\&quot;</span><span class="s1">).replace(/[ÜüÛûÚúÙù]/g,</span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">).replace(/[ŸÿÝý]/g,</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">).replace(/[^a-z0-9- ]/gi,</span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(/ /gi,</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">).toLowerCase()}function Le(e){return Q.test(e)?</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">:Z.test(e)?</span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;</span><span class="s1">:q.test(e)?</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:null}function Ae(e,t,n,r){const i=n.inTable;n.inTable=!0;let l=[[]],a=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;function o(){if(!a)return;const e=l[l.length-1];e.push.apply(e,t(a,n)),a=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}return e.trim().split(/(`[^`]*`|</span><span class="s3">\\\\\\</span><span class="s1">||</span><span class="s3">\\</span><span class="s1">|)/).filter(Boolean).forEach((e,t,n)=&gt;{</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">===e.trim()&amp;&amp;(o(),r)?0!==t&amp;&amp;t!==n.length-1&amp;&amp;l.push([]):a+=e}),o(),n.inTable=i,l}function Te(e,t,n){n.inline=!0;const i=e[2]?e[2].replace(W,</span><span class="s3">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">).map(Le):[],l=e[3]?function(e,t,n){return e.trim().split(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).map(function(e){return Ae(e,t,n,!0)})}(e[3],t,n):[],a=Ae(e[1],t,n,!!l.length);return n.inline=!1,l.length?{align:i,cells:l,header:a,type:r.table}:{children:a,type:r.paragraph}}function Be(e,t){return null==e.align[t]?{}:{textAlign:e.align[t]}}function Oe(e){return e.inline=1,e}function Me(e){return Oe(function(t,n){return n.inline?e.exec(t):null})}function Re(e){return Oe(function(t,n){return n.inline||n.simple?e.exec(t):null})}function Ie(e){return function(t,n){return n.inline||n.simple?null:e.exec(t)}}function Ue(e){return Oe(function(t){return e.exec(t)})}function De(e,t){if(t.inline||t.simple)return null;let n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;e.split(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).every(e=&gt;(e+=</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">,!Se.some(t=&gt;t.test(e))&amp;&amp;(n+=e,!!e.trim())));const r=Ee(n);return</span><span class="s3">\&quot;\&quot;</span><span class="s1">==r?null:[n,,r]}function Ne(e){try{if(decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g,</span><span class="s3">\&quot;\&quot;</span><span class="s1">).match(/^</span><span class="s3">\\</span><span class="s1">s*(javascript|vbscript|data(?!:image)):/i))return null}catch(e){return null}return e}function je(e){return e.replace(le,</span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}function He(e,t,n){const r=n.inline||!1,i=n.simple||!1;n.inline=!0,n.simple=!0;const l=e(t,n);return n.inline=r,n.simple=i,l}function Pe(e,t,n){const r=n.inline||!1,i=n.simple||!1;n.inline=!1,n.simple=!0;const l=e(t,n);return n.inline=r,n.simple=i,l}function _e(e,t,n){const r=n.inline||!1;n.inline=!1;const i=e(t,n);return n.inline=r,i}const Fe=(e,t,n)=&gt;({children:He(t,e[2],n)});function Ge(){return{}}function We(){return null}function Ze(...e){return e.filter(Boolean).join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)}function qe(e,t,n){let r=e;const i=t.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);for(;i.length&amp;&amp;(r=r[i[0]],void 0!==r);)i.shift();return r||n}function Qe(n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,i={}){function d(e,n,...r){const l=qe(i.overrides,`${e}.props`,{});return i.createElement(function(e,t){const n=qe(t,e);return n?</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof n||</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof n&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">render</span><span class="s3">\&quot;</span><span class="s1">in n?n:qe(t,`${e}.component`,e):e}(e,i.overrides),t({},n,l,{className:Ze(null==n?void 0:n.className,l.className)||void 0}),...r)}function W(e){e=e.replace(S,</span><span class="s3">\&quot;\&quot;</span><span class="s1">);let t=!1;i.forceInline?t=!0:i.forceBlock||(t=!1===F.test(e));const n=ae(le(t?e:`${Ee(e).replace(re,</span><span class="s3">\&quot;\&quot;</span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`,{inline:t}));for(;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof n[n.length-1]&amp;&amp;!n[n.length-1].trim();)n.pop();if(null===i.wrapper)return n;const r=i.wrapper||(t?</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);let l;if(n.length&gt;1||i.forceWrapper)l=n;else{if(1===n.length)return l=n[0],</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof l?d(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">,{key:</span><span class="s3">\&quot;</span><span class="s1">outer</span><span class="s3">\&quot;</span><span class="s1">},l):l;l=null}return i.createElement(r,{key:</span><span class="s3">\&quot;</span><span class="s1">outer</span><span class="s3">\&quot;</span><span class="s1">},l)}function Z(e,t){const n=t.match(c);return n?n.reduce(function(t,n){const r=n.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);if(-1!==r){const a=function(e){return-1!==e.indexOf(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">)&amp;&amp;null===e.match(O)&amp;&amp;(e=e.replace(N,function(e,t){return t.toUpperCase()})),e}(n.slice(0,r)).trim(),o=function(e){const t=e[0];return('</span><span class="s3">\&quot;</span><span class="s1">'===t||</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">===t)&amp;&amp;e.length&gt;=2&amp;&amp;e[e.length-1]===t?e.slice(1,-1):e}(n.slice(r+1).trim()),c=l[a]||a;if(</span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot;</span><span class="s1">===c)return t;const s=t[c]=function(e,t,n,r){return</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">===t?n.split(/;</span><span class="s3">\\</span><span class="s1">s?/).reduce(function(e,t){const n=t.slice(0,t.indexOf(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">));return e[n.trim().replace(/(-[a-z])/g,e=&gt;e[1].toUpperCase())]=t.slice(n.length+1).trim(),e},{}):</span><span class="s3">\&quot;</span><span class="s1">href</span><span class="s3">\&quot;</span><span class="s1">===t||</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">===t?r(n,e,t):(n.match(R)&amp;&amp;(n=n.slice(1,n.length-1)),</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">===n||</span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">!==n&amp;&amp;n)}(e,a,o,i.sanitizer);</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof s&amp;&amp;(A.test(s)||M.test(s))&amp;&amp;(t[c]=W(s.trim()))}else</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">!==n&amp;&amp;(t[l[n]||n]=!0);return t},{}):null}i.overrides=i.overrides||{},i.sanitizer=i.sanitizer||Ne,i.slugify=i.slugify||ze,i.namedCodesToUnicode=i.namedCodesToUnicode?t({},a,i.namedCodesToUnicode):a,i.createElement=i.createElement||e.createElement;const q=[],Q={},V={[r.blockQuote]:{match:Ie(u),order:1,parse(e,t,n){const[,r,i]=e[0].replace(p,</span><span class="s3">\&quot;\&quot;</span><span class="s1">).match(f);return{alert:r,children:t(i,n)}},render(e,t,n){const l={key:n.key};return e.alert&amp;&amp;(l.className=</span><span class="s3">\&quot;</span><span class="s1">markdown-alert-</span><span class="s3">\&quot;</span><span class="s1">+i.slugify(e.alert.toLowerCase(),ze),e.children.unshift({attrs:{},children:[{type:r.text,text:e.alert}],noInnerParse:!0,type:r.htmlBlock,tag:</span><span class="s3">\&quot;</span><span class="s1">header</span><span class="s3">\&quot;</span><span class="s1">})),d(</span><span class="s3">\&quot;</span><span class="s1">blockquote</span><span class="s3">\&quot;</span><span class="s1">,l,t(e.children,n))}},[r.breakLine]:{match:Ue(h),order:1,parse:Ge,render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">br</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key})},[r.breakThematic]:{match:Ie(m),order:1,parse:Ge,render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">hr</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key})},[r.codeBlock]:{match:Ie(y),order:0,parse:e=&gt;({lang:void 0,text:Ee(e[0].replace(/^ {4}/gm,</span><span class="s3">\&quot;\&quot;</span><span class="s1">)).replace(te,</span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}),render:(e,n,r)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">pre</span><span class="s3">\&quot;</span><span class="s1">,{key:r.key},d(</span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot;</span><span class="s1">,t({},e.attrs,{className:e.lang?`lang-${e.lang}`:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}),e.text))},[r.codeFenced]:{match:Ie(g),order:0,parse:e=&gt;({attrs:Z(</span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot;</span><span class="s1">,e[3]||</span><span class="s3">\&quot;\&quot;</span><span class="s1">),lang:e[2]||void 0,text:e[4].replace(te,</span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">),type:r.codeBlock})},[r.codeInline]:{match:Re(k),order:3,parse:e=&gt;({text:e[2].replace(te,</span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},e.text)},[r.footnote]:{match:Ie(v),order:0,parse:e=&gt;(q.push({footnote:e[2],identifier:e[1]}),{}),render:We},[r.footnoteReference]:{match:Me(C),order:1,parse:e=&gt;({target:`#${i.slugify(e[1],ze)}`,text:e[1]}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key,href:i.sanitizer(e.target,</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">href</span><span class="s3">\&quot;</span><span class="s1">)},d(</span><span class="s3">\&quot;</span><span class="s1">sup</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},e.text))},[r.gfmTask]:{match:Me(w),order:1,parse:e=&gt;({completed:</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">===e[1].toLowerCase()}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">,{checked:e.completed,key:n.key,readOnly:!0,type:</span><span class="s3">\&quot;</span><span class="s1">checkbox</span><span class="s3">\&quot;</span><span class="s1">})},[r.heading]:{match:Ie(i.enforceAtxHeadings?z:E),order:1,parse:(e,t,n)=&gt;({children:He(t,e[2],n),id:i.slugify(e[2],ze),level:e[1].length}),render:(e,t,n)=&gt;d(`h${e.level}`,{id:e.id,key:n.key},t(e.children,n))},[r.headingSetext]:{match:Ie(L),order:0,parse:(e,t,n)=&gt;({children:He(t,e[1],n),level:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">===e[2]?1:2,type:r.heading})},[r.htmlBlock]:{match:Ue(A),order:1,parse(e,t,n){const[,r]=e[3].match(ie),i=new RegExp(`^${r}`,</span><span class="s3">\&quot;</span><span class="s1">gm</span><span class="s3">\&quot;</span><span class="s1">),l=e[3].replace(i,</span><span class="s3">\&quot;\&quot;</span><span class="s1">),a=(c=l,we.some(e=&gt;e.test(c))?_e:He);var c;const s=e[1].toLowerCase(),d=-1!==o.indexOf(s),u=(d?s:e[1]).trim(),p={attrs:Z(u,e[2]),noInnerParse:d,tag:u};return n.inAnchor=n.inAnchor||</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">===s,d?p.text=e[3]:p.children=a(t,l,n),n.inAnchor=!1,p},render:(e,n,r)=&gt;d(e.tag,t({key:r.key},e.attrs),e.text||(e.children?n(e.children,r):</span><span class="s3">\&quot;\&quot;</span><span class="s1">))},[r.htmlSelfClosing]:{match:Ue(M),order:1,parse(e){const t=e[1].trim();return{attrs:Z(t,e[2]||</span><span class="s3">\&quot;\&quot;</span><span class="s1">),tag:t}},render:(e,n,r)=&gt;d(e.tag,t({},e.attrs,{key:r.key}))},[r.htmlComment]:{match:Ue(B),order:1,parse:()=&gt;({}),render:We},[r.image]:{match:Re($e),order:1,parse:e=&gt;({alt:e[1],target:je(e[2]),title:e[3]}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">img</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key,alt:e.alt||void 0,title:e.title||void 0,src:i.sanitizer(e.target,</span><span class="s3">\&quot;</span><span class="s1">img</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">)})},[r.link]:{match:Me(Ce),order:3,parse:(e,t,n)=&gt;({children:Pe(t,e[1],n),target:je(e[2]),title:e[3]}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key,href:i.sanitizer(e.target,</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">href</span><span class="s3">\&quot;</span><span class="s1">),title:e.title},t(e.children,n))},[r.linkAngleBraceStyleDetector]:{match:Me(D),order:0,parse:e=&gt;({children:[{text:e[1],type:r.text}],target:e[1],type:r.link})},[r.linkBareUrlDetector]:{match:Oe((e,t)=&gt;t.inAnchor||i.disableAutoLink?null:Me(I)(e,t)),order:0,parse:e=&gt;({children:[{text:e[1],type:r.text}],target:e[1],title:void 0,type:r.link})},[r.linkMailtoDetector]:{match:Me(U),order:0,parse(e){let t=e[1],n=e[1];return s.test(n)||(n=</span><span class="s3">\&quot;</span><span class="s1">mailto:</span><span class="s3">\&quot;</span><span class="s1">+n),{children:[{text:t.replace(</span><span class="s3">\&quot;</span><span class="s1">mailto:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;\&quot;</span><span class="s1">),type:r.text}],target:n,type:r.link}}},[r.orderedList]:ve(d,1),[r.unorderedList]:ve(d,2),[r.newlineCoalescer]:{match:Ie(x),order:3,parse:Ge,render:()=&gt;</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">},[r.paragraph]:{match:Oe(De),order:3,parse:Fe,render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},t(e.children,n))},[r.ref]:{match:Me(H),order:0,parse:e=&gt;(Q[e[1]]={target:e[2],title:e[4]},{}),render:We},[r.refImage]:{match:Re(P),order:0,parse:e=&gt;({alt:e[1]||void 0,ref:e[2]}),render:(e,t,n)=&gt;Q[e.ref]?d(</span><span class="s3">\&quot;</span><span class="s1">img</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key,alt:e.alt,src:i.sanitizer(Q[e.ref].target,</span><span class="s3">\&quot;</span><span class="s1">img</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">),title:Q[e.ref].title}):null},[r.refLink]:{match:Me(_),order:0,parse:(e,t,n)=&gt;({children:t(e[1],n),fallbackChildren:e[0],ref:e[2]}),render:(e,t,n)=&gt;Q[e.ref]?d(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key,href:i.sanitizer(Q[e.ref].target,</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">href</span><span class="s3">\&quot;</span><span class="s1">),title:Q[e.ref].title},t(e.children,n)):d(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},e.fallbackChildren)},[r.table]:{match:Ie(j),order:1,parse:Te,render(e,t,n){const r=e;return d(</span><span class="s3">\&quot;</span><span class="s1">table</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},d(</span><span class="s3">\&quot;</span><span class="s1">thead</span><span class="s3">\&quot;</span><span class="s1">,null,d(</span><span class="s3">\&quot;</span><span class="s1">tr</span><span class="s3">\&quot;</span><span class="s1">,null,r.header.map(function(e,i){return d(</span><span class="s3">\&quot;</span><span class="s1">th</span><span class="s3">\&quot;</span><span class="s1">,{key:i,style:Be(r,i)},t(e,n))}))),d(</span><span class="s3">\&quot;</span><span class="s1">tbody</span><span class="s3">\&quot;</span><span class="s1">,null,r.cells.map(function(e,i){return d(</span><span class="s3">\&quot;</span><span class="s1">tr</span><span class="s3">\&quot;</span><span class="s1">,{key:i},e.map(function(e,i){return d(</span><span class="s3">\&quot;</span><span class="s1">td</span><span class="s3">\&quot;</span><span class="s1">,{key:i,style:Be(r,i)},t(e,n))}))})))}},[r.text]:{match:Ue(ne),order:4,parse:e=&gt;({text:e[0].replace(T,(e,t)=&gt;i.namedCodesToUnicode[t]?i.namedCodesToUnicode[t]:e)}),render:e=&gt;e.text},[r.textBolded]:{match:Re(X),order:2,parse:(e,t,n)=&gt;({children:t(e[2],n)}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">strong</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},t(e.children,n))},[r.textEmphasized]:{match:Re(J),order:3,parse:(e,t,n)=&gt;({children:t(e[2],n)}),render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">em</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},t(e.children,n))},[r.textEscaped]:{match:Re(ee),order:1,parse:e=&gt;({text:e[1],type:r.text})},[r.textMarked]:{match:Re(K),order:3,parse:Fe,render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">mark</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},t(e.children,n))},[r.textStrikethroughed]:{match:Re(Y),order:3,parse:Fe,render:(e,t,n)=&gt;d(</span><span class="s3">\&quot;</span><span class="s1">del</span><span class="s3">\&quot;</span><span class="s1">,{key:n.key},t(e.children,n))}};!0===i.disableParsingRawHTML&amp;&amp;(delete V[r.htmlBlock],delete V[r.htmlSelfClosing]);const le=function(e){let t=Object.keys(e);function n(r,i){let l,a,o=[],c=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,s=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(i.prevCapture=i.prevCapture||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;r;){let d=0;for(;d&lt;t.length;){if(c=t[d],l=e[c],i.inline&amp;&amp;!l.match.inline){d++;continue}const u=l.match(r,i);if(u){s=u[0],i.prevCapture+=s,r=r.substring(s.length),a=l.parse(u,n,i),null==a.type&amp;&amp;(a.type=c),o.push(a);break}d++}}return i.prevCapture=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,o}return t.sort(function(t,n){let r=e[t].order,i=e[n].order;return r!==i?r-i:t&lt;n?-1:1}),function(e,t){return n(function(e){return e.replace(b,</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).replace($,</span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(G,</span><span class="s3">\&quot;    \&quot;</span><span class="s1">)}(e),t)}}(V),ae=(oe=function(e,t){return function(n,r,i){const l=e[n.type].render;return t?t(()=&gt;l(n,r,i),n,r,i):l(n,r,i)}}(V,i.renderRule),function e(t,n={}){if(Array.isArray(t)){const r=n.key,i=[];let l=!1;for(let r=0;r&lt;t.length;r++){n.key=r;const a=e(t[r],n),o=</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof a;o&amp;&amp;l?i[i.length-1]+=a:null!==a&amp;&amp;i.push(a),l=o}return n.key=r,i}return oe(t,e,n)});var oe;const ce=W(n);return q.length?d(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">,null,ce,d(</span><span class="s3">\&quot;</span><span class="s1">footer</span><span class="s3">\&quot;</span><span class="s1">,{key:</span><span class="s3">\&quot;</span><span class="s1">footer</span><span class="s3">\&quot;</span><span class="s1">},q.map(function(e){return d(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">,{id:i.slugify(e.identifier,ze),key:e.identifier},e.identifier,ae(le(e.footnote,{inline:!0})))}))):ce}export default t=&gt;{let{children:r=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,options:i}=t,l=function(e,t){if(null==e)return{};var n,r,i={},l=Object.keys(e);for(r=0;r&lt;l.length;r++)t.indexOf(n=l[r])&gt;=0||(i[n]=e[n]);return i}(t,n);return e.cloneElement(Qe(r,i),l)};export{r as RuleType,Qe as compiler,Ne as sanitizer,ze as slugify};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.modern.js.map</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Component } from 'react';</span><span class="s3">\n</span><span class="s1">import { getTemplate, getUiOptions, orderProperties, TranslatableString, ADDITIONAL_PROPERTY_FLAG, PROPERTIES_KEY, REF_KEY, ANY_OF_KEY, ONE_OF_KEY, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import Markdown from 'markdown-to-jsx';</span><span class="s3">\n</span><span class="s1">import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import has from 'lodash/has';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">import set from 'lodash/set';</span><span class="s3">\n</span><span class="s1">import unset from 'lodash/unset';</span><span class="s3">\n</span><span class="s1">/** The `ObjectField` component is used to render a field in the schema that is of type `object`. It tracks whether an</span><span class="s3">\n </span><span class="s1">* additional property key was modified and what it was modified to</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ObjectField extends Component {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">/** Set up the initial state */</span><span class="s3">\n        </span><span class="s1">this.state = {</span><span class="s3">\n            </span><span class="s1">wasPropertyKeyModified: false,</span><span class="s3">\n            </span><span class="s1">additionalProperties: {},</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting</span><span class="s3">\n         </span><span class="s1">* to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated</span><span class="s3">\n         </span><span class="s1">* formData.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param name - The name of the property</span><span class="s3">\n         </span><span class="s1">* @param addedByAdditionalProperties - Flag indicating whether this property is an additional property</span><span class="s3">\n         </span><span class="s1">* @returns - The onPropertyChange callback for the `name` property</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onPropertyChange = (name, addedByAdditionalProperties = false) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (value, newErrorSchema, id) =&gt; {</span><span class="s3">\n                </span><span class="s1">const { formData, onChange, errorSchema } = this.props;</span><span class="s3">\n                </span><span class="s1">if (value === undefined &amp;&amp; addedByAdditionalProperties) {</span><span class="s3">\n                    </span><span class="s1">// Don't set value = undefined for fields added by</span><span class="s3">\n                    </span><span class="s1">// additionalProperties. Doing so removes them from the</span><span class="s3">\n                    </span><span class="s1">// formData, which causes them to completely disappear</span><span class="s3">\n                    </span><span class="s1">// (including the input field for the property name). Unlike</span><span class="s3">\n                    </span><span class="s1">// fields which are </span><span class="s3">\&quot;</span><span class="s1">mandated</span><span class="s3">\&quot; </span><span class="s1">by the schema, these fields can</span><span class="s3">\n                    </span><span class="s1">// be set to undefined by clicking a </span><span class="s3">\&quot;</span><span class="s1">delete field</span><span class="s3">\&quot; </span><span class="s1">button, so</span><span class="s3">\n                    </span><span class="s1">// set empty values to the empty string.</span><span class="s3">\n                    </span><span class="s1">value = '';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const newFormData = { ...formData, [name]: value };</span><span class="s3">\n                </span><span class="s1">onChange(newFormData, errorSchema &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">errorSchema &amp;&amp; {</span><span class="s3">\n                    </span><span class="s1">...errorSchema,</span><span class="s3">\n                    </span><span class="s1">[name]: newErrorSchema,</span><span class="s3">\n                </span><span class="s1">}, id);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data</span><span class="s3">\n         </span><span class="s1">* and calls the `onChange` callback with it</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param key - The key for which the drop callback is desired</span><span class="s3">\n         </span><span class="s1">* @returns - The drop property click callback</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onDropPropertyClick = (key) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">const { onChange, formData } = this.props;</span><span class="s3">\n                </span><span class="s1">const copiedFormData = { ...formData };</span><span class="s3">\n                </span><span class="s1">unset(copiedFormData, key);</span><span class="s3">\n                </span><span class="s1">onChange(copiedFormData);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one</span><span class="s3">\n         </span><span class="s1">* that is already not assigned is found.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param preferredKey - The preferred name of a new key</span><span class="s3">\n         </span><span class="s1">* @param [formData] - The form data in which to check if the desired key already exists</span><span class="s3">\n         </span><span class="s1">* @returns - The name of the next available key from `preferredKey`</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.getAvailableKey = (preferredKey, formData) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { uiSchema, registry } = this.props;</span><span class="s3">\n            </span><span class="s1">const { duplicateKeySuffixSeparator = '-' } = getUiOptions(uiSchema, registry.globalUiOptions);</span><span class="s3">\n            </span><span class="s1">let index = 0;</span><span class="s3">\n            </span><span class="s1">let newKey = preferredKey;</span><span class="s3">\n            </span><span class="s1">while (has(formData, newKey)) {</span><span class="s3">\n                </span><span class="s1">newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return newKey;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Returns a callback function that deals with the rename of a key for an additional property for a schema. That</span><span class="s3">\n         </span><span class="s1">* callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param oldValue - The old value of a field</span><span class="s3">\n         </span><span class="s1">* @returns - The key change callback function</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onKeyChange = (oldValue) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (value, newErrorSchema) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (oldValue === value) {</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { formData, onChange, errorSchema } = this.props;</span><span class="s3">\n                </span><span class="s1">value = this.getAvailableKey(value, formData);</span><span class="s3">\n                </span><span class="s1">const newFormData = {</span><span class="s3">\n                    </span><span class="s1">...formData,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">const newKeys = { [oldValue]: value };</span><span class="s3">\n                </span><span class="s1">const keyValues = Object.keys(newFormData).map((key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const newKey = newKeys[key] || key;</span><span class="s3">\n                    </span><span class="s1">return { [newKey]: newFormData[key] };</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">const renamedObj = Object.assign({}, ...keyValues);</span><span class="s3">\n                </span><span class="s1">this.setState({ wasPropertyKeyModified: true });</span><span class="s3">\n                </span><span class="s1">onChange(renamedObj, errorSchema &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">errorSchema &amp;&amp; {</span><span class="s3">\n                    </span><span class="s1">...errorSchema,</span><span class="s3">\n                    </span><span class="s1">[value]: newErrorSchema,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new</span><span class="s3">\n         </span><span class="s1">* default data for that field has been added to the formData.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param schema - The schema element to which the new property is being added</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.handleAddClick = (schema) =&gt; () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!schema.additionalProperties) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const { formData, onChange, registry } = this.props;</span><span class="s3">\n            </span><span class="s1">const newFormData = { ...formData };</span><span class="s3">\n            </span><span class="s1">let type = undefined;</span><span class="s3">\n            </span><span class="s1">if (isObject(schema.additionalProperties)) {</span><span class="s3">\n                </span><span class="s1">type = schema.additionalProperties.type;</span><span class="s3">\n                </span><span class="s1">let apSchema = schema.additionalProperties;</span><span class="s3">\n                </span><span class="s1">if (REF_KEY in apSchema) {</span><span class="s3">\n                    </span><span class="s1">const { schemaUtils } = registry;</span><span class="s3">\n                    </span><span class="s1">apSchema = schemaUtils.retrieveSchema({ $ref: apSchema[REF_KEY] }, formData);</span><span class="s3">\n                    </span><span class="s1">type = apSchema.type;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!type &amp;&amp; (ANY_OF_KEY in apSchema || ONE_OF_KEY in apSchema)) {</span><span class="s3">\n                    </span><span class="s1">type = 'object';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const newKey = this.getAvailableKey('newKey', newFormData);</span><span class="s3">\n            </span><span class="s1">// Cast this to make the `set` work properly</span><span class="s3">\n            </span><span class="s1">set(newFormData, newKey, this.getDefaultValue(type));</span><span class="s3">\n            </span><span class="s1">onChange(newFormData);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns a flag indicating whether the `name` field is required in the object schema</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param name - The name of the field to check for required-ness</span><span class="s3">\n     </span><span class="s1">* @returns - True if the field `name` is required, false otherwise</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isRequired(name) {</span><span class="s3">\n        </span><span class="s1">const { schema } = this.props;</span><span class="s3">\n        </span><span class="s1">return Array.isArray(schema.required) &amp;&amp; schema.required.indexOf(name) !== -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns a default value to be used for a new additional schema property of the given `type`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param type - The type of the new additional schema property</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getDefaultValue(type) {</span><span class="s3">\n        </span><span class="s1">const { registry: { translateString }, } = this.props;</span><span class="s3">\n        </span><span class="s1">switch (type) {</span><span class="s3">\n            </span><span class="s1">case 'array':</span><span class="s3">\n                </span><span class="s1">return [];</span><span class="s3">\n            </span><span class="s1">case 'boolean':</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">case 'null':</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">case 'number':</span><span class="s3">\n                </span><span class="s1">return 0;</span><span class="s3">\n            </span><span class="s1">case 'object':</span><span class="s3">\n                </span><span class="s1">return {};</span><span class="s3">\n            </span><span class="s1">case 'string':</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">// We don't have a datatype for some reason (perhaps additionalProperties was true)</span><span class="s3">\n                </span><span class="s1">return translateString(TranslatableString.NewStringDefault);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders the `ObjectField` from the given props</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">render() {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">const { schema: rawSchema, uiSchema = {}, formData, errorSchema, idSchema, name, required = false, disabled = false, readonly = false, hideError, idPrefix, idSeparator, onBlur, onFocus, registry, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { fields, formContext, schemaUtils, translateString, globalUiOptions } = registry;</span><span class="s3">\n        </span><span class="s1">const { SchemaField } = fields;</span><span class="s3">\n        </span><span class="s1">const schema = schemaUtils.retrieveSchema(rawSchema, formData);</span><span class="s3">\n        </span><span class="s1">const uiOptions = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n        </span><span class="s1">const { properties: schemaProperties = {} } = schema;</span><span class="s3">\n        </span><span class="s1">const title = (_b = (_a = uiOptions.title) !== null &amp;&amp; _a !== void 0 ? _a : schema.title) !== null &amp;&amp; _b !== void 0 ? _b : name;</span><span class="s3">\n        </span><span class="s1">const description = (_c = uiOptions.description) !== null &amp;&amp; _c !== void 0 ? _c : schema.description;</span><span class="s3">\n        </span><span class="s1">let orderedProperties;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const properties = Object.keys(schemaProperties);</span><span class="s3">\n            </span><span class="s1">orderedProperties = orderProperties(properties, uiOptions.order);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">, { className: 'config-error', style: { color: 'red' }, children: _jsx(Markdown, { children: translateString(TranslatableString.InvalidObjectField, [name || 'root', err.message]) }) }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">pre</span><span class="s3">\&quot;</span><span class="s1">, { children: JSON.stringify(schema) })] }));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const Template = getTemplate('ObjectFieldTemplate', registry, uiOptions);</span><span class="s3">\n        </span><span class="s1">const templateProps = {</span><span class="s3">\n            </span><span class="s1">// getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`</span><span class="s3">\n            </span><span class="s1">title: uiOptions.label === false ? '' : title,</span><span class="s3">\n            </span><span class="s1">description: uiOptions.label === false ? undefined : description,</span><span class="s3">\n            </span><span class="s1">properties: orderedProperties.map((name) =&gt; {</span><span class="s3">\n                </span><span class="s1">const addedByAdditionalProperties = has(schema, [PROPERTIES_KEY, name, ADDITIONAL_PROPERTY_FLAG]);</span><span class="s3">\n                </span><span class="s1">const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name];</span><span class="s3">\n                </span><span class="s1">const hidden = getUiOptions(fieldUiSchema).widget === 'hidden';</span><span class="s3">\n                </span><span class="s1">const fieldIdSchema = get(idSchema, [name], {});</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">content: (_jsx(SchemaField, { name: name, required: this.isRequired(name), schema: get(schema, [PROPERTIES_KEY, name], {}), uiSchema: fieldUiSchema, errorSchema: get(errorSchema, name), idSchema: fieldIdSchema, idPrefix: idPrefix, idSeparator: idSeparator, formData: get(formData, name), formContext: formContext, wasPropertyKeyModified: this.state.wasPropertyKeyModified, onKeyChange: this.onKeyChange(name), onChange: this.onPropertyChange(name, addedByAdditionalProperties), onBlur: onBlur, onFocus: onFocus, registry: registry, disabled: disabled, readonly: readonly, hideError: hideError, onDropPropertyClick: this.onDropPropertyClick }, name)),</span><span class="s3">\n                    </span><span class="s1">name,</span><span class="s3">\n                    </span><span class="s1">readonly,</span><span class="s3">\n                    </span><span class="s1">disabled,</span><span class="s3">\n                    </span><span class="s1">required,</span><span class="s3">\n                    </span><span class="s1">hidden,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">readonly,</span><span class="s3">\n            </span><span class="s1">disabled,</span><span class="s3">\n            </span><span class="s1">required,</span><span class="s3">\n            </span><span class="s1">idSchema,</span><span class="s3">\n            </span><span class="s1">uiSchema,</span><span class="s3">\n            </span><span class="s1">errorSchema,</span><span class="s3">\n            </span><span class="s1">schema,</span><span class="s3">\n            </span><span class="s1">formData,</span><span class="s3">\n            </span><span class="s1">formContext,</span><span class="s3">\n            </span><span class="s1">registry,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return _jsx(Template, { ...templateProps, onAddClick: this.handleAddClick });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default ObjectField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ObjectField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback, Component } from 'react';</span><span class="s3">\n</span><span class="s1">import { ADDITIONAL_PROPERTY_FLAG, deepEquals, descriptionId, getSchemaType, getTemplate, getUiOptions, ID_KEY, mergeObjects, TranslatableString, UI_OPTIONS_KEY, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">import omit from 'lodash/omit';</span><span class="s3">\n</span><span class="s1">import Markdown from 'markdown-to-jsx';</span><span class="s3">\n</span><span class="s1">/** The map of component type to FieldName */</span><span class="s3">\n</span><span class="s1">const COMPONENT_TYPES = {</span><span class="s3">\n    </span><span class="s1">array: 'ArrayField',</span><span class="s3">\n    </span><span class="s1">boolean: 'BooleanField',</span><span class="s3">\n    </span><span class="s1">integer: 'NumberField',</span><span class="s3">\n    </span><span class="s1">number: 'NumberField',</span><span class="s3">\n    </span><span class="s1">object: 'ObjectField',</span><span class="s3">\n    </span><span class="s1">string: 'StringField',</span><span class="s3">\n    </span><span class="s1">null: 'NullField',</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/** Computes and returns which `Field` implementation to return in order to render the field represented by the</span><span class="s3">\n </span><span class="s1">* `schema`. The `uiOptions` are used to alter what potential `Field` implementation is actually returned. If no</span><span class="s3">\n </span><span class="s1">* appropriate `Field` implementation can be found then a wrapper around `UnsupportedFieldTemplate` is used.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema from which to obtain the type</span><span class="s3">\n </span><span class="s1">* @param uiOptions - The UI Options that may affect the component decision</span><span class="s3">\n </span><span class="s1">* @param idSchema - The id that is passed to the `UnsupportedFieldTemplate`</span><span class="s3">\n </span><span class="s1">* @param registry - The registry from which fields and templates are obtained</span><span class="s3">\n </span><span class="s1">* @returns - The `Field` component that is used to render the actual field data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getFieldComponent(schema, uiOptions, idSchema, registry) {</span><span class="s3">\n    </span><span class="s1">const field = uiOptions.field;</span><span class="s3">\n    </span><span class="s1">const { fields, translateString } = registry;</span><span class="s3">\n    </span><span class="s1">if (typeof field === 'function') {</span><span class="s3">\n        </span><span class="s1">return field;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof field === 'string' &amp;&amp; field in fields) {</span><span class="s3">\n        </span><span class="s1">return fields[field];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const schemaType = getSchemaType(schema);</span><span class="s3">\n    </span><span class="s1">const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || '';</span><span class="s3">\n    </span><span class="s1">const schemaId = schema.$id;</span><span class="s3">\n    </span><span class="s1">let componentName = COMPONENT_TYPES[type];</span><span class="s3">\n    </span><span class="s1">if (schemaId &amp;&amp; schemaId in fields) {</span><span class="s3">\n        </span><span class="s1">componentName = schemaId;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't</span><span class="s3">\n    </span><span class="s1">// render a field and let the MultiSchemaField component handle the form display</span><span class="s3">\n    </span><span class="s1">if (!componentName &amp;&amp; (schema.anyOf || schema.oneOf)) {</span><span class="s3">\n        </span><span class="s1">return () =&gt; null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return componentName in fields</span><span class="s3">\n        </span><span class="s1">? fields[componentName]</span><span class="s3">\n        </span><span class="s1">: () =&gt; {</span><span class="s3">\n            </span><span class="s1">const UnsupportedFieldTemplate = getTemplate('UnsupportedFieldTemplate', registry, uiOptions);</span><span class="s3">\n            </span><span class="s1">return (_jsx(UnsupportedFieldTemplate, { schema: schema, idSchema: idSchema, reason: translateString(TranslatableString.UnknownFieldType, [String(schema.type)]), registry: registry }));</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** The `SchemaFieldRender` component is the work-horse of react-jsonschema-form, determining what kind of real field to</span><span class="s3">\n </span><span class="s1">* render based on the `schema`, `uiSchema` and all the other props. It also deals with rendering the `anyOf` and</span><span class="s3">\n </span><span class="s1">* `oneOf` fields.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function SchemaFieldRender(props) {</span><span class="s3">\n    </span><span class="s1">const { schema: _schema, idSchema: _idSchema, uiSchema, formData, errorSchema, idPrefix, idSeparator, name, onChange, onKeyChange, onDropPropertyClick, required, registry, wasPropertyKeyModified = false, } = props;</span><span class="s3">\n    </span><span class="s1">const { formContext, schemaUtils, globalUiOptions } = registry;</span><span class="s3">\n    </span><span class="s1">const uiOptions = getUiOptions(uiSchema, globalUiOptions);</span><span class="s3">\n    </span><span class="s1">const FieldTemplate = getTemplate('FieldTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">const DescriptionFieldTemplate = getTemplate('DescriptionFieldTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">const FieldHelpTemplate = getTemplate('FieldHelpTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">const FieldErrorTemplate = getTemplate('FieldErrorTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">const schema = schemaUtils.retrieveSchema(_schema, formData);</span><span class="s3">\n    </span><span class="s1">const fieldId = _idSchema[ID_KEY];</span><span class="s3">\n    </span><span class="s1">const idSchema = mergeObjects(schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator), _idSchema);</span><span class="s3">\n    </span><span class="s1">/** Intermediary `onChange` handler for field components that will inject the `id` of the current field into the</span><span class="s3">\n     </span><span class="s1">* `onChange` chain if it is not already being provided from a deeper level in the hierarchy</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const handleFieldComponentChange = useCallback((formData, newErrorSchema, id) =&gt; {</span><span class="s3">\n        </span><span class="s1">const theId = id || fieldId;</span><span class="s3">\n        </span><span class="s1">return onChange(formData, newErrorSchema, theId);</span><span class="s3">\n    </span><span class="s1">}, [fieldId, onChange]);</span><span class="s3">\n    </span><span class="s1">const FieldComponent = getFieldComponent(schema, uiOptions, idSchema, registry);</span><span class="s3">\n    </span><span class="s1">const disabled = Boolean(props.disabled || uiOptions.disabled);</span><span class="s3">\n    </span><span class="s1">const readonly = Boolean(props.readonly || uiOptions.readonly || props.schema.readOnly || schema.readOnly);</span><span class="s3">\n    </span><span class="s1">const uiSchemaHideError = uiOptions.hideError;</span><span class="s3">\n    </span><span class="s1">// Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children</span><span class="s3">\n    </span><span class="s1">const hideError = uiSchemaHideError === undefined ? props.hideError : Boolean(uiSchemaHideError);</span><span class="s3">\n    </span><span class="s1">const autofocus = Boolean(props.autofocus || uiOptions.autofocus);</span><span class="s3">\n    </span><span class="s1">if (Object.keys(schema).length === 0) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);</span><span class="s3">\n    </span><span class="s1">const { __errors, ...fieldErrorSchema } = errorSchema || {};</span><span class="s3">\n    </span><span class="s1">// See #439: uiSchema: Don't pass consumed class names or style to child components</span><span class="s3">\n    </span><span class="s1">const fieldUiSchema = omit(uiSchema, ['ui:classNames', 'classNames', 'ui:style']);</span><span class="s3">\n    </span><span class="s1">if (UI_OPTIONS_KEY in fieldUiSchema) {</span><span class="s3">\n        </span><span class="s1">fieldUiSchema[UI_OPTIONS_KEY] = omit(fieldUiSchema[UI_OPTIONS_KEY], ['classNames', 'style']);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const field = (_jsx(FieldComponent, { ...props, onChange: handleFieldComponentChange, idSchema: idSchema, schema: schema, uiSchema: fieldUiSchema, disabled: disabled, readonly: readonly, hideError: hideError, autofocus: autofocus, errorSchema: fieldErrorSchema, formContext: formContext, rawErrors: __errors }));</span><span class="s3">\n    </span><span class="s1">const id = idSchema[ID_KEY];</span><span class="s3">\n    </span><span class="s1">// If this schema has a title defined, but the user has set a new key/label, retain their input.</span><span class="s3">\n    </span><span class="s1">let label;</span><span class="s3">\n    </span><span class="s1">if (wasPropertyKeyModified) {</span><span class="s3">\n        </span><span class="s1">label = name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">label = ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const description = uiOptions.description || props.schema.description || schema.description || '';</span><span class="s3">\n    </span><span class="s1">const richDescription = uiOptions.enableMarkdownInDescription ? _jsx(Markdown, { children: description }) : description;</span><span class="s3">\n    </span><span class="s1">const help = uiOptions.help;</span><span class="s3">\n    </span><span class="s1">const hidden = uiOptions.widget === 'hidden';</span><span class="s3">\n    </span><span class="s1">const classNames = ['form-group', 'field', `field-${getSchemaType(schema)}`];</span><span class="s3">\n    </span><span class="s1">if (!hideError &amp;&amp; __errors &amp;&amp; __errors.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">classNames.push('field-error has-error has-danger');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema.classNames) {</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n            </span><span class="s1">console.warn(</span><span class="s3">\&quot;</span><span class="s1">'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">classNames.push(uiSchema.classNames);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (uiOptions.classNames) {</span><span class="s3">\n        </span><span class="s1">classNames.push(uiOptions.classNames);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const helpComponent = (_jsx(FieldHelpTemplate, { help: help, idSchema: idSchema, schema: schema, uiSchema: uiSchema, hasErrors: !hideError &amp;&amp; __errors &amp;&amp; __errors.length &gt; 0, registry: registry }));</span><span class="s3">\n    </span><span class="s1">/*</span><span class="s3">\n     </span><span class="s1">* AnyOf/OneOf errors handled by child schema</span><span class="s3">\n     </span><span class="s1">* unless it can be rendered as select control</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const errorsComponent = hideError || ((schema.anyOf || schema.oneOf) &amp;&amp; !schemaUtils.isSelect(schema)) ? undefined : (_jsx(FieldErrorTemplate, { errors: __errors, errorSchema: errorSchema, idSchema: idSchema, schema: schema, uiSchema: uiSchema, registry: registry }));</span><span class="s3">\n    </span><span class="s1">const fieldProps = {</span><span class="s3">\n        </span><span class="s1">description: (_jsx(DescriptionFieldTemplate, { id: descriptionId(id), description: richDescription, schema: schema, uiSchema: uiSchema, registry: registry })),</span><span class="s3">\n        </span><span class="s1">rawDescription: description,</span><span class="s3">\n        </span><span class="s1">help: helpComponent,</span><span class="s3">\n        </span><span class="s1">rawHelp: typeof help === 'string' ? help : undefined,</span><span class="s3">\n        </span><span class="s1">errors: errorsComponent,</span><span class="s3">\n        </span><span class="s1">rawErrors: hideError ? undefined : __errors,</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">label,</span><span class="s3">\n        </span><span class="s1">hidden,</span><span class="s3">\n        </span><span class="s1">onChange,</span><span class="s3">\n        </span><span class="s1">onKeyChange,</span><span class="s3">\n        </span><span class="s1">onDropPropertyClick,</span><span class="s3">\n        </span><span class="s1">required,</span><span class="s3">\n        </span><span class="s1">disabled,</span><span class="s3">\n        </span><span class="s1">readonly,</span><span class="s3">\n        </span><span class="s1">hideError,</span><span class="s3">\n        </span><span class="s1">displayLabel,</span><span class="s3">\n        </span><span class="s1">classNames: classNames.join(' ').trim(),</span><span class="s3">\n        </span><span class="s1">style: uiOptions.style,</span><span class="s3">\n        </span><span class="s1">formContext,</span><span class="s3">\n        </span><span class="s1">formData,</span><span class="s3">\n        </span><span class="s1">schema,</span><span class="s3">\n        </span><span class="s1">uiSchema,</span><span class="s3">\n        </span><span class="s1">registry,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">const _AnyOfField = registry.fields.AnyOfField;</span><span class="s3">\n    </span><span class="s1">const _OneOfField = registry.fields.OneOfField;</span><span class="s3">\n    </span><span class="s1">const isReplacingAnyOrOneOf = (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema['ui:field']) &amp;&amp; (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema['ui:fieldReplacesAnyOrOneOf']) === true;</span><span class="s3">\n    </span><span class="s1">return (_jsx(FieldTemplate, { ...fieldProps, children: _jsxs(_Fragment, { children: [field, schema.anyOf &amp;&amp; !isReplacingAnyOrOneOf &amp;&amp; !schemaUtils.isSelect(schema) &amp;&amp; (_jsx(_AnyOfField, { name: name, disabled: disabled, readonly: readonly, hideError: hideError, errorSchema: errorSchema, formData: formData, formContext: formContext, idPrefix: idPrefix, idSchema: idSchema, idSeparator: idSeparator, onBlur: props.onBlur, onChange: props.onChange, onFocus: props.onFocus, options: schema.anyOf.map((_schema) =&gt; schemaUtils.retrieveSchema(isObject(_schema) ? _schema : {}, formData)), registry: registry, schema: schema, uiSchema: uiSchema })), schema.oneOf &amp;&amp; !isReplacingAnyOrOneOf &amp;&amp; !schemaUtils.isSelect(schema) &amp;&amp; (_jsx(_OneOfField, { name: name, disabled: disabled, readonly: readonly, hideError: hideError, errorSchema: errorSchema, formData: formData, formContext: formContext, idPrefix: idPrefix, idSchema: idSchema, idSeparator: idSeparator, onBlur: props.onBlur, onChange: props.onChange, onFocus: props.onFocus, options: schema.oneOf.map((_schema) =&gt; schemaUtils.retrieveSchema(isObject(_schema) ? _schema : {}, formData)), registry: registry, schema: schema, uiSchema: uiSchema }))] }) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** The `SchemaField` component determines whether it is necessary to rerender the component based on any props changes</span><span class="s3">\n </span><span class="s1">* and if so, calls the `SchemaFieldRender` component with the props.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SchemaField extends Component {</span><span class="s3">\n    </span><span class="s1">shouldComponentUpdate(nextProps) {</span><span class="s3">\n        </span><span class="s1">return !deepEquals(this.props, nextProps);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render() {</span><span class="s3">\n        </span><span class="s1">return _jsx(SchemaFieldRender, { ...this.props });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default SchemaField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=SchemaField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getWidget, getUiOptions, optionsList, hasWidget, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `StringField` component is used to render a schema field that represents a string type</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function StringField(props) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const { schema, name, uiSchema, idSchema, formData, required, disabled = false, readonly = false, autofocus = false, onChange, onBlur, onFocus, registry, rawErrors, hideError, } = props;</span><span class="s3">\n    </span><span class="s1">const { title, format } = schema;</span><span class="s3">\n    </span><span class="s1">const { widgets, formContext, schemaUtils, globalUiOptions } = registry;</span><span class="s3">\n    </span><span class="s1">const enumOptions = schemaUtils.isSelect(schema) ? optionsList(schema) : undefined;</span><span class="s3">\n    </span><span class="s1">let defaultWidget = enumOptions ? 'select' : 'text';</span><span class="s3">\n    </span><span class="s1">if (format &amp;&amp; hasWidget(schema, format, widgets)) {</span><span class="s3">\n        </span><span class="s1">defaultWidget = format;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { widget = defaultWidget, placeholder = '', title: uiTitle, ...options } = getUiOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);</span><span class="s3">\n    </span><span class="s1">const label = (_a = uiTitle !== null &amp;&amp; uiTitle !== void 0 ? uiTitle : title) !== null &amp;&amp; _a !== void 0 ? _a : name;</span><span class="s3">\n    </span><span class="s1">const Widget = getWidget(schema, widget, widgets);</span><span class="s3">\n    </span><span class="s1">return (_jsx(Widget, { options: { ...options, enumOptions }, schema: schema, uiSchema: uiSchema, id: idSchema.$id, name: name, label: label, hideLabel: !displayLabel, hideError: hideError, value: formData, onChange: onChange, onBlur: onBlur, onFocus: onFocus, required: required, disabled: disabled, readonly: readonly, formContext: formContext, autofocus: autofocus, registry: registry, placeholder: placeholder, rawErrors: rawErrors }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default StringField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=StringField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { useEffect } from 'react';</span><span class="s3">\n</span><span class="s1">/** The `NullField` component is used to render a field in the schema is null. It also ensures that the `formData` is</span><span class="s3">\n </span><span class="s1">* also set to null if it has no value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function NullField(props) {</span><span class="s3">\n    </span><span class="s1">const { formData, onChange } = props;</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (formData === undefined) {</span><span class="s3">\n            </span><span class="s1">onChange(null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [formData, onChange]);</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default NullField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=NullField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import ArrayField from './ArrayField';</span><span class="s3">\n</span><span class="s1">import BooleanField from './BooleanField';</span><span class="s3">\n</span><span class="s1">import MultiSchemaField from './MultiSchemaField';</span><span class="s3">\n</span><span class="s1">import NumberField from './NumberField';</span><span class="s3">\n</span><span class="s1">import ObjectField from './ObjectField';</span><span class="s3">\n</span><span class="s1">import SchemaField from './SchemaField';</span><span class="s3">\n</span><span class="s1">import StringField from './StringField';</span><span class="s3">\n</span><span class="s1">import NullField from './NullField';</span><span class="s3">\n</span><span class="s1">function fields() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">AnyOfField: MultiSchemaField,</span><span class="s3">\n        </span><span class="s1">ArrayField: ArrayField,</span><span class="s3">\n        </span><span class="s1">// ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default</span><span class="s3">\n        </span><span class="s1">BooleanField,</span><span class="s3">\n        </span><span class="s1">NumberField,</span><span class="s3">\n        </span><span class="s1">ObjectField,</span><span class="s3">\n        </span><span class="s1">OneOfField: MultiSchemaField,</span><span class="s3">\n        </span><span class="s1">SchemaField,</span><span class="s3">\n        </span><span class="s1">StringField,</span><span class="s3">\n        </span><span class="s1">NullField,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default fields;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { descriptionId, getTemplate, getUiOptions, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `ArrayFieldDescriptionTemplate` component renders a `DescriptionFieldTemplate` with an `id` derived from</span><span class="s3">\n </span><span class="s1">* the `idSchema`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `ArrayFieldDescriptionProps` for the component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ArrayFieldDescriptionTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { idSchema, description, registry, schema, uiSchema } = props;</span><span class="s3">\n    </span><span class="s1">const options = getUiOptions(uiSchema, registry.globalUiOptions);</span><span class="s3">\n    </span><span class="s1">const { label: displayLabel = true } = options;</span><span class="s3">\n    </span><span class="s1">if (!description || !displayLabel) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const DescriptionFieldTemplate = getTemplate('DescriptionFieldTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return (_jsx(DescriptionFieldTemplate, { id: descriptionId(idSchema), description: description, schema: schema, uiSchema: uiSchema, registry: registry }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ArrayFieldDescriptionTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/** The `ArrayFieldItemTemplate` component is the template used to render an items of an array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `ArrayFieldTemplateItemType` props for the component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ArrayFieldItemTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { children, className, disabled, hasToolbar, hasMoveDown, hasMoveUp, hasRemove, hasCopy, index, onCopyIndexClick, onDropIndexClick, onReorderClick, readonly, registry, uiSchema, } = props;</span><span class="s3">\n    </span><span class="s1">const { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } = registry.templates.ButtonTemplates;</span><span class="s3">\n    </span><span class="s1">const btnStyle = {</span><span class="s3">\n        </span><span class="s1">flex: 1,</span><span class="s3">\n        </span><span class="s1">paddingLeft: 6,</span><span class="s3">\n        </span><span class="s1">paddingRight: 6,</span><span class="s3">\n        </span><span class="s1">fontWeight: 'bold',</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: className, children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: hasToolbar ? 'col-xs-9' : 'col-xs-12', children: children }), hasToolbar &amp;&amp; (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'col-xs-3 array-item-toolbox', children: _jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'btn-group', style: {</span><span class="s3">\n                        </span><span class="s1">display: 'flex',</span><span class="s3">\n                        </span><span class="s1">justifyContent: 'space-around',</span><span class="s3">\n                    </span><span class="s1">}, children: [(hasMoveUp || hasMoveDown) &amp;&amp; (_jsx(MoveUpButton, { style: btnStyle, disabled: disabled || readonly || !hasMoveUp, onClick: onReorderClick(index, index - 1), uiSchema: uiSchema, registry: registry })), (hasMoveUp || hasMoveDown) &amp;&amp; (_jsx(MoveDownButton, { style: btnStyle, disabled: disabled || readonly || !hasMoveDown, onClick: onReorderClick(index, index + 1), uiSchema: uiSchema, registry: registry })), hasCopy &amp;&amp; (_jsx(CopyButton, { style: btnStyle, disabled: disabled || readonly, onClick: onCopyIndexClick(index), uiSchema: uiSchema, registry: registry })), hasRemove &amp;&amp; (_jsx(RemoveButton, { style: btnStyle, disabled: disabled || readonly, onClick: onDropIndexClick(index), uiSchema: uiSchema, registry: registry }))] }) }))] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ArrayFieldItemTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate, getUiOptions, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `ArrayFieldTemplate` component is the template used to render all items in an array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `ArrayFieldTemplateItemType` props for the component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ArrayFieldTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { canAdd, className, disabled, idSchema, uiSchema, items, onAddClick, readonly, registry, required, schema, title, } = props;</span><span class="s3">\n    </span><span class="s1">const uiOptions = getUiOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">const ArrayFieldDescriptionTemplate = getTemplate('ArrayFieldDescriptionTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">const ArrayFieldItemTemplate = getTemplate('ArrayFieldItemTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">const ArrayFieldTitleTemplate = getTemplate('ArrayFieldTitleTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">// Button templates are not overridden in the uiSchema</span><span class="s3">\n    </span><span class="s1">const { ButtonTemplates: { AddButton }, } = registry.templates;</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">fieldset</span><span class="s3">\&quot;</span><span class="s1">, { className: className, id: idSchema.$id, children: [_jsx(ArrayFieldTitleTemplate, { idSchema: idSchema, title: uiOptions.title || title, required: required, schema: schema, uiSchema: uiSchema, registry: registry }), _jsx(ArrayFieldDescriptionTemplate, { idSchema: idSchema, description: uiOptions.description || schema.description, schema: schema, uiSchema: uiSchema, registry: registry }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'row array-item-list', children: items &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">items.map(({ key, ...itemProps }) =&gt; (_jsx(ArrayFieldItemTemplate, { ...itemProps }, key))) }), canAdd &amp;&amp; (_jsx(AddButton, { className: 'array-item-add', onClick: onAddClick, disabled: disabled || readonly, uiSchema: uiSchema, registry: registry }))] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ArrayFieldTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate, getUiOptions, titleId, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `ArrayFieldTitleTemplate` component renders a `TitleFieldTemplate` with an `id` derived from</span><span class="s3">\n </span><span class="s1">* the `idSchema`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `ArrayFieldTitleProps` for the component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ArrayFieldTitleTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { idSchema, title, schema, uiSchema, required, registry } = props;</span><span class="s3">\n    </span><span class="s1">const options = getUiOptions(uiSchema, registry.globalUiOptions);</span><span class="s3">\n    </span><span class="s1">const { label: displayLabel = true } = options;</span><span class="s3">\n    </span><span class="s1">if (!title || !displayLabel) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const TitleFieldTemplate = getTemplate('TitleFieldTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return (_jsx(TitleFieldTemplate, { id: titleId(idSchema), title: title, required: required, schema: schema, uiSchema: uiSchema, registry: registry }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ArrayFieldTitleTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, examplesId, getInputProps, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `BaseInputTemplate` is the template to use to render the basic `&lt;input&gt;` component for the `core` theme.</span><span class="s3">\n </span><span class="s1">* It is used as the template for rendering many of the &lt;input&gt; based widgets that differ by `type` and callbacks only.</span><span class="s3">\n </span><span class="s1">* It can be customized/overridden for other themes or individual implementations as needed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function BaseInputTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { id, name, // remove this from ...rest</span><span class="s3">\n    </span><span class="s1">value, readonly, disabled, autofocus, onBlur, onFocus, onChange, onChangeOverride, options, schema, uiSchema, formContext, registry, rawErrors, type, hideLabel, // remove this from ...rest</span><span class="s3">\n    </span><span class="s1">hideError, // remove this from ...rest</span><span class="s3">\n    </span><span class="s1">...rest } = props;</span><span class="s3">\n    </span><span class="s1">// Note: since React 15.2.0 we can't forward unknown element attributes, so we</span><span class="s3">\n    </span><span class="s1">// exclude the </span><span class="s3">\&quot;</span><span class="s1">options</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot; </span><span class="s1">ones here.</span><span class="s3">\n    </span><span class="s1">if (!id) {</span><span class="s3">\n        </span><span class="s1">console.log('No id for', props);</span><span class="s3">\n        </span><span class="s1">throw new Error(`no id for props ${JSON.stringify(props)}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const inputProps = {</span><span class="s3">\n        </span><span class="s1">...rest,</span><span class="s3">\n        </span><span class="s1">...getInputProps(schema, type, options),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">let inputValue;</span><span class="s3">\n    </span><span class="s1">if (inputProps.type === 'number' || inputProps.type === 'integer') {</span><span class="s3">\n        </span><span class="s1">inputValue = value || value === 0 ? value : '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">inputValue = value == null ? '' : value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const _onChange = useCallback(({ target: { value } }) =&gt; onChange(value === '' ? options.emptyValue : value), [onChange, options]);</span><span class="s3">\n    </span><span class="s1">const _onBlur = useCallback(({ target: { value } }) =&gt; onBlur(id, value), [onBlur, id]);</span><span class="s3">\n    </span><span class="s1">const _onFocus = useCallback(({ target: { value } }) =&gt; onFocus(id, value), [onFocus, id]);</span><span class="s3">\n    </span><span class="s1">return (_jsxs(_Fragment, { children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { id: id, name: id, className: 'form-control', readOnly: readonly, disabled: disabled, autoFocus: autofocus, value: inputValue, ...inputProps, list: schema.examples ? examplesId(id) : undefined, onChange: onChangeOverride || _onChange, onBlur: _onBlur, onFocus: _onFocus, </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(id, !!schema.examples) }), Array.isArray(schema.examples) &amp;&amp; (_jsx(</span><span class="s3">\&quot;</span><span class="s1">datalist</span><span class="s3">\&quot;</span><span class="s1">, { id: examplesId(id), children: schema.examples</span><span class="s3">\n                    </span><span class="s1">.concat(schema.default &amp;&amp; !schema.examples.includes(schema.default) ? [schema.default] : [])</span><span class="s3">\n                    </span><span class="s1">.map((example) =&gt; {</span><span class="s3">\n                    </span><span class="s1">return _jsx(</span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">, { value: example }, example);</span><span class="s3">\n                </span><span class="s1">}) }, `datalist_${id}`))] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=BaseInputTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getSubmitButtonOptions } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `SubmitButton` renders a button that represent the `Submit` action on a form</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function SubmitButton({ uiSchema }) {</span><span class="s3">\n    </span><span class="s1">const { submitText, norender, props: submitButtonProps = {} } = getSubmitButtonOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">if (norender) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">, { type: 'submit', ...submitButtonProps, className: `btn btn-info ${submitButtonProps.className || ''}`, children: submitText }) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=SubmitButton.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TranslatableString } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">export default function IconButton(props) {</span><span class="s3">\n    </span><span class="s1">const { iconType = 'default', icon, className, uiSchema, registry, ...otherProps } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">, { type: 'button', className: `btn btn-${iconType} ${className}`, ...otherProps, children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">, { className: `glyphicon glyphicon-${icon}` }) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function CopyButton(props) {</span><span class="s3">\n    </span><span class="s1">const { registry: { translateString }, } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsx(IconButton, { title: translateString(TranslatableString.CopyButton), className: 'array-item-copy', ...props, icon: 'copy' }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function MoveDownButton(props) {</span><span class="s3">\n    </span><span class="s1">const { registry: { translateString }, } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsx(IconButton, { title: translateString(TranslatableString.MoveDownButton), className: 'array-item-move-down', ...props, icon: 'arrow-down' }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function MoveUpButton(props) {</span><span class="s3">\n    </span><span class="s1">const { registry: { translateString }, } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsx(IconButton, { title: translateString(TranslatableString.MoveUpButton), className: 'array-item-move-up', ...props, icon: 'arrow-up' }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function RemoveButton(props) {</span><span class="s3">\n    </span><span class="s1">const { registry: { translateString }, } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsx(IconButton, { title: translateString(TranslatableString.RemoveButton), className: 'array-item-remove', ...props, iconType: 'danger', icon: 'remove' }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=IconButton.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TranslatableString } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import IconButton from './IconButton';</span><span class="s3">\n</span><span class="s1">/** The `AddButton` renders a button that represent the `Add` action on a form</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function AddButton({ className, onClick, disabled, registry, }) {</span><span class="s3">\n    </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'row', children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">, { className: `col-xs-3 col-xs-offset-9 text-right ${className}`, children: _jsx(IconButton, { iconType: 'info', icon: 'plus', className: 'btn-add col-xs-12', title: translateString(TranslatableString.AddButton), onClick: onClick, disabled: disabled, registry: registry }) }) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=AddButton.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import SubmitButton from './SubmitButton';</span><span class="s3">\n</span><span class="s1">import AddButton from './AddButton';</span><span class="s3">\n</span><span class="s1">import { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } from './IconButton';</span><span class="s3">\n</span><span class="s1">function buttonTemplates() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">SubmitButton,</span><span class="s3">\n        </span><span class="s1">AddButton,</span><span class="s3">\n        </span><span class="s1">CopyButton,</span><span class="s3">\n        </span><span class="s1">MoveDownButton,</span><span class="s3">\n        </span><span class="s1">MoveUpButton,</span><span class="s3">\n        </span><span class="s1">RemoveButton,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default buttonTemplates;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/** The `DescriptionField` is the template to use to render the description of a field</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `DescriptionFieldProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function DescriptionField(props) {</span><span class="s3">\n    </span><span class="s1">const { id, description } = props;</span><span class="s3">\n    </span><span class="s1">if (!description) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof description === 'string') {</span><span class="s3">\n        </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">, { id: id, className: 'field-description', children: description }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { id: id, className: 'field-description', children: description }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=DescriptionField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TranslatableString, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `ErrorList` component is the template that renders the all the errors associated with the fields in the `Form`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `ErrorListProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ErrorList({ errors, registry, }) {</span><span class="s3">\n    </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'panel panel-danger errors', children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'panel-heading', children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">h3</span><span class="s3">\&quot;</span><span class="s1">, { className: 'panel-title', children: translateString(TranslatableString.ErrorsLabel) }) }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">, { className: 'list-group', children: errors.map((error, i) =&gt; {</span><span class="s3">\n                    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">, { className: 'list-group-item text-danger', children: error.stack }, i));</span><span class="s3">\n                </span><span class="s1">}) })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ErrorList.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const REQUIRED_FIELD_SYMBOL = '*';</span><span class="s3">\n</span><span class="s1">/** Renders a label for a field</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `LabelProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function Label(props) {</span><span class="s3">\n    </span><span class="s1">const { label, required, id } = props;</span><span class="s3">\n    </span><span class="s1">if (!label) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, { className: 'control-label', htmlFor: id, children: [label, required &amp;&amp; _jsx(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { className: 'required', children: REQUIRED_FIELD_SYMBOL })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=Label.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate, getUiOptions, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import Label from './Label';</span><span class="s3">\n</span><span class="s1">/** The `FieldTemplate` component is the template used by `SchemaField` to render any field. It renders the field</span><span class="s3">\n </span><span class="s1">* content, (label, description, children, errors and help) inside of a `WrapIfAdditional` component.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldTemplateProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function FieldTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;</span><span class="s3">\n    </span><span class="s1">const uiOptions = getUiOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">const WrapIfAdditionalTemplate = getTemplate('WrapIfAdditionalTemplate', registry, uiOptions);</span><span class="s3">\n    </span><span class="s1">if (hidden) {</span><span class="s3">\n        </span><span class="s1">return _jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'hidden', children: children });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsxs(WrapIfAdditionalTemplate, { ...props, children: [displayLabel &amp;&amp; _jsx(Label, { label: label, required: required, id: id }), displayLabel &amp;&amp; description ? description : null, children, errors, help] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=FieldTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import FieldTemplate from './FieldTemplate';</span><span class="s3">\n</span><span class="s1">export default FieldTemplate;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { errorId } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `FieldErrorTemplate` component renders the errors local to the particular field</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldErrorProps` for the errors being rendered</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function FieldErrorTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { errors = [], idSchema } = props;</span><span class="s3">\n    </span><span class="s1">if (errors.length === 0) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const id = errorId(idSchema);</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">, { id: id, className: 'error-detail bs-callout bs-callout-info', children: errors</span><span class="s3">\n                </span><span class="s1">.filter((elem) =&gt; !!elem)</span><span class="s3">\n                </span><span class="s1">.map((error, index) =&gt; {</span><span class="s3">\n                </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">, { className: 'text-danger', children: error }, index));</span><span class="s3">\n            </span><span class="s1">}) }) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=FieldErrorTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { helpId } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `FieldHelpTemplate` component renders any help desired for a field</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldHelpProps` to be rendered</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function FieldHelpTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { idSchema, help } = props;</span><span class="s3">\n    </span><span class="s1">if (!help) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const id = helpId(idSchema);</span><span class="s3">\n    </span><span class="s1">if (typeof help === 'string') {</span><span class="s3">\n        </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">, { id: id, className: 'help-block', children: help }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { id: id, className: 'help-block', children: help }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=FieldHelpTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { canExpand, descriptionId, getTemplate, getUiOptions, titleId, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `ObjectFieldTemplate` is the template to use to render all the inner properties of an object along with the</span><span class="s3">\n </span><span class="s1">* title and description if available. If the object is expandable, then an `AddButton` is also rendered after all</span><span class="s3">\n </span><span class="s1">* the properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `ObjectFieldTemplateProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ObjectFieldTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { description, disabled, formData, idSchema, onAddClick, properties, readonly, registry, required, schema, title, uiSchema, } = props;</span><span class="s3">\n    </span><span class="s1">const options = getUiOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">const TitleFieldTemplate = getTemplate('TitleFieldTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">const DescriptionFieldTemplate = getTemplate('DescriptionFieldTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">// Button templates are not overridden in the uiSchema</span><span class="s3">\n    </span><span class="s1">const { ButtonTemplates: { AddButton }, } = registry.templates;</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">fieldset</span><span class="s3">\&quot;</span><span class="s1">, { id: idSchema.$id, children: [title &amp;&amp; (_jsx(TitleFieldTemplate, { id: titleId(idSchema), title: title, required: required, schema: schema, uiSchema: uiSchema, registry: registry })), description &amp;&amp; (_jsx(DescriptionFieldTemplate, { id: descriptionId(idSchema), description: description, schema: schema, uiSchema: uiSchema, registry: registry })), properties.map((prop) =&gt; prop.content), canExpand(schema, uiSchema, formData) &amp;&amp; (_jsx(AddButton, { className: 'object-property-expand', onClick: onAddClick(schema), disabled: disabled || readonly, uiSchema: uiSchema, registry: registry }))] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ObjectFieldTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const REQUIRED_FIELD_SYMBOL = '*';</span><span class="s3">\n</span><span class="s1">/** The `TitleField` is the template to use to render the title of a field</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `TitleFieldProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function TitleField(props) {</span><span class="s3">\n    </span><span class="s1">const { id, title, required } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">legend</span><span class="s3">\&quot;</span><span class="s1">, { id: id, children: [title, required &amp;&amp; _jsx(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { className: 'required', children: REQUIRED_FIELD_SYMBOL })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=TitleField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TranslatableString } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import Markdown from 'markdown-to-jsx';</span><span class="s3">\n</span><span class="s1">/** The `UnsupportedField` component is used to render a field in the schema is one that is not supported by</span><span class="s3">\n </span><span class="s1">* react-jsonschema-form.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `FieldProps` for this template</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function UnsupportedField(props) {</span><span class="s3">\n    </span><span class="s1">const { schema, idSchema, reason, registry } = props;</span><span class="s3">\n    </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n    </span><span class="s1">let translateEnum = TranslatableString.UnsupportedField;</span><span class="s3">\n    </span><span class="s1">const translateParams = [];</span><span class="s3">\n    </span><span class="s1">if (idSchema &amp;&amp; idSchema.$id) {</span><span class="s3">\n        </span><span class="s1">translateEnum = TranslatableString.UnsupportedFieldWithId;</span><span class="s3">\n        </span><span class="s1">translateParams.push(idSchema.$id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (reason) {</span><span class="s3">\n        </span><span class="s1">translateEnum =</span><span class="s3">\n            </span><span class="s1">translateEnum === TranslatableString.UnsupportedField</span><span class="s3">\n                </span><span class="s1">? TranslatableString.UnsupportedFieldWithReason</span><span class="s3">\n                </span><span class="s1">: TranslatableString.UnsupportedFieldWithIdAndReason;</span><span class="s3">\n        </span><span class="s1">translateParams.push(reason);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'unsupported-field', children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">, { children: _jsx(Markdown, { children: translateString(translateEnum, translateParams) }) }), schema &amp;&amp; _jsx(</span><span class="s3">\&quot;</span><span class="s1">pre</span><span class="s3">\&quot;</span><span class="s1">, { children: JSON.stringify(schema, null, 2) })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default UnsupportedField;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=UnsupportedField.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ADDITIONAL_PROPERTY_FLAG, TranslatableString, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import Label from './FieldTemplate/Label';</span><span class="s3">\n</span><span class="s1">/** The `WrapIfAdditional` component is used by the `FieldTemplate` to rename, or remove properties that are</span><span class="s3">\n </span><span class="s1">* part of an `additionalProperties` part of a schema.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WrapIfAdditionalProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function WrapIfAdditionalTemplate(props) {</span><span class="s3">\n    </span><span class="s1">const { id, classNames, style, disabled, label, onKeyChange, onDropPropertyClick, readonly, required, schema, children, uiSchema, registry, } = props;</span><span class="s3">\n    </span><span class="s1">const { templates, translateString } = registry;</span><span class="s3">\n    </span><span class="s1">// Button templates are not overridden in the uiSchema</span><span class="s3">\n    </span><span class="s1">const { RemoveButton } = templates.ButtonTemplates;</span><span class="s3">\n    </span><span class="s1">const keyLabel = translateString(TranslatableString.KeyLabel, [label]);</span><span class="s3">\n    </span><span class="s1">const additional = ADDITIONAL_PROPERTY_FLAG in schema;</span><span class="s3">\n    </span><span class="s1">if (!additional) {</span><span class="s3">\n        </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: classNames, style: style, children: children }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: classNames, style: style, children: _jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'row', children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'col-xs-5 form-additional', children: _jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'form-group', children: [_jsx(Label, { label: keyLabel, required: required, id: `${id}-key` }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { className: 'form-control', type: 'text', id: `${id}-key`, onBlur: (event) =&gt; onKeyChange(event.target.value), defaultValue: label })] }) }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'form-additional form-group col-xs-5', children: children }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'col-xs-2', children: _jsx(RemoveButton, { className: 'array-item-remove btn-block', style: { border: '0' }, disabled: disabled || readonly, onClick: onDropPropertyClick(label), uiSchema: uiSchema, registry: registry }) })] }) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=WrapIfAdditionalTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import ArrayFieldDescriptionTemplate from './ArrayFieldDescriptionTemplate';</span><span class="s3">\n</span><span class="s1">import ArrayFieldItemTemplate from './ArrayFieldItemTemplate';</span><span class="s3">\n</span><span class="s1">import ArrayFieldTemplate from './ArrayFieldTemplate';</span><span class="s3">\n</span><span class="s1">import ArrayFieldTitleTemplate from './ArrayFieldTitleTemplate';</span><span class="s3">\n</span><span class="s1">import BaseInputTemplate from './BaseInputTemplate';</span><span class="s3">\n</span><span class="s1">import ButtonTemplates from './ButtonTemplates';</span><span class="s3">\n</span><span class="s1">import DescriptionField from './DescriptionField';</span><span class="s3">\n</span><span class="s1">import ErrorList from './ErrorList';</span><span class="s3">\n</span><span class="s1">import FieldTemplate from './FieldTemplate';</span><span class="s3">\n</span><span class="s1">import FieldErrorTemplate from './FieldErrorTemplate';</span><span class="s3">\n</span><span class="s1">import FieldHelpTemplate from './FieldHelpTemplate';</span><span class="s3">\n</span><span class="s1">import ObjectFieldTemplate from './ObjectFieldTemplate';</span><span class="s3">\n</span><span class="s1">import TitleField from './TitleField';</span><span class="s3">\n</span><span class="s1">import UnsupportedField from './UnsupportedField';</span><span class="s3">\n</span><span class="s1">import WrapIfAdditionalTemplate from './WrapIfAdditionalTemplate';</span><span class="s3">\n</span><span class="s1">function templates() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">ArrayFieldDescriptionTemplate,</span><span class="s3">\n        </span><span class="s1">ArrayFieldItemTemplate,</span><span class="s3">\n        </span><span class="s1">ArrayFieldTemplate,</span><span class="s3">\n        </span><span class="s1">ArrayFieldTitleTemplate,</span><span class="s3">\n        </span><span class="s1">ButtonTemplates: ButtonTemplates(),</span><span class="s3">\n        </span><span class="s1">BaseInputTemplate,</span><span class="s3">\n        </span><span class="s1">DescriptionFieldTemplate: DescriptionField,</span><span class="s3">\n        </span><span class="s1">ErrorListTemplate: ErrorList,</span><span class="s3">\n        </span><span class="s1">FieldTemplate,</span><span class="s3">\n        </span><span class="s1">FieldErrorTemplate,</span><span class="s3">\n        </span><span class="s1">FieldHelpTemplate,</span><span class="s3">\n        </span><span class="s1">ObjectFieldTemplate,</span><span class="s3">\n        </span><span class="s1">TitleFieldTemplate: TitleField,</span><span class="s3">\n        </span><span class="s1">UnsupportedFieldTemplate: UnsupportedField,</span><span class="s3">\n        </span><span class="s1">WrapIfAdditionalTemplate,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default templates;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback, useEffect, useReducer, useState } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, parseDateString, toDateString, pad, TranslatableString, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">function rangeOptions(start, stop) {</span><span class="s3">\n    </span><span class="s1">const options = [];</span><span class="s3">\n    </span><span class="s1">for (let i = start; i &lt;= stop; i++) {</span><span class="s3">\n        </span><span class="s1">options.push({ value: i, label: pad(i, 2) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return options;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readyForChange(state) {</span><span class="s3">\n    </span><span class="s1">return Object.values(state).every((value) =&gt; value !== -1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function dateElementProps(state, time, yearsRange = [1900, new Date().getFullYear() + 2]) {</span><span class="s3">\n    </span><span class="s1">const { year, month, day, hour, minute, second } = state;</span><span class="s3">\n    </span><span class="s1">const data = [</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: 'year',</span><span class="s3">\n            </span><span class="s1">range: yearsRange,</span><span class="s3">\n            </span><span class="s1">value: year,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{ type: 'month', range: [1, 12], value: month },</span><span class="s3">\n        </span><span class="s1">{ type: 'day', range: [1, 31], value: day },</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">if (time) {</span><span class="s3">\n        </span><span class="s1">data.push({ type: 'hour', range: [0, 23], value: hour }, { type: 'minute', range: [0, 59], value: minute }, { type: 'second', range: [0, 59], value: second });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return data;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function DateElement({ type, range, value, select, rootId, name, disabled, readonly, autofocus, registry, onBlur, onFocus, }) {</span><span class="s3">\n    </span><span class="s1">const id = rootId + '_' + type;</span><span class="s3">\n    </span><span class="s1">const { SelectWidget } = registry.widgets;</span><span class="s3">\n    </span><span class="s1">return (_jsx(SelectWidget, { schema: { type: 'integer' }, id: id, name: name, className: 'form-control', options: { enumOptions: rangeOptions(range[0], range[1]) }, placeholder: type, value: value, disabled: disabled, readonly: readonly, autofocus: autofocus, onChange: (value) =&gt; select(type, value), onBlur: onBlur, onFocus: onFocus, registry: registry, label: '', </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(rootId) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** The `AltDateWidget` is an alternative widget for rendering date properties.</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function AltDateWidget({ time = false, disabled = false, readonly = false, autofocus = false, options, id, name, registry, onBlur, onFocus, onChange, value, }) {</span><span class="s3">\n    </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n    </span><span class="s1">const [lastValue, setLastValue] = useState(value);</span><span class="s3">\n    </span><span class="s1">const [state, setState] = useReducer((state, action) =&gt; {</span><span class="s3">\n        </span><span class="s1">return { ...state, ...action };</span><span class="s3">\n    </span><span class="s1">}, parseDateString(value, time));</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n        </span><span class="s1">const stateValue = toDateString(state, time);</span><span class="s3">\n        </span><span class="s1">if (readyForChange(state) &amp;&amp; stateValue !== value) {</span><span class="s3">\n            </span><span class="s1">// The user changed the date to a new valid data via the comboboxes, so call onChange</span><span class="s3">\n            </span><span class="s1">onChange(stateValue);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (lastValue !== value) {</span><span class="s3">\n            </span><span class="s1">// We got a new value in the props</span><span class="s3">\n            </span><span class="s1">setLastValue(value);</span><span class="s3">\n            </span><span class="s1">setState(parseDateString(value, time));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [time, value, onChange, state, lastValue]);</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((property, value) =&gt; {</span><span class="s3">\n        </span><span class="s1">setState({ [property]: value });</span><span class="s3">\n    </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">const handleSetNow = useCallback((event) =&gt; {</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">if (disabled || readonly) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const nextState = parseDateString(new Date().toJSON(), time);</span><span class="s3">\n        </span><span class="s1">onChange(toDateString(nextState, time));</span><span class="s3">\n    </span><span class="s1">}, [disabled, readonly, time]);</span><span class="s3">\n    </span><span class="s1">const handleClear = useCallback((event) =&gt; {</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">if (disabled || readonly) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">onChange(undefined);</span><span class="s3">\n    </span><span class="s1">}, [disabled, readonly, onChange]);</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">, { className: 'list-inline', children: [dateElementProps(state, time, options.yearsRange).map((elemProps, i) =&gt; (_jsx(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">, { className: 'list-inline-item', children: _jsx(DateElement, { rootId: id, name: name, select: handleChange, ...elemProps, disabled: disabled, readonly: readonly, registry: registry, onBlur: onBlur, onFocus: onFocus, autofocus: autofocus &amp;&amp; i === 0 }) }, i))), (options.hideNowButton !== 'undefined' ? !options.hideNowButton : true) &amp;&amp; (_jsx(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">, { className: 'list-inline-item', children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">, { href: '#', className: 'btn btn-info btn-now', onClick: handleSetNow, children: translateString(TranslatableString.NowLabel) }) })), (options.hideClearButton !== 'undefined' ? !options.hideClearButton : true) &amp;&amp; (_jsx(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">, { className: 'list-inline-item', children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">, { href: '#', className: 'btn btn-warning btn-clear', onClick: handleClear, children: translateString(TranslatableString.ClearLabel) }) }))] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default AltDateWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=AltDateWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/** The `AltDateTimeWidget` is an alternative widget for rendering datetime properties.</span><span class="s3">\n </span><span class="s1">*  It uses the AltDateWidget for rendering, with the `time` prop set to true by default.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function AltDateTimeWidget({ time = true, ...props }) {</span><span class="s3">\n    </span><span class="s1">const { AltDateWidget } = props.registry.widgets;</span><span class="s3">\n    </span><span class="s1">return _jsx(AltDateWidget, { time: time, ...props });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default AltDateTimeWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=AltDateTimeWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, descriptionId, getTemplate, labelValue, schemaRequiresTrueValue, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `CheckBoxWidget` is a widget for rendering boolean properties.</span><span class="s3">\n </span><span class="s1">*  It is typically used to represent a boolean.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function CheckboxWidget({ schema, uiSchema, options, id, value, disabled, readonly, label, hideLabel, autofocus = false, onBlur, onFocus, onChange, registry, }) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const DescriptionFieldTemplate = getTemplate('DescriptionFieldTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">// Because an unchecked checkbox will cause html5 validation to fail, only add</span><span class="s3">\n    </span><span class="s1">// the </span><span class="s3">\&quot;</span><span class="s1">required</span><span class="s3">\&quot; </span><span class="s1">attribute if the field value must be </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">, due to the</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot; </span><span class="s1">keywords</span><span class="s3">\n    </span><span class="s1">const required = schemaRequiresTrueValue(schema);</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((event) =&gt; onChange(event.target.checked), [onChange]);</span><span class="s3">\n    </span><span class="s1">const handleBlur = useCallback((event) =&gt; onBlur(id, event.target.checked), [onBlur, id]);</span><span class="s3">\n    </span><span class="s1">const handleFocus = useCallback((event) =&gt; onFocus(id, event.target.checked), [onFocus, id]);</span><span class="s3">\n    </span><span class="s1">const description = (_a = options.description) !== null &amp;&amp; _a !== void 0 ? _a : schema.description;</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: `checkbox ${disabled || readonly ? 'disabled' : ''}`, children: [!hideLabel &amp;&amp; !!description &amp;&amp; (_jsx(DescriptionFieldTemplate, { id: descriptionId(id), description: description, schema: schema, uiSchema: uiSchema, registry: registry })), _jsxs(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, { children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { type: 'checkbox', id: id, name: id, checked: typeof value === 'undefined' ? false : value, required: required, disabled: disabled || readonly, autoFocus: autofocus, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(id) }), labelValue(_jsx(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { children: label }), hideLabel)] })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default CheckboxWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=CheckboxWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, enumOptionsDeselectValue, enumOptionsIsSelected, enumOptionsSelectValue, enumOptionsValueForIndex, optionId, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `CheckboxesWidget` is a widget for rendering checkbox groups.</span><span class="s3">\n </span><span class="s1">*  It is typically used to represent an array of enums.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function CheckboxesWidget({ id, disabled, options: { inline = false, enumOptions, enumDisabled, emptyValue }, value, autofocus = false, readonly, onChange, onBlur, onFocus, }) {</span><span class="s3">\n    </span><span class="s1">const checkboxesValues = Array.isArray(value) ? value : [value];</span><span class="s3">\n    </span><span class="s1">const handleBlur = useCallback(({ target: { value } }) =&gt; onBlur(id, enumOptionsValueForIndex(value, enumOptions, emptyValue)), [onBlur, id]);</span><span class="s3">\n    </span><span class="s1">const handleFocus = useCallback(({ target: { value } }) =&gt; onFocus(id, enumOptionsValueForIndex(value, enumOptions, emptyValue)), [onFocus, id]);</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'checkboxes', id: id, children: Array.isArray(enumOptions) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">enumOptions.map((option, index) =&gt; {</span><span class="s3">\n                </span><span class="s1">const checked = enumOptionsIsSelected(option.value, checkboxesValues);</span><span class="s3">\n                </span><span class="s1">const itemDisabled = Array.isArray(enumDisabled) &amp;&amp; enumDisabled.indexOf(option.value) !== -1;</span><span class="s3">\n                </span><span class="s1">const disabledCls = disabled || itemDisabled || readonly ? 'disabled' : '';</span><span class="s3">\n                </span><span class="s1">const handleChange = (event) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (event.target.checked) {</span><span class="s3">\n                        </span><span class="s1">onChange(enumOptionsSelectValue(index, checkboxesValues, enumOptions));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">onChange(enumOptionsDeselectValue(index, checkboxesValues, enumOptions));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">const checkbox = (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { type: 'checkbox', id: optionId(id, index), name: id, checked: checked, value: String(index), disabled: disabled || itemDisabled || readonly, autoFocus: autofocus &amp;&amp; index === 0, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(id) }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { children: option.label })] }));</span><span class="s3">\n                </span><span class="s1">return inline ? (_jsx(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, { className: `checkbox-inline ${disabledCls}`, children: checkbox }, index)) : (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: `checkbox ${disabledCls}`, children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, { children: checkbox }) }, index));</span><span class="s3">\n            </span><span class="s1">}) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default CheckboxesWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=CheckboxesWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `ColorWidget` component uses the `BaseInputTemplate` changing the type to `color` and disables it when it is</span><span class="s3">\n </span><span class="s1">* either disabled or readonly.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function ColorWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { disabled, readonly, options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'color', ...props, disabled: disabled || readonly });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ColorWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `DateWidget` component uses the `BaseInputTemplate` changing the type to `date` and transforms</span><span class="s3">\n </span><span class="s1">* the value to undefined when it is falsy during the `onChange` handling.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function DateWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { onChange, options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((value) =&gt; onChange(value || undefined), [onChange]);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'date', ...props, onChange: handleChange });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=DateWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate, localToUTC, utcToLocal, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `DateTimeWidget` component uses the `BaseInputTemplate` changing the type to `datetime-local` and transforms</span><span class="s3">\n </span><span class="s1">* the value to/from utc using the appropriate utility functions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function DateTimeWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { onChange, value, options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return (_jsx(BaseInputTemplate, { type: 'datetime-local', ...props, value: utcToLocal(value), onChange: (value) =&gt; onChange(localToUTC(value)) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=DateTimeWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `EmailWidget` component uses the `BaseInputTemplate` changing the type to `email`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function EmailWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'email', ...props });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=EmailWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback, useState } from 'react';</span><span class="s3">\n</span><span class="s1">import { dataURItoBlob, getTemplate, TranslatableString, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import Markdown from 'markdown-to-jsx';</span><span class="s3">\n</span><span class="s1">function addNameToDataURL(dataURL, name) {</span><span class="s3">\n    </span><span class="s1">if (dataURL === null) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function processFile(file) {</span><span class="s3">\n    </span><span class="s1">const { name, size, type } = file;</span><span class="s3">\n    </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n        </span><span class="s1">const reader = new window.FileReader();</span><span class="s3">\n        </span><span class="s1">reader.onerror = reject;</span><span class="s3">\n        </span><span class="s1">reader.onload = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">var _a;</span><span class="s3">\n            </span><span class="s1">if (typeof ((_a = event.target) === null || _a === void 0 ? void 0 : _a.result) === 'string') {</span><span class="s3">\n                </span><span class="s1">resolve({</span><span class="s3">\n                    </span><span class="s1">dataURL: addNameToDataURL(event.target.result, name),</span><span class="s3">\n                    </span><span class="s1">name,</span><span class="s3">\n                    </span><span class="s1">size,</span><span class="s3">\n                    </span><span class="s1">type,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">resolve({</span><span class="s3">\n                    </span><span class="s1">dataURL: null,</span><span class="s3">\n                    </span><span class="s1">name,</span><span class="s3">\n                    </span><span class="s1">size,</span><span class="s3">\n                    </span><span class="s1">type,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">reader.readAsDataURL(file);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function processFiles(files) {</span><span class="s3">\n    </span><span class="s1">return Promise.all(Array.from(files).map(processFile));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function FileInfoPreview({ fileInfo, registry, }) {</span><span class="s3">\n    </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n    </span><span class="s1">const { dataURL, type, name } = fileInfo;</span><span class="s3">\n    </span><span class="s1">if (!dataURL) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type.indexOf('image') !== -1) {</span><span class="s3">\n        </span><span class="s1">return _jsx(</span><span class="s3">\&quot;</span><span class="s1">img</span><span class="s3">\&quot;</span><span class="s1">, { src: dataURL, style: { maxWidth: '100%' }, className: 'file-preview' });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (_jsxs(_Fragment, { children: [' ', _jsx(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">, { download: `preview-${name}`, href: dataURL, className: 'file-download', children: translateString(TranslatableString.PreviewLabel) })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function FilesInfo({ filesInfo, registry, preview, }) {</span><span class="s3">\n    </span><span class="s1">if (filesInfo.length === 0) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { translateString } = registry;</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">, { className: 'file-info', children: filesInfo.map((fileInfo, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { name, size, type } = fileInfo;</span><span class="s3">\n            </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">, { children: [_jsx(Markdown, { children: translateString(TranslatableString.FilesInfo, [name, type, String(size)]) }), preview &amp;&amp; _jsx(FileInfoPreview, { fileInfo: fileInfo, registry: registry })] }, key));</span><span class="s3">\n        </span><span class="s1">}) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function extractFileInfo(dataURLs) {</span><span class="s3">\n    </span><span class="s1">return dataURLs</span><span class="s3">\n        </span><span class="s1">.filter((dataURL) =&gt; dataURL)</span><span class="s3">\n        </span><span class="s1">.map((dataURL) =&gt; {</span><span class="s3">\n        </span><span class="s1">const { blob, name } = dataURItoBlob(dataURL);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">dataURL,</span><span class="s3">\n            </span><span class="s1">name: name,</span><span class="s3">\n            </span><span class="s1">size: blob.size,</span><span class="s3">\n            </span><span class="s1">type: blob.type,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*  The `FileWidget` is a widget for rendering file upload fields.</span><span class="s3">\n </span><span class="s1">*  It is typically used with a string property with data-url format.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function FileWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">const [filesInfo, setFilesInfo] = useState(Array.isArray(value) ? extractFileInfo(value) : extractFileInfo([value]));</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((event) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!event.target.files) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Due to variances in themes, dealing with multiple files for the array case now happens one file at a time.</span><span class="s3">\n        </span><span class="s1">// This is because we don't pass `multiple` into the `BaseInputTemplate` anymore. Instead, we deal with the single</span><span class="s3">\n        </span><span class="s1">// file in each event and concatenate them together ourselves</span><span class="s3">\n        </span><span class="s1">processFiles(event.target.files).then((filesInfoEvent) =&gt; {</span><span class="s3">\n            </span><span class="s1">const newValue = filesInfoEvent.map((fileInfo) =&gt; fileInfo.dataURL);</span><span class="s3">\n            </span><span class="s1">if (multiple) {</span><span class="s3">\n                </span><span class="s1">setFilesInfo(filesInfo.concat(filesInfoEvent[0]));</span><span class="s3">\n                </span><span class="s1">onChange(value.concat(newValue[0]));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">setFilesInfo(filesInfoEvent);</span><span class="s3">\n                </span><span class="s1">onChange(newValue[0]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}, [multiple, value, filesInfo, onChange]);</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { children: [_jsx(BaseInputTemplate, { ...props, disabled: disabled || readonly, type: 'file', required: value ? false : required, onChangeOverride: handleChange, value: '', accept: options.accept ? String(options.accept) : undefined }), _jsx(FilesInfo, { filesInfo: filesInfo, registry: registry, preview: options.filePreview })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default FileWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=FileWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/** The `HiddenWidget` is a widget for rendering a hidden input field.</span><span class="s3">\n </span><span class="s1">*  It is typically used by setting type to </span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function HiddenWidget({ id, value, }) {</span><span class="s3">\n    </span><span class="s1">return _jsx(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { type: 'hidden', id: id, name: id, value: typeof value === 'undefined' ? '' : value });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default HiddenWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=HiddenWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `PasswordWidget` component uses the `BaseInputTemplate` changing the type to `password`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function PasswordWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'password', ...props });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=PasswordWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, enumOptionsIsSelected, enumOptionsValueForIndex, optionId, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `RadioWidget` is a widget for rendering a radio group.</span><span class="s3">\n </span><span class="s1">*  It is typically used with a string property constrained with enum options.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function RadioWidget({ options, value, required, disabled, readonly, autofocus = false, onBlur, onFocus, onChange, id, }) {</span><span class="s3">\n    </span><span class="s1">const { enumOptions, enumDisabled, inline, emptyValue } = options;</span><span class="s3">\n    </span><span class="s1">const handleBlur = useCallback(({ target: { value } }) =&gt; onBlur(id, enumOptionsValueForIndex(value, enumOptions, emptyValue)), [onBlur, id]);</span><span class="s3">\n    </span><span class="s1">const handleFocus = useCallback(({ target: { value } }) =&gt; onFocus(id, enumOptionsValueForIndex(value, enumOptions, emptyValue)), [onFocus, id]);</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'field-radio-group', id: id, children: Array.isArray(enumOptions) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">enumOptions.map((option, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">const checked = enumOptionsIsSelected(option.value, value);</span><span class="s3">\n                </span><span class="s1">const itemDisabled = Array.isArray(enumDisabled) &amp;&amp; enumDisabled.indexOf(option.value) !== -1;</span><span class="s3">\n                </span><span class="s1">const disabledCls = disabled || itemDisabled || readonly ? 'disabled' : '';</span><span class="s3">\n                </span><span class="s1">const handleChange = () =&gt; onChange(option.value);</span><span class="s3">\n                </span><span class="s1">const radio = (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { children: [_jsx(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { type: 'radio', id: optionId(id, i), checked: checked, name: id, required: required, value: String(i), disabled: disabled || itemDisabled || readonly, autoFocus: autofocus &amp;&amp; i === 0, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(id) }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { children: option.label })] }));</span><span class="s3">\n                </span><span class="s1">return inline ? (_jsx(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, { className: `radio-inline ${disabledCls}`, children: radio }, i)) : (_jsx(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: `radio ${disabledCls}`, children: _jsx(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, { children: radio }) }, i));</span><span class="s3">\n            </span><span class="s1">}) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default RadioWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=RadioWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/** The `RangeWidget` component uses the `BaseInputTemplate` changing the type to `range` and wrapping the result</span><span class="s3">\n </span><span class="s1">* in a div, with the value along side it.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function RangeWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { value, registry: { templates: { BaseInputTemplate }, }, } = props;</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { className: 'field-range-wrapper', children: [_jsx(BaseInputTemplate, { type: 'range', ...props }), _jsx(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">, { className: 'range-view', children: value })] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=RangeWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, enumOptionsIndexForValue, enumOptionsValueForIndex, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">function getValue(event, multiple) {</span><span class="s3">\n    </span><span class="s1">if (multiple) {</span><span class="s3">\n        </span><span class="s1">return Array.from(event.target.options)</span><span class="s3">\n            </span><span class="s1">.slice()</span><span class="s3">\n            </span><span class="s1">.filter((o) =&gt; o.selected)</span><span class="s3">\n            </span><span class="s1">.map((o) =&gt; o.value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return event.target.value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** The `SelectWidget` is a widget for rendering dropdowns.</span><span class="s3">\n </span><span class="s1">*  It is typically used with string properties constrained with enum options.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function SelectWidget({ schema, id, options, value, required, disabled, readonly, multiple = false, autofocus = false, onChange, onBlur, onFocus, placeholder, }) {</span><span class="s3">\n    </span><span class="s1">const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;</span><span class="s3">\n    </span><span class="s1">const emptyValue = multiple ? [] : '';</span><span class="s3">\n    </span><span class="s1">const handleFocus = useCallback((event) =&gt; {</span><span class="s3">\n        </span><span class="s1">const newValue = getValue(event, multiple);</span><span class="s3">\n        </span><span class="s1">return onFocus(id, enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));</span><span class="s3">\n    </span><span class="s1">}, [onFocus, id, schema, multiple, options]);</span><span class="s3">\n    </span><span class="s1">const handleBlur = useCallback((event) =&gt; {</span><span class="s3">\n        </span><span class="s1">const newValue = getValue(event, multiple);</span><span class="s3">\n        </span><span class="s1">return onBlur(id, enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));</span><span class="s3">\n    </span><span class="s1">}, [onBlur, id, schema, multiple, options]);</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((event) =&gt; {</span><span class="s3">\n        </span><span class="s1">const newValue = getValue(event, multiple);</span><span class="s3">\n        </span><span class="s1">return onChange(enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));</span><span class="s3">\n    </span><span class="s1">}, [onChange, schema, multiple, options]);</span><span class="s3">\n    </span><span class="s1">const selectedIndexes = enumOptionsIndexForValue(value, enumOptions, multiple);</span><span class="s3">\n    </span><span class="s1">return (_jsxs(</span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">, { id: id, name: id, multiple: multiple, className: 'form-control', value: typeof selectedIndexes === 'undefined' ? emptyValue : selectedIndexes, required: required, disabled: disabled || readonly, autoFocus: autofocus, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(id), children: [!multiple &amp;&amp; schema.default === undefined &amp;&amp; _jsx(</span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">, { value: '', children: placeholder }), Array.isArray(enumOptions) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">enumOptions.map(({ value, label }, i) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const disabled = enumDisabled &amp;&amp; enumDisabled.indexOf(value) !== -1;</span><span class="s3">\n                    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">, { value: String(i), disabled: disabled, children: label }, i));</span><span class="s3">\n                </span><span class="s1">})] }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default SelectWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=SelectWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `TextareaWidget` is a widget for rendering input fields as textarea.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function TextareaWidget({ id, options = {}, placeholder, value, required, disabled, readonly, autofocus = false, onChange, onBlur, onFocus, }) {</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback(({ target: { value } }) =&gt; onChange(value === '' ? options.emptyValue : value), [onChange, options.emptyValue]);</span><span class="s3">\n    </span><span class="s1">const handleBlur = useCallback(({ target: { value } }) =&gt; onBlur(id, value), [onBlur, id]);</span><span class="s3">\n    </span><span class="s1">const handleFocus = useCallback(({ target: { value } }) =&gt; onFocus(id, value), [id, onFocus]);</span><span class="s3">\n    </span><span class="s1">return (_jsx(</span><span class="s3">\&quot;</span><span class="s1">textarea</span><span class="s3">\&quot;</span><span class="s1">, { id: id, name: id, className: 'form-control', value: value ? value : '', placeholder: placeholder, required: required, disabled: disabled, readOnly: readonly, autoFocus: autofocus, rows: options.rows, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, </span><span class="s3">\&quot;</span><span class="s1">aria-describedby</span><span class="s3">\&quot;</span><span class="s1">: ariaDescribedByIds(id) }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">TextareaWidget.defaultProps = {</span><span class="s3">\n    </span><span class="s1">autofocus: false,</span><span class="s3">\n    </span><span class="s1">options: {},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export default TextareaWidget;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=TextareaWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `TextWidget` component uses the `BaseInputTemplate`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function TextWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { ...props });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=TextWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `TimeWidget` component uses the `BaseInputTemplate` changing the type to `time` and transforms</span><span class="s3">\n </span><span class="s1">* the value to undefined when it is falsy during the `onChange` handling.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function TimeWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { onChange, options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">const handleChange = useCallback((value) =&gt; onChange(value ? `${value}:00` : undefined), [onChange]);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'time', ...props, onChange: handleChange });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=TimeWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `URLWidget` component uses the `BaseInputTemplate` changing the type to `url`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function URLWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'url', ...props });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=URLWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getTemplate } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** The `UpDownWidget` component uses the `BaseInputTemplate` changing the type to `number`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param props - The `WidgetProps` for this component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function UpDownWidget(props) {</span><span class="s3">\n    </span><span class="s1">const { options, registry } = props;</span><span class="s3">\n    </span><span class="s1">const BaseInputTemplate = getTemplate('BaseInputTemplate', registry, options);</span><span class="s3">\n    </span><span class="s1">return _jsx(BaseInputTemplate, { type: 'number', ...props });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=UpDownWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import AltDateWidget from './AltDateWidget';</span><span class="s3">\n</span><span class="s1">import AltDateTimeWidget from './AltDateTimeWidget';</span><span class="s3">\n</span><span class="s1">import CheckboxWidget from './CheckboxWidget';</span><span class="s3">\n</span><span class="s1">import CheckboxesWidget from './CheckboxesWidget';</span><span class="s3">\n</span><span class="s1">import ColorWidget from './ColorWidget';</span><span class="s3">\n</span><span class="s1">import DateWidget from './DateWidget';</span><span class="s3">\n</span><span class="s1">import DateTimeWidget from './DateTimeWidget';</span><span class="s3">\n</span><span class="s1">import EmailWidget from './EmailWidget';</span><span class="s3">\n</span><span class="s1">import FileWidget from './FileWidget';</span><span class="s3">\n</span><span class="s1">import HiddenWidget from './HiddenWidget';</span><span class="s3">\n</span><span class="s1">import PasswordWidget from './PasswordWidget';</span><span class="s3">\n</span><span class="s1">import RadioWidget from './RadioWidget';</span><span class="s3">\n</span><span class="s1">import RangeWidget from './RangeWidget';</span><span class="s3">\n</span><span class="s1">import SelectWidget from './SelectWidget';</span><span class="s3">\n</span><span class="s1">import TextareaWidget from './TextareaWidget';</span><span class="s3">\n</span><span class="s1">import TextWidget from './TextWidget';</span><span class="s3">\n</span><span class="s1">import TimeWidget from './TimeWidget';</span><span class="s3">\n</span><span class="s1">import URLWidget from './URLWidget';</span><span class="s3">\n</span><span class="s1">import UpDownWidget from './UpDownWidget';</span><span class="s3">\n</span><span class="s1">function widgets() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">AltDateWidget,</span><span class="s3">\n        </span><span class="s1">AltDateTimeWidget,</span><span class="s3">\n        </span><span class="s1">CheckboxWidget,</span><span class="s3">\n        </span><span class="s1">CheckboxesWidget,</span><span class="s3">\n        </span><span class="s1">ColorWidget,</span><span class="s3">\n        </span><span class="s1">DateWidget,</span><span class="s3">\n        </span><span class="s1">DateTimeWidget,</span><span class="s3">\n        </span><span class="s1">EmailWidget,</span><span class="s3">\n        </span><span class="s1">FileWidget,</span><span class="s3">\n        </span><span class="s1">HiddenWidget,</span><span class="s3">\n        </span><span class="s1">PasswordWidget,</span><span class="s3">\n        </span><span class="s1">RadioWidget,</span><span class="s3">\n        </span><span class="s1">RangeWidget,</span><span class="s3">\n        </span><span class="s1">SelectWidget,</span><span class="s3">\n        </span><span class="s1">TextWidget,</span><span class="s3">\n        </span><span class="s1">TextareaWidget,</span><span class="s3">\n        </span><span class="s1">TimeWidget,</span><span class="s3">\n        </span><span class="s1">UpDownWidget,</span><span class="s3">\n        </span><span class="s1">URLWidget,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default widgets;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { englishStringTranslator } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import fields from './components/fields';</span><span class="s3">\n</span><span class="s1">import templates from './components/templates';</span><span class="s3">\n</span><span class="s1">import widgets from './components/widgets';</span><span class="s3">\n</span><span class="s1">/** The default registry consists of all the fields, templates and widgets provided in the core implementation,</span><span class="s3">\n </span><span class="s1">* plus an empty `rootSchema` and `formContext. We omit schemaUtils here because it cannot be defaulted without a</span><span class="s3">\n </span><span class="s1">* rootSchema and validator. It will be added into the computed registry later in the Form.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getDefaultRegistry() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">fields: fields(),</span><span class="s3">\n        </span><span class="s1">templates: templates(),</span><span class="s3">\n        </span><span class="s1">widgets: widgets(),</span><span class="s3">\n        </span><span class="s1">rootSchema: {},</span><span class="s3">\n        </span><span class="s1">formContext: {},</span><span class="s3">\n        </span><span class="s1">translateString: englishStringTranslator,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getDefaultRegistry.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx, jsxs as _jsxs } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Component, createRef } from 'react';</span><span class="s3">\n</span><span class="s1">import { createSchemaUtils, deepEquals, getTemplate, getUiOptions, isObject, mergeObjects, NAME_KEY, RJSF_ADDITONAL_PROPERTIES_FLAG, shouldRender, SUBMIT_BTN_OPTIONS_KEY, toErrorList, UI_GLOBAL_OPTIONS_KEY, UI_OPTIONS_KEY, validationDataMerge, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import _get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import _isEmpty from 'lodash/isEmpty';</span><span class="s3">\n</span><span class="s1">import _pick from 'lodash/pick';</span><span class="s3">\n</span><span class="s1">import _toPath from 'lodash/toPath';</span><span class="s3">\n</span><span class="s1">import getDefaultRegistry from '../getDefaultRegistry';</span><span class="s3">\n</span><span class="s1">/** The `Form` component renders the outer form and all the fields defined in the `schema` */</span><span class="s3">\n</span><span class="s1">export default class Form extends Component {</span><span class="s3">\n    </span><span class="s1">/** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the</span><span class="s3">\n     </span><span class="s1">* `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the</span><span class="s3">\n     </span><span class="s1">* state construction.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param props - The initial props for the `Form`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(props) {</span><span class="s3">\n        </span><span class="s1">super(props);</span><span class="s3">\n        </span><span class="s1">/** Returns the `formData` with only the elements specified in the `fields` list</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param formData - The data for the `Form`</span><span class="s3">\n         </span><span class="s1">* @param fields - The fields to keep while filtering</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.getUsedFormData = (formData, fields) =&gt; {</span><span class="s3">\n            </span><span class="s1">// For the case of a single input form</span><span class="s3">\n            </span><span class="s1">if (fields.length === 0 &amp;&amp; typeof formData !== 'object') {</span><span class="s3">\n                </span><span class="s1">return formData;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// _pick has incorrect type definition, it works with string[][], because lodash/hasIn supports it</span><span class="s3">\n            </span><span class="s1">const data = _pick(formData, fields);</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(formData)) {</span><span class="s3">\n                </span><span class="s1">return Object.keys(data).map((key) =&gt; data[key]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return data;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param pathSchema - The `PathSchema` object for the form</span><span class="s3">\n         </span><span class="s1">* @param [formData] - The form data to use while checking for empty objects/arrays</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.getFieldNames = (pathSchema, formData) =&gt; {</span><span class="s3">\n            </span><span class="s1">const getAllPaths = (_obj, acc = [], paths = [[]]) =&gt; {</span><span class="s3">\n                </span><span class="s1">Object.keys(_obj).forEach((key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (typeof _obj[key] === 'object') {</span><span class="s3">\n                        </span><span class="s1">const newPaths = paths.map((path) =&gt; [...path, key]);</span><span class="s3">\n                        </span><span class="s1">// If an object is marked with additionalProperties, all its keys are valid</span><span class="s3">\n                        </span><span class="s1">if (_obj[key][RJSF_ADDITONAL_PROPERTIES_FLAG] &amp;&amp; _obj[key][NAME_KEY] !== '') {</span><span class="s3">\n                            </span><span class="s1">acc.push(_obj[key][NAME_KEY]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">getAllPaths(_obj[key], acc, newPaths);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (key === NAME_KEY &amp;&amp; _obj[key] !== '') {</span><span class="s3">\n                        </span><span class="s1">paths.forEach((path) =&gt; {</span><span class="s3">\n                            </span><span class="s1">const formValue = _get(formData, path);</span><span class="s3">\n                            </span><span class="s1">// adds path to fieldNames if it points to a value</span><span class="s3">\n                            </span><span class="s1">// or an empty object/array</span><span class="s3">\n                            </span><span class="s1">if (typeof formValue !== 'object' ||</span><span class="s3">\n                                </span><span class="s1">_isEmpty(formValue) ||</span><span class="s3">\n                                </span><span class="s1">(Array.isArray(formValue) &amp;&amp; formValue.every((val) =&gt; typeof val !== 'object'))) {</span><span class="s3">\n                                </span><span class="s1">acc.push(path);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">return acc;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">return getAllPaths(pathSchema);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Function to handle changes made to a field in the `Form`. This handler receives an entirely new copy of the</span><span class="s3">\n         </span><span class="s1">* `formData` along with a new `ErrorSchema`. It will first update the `formData` with any missing default fields and</span><span class="s3">\n         </span><span class="s1">* then, if `omitExtraData` and `liveOmit` are turned on, the `formData` will be filterer to remove any extra data not</span><span class="s3">\n         </span><span class="s1">* in a form field. Then, the resulting formData will be validated if required. The state will be updated with the new</span><span class="s3">\n         </span><span class="s1">* updated (potentially filtered) `formData`, any errors that resulted from validation. Finally the `onChange`</span><span class="s3">\n         </span><span class="s1">* callback will be called if specified with the updated state.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param formData - The new form data from a change to a field</span><span class="s3">\n         </span><span class="s1">* @param newErrorSchema - The new `ErrorSchema` based on the field change</span><span class="s3">\n         </span><span class="s1">* @param id - The id of the field that caused the change</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onChange = (formData, newErrorSchema, id) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange } = this.props;</span><span class="s3">\n            </span><span class="s1">const { schemaUtils, schema, retrievedSchema } = this.state;</span><span class="s3">\n            </span><span class="s1">if (isObject(formData) || Array.isArray(formData)) {</span><span class="s3">\n                </span><span class="s1">const newState = this.getStateFromProps(this.props, formData, retrievedSchema);</span><span class="s3">\n                </span><span class="s1">formData = newState.formData;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const mustValidate = !noValidate &amp;&amp; liveValidate;</span><span class="s3">\n            </span><span class="s1">let state = { formData, schema };</span><span class="s3">\n            </span><span class="s1">let newFormData = formData;</span><span class="s3">\n            </span><span class="s1">let _retrievedSchema;</span><span class="s3">\n            </span><span class="s1">if (omitExtraData === true &amp;&amp; liveOmit === true) {</span><span class="s3">\n                </span><span class="s1">_retrievedSchema = schemaUtils.retrieveSchema(schema, formData);</span><span class="s3">\n                </span><span class="s1">const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, '', formData);</span><span class="s3">\n                </span><span class="s1">const fieldNames = this.getFieldNames(pathSchema, formData);</span><span class="s3">\n                </span><span class="s1">newFormData = this.getUsedFormData(formData, fieldNames);</span><span class="s3">\n                </span><span class="s1">state = {</span><span class="s3">\n                    </span><span class="s1">formData: newFormData,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (mustValidate) {</span><span class="s3">\n                </span><span class="s1">const schemaValidation = this.validate(newFormData, schema, schemaUtils, retrievedSchema);</span><span class="s3">\n                </span><span class="s1">let errors = schemaValidation.errors;</span><span class="s3">\n                </span><span class="s1">let errorSchema = schemaValidation.errorSchema;</span><span class="s3">\n                </span><span class="s1">const schemaValidationErrors = errors;</span><span class="s3">\n                </span><span class="s1">const schemaValidationErrorSchema = errorSchema;</span><span class="s3">\n                </span><span class="s1">if (extraErrors) {</span><span class="s3">\n                    </span><span class="s1">const merged = validationDataMerge(schemaValidation, extraErrors);</span><span class="s3">\n                    </span><span class="s1">errorSchema = merged.errorSchema;</span><span class="s3">\n                    </span><span class="s1">errors = merged.errors;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">state = {</span><span class="s3">\n                    </span><span class="s1">formData: newFormData,</span><span class="s3">\n                    </span><span class="s1">errors,</span><span class="s3">\n                    </span><span class="s1">errorSchema,</span><span class="s3">\n                    </span><span class="s1">schemaValidationErrors,</span><span class="s3">\n                    </span><span class="s1">schemaValidationErrorSchema,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!noValidate &amp;&amp; newErrorSchema) {</span><span class="s3">\n                </span><span class="s1">const errorSchema = extraErrors</span><span class="s3">\n                    </span><span class="s1">? mergeObjects(newErrorSchema, extraErrors, 'preventDuplicates')</span><span class="s3">\n                    </span><span class="s1">: newErrorSchema;</span><span class="s3">\n                </span><span class="s1">state = {</span><span class="s3">\n                    </span><span class="s1">formData: newFormData,</span><span class="s3">\n                    </span><span class="s1">errorSchema: errorSchema,</span><span class="s3">\n                    </span><span class="s1">errors: toErrorList(errorSchema),</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (_retrievedSchema) {</span><span class="s3">\n                </span><span class="s1">state.retrievedSchema = _retrievedSchema;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.setState(state, () =&gt; onChange &amp;&amp; onChange({ ...this.state, ...state }, id));</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Callback function to handle reset form data.</span><span class="s3">\n         </span><span class="s1">* - Reset all fields with default values.</span><span class="s3">\n         </span><span class="s1">* - Reset validations and errors</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.reset = () =&gt; {</span><span class="s3">\n            </span><span class="s1">const { onChange } = this.props;</span><span class="s3">\n            </span><span class="s1">const newState = this.getStateFromProps(this.props, undefined);</span><span class="s3">\n            </span><span class="s1">const newFormData = newState.formData;</span><span class="s3">\n            </span><span class="s1">const state = {</span><span class="s3">\n                </span><span class="s1">formData: newFormData,</span><span class="s3">\n                </span><span class="s1">errorSchema: {},</span><span class="s3">\n                </span><span class="s1">errors: [],</span><span class="s3">\n                </span><span class="s1">schemaValidationErrors: [],</span><span class="s3">\n                </span><span class="s1">schemaValidationErrorSchema: {},</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this.setState(state, () =&gt; onChange &amp;&amp; onChange({ ...this.state, ...state }));</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it</span><span class="s3">\n         </span><span class="s1">* was provided.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param id - The unique `id` of the field that was blurred</span><span class="s3">\n         </span><span class="s1">* @param data - The data associated with the field that was blurred</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onBlur = (id, data) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { onBlur } = this.props;</span><span class="s3">\n            </span><span class="s1">if (onBlur) {</span><span class="s3">\n                </span><span class="s1">onBlur(id, data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it</span><span class="s3">\n         </span><span class="s1">* was provided.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param id - The unique `id` of the field that was focused</span><span class="s3">\n         </span><span class="s1">* @param data - The data associated with the field that was focused</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onFocus = (id, data) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { onFocus } = this.props;</span><span class="s3">\n            </span><span class="s1">if (onFocus) {</span><span class="s3">\n                </span><span class="s1">onFocus(id, data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing</span><span class="s3">\n         </span><span class="s1">* happens if the target and currentTarget of the event are not the same. It will omit any extra data in the</span><span class="s3">\n         </span><span class="s1">* `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors</span><span class="s3">\n         </span><span class="s1">* via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call</span><span class="s3">\n         </span><span class="s1">* back the `onSubmit` callback if it was provided.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param event - The submit HTML form event</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onSubmit = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">if (event.target !== event.currentTarget) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">event.persist();</span><span class="s3">\n            </span><span class="s1">const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;</span><span class="s3">\n            </span><span class="s1">let { formData: newFormData } = this.state;</span><span class="s3">\n            </span><span class="s1">const { schema, schemaUtils } = this.state;</span><span class="s3">\n            </span><span class="s1">if (omitExtraData === true) {</span><span class="s3">\n                </span><span class="s1">const retrievedSchema = schemaUtils.retrieveSchema(schema, newFormData);</span><span class="s3">\n                </span><span class="s1">const pathSchema = schemaUtils.toPathSchema(retrievedSchema, '', newFormData);</span><span class="s3">\n                </span><span class="s1">const fieldNames = this.getFieldNames(pathSchema, newFormData);</span><span class="s3">\n                </span><span class="s1">newFormData = this.getUsedFormData(newFormData, fieldNames);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (noValidate || this.validateForm()) {</span><span class="s3">\n                </span><span class="s1">// There are no errors generated through schema validation.</span><span class="s3">\n                </span><span class="s1">// Check for user provided errors and update state accordingly.</span><span class="s3">\n                </span><span class="s1">const errorSchema = extraErrors || {};</span><span class="s3">\n                </span><span class="s1">const errors = extraErrors ? toErrorList(extraErrors) : [];</span><span class="s3">\n                </span><span class="s1">this.setState({</span><span class="s3">\n                    </span><span class="s1">formData: newFormData,</span><span class="s3">\n                    </span><span class="s1">errors,</span><span class="s3">\n                    </span><span class="s1">errorSchema,</span><span class="s3">\n                    </span><span class="s1">schemaValidationErrors: [],</span><span class="s3">\n                    </span><span class="s1">schemaValidationErrorSchema: {},</span><span class="s3">\n                </span><span class="s1">}, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (onSubmit) {</span><span class="s3">\n                        </span><span class="s1">onSubmit({ ...this.state, formData: newFormData, status: 'submitted' }, event);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (!props.validator) {</span><span class="s3">\n            </span><span class="s1">throw new Error('A validator is required for Form functionality to work');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.state = this.getStateFromProps(props, props.formData);</span><span class="s3">\n        </span><span class="s1">if (this.props.onChange &amp;&amp; !deepEquals(this.state.formData, this.props.formData)) {</span><span class="s3">\n            </span><span class="s1">this.props.onChange(this.state);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.formElement = createRef();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered</span><span class="s3">\n     </span><span class="s1">* output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before</span><span class="s3">\n     </span><span class="s1">* they are potentially changed.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* In this case, it checks if the props have changed since the last render. If they have, it computes the next state</span><span class="s3">\n     </span><span class="s1">* of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF</span><span class="s3">\n     </span><span class="s1">* the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date</span><span class="s3">\n     </span><span class="s1">* state ready to be applied in `componentDidUpdate`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a</span><span class="s3">\n     </span><span class="s1">* state update is not necessary.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param prevProps - The previous set of props before the update.</span><span class="s3">\n     </span><span class="s1">* @param prevState - The previous state before the update.</span><span class="s3">\n     </span><span class="s1">* @returns Either an object containing the next state and a flag indicating that an update should occur, or an object</span><span class="s3">\n     </span><span class="s1">*        with a flag indicating that an update is not necessary.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getSnapshotBeforeUpdate(prevProps, prevState) {</span><span class="s3">\n        </span><span class="s1">if (!deepEquals(this.props, prevProps)) {</span><span class="s3">\n            </span><span class="s1">const nextState = this.getStateFromProps(this.props, this.props.formData, prevProps.schema !== this.props.schema ? undefined : this.state.retrievedSchema);</span><span class="s3">\n            </span><span class="s1">const shouldUpdate = !deepEquals(nextState, prevState);</span><span class="s3">\n            </span><span class="s1">return { nextState, shouldUpdate };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { shouldUpdate: false };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is</span><span class="s3">\n     </span><span class="s1">* not called for the initial render.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.</span><span class="s3">\n     </span><span class="s1">* If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about</span><span class="s3">\n     </span><span class="s1">* changes.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative</span><span class="s3">\n     </span><span class="s1">* to handle prop changes and state updates.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param _ - The previous set of props.</span><span class="s3">\n     </span><span class="s1">* @param prevState - The previous state of the component before the update.</span><span class="s3">\n     </span><span class="s1">* @param snapshot - The value returned from `getSnapshotBeforeUpdate`.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">componentDidUpdate(_, prevState, snapshot) {</span><span class="s3">\n        </span><span class="s1">if (snapshot.shouldUpdate) {</span><span class="s3">\n            </span><span class="s1">const { nextState } = snapshot;</span><span class="s3">\n            </span><span class="s1">if (!deepEquals(nextState.formData, this.props.formData) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!deepEquals(nextState.formData, prevState.formData) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.props.onChange) {</span><span class="s3">\n                </span><span class="s1">this.props.onChange(nextState);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.setState(nextState);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the</span><span class="s3">\n     </span><span class="s1">* `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the</span><span class="s3">\n     </span><span class="s1">* validation process IF required by the `props`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param props - The props passed to the `Form`</span><span class="s3">\n     </span><span class="s1">* @param inputFormData - The new or current data for the `Form`</span><span class="s3">\n     </span><span class="s1">* @returns - The new state for the `Form`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getStateFromProps(props, inputFormData, retrievedSchema) {</span><span class="s3">\n        </span><span class="s1">const state = this.state || {};</span><span class="s3">\n        </span><span class="s1">const schema = 'schema' in props ? props.schema : this.props.schema;</span><span class="s3">\n        </span><span class="s1">const uiSchema = ('uiSchema' in props ? props.uiSchema : this.props.uiSchema) || {};</span><span class="s3">\n        </span><span class="s1">const edit = typeof inputFormData !== 'undefined';</span><span class="s3">\n        </span><span class="s1">const liveValidate = 'liveValidate' in props ? props.liveValidate : this.props.liveValidate;</span><span class="s3">\n        </span><span class="s1">const mustValidate = edit &amp;&amp; !props.noValidate &amp;&amp; liveValidate;</span><span class="s3">\n        </span><span class="s1">const rootSchema = schema;</span><span class="s3">\n        </span><span class="s1">const experimental_defaultFormStateBehavior = 'experimental_defaultFormStateBehavior' in props</span><span class="s3">\n            </span><span class="s1">? props.experimental_defaultFormStateBehavior</span><span class="s3">\n            </span><span class="s1">: this.props.experimental_defaultFormStateBehavior;</span><span class="s3">\n        </span><span class="s1">let schemaUtils = state.schemaUtils;</span><span class="s3">\n        </span><span class="s1">if (!schemaUtils ||</span><span class="s3">\n            </span><span class="s1">schemaUtils.doesSchemaUtilsDiffer(props.validator, rootSchema, experimental_defaultFormStateBehavior)) {</span><span class="s3">\n            </span><span class="s1">schemaUtils = createSchemaUtils(props.validator, rootSchema, experimental_defaultFormStateBehavior);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const formData = schemaUtils.getDefaultFormState(schema, inputFormData);</span><span class="s3">\n        </span><span class="s1">const _retrievedSchema = retrievedSchema !== null &amp;&amp; retrievedSchema !== void 0 ? retrievedSchema : schemaUtils.retrieveSchema(schema, formData);</span><span class="s3">\n        </span><span class="s1">const getCurrentErrors = () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (props.noValidate) {</span><span class="s3">\n                </span><span class="s1">return { errors: [], errorSchema: {} };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!props.liveValidate) {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">errors: state.schemaValidationErrors || [],</span><span class="s3">\n                    </span><span class="s1">errorSchema: state.schemaValidationErrorSchema || {},</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">errors: state.errors || [],</span><span class="s3">\n                </span><span class="s1">errorSchema: state.errorSchema || {},</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let errors;</span><span class="s3">\n        </span><span class="s1">let errorSchema;</span><span class="s3">\n        </span><span class="s1">let schemaValidationErrors = state.schemaValidationErrors;</span><span class="s3">\n        </span><span class="s1">let schemaValidationErrorSchema = state.schemaValidationErrorSchema;</span><span class="s3">\n        </span><span class="s1">if (mustValidate) {</span><span class="s3">\n            </span><span class="s1">const schemaValidation = this.validate(formData, schema, schemaUtils, _retrievedSchema);</span><span class="s3">\n            </span><span class="s1">errors = schemaValidation.errors;</span><span class="s3">\n            </span><span class="s1">errorSchema = schemaValidation.errorSchema;</span><span class="s3">\n            </span><span class="s1">schemaValidationErrors = errors;</span><span class="s3">\n            </span><span class="s1">schemaValidationErrorSchema = errorSchema;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const currentErrors = getCurrentErrors();</span><span class="s3">\n            </span><span class="s1">errors = currentErrors.errors;</span><span class="s3">\n            </span><span class="s1">errorSchema = currentErrors.errorSchema;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (props.extraErrors) {</span><span class="s3">\n            </span><span class="s1">const merged = validationDataMerge({ errorSchema, errors }, props.extraErrors);</span><span class="s3">\n            </span><span class="s1">errorSchema = merged.errorSchema;</span><span class="s3">\n            </span><span class="s1">errors = merged.errors;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const idSchema = schemaUtils.toIdSchema(_retrievedSchema, uiSchema['ui:rootFieldId'], formData, props.idPrefix, props.idSeparator);</span><span class="s3">\n        </span><span class="s1">const nextState = {</span><span class="s3">\n            </span><span class="s1">schemaUtils,</span><span class="s3">\n            </span><span class="s1">schema,</span><span class="s3">\n            </span><span class="s1">uiSchema,</span><span class="s3">\n            </span><span class="s1">idSchema,</span><span class="s3">\n            </span><span class="s1">formData,</span><span class="s3">\n            </span><span class="s1">edit,</span><span class="s3">\n            </span><span class="s1">errors,</span><span class="s3">\n            </span><span class="s1">errorSchema,</span><span class="s3">\n            </span><span class="s1">schemaValidationErrors,</span><span class="s3">\n            </span><span class="s1">schemaValidationErrorSchema,</span><span class="s3">\n            </span><span class="s1">retrievedSchema: _retrievedSchema,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return nextState;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** React lifecycle method that is used to determine whether component should be updated.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param nextProps - The next version of the props</span><span class="s3">\n     </span><span class="s1">* @param nextState - The next version of the state</span><span class="s3">\n     </span><span class="s1">* @returns - True if the component should be updated, false otherwise</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">shouldComponentUpdate(nextProps, nextState) {</span><span class="s3">\n        </span><span class="s1">return shouldRender(this, nextProps, nextState);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the</span><span class="s3">\n     </span><span class="s1">* `schemaUtils` in the state), returning the results.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The new form data to validate</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema used to validate against</span><span class="s3">\n     </span><span class="s1">* @param altSchemaUtils - The alternate schemaUtils to use for validation</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validate(formData, schema = this.props.schema, altSchemaUtils, retrievedSchema) {</span><span class="s3">\n        </span><span class="s1">const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;</span><span class="s3">\n        </span><span class="s1">const { customValidate, transformErrors, uiSchema } = this.props;</span><span class="s3">\n        </span><span class="s1">const resolvedSchema = retrievedSchema !== null &amp;&amp; retrievedSchema !== void 0 ? retrievedSchema : schemaUtils.retrieveSchema(schema, formData);</span><span class="s3">\n        </span><span class="s1">return schemaUtils</span><span class="s3">\n            </span><span class="s1">.getValidator()</span><span class="s3">\n            </span><span class="s1">.validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */</span><span class="s3">\n    </span><span class="s1">renderErrors(registry) {</span><span class="s3">\n        </span><span class="s1">const { errors, errorSchema, schema, uiSchema } = this.state;</span><span class="s3">\n        </span><span class="s1">const { formContext } = this.props;</span><span class="s3">\n        </span><span class="s1">const options = getUiOptions(uiSchema);</span><span class="s3">\n        </span><span class="s1">const ErrorListTemplate = getTemplate('ErrorListTemplate', registry, options);</span><span class="s3">\n        </span><span class="s1">if (errors &amp;&amp; errors.length) {</span><span class="s3">\n            </span><span class="s1">return (_jsx(ErrorListTemplate, { errors: errors, errorSchema: errorSchema || {}, schema: schema, uiSchema: uiSchema, formContext: formContext, registry: registry }));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the registry for the form */</span><span class="s3">\n    </span><span class="s1">getRegistry() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const { translateString: customTranslateString, uiSchema = {} } = this.props;</span><span class="s3">\n        </span><span class="s1">const { schemaUtils } = this.state;</span><span class="s3">\n        </span><span class="s1">const { fields, templates, widgets, formContext, translateString } = getDefaultRegistry();</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">fields: { ...fields, ...this.props.fields },</span><span class="s3">\n            </span><span class="s1">templates: {</span><span class="s3">\n                </span><span class="s1">...templates,</span><span class="s3">\n                </span><span class="s1">...this.props.templates,</span><span class="s3">\n                </span><span class="s1">ButtonTemplates: {</span><span class="s3">\n                    </span><span class="s1">...templates.ButtonTemplates,</span><span class="s3">\n                    </span><span class="s1">...(_a = this.props.templates) === null || _a === void 0 ? void 0 : _a.ButtonTemplates,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">widgets: { ...widgets, ...this.props.widgets },</span><span class="s3">\n            </span><span class="s1">rootSchema: this.props.schema,</span><span class="s3">\n            </span><span class="s1">formContext: this.props.formContext || formContext,</span><span class="s3">\n            </span><span class="s1">schemaUtils,</span><span class="s3">\n            </span><span class="s1">translateString: customTranslateString || translateString,</span><span class="s3">\n            </span><span class="s1">globalUiOptions: uiSchema[UI_GLOBAL_OPTIONS_KEY],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Provides a function that can be used to programmatically submit the `Form` */</span><span class="s3">\n    </span><span class="s1">submit() {</span><span class="s3">\n        </span><span class="s1">if (this.formElement.current) {</span><span class="s3">\n            </span><span class="s1">this.formElement.current.dispatchEvent(new CustomEvent('submit', {</span><span class="s3">\n                </span><span class="s1">cancelable: true,</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">this.formElement.current.requestSubmit();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error</span><span class="s3">\n     </span><span class="s1">* field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that</span><span class="s3">\n     </span><span class="s1">* id is attempted to be found using the `formElement` ref. If it is located, then it is focused.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param error - The error on which to focus</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">focusOnError(error) {</span><span class="s3">\n        </span><span class="s1">const { idPrefix = 'root', idSeparator = '_' } = this.props;</span><span class="s3">\n        </span><span class="s1">const { property } = error;</span><span class="s3">\n        </span><span class="s1">const path = _toPath(property);</span><span class="s3">\n        </span><span class="s1">if (path[0] === '') {</span><span class="s3">\n            </span><span class="s1">// Most of the time the `.foo` property results in the first element being empty, so replace it with the idPrefix</span><span class="s3">\n            </span><span class="s1">path[0] = idPrefix;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// Otherwise insert the idPrefix into the first location using unshift</span><span class="s3">\n            </span><span class="s1">path.unshift(idPrefix);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const elementId = path.join(idSeparator);</span><span class="s3">\n        </span><span class="s1">let field = this.formElement.current.elements[elementId];</span><span class="s3">\n        </span><span class="s1">if (!field) {</span><span class="s3">\n            </span><span class="s1">// if not an exact match, try finding an input starting with the element id (like radio buttons or checkboxes)</span><span class="s3">\n            </span><span class="s1">field = this.formElement.current.querySelector(`input[id^=${elementId}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (field &amp;&amp; field.length) {</span><span class="s3">\n            </span><span class="s1">// If we got a list with length &gt; 0</span><span class="s3">\n            </span><span class="s1">field = field[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (field) {</span><span class="s3">\n            </span><span class="s1">field.focus();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Programmatically validate the form. If `onError` is provided, then it will be called with the list of errors the</span><span class="s3">\n     </span><span class="s1">* same way as would happen on form submission.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns - True if the form is valid, false otherwise.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validateForm() {</span><span class="s3">\n        </span><span class="s1">const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;</span><span class="s3">\n        </span><span class="s1">const { formData, errors: prevErrors } = this.state;</span><span class="s3">\n        </span><span class="s1">const schemaValidation = this.validate(formData);</span><span class="s3">\n        </span><span class="s1">let errors = schemaValidation.errors;</span><span class="s3">\n        </span><span class="s1">let errorSchema = schemaValidation.errorSchema;</span><span class="s3">\n        </span><span class="s1">const schemaValidationErrors = errors;</span><span class="s3">\n        </span><span class="s1">const schemaValidationErrorSchema = errorSchema;</span><span class="s3">\n        </span><span class="s1">const hasError = errors.length &gt; 0 || (extraErrors &amp;&amp; extraErrorsBlockSubmit);</span><span class="s3">\n        </span><span class="s1">if (hasError) {</span><span class="s3">\n            </span><span class="s1">if (extraErrors) {</span><span class="s3">\n                </span><span class="s1">const merged = validationDataMerge(schemaValidation, extraErrors);</span><span class="s3">\n                </span><span class="s1">errorSchema = merged.errorSchema;</span><span class="s3">\n                </span><span class="s1">errors = merged.errors;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (focusOnFirstError) {</span><span class="s3">\n                </span><span class="s1">if (typeof focusOnFirstError === 'function') {</span><span class="s3">\n                    </span><span class="s1">focusOnFirstError(errors[0]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.focusOnError(errors[0]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.setState({</span><span class="s3">\n                </span><span class="s1">errors,</span><span class="s3">\n                </span><span class="s1">errorSchema,</span><span class="s3">\n                </span><span class="s1">schemaValidationErrors,</span><span class="s3">\n                </span><span class="s1">schemaValidationErrorSchema,</span><span class="s3">\n            </span><span class="s1">}, () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (onError) {</span><span class="s3">\n                    </span><span class="s1">onError(errors);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">console.error('Form validation failed', errors);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prevErrors.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this.setState({</span><span class="s3">\n                </span><span class="s1">errors: [],</span><span class="s3">\n                </span><span class="s1">errorSchema: {},</span><span class="s3">\n                </span><span class="s1">schemaValidationErrors: [],</span><span class="s3">\n                </span><span class="s1">schemaValidationErrorSchema: {},</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return !hasError;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Renders the `Form` fields inside the &lt;form&gt; | `tagName` or `_internalFormWrapper`, rendering any errors if</span><span class="s3">\n     </span><span class="s1">* needed along with the submit button or any children of the form.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">render() {</span><span class="s3">\n        </span><span class="s1">const { children, id, idPrefix, idSeparator, className = '', tagName, name, method, target, action, autoComplete, enctype, acceptcharset, noHtml5Validate = false, disabled = false, readonly = false, formContext, showErrorList = 'top', _internalFormWrapper, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { schema, uiSchema, formData, errorSchema, idSchema } = this.state;</span><span class="s3">\n        </span><span class="s1">const registry = this.getRegistry();</span><span class="s3">\n        </span><span class="s1">const { SchemaField: _SchemaField } = registry.fields;</span><span class="s3">\n        </span><span class="s1">const { SubmitButton } = registry.templates.ButtonTemplates;</span><span class="s3">\n        </span><span class="s1">// The `semantic-ui` and `material-ui` themes have `_internalFormWrapper`s that take an `as` prop that is the</span><span class="s3">\n        </span><span class="s1">// PropTypes.elementType to use for the inner tag, so we'll need to pass `tagName` along if it is provided.</span><span class="s3">\n        </span><span class="s1">// NOTE, the `as` prop is native to `semantic-ui` and is emulated in the `material-ui` theme</span><span class="s3">\n        </span><span class="s1">const as = _internalFormWrapper ? tagName : undefined;</span><span class="s3">\n        </span><span class="s1">const FormTag = _internalFormWrapper || tagName || 'form';</span><span class="s3">\n        </span><span class="s1">let { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = getUiOptions(uiSchema);</span><span class="s3">\n        </span><span class="s1">if (disabled) {</span><span class="s3">\n            </span><span class="s1">submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const submitUiSchema = { [UI_OPTIONS_KEY]: { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };</span><span class="s3">\n        </span><span class="s1">return (_jsxs(FormTag, { className: className ? className : 'rjsf', id: id, name: name, method: method, target: target, action: action, autoComplete: autoComplete, encType: enctype, acceptCharset: acceptcharset, noValidate: noHtml5Validate, onSubmit: this.onSubmit, as: as, ref: this.formElement, children: [showErrorList === 'top' &amp;&amp; this.renderErrors(registry), _jsx(_SchemaField, { name: '', schema: schema, uiSchema: uiSchema, errorSchema: errorSchema, idSchema: idSchema, idPrefix: idPrefix, idSeparator: idSeparator, formContext: formContext, formData: formData, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: registry, disabled: disabled, readonly: readonly }), children ? children : _jsx(SubmitButton, { uiSchema: submitUiSchema, registry: registry }), showErrorList === 'bottom' &amp;&amp; this.renderErrors(registry)] }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=Form.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { forwardRef } from 'react';</span><span class="s3">\n</span><span class="s1">import Form from './components/Form';</span><span class="s3">\n</span><span class="s1">/** A Higher-Order component that creates a wrapper around a `Form` with the overrides from the `WithThemeProps` */</span><span class="s3">\n</span><span class="s1">export default function withTheme(themeProps) {</span><span class="s3">\n    </span><span class="s1">return forwardRef(({ fields, widgets, templates, ...directProps }, ref) =&gt; {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">fields = { ...themeProps === null || themeProps === void 0 ? void 0 : themeProps.fields, ...fields };</span><span class="s3">\n        </span><span class="s1">widgets = { ...themeProps === null || themeProps === void 0 ? void 0 : themeProps.widgets, ...widgets };</span><span class="s3">\n        </span><span class="s1">templates = {</span><span class="s3">\n            </span><span class="s1">...themeProps === null || themeProps === void 0 ? void 0 : themeProps.templates,</span><span class="s3">\n            </span><span class="s1">...templates,</span><span class="s3">\n            </span><span class="s1">ButtonTemplates: {</span><span class="s3">\n                </span><span class="s1">...(_a = themeProps === null || themeProps === void 0 ? void 0 : themeProps.templates) === null || _a === void 0 ? void 0 : _a.ButtonTemplates,</span><span class="s3">\n                </span><span class="s1">...templates === null || templates === void 0 ? void 0 : templates.ButtonTemplates,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return (_jsx(Form, { ...themeProps, ...directProps, fields: fields, widgets: widgets, templates: templates, ref: ref }));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=withTheme.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import Form from './components/Form';</span><span class="s3">\n</span><span class="s1">import withTheme from './withTheme';</span><span class="s3">\n</span><span class="s1">import getDefaultRegistry from './getDefaultRegistry';</span><span class="s3">\n</span><span class="s1">export { withTheme, getDefaultRegistry };</span><span class="s3">\n</span><span class="s1">export default Form;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The unique id is used for unique hashes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let uniqueId = 0;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Quick dictionary lookup for unit-less numbers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const CSS_NUMBER = Object.create(null);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* CSS properties that are valid unit-less numbers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const CSS_NUMBER_KEYS = [</span><span class="s3">\n    \&quot;</span><span class="s1">animation-iteration-count</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">border-image-outset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">border-image-slice</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">border-image-width</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">box-flex</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">box-flex-group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">box-ordinal-group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">column-count</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">columns</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">counter-increment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">counter-reset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flex</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flex-grow</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flex-positive</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flex-shrink</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flex-negative</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flex-order</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">font-weight</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-area</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-column</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-column-end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-column-span</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-column-start</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-row</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-row-end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-row-span</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">grid-row-start</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">line-clamp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">line-height</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">opacity</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">order</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">orphans</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">tab-size</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">widows</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">z-index</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">zoom</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">// SVG properties.</span><span class="s3">\n    \&quot;</span><span class="s1">fill-opacity</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">flood-opacity</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stop-opacity</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stroke-dasharray</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stroke-dashoffset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stroke-miterlimit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stroke-opacity</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stroke-width</span><span class="s3">\&quot;\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">// Add vendor prefixes to all unit-less properties.</span><span class="s3">\n</span><span class="s1">for (const property of CSS_NUMBER_KEYS) {</span><span class="s3">\n    </span><span class="s1">for (const prefix of [</span><span class="s3">\&quot;</span><span class="s1">-webkit-</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">-ms-</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">-moz-</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">-o-</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">]) {</span><span class="s3">\n        </span><span class="s1">CSS_NUMBER[prefix + property] = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Escape a CSS class name.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function escape(str) {</span><span class="s3">\n    </span><span class="s1">return str.replace(/[ !#$%&amp;()*+,./;&lt;=&gt;?@[</span><span class="s3">\\</span><span class="s1">]^`{|}~</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">]/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">$&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform a JavaScript property into a CSS property.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hyphenate(propertyName) {</span><span class="s3">\n    </span><span class="s1">return propertyName</span><span class="s3">\n        </span><span class="s1">.replace(/[A-Z]/g, (m) =&gt; `-${m.toLowerCase()}`)</span><span class="s3">\n        </span><span class="s1">.replace(/^ms-/, </span><span class="s3">\&quot;</span><span class="s1">-ms-</span><span class="s3">\&quot;</span><span class="s1">); // Internet Explorer vendor prefix.</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generate a hash value from a string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stringHash(str) {</span><span class="s3">\n    </span><span class="s1">let value = 5381;</span><span class="s3">\n    </span><span class="s1">let len = str.length;</span><span class="s3">\n    </span><span class="s1">while (len--)</span><span class="s3">\n        </span><span class="s1">value = (value * 33) ^ str.charCodeAt(len);</span><span class="s3">\n    </span><span class="s1">return (value &gt;&gt;&gt; 0).toString(36);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform a style string to a CSS string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function styleToString(key, value) {</span><span class="s3">\n    </span><span class="s1">if (value &amp;&amp; typeof value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !CSS_NUMBER[key]) {</span><span class="s3">\n        </span><span class="s1">return `${key}:${value}px`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return `${key}:${value}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sort an array of tuples by first value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function sortTuples(value) {</span><span class="s3">\n    </span><span class="s1">return value.sort((a, b) =&gt; (a[0] &gt; b[0] ? 1 : -1));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Categorize user styles.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function parseStyles(styles, hasNestedStyles) {</span><span class="s3">\n    </span><span class="s1">const properties = [];</span><span class="s3">\n    </span><span class="s1">const nestedStyles = [];</span><span class="s3">\n    </span><span class="s1">// Sort keys before adding to styles.</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(styles)) {</span><span class="s3">\n        </span><span class="s1">const name = key.trim();</span><span class="s3">\n        </span><span class="s1">const value = styles[key];</span><span class="s3">\n        </span><span class="s1">if (name.charCodeAt(0) !== 36 /* $ */ &amp;&amp; value != null) {</span><span class="s3">\n            </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !Array.isArray(value)) {</span><span class="s3">\n                </span><span class="s1">nestedStyles.push([name, value]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">properties.push([hyphenate(name), value]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">style: stringifyProperties(sortTuples(properties)),</span><span class="s3">\n        </span><span class="s1">nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),</span><span class="s3">\n        </span><span class="s1">isUnique: !!styles.$unique</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Stringify an array of property tuples.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stringifyProperties(properties) {</span><span class="s3">\n    </span><span class="s1">return properties</span><span class="s3">\n        </span><span class="s1">.map(([name, value]) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(value))</span><span class="s3">\n            </span><span class="s1">return styleToString(name, value);</span><span class="s3">\n        </span><span class="s1">return value.map(x =&gt; styleToString(name, x)).join(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.join(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Interpolate CSS selectors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function interpolate(selector, parent) {</span><span class="s3">\n    </span><span class="s1">if (selector.indexOf(</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">) === -1)</span><span class="s3">\n        </span><span class="s1">return `${parent} ${selector}`;</span><span class="s3">\n    </span><span class="s1">return selector.replace(/&amp;/g, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursive loop building styles with deferred selectors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stylize(selector, styles, rulesList, stylesList, parent) {</span><span class="s3">\n    </span><span class="s1">const { style, nested, isUnique } = parseStyles(styles, selector !== </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let pid = style;</span><span class="s3">\n    </span><span class="s1">if (selector.charCodeAt(0) === 64 /* @ */) {</span><span class="s3">\n        </span><span class="s1">const child = {</span><span class="s3">\n            </span><span class="s1">selector,</span><span class="s3">\n            </span><span class="s1">styles: [],</span><span class="s3">\n            </span><span class="s1">rules: [],</span><span class="s3">\n            </span><span class="s1">style: parent ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: style</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">rulesList.push(child);</span><span class="s3">\n        </span><span class="s1">// Nested styles support (e.g. `.foo &gt; @media &gt; .bar`).</span><span class="s3">\n        </span><span class="s1">if (style &amp;&amp; parent) {</span><span class="s3">\n            </span><span class="s1">child.styles.push({ selector: parent, style, isUnique });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const [name, value] of nested) {</span><span class="s3">\n            </span><span class="s1">pid += name + stylize(name, value, child.rules, child.styles, parent);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const key = parent ? interpolate(selector, parent) : selector;</span><span class="s3">\n        </span><span class="s1">if (style)</span><span class="s3">\n            </span><span class="s1">stylesList.push({ selector: key, style, isUnique });</span><span class="s3">\n        </span><span class="s1">for (const [name, value] of nested) {</span><span class="s3">\n            </span><span class="s1">pid += name + stylize(name, value, rulesList, stylesList, key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pid;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform `stylize` tree into style objects.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {</span><span class="s3">\n    </span><span class="s1">for (const { selector, style, isUnique } of stylesList) {</span><span class="s3">\n        </span><span class="s1">const key = isStyle ? interpolate(selector, className) : selector;</span><span class="s3">\n        </span><span class="s1">const id = isUnique</span><span class="s3">\n            </span><span class="s1">? `u</span><span class="s3">\\</span><span class="s1">0${(++uniqueId).toString(36)}`</span><span class="s3">\n            </span><span class="s1">: `s</span><span class="s3">\\</span><span class="s1">0${pid}</span><span class="s3">\\</span><span class="s1">0${style}`;</span><span class="s3">\n        </span><span class="s1">const item = new Style(style, id);</span><span class="s3">\n        </span><span class="s1">item.add(new Selector(key, `k</span><span class="s3">\\</span><span class="s1">0${pid}</span><span class="s3">\\</span><span class="s1">0${key}`));</span><span class="s3">\n        </span><span class="s1">cache.add(item);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const { selector, style, rules, styles } of rulesList) {</span><span class="s3">\n        </span><span class="s1">const item = new Rule(selector, style, `r</span><span class="s3">\\</span><span class="s1">0${pid}</span><span class="s3">\\</span><span class="s1">0${selector}</span><span class="s3">\\</span><span class="s1">0${style}`);</span><span class="s3">\n        </span><span class="s1">composeStylize(item, pid, rules, styles, className, isStyle);</span><span class="s3">\n        </span><span class="s1">cache.add(item);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cache to list to styles.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function join(arr) {</span><span class="s3">\n    </span><span class="s1">let res = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; arr.length; i++)</span><span class="s3">\n        </span><span class="s1">res += arr[i];</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Noop changes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const noopChanges = {</span><span class="s3">\n    </span><span class="s1">add: () =&gt; undefined,</span><span class="s3">\n    </span><span class="s1">change: () =&gt; undefined,</span><span class="s3">\n    </span><span class="s1">remove: () =&gt; undefined</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Implement a cache/event emitter.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Cache {</span><span class="s3">\n    </span><span class="s1">constructor(changes = noopChanges) {</span><span class="s3">\n        </span><span class="s1">this.changes = changes;</span><span class="s3">\n        </span><span class="s1">this.sheet = [];</span><span class="s3">\n        </span><span class="s1">this.changeId = 0;</span><span class="s3">\n        </span><span class="s1">this._keys = [];</span><span class="s3">\n        </span><span class="s1">this._children = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this._counters = Object.create(null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">add(style) {</span><span class="s3">\n        </span><span class="s1">const count = this._counters[style.id] || 0;</span><span class="s3">\n        </span><span class="s1">const item = this._children[style.id] || style.clone();</span><span class="s3">\n        </span><span class="s1">this._counters[style.id] = count + 1;</span><span class="s3">\n        </span><span class="s1">if (count === 0) {</span><span class="s3">\n            </span><span class="s1">this._children[item.id] = item;</span><span class="s3">\n            </span><span class="s1">this._keys.push(item.id);</span><span class="s3">\n            </span><span class="s1">this.sheet.push(item.getStyles());</span><span class="s3">\n            </span><span class="s1">this.changeId++;</span><span class="s3">\n            </span><span class="s1">this.changes.add(item, this._keys.length - 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (item instanceof Cache &amp;&amp; style instanceof Cache) {</span><span class="s3">\n            </span><span class="s1">const curIndex = this._keys.indexOf(style.id);</span><span class="s3">\n            </span><span class="s1">const prevItemChangeId = item.changeId;</span><span class="s3">\n            </span><span class="s1">item.merge(style);</span><span class="s3">\n            </span><span class="s1">if (item.changeId !== prevItemChangeId) {</span><span class="s3">\n                </span><span class="s1">this.sheet.splice(curIndex, 1, item.getStyles());</span><span class="s3">\n                </span><span class="s1">this.changeId++;</span><span class="s3">\n                </span><span class="s1">this.changes.change(item, curIndex, curIndex);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(style) {</span><span class="s3">\n        </span><span class="s1">const count = this._counters[style.id];</span><span class="s3">\n        </span><span class="s1">if (count) {</span><span class="s3">\n            </span><span class="s1">this._counters[style.id] = count - 1;</span><span class="s3">\n            </span><span class="s1">const item = this._children[style.id];</span><span class="s3">\n            </span><span class="s1">const index = this._keys.indexOf(item.id);</span><span class="s3">\n            </span><span class="s1">if (count === 1) {</span><span class="s3">\n                </span><span class="s1">delete this._counters[style.id];</span><span class="s3">\n                </span><span class="s1">delete this._children[style.id];</span><span class="s3">\n                </span><span class="s1">this._keys.splice(index, 1);</span><span class="s3">\n                </span><span class="s1">this.sheet.splice(index, 1);</span><span class="s3">\n                </span><span class="s1">this.changeId++;</span><span class="s3">\n                </span><span class="s1">this.changes.remove(item, index);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (item instanceof Cache &amp;&amp; style instanceof Cache) {</span><span class="s3">\n                </span><span class="s1">const prevChangeId = item.changeId;</span><span class="s3">\n                </span><span class="s1">item.unmerge(style);</span><span class="s3">\n                </span><span class="s1">if (item.changeId !== prevChangeId) {</span><span class="s3">\n                    </span><span class="s1">this.sheet.splice(index, 1, item.getStyles());</span><span class="s3">\n                    </span><span class="s1">this.changeId++;</span><span class="s3">\n                    </span><span class="s1">this.changes.change(item, index, index);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">values() {</span><span class="s3">\n        </span><span class="s1">return this._keys.map(key =&gt; this._children[key]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">merge(cache) {</span><span class="s3">\n        </span><span class="s1">for (const item of cache.values())</span><span class="s3">\n            </span><span class="s1">this.add(item);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmerge(cache) {</span><span class="s3">\n        </span><span class="s1">for (const item of cache.values())</span><span class="s3">\n            </span><span class="s1">this.remove(item);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clone() {</span><span class="s3">\n        </span><span class="s1">return new Cache().merge(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Selector is a dumb class made to represent nested CSS selectors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Selector {</span><span class="s3">\n    </span><span class="s1">constructor(selector, id) {</span><span class="s3">\n        </span><span class="s1">this.selector = selector;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getStyles() {</span><span class="s3">\n        </span><span class="s1">return this.selector;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clone() {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The style container registers a style string with selectors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Style extends Cache {</span><span class="s3">\n    </span><span class="s1">constructor(style, id) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.style = style;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getStyles() {</span><span class="s3">\n        </span><span class="s1">return `${this.sheet.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}{${this.style}}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clone() {</span><span class="s3">\n        </span><span class="s1">return new Style(this.style, this.id).merge(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Implement rule logic for style output.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Rule extends Cache {</span><span class="s3">\n    </span><span class="s1">constructor(rule, style, id) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.rule = rule;</span><span class="s3">\n        </span><span class="s1">this.style = style;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getStyles() {</span><span class="s3">\n        </span><span class="s1">return `${this.rule}{${this.style}${join(this.sheet)}}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clone() {</span><span class="s3">\n        </span><span class="s1">return new Rule(this.rule, this.style, this.id).merge(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function key(pid, styles) {</span><span class="s3">\n    </span><span class="s1">const key = `f${stringHash(pid)}`;</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV === </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot; </span><span class="s1">|| !styles.$displayName)</span><span class="s3">\n        </span><span class="s1">return key;</span><span class="s3">\n    </span><span class="s1">return `${styles.$displayName}_${key}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The FreeStyle class implements the API for everything else.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class FreeStyle extends Cache {</span><span class="s3">\n    </span><span class="s1">constructor(id, changes) {</span><span class="s3">\n        </span><span class="s1">super(changes);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">registerStyle(styles) {</span><span class="s3">\n        </span><span class="s1">const rulesList = [];</span><span class="s3">\n        </span><span class="s1">const stylesList = [];</span><span class="s3">\n        </span><span class="s1">const pid = stylize(</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">, styles, rulesList, stylesList);</span><span class="s3">\n        </span><span class="s1">const id = key(pid, styles);</span><span class="s3">\n        </span><span class="s1">const selector = `.${process.env.NODE_ENV === </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot; </span><span class="s1">? id : escape(id)}`;</span><span class="s3">\n        </span><span class="s1">composeStylize(this, pid, rulesList, stylesList, selector, true);</span><span class="s3">\n        </span><span class="s1">return id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">registerKeyframes(keyframes) {</span><span class="s3">\n        </span><span class="s1">return this.registerHashRule(</span><span class="s3">\&quot;</span><span class="s1">@keyframes</span><span class="s3">\&quot;</span><span class="s1">, keyframes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">registerHashRule(prefix, styles) {</span><span class="s3">\n        </span><span class="s1">const rulesList = [];</span><span class="s3">\n        </span><span class="s1">const stylesList = [];</span><span class="s3">\n        </span><span class="s1">const pid = stylize(</span><span class="s3">\&quot;\&quot;</span><span class="s1">, styles, rulesList, stylesList);</span><span class="s3">\n        </span><span class="s1">const id = key(pid, styles);</span><span class="s3">\n        </span><span class="s1">const selector = `${prefix} ${process.env.NODE_ENV === </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot; </span><span class="s1">? id : escape(id)}`;</span><span class="s3">\n        </span><span class="s1">const rule = new Rule(selector, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, `h</span><span class="s3">\\</span><span class="s1">0${pid}</span><span class="s3">\\</span><span class="s1">0${prefix}`);</span><span class="s3">\n        </span><span class="s1">composeStylize(rule, pid, rulesList, stylesList, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, false);</span><span class="s3">\n        </span><span class="s1">this.add(rule);</span><span class="s3">\n        </span><span class="s1">return id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">registerRule(rule, styles) {</span><span class="s3">\n        </span><span class="s1">const rulesList = [];</span><span class="s3">\n        </span><span class="s1">const stylesList = [];</span><span class="s3">\n        </span><span class="s1">const pid = stylize(rule, styles, rulesList, stylesList);</span><span class="s3">\n        </span><span class="s1">composeStylize(this, pid, rulesList, stylesList, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">registerCss(styles) {</span><span class="s3">\n        </span><span class="s1">return this.registerRule(</span><span class="s3">\&quot;\&quot;</span><span class="s1">, styles);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getStyles() {</span><span class="s3">\n        </span><span class="s1">return join(this.sheet);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clone() {</span><span class="s3">\n        </span><span class="s1">return new FreeStyle(this.id, this.changes).merge(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Exports a simple function to create a new instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function create(changes) {</span><span class="s3">\n    </span><span class="s1">return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;var basePickBy = require('./_basePickBy'),</span><span class="s3">\n    </span><span class="s1">hasIn = require('./hasIn');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.pick` without support for individual</span><span class="s3">\n </span><span class="s1">* property identifiers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {string[]} paths The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePick(object, paths) {</span><span class="s3">\n  </span><span class="s1">return basePickBy(object, paths, function(value, path) {</span><span class="s3">\n    </span><span class="s1">return hasIn(object, path);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = basePick;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseGet = require('./_baseGet'),</span><span class="s3">\n    </span><span class="s1">baseSet = require('./_baseSet'),</span><span class="s3">\n    </span><span class="s1">castPath = require('./_castPath');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of  `_.pickBy` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {string[]} paths The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per property.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePickBy(object, paths, predicate) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = paths.length,</span><span class="s3">\n      </span><span class="s1">result = {};</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var path = paths[index],</span><span class="s3">\n        </span><span class="s1">value = baseGet(object, path);</span><span class="s3">\n\n    </span><span class="s1">if (predicate(value, path)) {</span><span class="s3">\n      </span><span class="s1">baseSet(result, castPath(path, object), value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = basePickBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var basePick = require('./_basePick'),</span><span class="s3">\n    </span><span class="s1">flatRest = require('./_flatRest');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an object composed of the picked `object` properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {...(string|string[])} [paths] The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1, 'b': '2', 'c': 3 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.pick(object, ['a', 'c']);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'c': 3 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var pick = flatRest(function(object, paths) {</span><span class="s3">\n  </span><span class="s1">return object == null ? {} : basePick(object, paths);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = pick;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseUnset = require('./_baseUnset');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes the property at `path` of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path of the property to unset.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the property is deleted, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': [{ 'b': { 'c': 7 } }] };</span><span class="s3">\n </span><span class="s1">* _.unset(object, 'a[0].b.c');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* console.log(object);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': [{ 'b': {} }] };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.unset(object, ['a', '0', 'b', 'c']);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* console.log(object);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': [{ 'b': {} }] };</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function unset(object, path) {</span><span class="s3">\n  </span><span class="s1">return object == null ? true : baseUnset(object, path);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = unset;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">var m = require('react-dom');</span><span class="s3">\n</span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n  </span><span class="s1">exports.createRoot = m.createRoot;</span><span class="s3">\n  </span><span class="s1">exports.hydrateRoot = m.hydrateRoot;</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span><span class="s3">\n  </span><span class="s1">exports.createRoot = function(c, o) {</span><span class="s3">\n    </span><span class="s1">i.usingClientEntryPoint = true;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return m.createRoot(c, o);</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">i.usingClientEntryPoint = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">exports.hydrateRoot = function(c, h, o) {</span><span class="s3">\n    </span><span class="s1">i.usingClientEntryPoint = true;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return m.hydrateRoot(c, h, o);</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">i.usingClientEntryPoint = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">var typestyle_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./internal/typestyle</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">exports.TypeStyle = typestyle_1.TypeStyle;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* All the CSS types in the 'types' namespace</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var types = require(</span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">exports.types = types;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Export certain utilities</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var utilities_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./internal/utilities</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">exports.extend = utilities_1.extend;</span><span class="s3">\n</span><span class="s1">exports.classes = utilities_1.classes;</span><span class="s3">\n</span><span class="s1">exports.media = utilities_1.media;</span><span class="s3">\n</span><span class="s1">/** Zero configuration, default instance of TypeStyle */</span><span class="s3">\n</span><span class="s1">var ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });</span><span class="s3">\n</span><span class="s1">/** Sets the target tag where we write the css on style updates */</span><span class="s3">\n</span><span class="s1">exports.setStylesTarget = ts.setStylesTarget;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Insert `raw` CSS as a string. This is useful for e.g.</span><span class="s3">\n </span><span class="s1">* - third party CSS that you are customizing with template strings</span><span class="s3">\n </span><span class="s1">* - generating raw CSS in JavaScript</span><span class="s3">\n </span><span class="s1">* - reset libraries like normalize.css that you can use without loaders</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.cssRaw = ts.cssRaw;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes CSSProperties and registers it to a global selector (body, html, etc.)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.cssRule = ts.cssRule;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Renders styles to the singleton tag imediately</span><span class="s3">\n </span><span class="s1">* NOTE: You should only call it on initial render to prevent any non CSS flash.</span><span class="s3">\n </span><span class="s1">* After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n</span><span class="s1">exports.forceRenderStyles = ts.forceRenderStyles;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility function to register an @font-face</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.fontFace = ts.fontFace;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Allows use to use the stylesheet in a node.js environment</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.getStyles = ts.getStyles;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes keyframes and returns a generated animationName</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.keyframes = ts.keyframes;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Helps with testing. Reinitializes FreeStyle + raw</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.reinit = ts.reinit;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes CSSProperties and return a generated className you can use on your component</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.style = ts.style;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes an object where property names are ideal class names and property values are CSSProperties, and</span><span class="s3">\n </span><span class="s1">* returns an object where property names are the same ideal class names and the property values are</span><span class="s3">\n </span><span class="s1">* the actual generated class names using the ideal class name as the $debugName</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.stylesheet = ts.stylesheet;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a new instance of TypeStyle separate from the default instance.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - Use this for creating a different typestyle instance for a shadow dom component.</span><span class="s3">\n </span><span class="s1">* - Use this if you don't want an auto tag generated and you just want to collect the CSS.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* NOTE: styles aren't shared between different instances.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createTypeStyle(target) {</span><span class="s3">\n    </span><span class="s1">var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });</span><span class="s3">\n    </span><span class="s1">if (target) {</span><span class="s3">\n        </span><span class="s1">instance.setStylesTarget(target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return instance;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.createTypeStyle = createTypeStyle;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We need to do the following to *our* objects before passing to freestyle:</span><span class="s3">\n </span><span class="s1">* - For any `$nest` directive move up to FreeStyle style nesting</span><span class="s3">\n </span><span class="s1">* - For any `$unique` directive map to FreeStyle Unique</span><span class="s3">\n </span><span class="s1">* - For any `$debugName` directive return the debug name</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function convertToStyles(object) {</span><span class="s3">\n    </span><span class="s1">/** The final result we will return */</span><span class="s3">\n    </span><span class="s1">var styles = {};</span><span class="s3">\n    </span><span class="s1">for (var key in object) {</span><span class="s3">\n        </span><span class="s1">/** Grab the value upfront */</span><span class="s3">\n        </span><span class="s1">var val = object[key];</span><span class="s3">\n        </span><span class="s1">/** TypeStyle configuration options */</span><span class="s3">\n        </span><span class="s1">if (key === '$nest') {</span><span class="s3">\n            </span><span class="s1">var nested = val;</span><span class="s3">\n            </span><span class="s1">for (var selector in nested) {</span><span class="s3">\n                </span><span class="s1">var subproperties = nested[selector];</span><span class="s3">\n                </span><span class="s1">styles[selector] = convertToStyles(subproperties);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (key === '$debugName') {</span><span class="s3">\n            </span><span class="s1">styles.$displayName = val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">styles[key] = val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return styles;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.convertToStyles = convertToStyles;</span><span class="s3">\n</span><span class="s1">// todo: better name here</span><span class="s3">\n</span><span class="s1">function convertToKeyframes(frames) {</span><span class="s3">\n    </span><span class="s1">var result = {};</span><span class="s3">\n    </span><span class="s1">for (var offset in frames) {</span><span class="s3">\n        </span><span class="s1">if (offset !== '$debugName') {</span><span class="s3">\n            </span><span class="s1">result[offset] = frames[offset];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (frames.$debugName) {</span><span class="s3">\n        </span><span class="s1">result.$displayName = frames.$debugName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.convertToKeyframes = convertToKeyframes;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">var FreeStyle = require(</span><span class="s3">\&quot;</span><span class="s1">free-style</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var formatting_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./formatting</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var utilities_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./utilities</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an instance of free style with our options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var createFreeStyle = function () { return FreeStyle.create(); };</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maintains a single stylesheet and keeps it in sync with requested styles</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TypeStyle = /** @class */ (function () {</span><span class="s3">\n    </span><span class="s1">function TypeStyle(_a) {</span><span class="s3">\n        </span><span class="s1">var _this = this;</span><span class="s3">\n        </span><span class="s1">var autoGenerateTag = _a.autoGenerateTag;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Insert `raw` CSS as a string. This is useful for e.g.</span><span class="s3">\n         </span><span class="s1">* - third party CSS that you are customizing with template strings</span><span class="s3">\n         </span><span class="s1">* - generating raw CSS in JavaScript</span><span class="s3">\n         </span><span class="s1">* - reset libraries like normalize.css that you can use without loaders</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.cssRaw = function (mustBeValidCSS) {</span><span class="s3">\n            </span><span class="s1">if (!mustBeValidCSS) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">_this._raw += mustBeValidCSS || '';</span><span class="s3">\n            </span><span class="s1">_this._pendingRawChange = true;</span><span class="s3">\n            </span><span class="s1">_this._styleUpdated();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Takes CSSProperties and registers it to a global selector (body, html, etc.)</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.cssRule = function (selector) {</span><span class="s3">\n            </span><span class="s1">var objects = [];</span><span class="s3">\n            </span><span class="s1">for (var _i = 1; _i &lt; arguments.length; _i++) {</span><span class="s3">\n                </span><span class="s1">objects[_i - 1] = arguments[_i];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var styles = formatting_1.convertToStyles(utilities_1.extend.apply(void 0, objects));</span><span class="s3">\n            </span><span class="s1">_this._freeStyle.registerRule(selector, styles);</span><span class="s3">\n            </span><span class="s1">_this._styleUpdated();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Renders styles to the singleton tag imediately</span><span class="s3">\n         </span><span class="s1">* NOTE: You should only call it on initial render to prevent any non CSS flash.</span><span class="s3">\n         </span><span class="s1">* After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.</span><span class="s3">\n         </span><span class="s1">**/</span><span class="s3">\n        </span><span class="s1">this.forceRenderStyles = function () {</span><span class="s3">\n            </span><span class="s1">var target = _this._getTag();</span><span class="s3">\n            </span><span class="s1">if (!target) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">target.textContent = _this.getStyles();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Utility function to register an @font-face</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.fontFace = function () {</span><span class="s3">\n            </span><span class="s1">var fontFace = [];</span><span class="s3">\n            </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s3">\n                </span><span class="s1">fontFace[_i] = arguments[_i];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var freeStyle = _this._freeStyle;</span><span class="s3">\n            </span><span class="s1">for (var _a = 0, _b = fontFace; _a &lt; _b.length; _a++) {</span><span class="s3">\n                </span><span class="s1">var face = _b[_a];</span><span class="s3">\n                </span><span class="s1">freeStyle.registerRule('@font-face', face);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">_this._styleUpdated();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Allows use to use the stylesheet in a node.js environment</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.getStyles = function () {</span><span class="s3">\n            </span><span class="s1">return (_this._raw || '') + _this._freeStyle.getStyles();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Takes keyframes and returns a generated animationName</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.keyframes = function (frames) {</span><span class="s3">\n            </span><span class="s1">var keyframes = formatting_1.convertToKeyframes(frames);</span><span class="s3">\n            </span><span class="s1">// TODO: replace $debugName with display name</span><span class="s3">\n            </span><span class="s1">var animationName = _this._freeStyle.registerKeyframes(keyframes);</span><span class="s3">\n            </span><span class="s1">_this._styleUpdated();</span><span class="s3">\n            </span><span class="s1">return animationName;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Helps with testing. Reinitializes FreeStyle + raw</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.reinit = function () {</span><span class="s3">\n            </span><span class="s1">/** reinit freestyle */</span><span class="s3">\n            </span><span class="s1">var freeStyle = createFreeStyle();</span><span class="s3">\n            </span><span class="s1">_this._freeStyle = freeStyle;</span><span class="s3">\n            </span><span class="s1">_this._lastFreeStyleChangeId = freeStyle.changeId;</span><span class="s3">\n            </span><span class="s1">/** reinit raw */</span><span class="s3">\n            </span><span class="s1">_this._raw = '';</span><span class="s3">\n            </span><span class="s1">_this._pendingRawChange = false;</span><span class="s3">\n            </span><span class="s1">/** Clear any styles that were flushed */</span><span class="s3">\n            </span><span class="s1">var target = _this._getTag();</span><span class="s3">\n            </span><span class="s1">if (target) {</span><span class="s3">\n                </span><span class="s1">target.textContent = '';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/** Sets the target tag where we write the css on style updates */</span><span class="s3">\n        </span><span class="s1">this.setStylesTarget = function (tag) {</span><span class="s3">\n            </span><span class="s1">/** Clear any data in any previous tag */</span><span class="s3">\n            </span><span class="s1">if (_this._tag) {</span><span class="s3">\n                </span><span class="s1">_this._tag.textContent = '';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">_this._tag = tag;</span><span class="s3">\n            </span><span class="s1">/** This special time buffer immediately */</span><span class="s3">\n            </span><span class="s1">_this.forceRenderStyles();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Takes an object where property names are ideal class names and property values are CSSProperties, and</span><span class="s3">\n         </span><span class="s1">* returns an object where property names are the same ideal class names and the property values are</span><span class="s3">\n         </span><span class="s1">* the actual generated class names using the ideal class name as the $debugName</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.stylesheet = function (classes) {</span><span class="s3">\n            </span><span class="s1">var classNames = Object.getOwnPropertyNames(classes);</span><span class="s3">\n            </span><span class="s1">var result = {};</span><span class="s3">\n            </span><span class="s1">for (var _i = 0, classNames_1 = classNames; _i &lt; classNames_1.length; _i++) {</span><span class="s3">\n                </span><span class="s1">var className = classNames_1[_i];</span><span class="s3">\n                </span><span class="s1">var classDef = classes[className];</span><span class="s3">\n                </span><span class="s1">if (classDef) {</span><span class="s3">\n                    </span><span class="s1">classDef.$debugName = className;</span><span class="s3">\n                    </span><span class="s1">result[className] = _this.style(classDef);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var freeStyle = createFreeStyle();</span><span class="s3">\n        </span><span class="s1">this._autoGenerateTag = autoGenerateTag;</span><span class="s3">\n        </span><span class="s1">this._freeStyle = freeStyle;</span><span class="s3">\n        </span><span class="s1">this._lastFreeStyleChangeId = freeStyle.changeId;</span><span class="s3">\n        </span><span class="s1">this._pending = 0;</span><span class="s3">\n        </span><span class="s1">this._pendingRawChange = false;</span><span class="s3">\n        </span><span class="s1">this._raw = '';</span><span class="s3">\n        </span><span class="s1">this._tag = undefined;</span><span class="s3">\n        </span><span class="s1">// rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}</span><span class="s3">\n        </span><span class="s1">this.style = this.style.bind(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Only calls cb all sync operations settle</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TypeStyle.prototype._afterAllSync = function (cb) {</span><span class="s3">\n        </span><span class="s1">var _this = this;</span><span class="s3">\n        </span><span class="s1">this._pending++;</span><span class="s3">\n        </span><span class="s1">var pending = this._pending;</span><span class="s3">\n        </span><span class="s1">utilities_1.raf(function () {</span><span class="s3">\n            </span><span class="s1">if (pending !== _this._pending) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">cb();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">TypeStyle.prototype._getTag = function () {</span><span class="s3">\n        </span><span class="s1">if (this._tag) {</span><span class="s3">\n            </span><span class="s1">return this._tag;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._autoGenerateTag) {</span><span class="s3">\n            </span><span class="s1">var tag = typeof window === 'undefined'</span><span class="s3">\n                </span><span class="s1">? { textContent: '' }</span><span class="s3">\n                </span><span class="s1">: document.createElement('style');</span><span class="s3">\n            </span><span class="s1">if (typeof document !== 'undefined') {</span><span class="s3">\n                </span><span class="s1">document.head.appendChild(tag);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._tag = tag;</span><span class="s3">\n            </span><span class="s1">return tag;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/** Checks if the style tag needs updating and if so queues up the change */</span><span class="s3">\n    </span><span class="s1">TypeStyle.prototype._styleUpdated = function () {</span><span class="s3">\n        </span><span class="s1">var _this = this;</span><span class="s3">\n        </span><span class="s1">var changeId = this._freeStyle.changeId;</span><span class="s3">\n        </span><span class="s1">var lastChangeId = this._lastFreeStyleChangeId;</span><span class="s3">\n        </span><span class="s1">if (!this._pendingRawChange &amp;&amp; changeId === lastChangeId) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._lastFreeStyleChangeId = changeId;</span><span class="s3">\n        </span><span class="s1">this._pendingRawChange = false;</span><span class="s3">\n        </span><span class="s1">this._afterAllSync(function () { return _this.forceRenderStyles(); });</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">TypeStyle.prototype.style = function () {</span><span class="s3">\n        </span><span class="s1">var className = this._freeStyle.registerStyle(formatting_1.convertToStyles(utilities_1.extend.apply(undefined, arguments)));</span><span class="s3">\n        </span><span class="s1">this._styleUpdated();</span><span class="s3">\n        </span><span class="s1">return className;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return TypeStyle;</span><span class="s3">\n</span><span class="s1">}());</span><span class="s3">\n</span><span class="s1">exports.TypeStyle = TypeStyle;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">/** Raf for node + browser */</span><span class="s3">\n</span><span class="s1">exports.raf = typeof requestAnimationFrame === 'undefined'</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Make sure setTimeout is always invoked with</span><span class="s3">\n     </span><span class="s1">* `this` set to `window` or `global` automatically</span><span class="s3">\n     </span><span class="s1">**/</span><span class="s3">\n    </span><span class="s1">? function (cb) { return setTimeout(cb); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Make sure window.requestAnimationFrame is always invoked with `this` window</span><span class="s3">\n     </span><span class="s1">* We might have raf without window in case of `raf/polyfill` (recommended by React)</span><span class="s3">\n     </span><span class="s1">**/</span><span class="s3">\n    </span><span class="s1">: typeof window === 'undefined'</span><span class="s3">\n        </span><span class="s1">? requestAnimationFrame</span><span class="s3">\n        </span><span class="s1">: requestAnimationFrame.bind(window);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility to join classes conditionally</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function classes() {</span><span class="s3">\n    </span><span class="s1">var classes = [];</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s3">\n        </span><span class="s1">classes[_i] = arguments[_i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return classes</span><span class="s3">\n        </span><span class="s1">.map(function (c) { return c &amp;&amp; typeof c === 'object' ? Object.keys(c).map(function (key) { return !!c[key] &amp;&amp; key; }) : [c]; })</span><span class="s3">\n        </span><span class="s1">.reduce(function (flattened, c) { return flattened.concat(c); }, [])</span><span class="s3">\n        </span><span class="s1">.filter(function (c) { return !!c; })</span><span class="s3">\n        </span><span class="s1">.join(' ');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.classes = classes;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Merges various styles into a single style object.</span><span class="s3">\n </span><span class="s1">* Note: if two objects have the same property the last one wins</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function extend() {</span><span class="s3">\n    </span><span class="s1">var objects = [];</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s3">\n        </span><span class="s1">objects[_i] = arguments[_i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** The final result we will return */</span><span class="s3">\n    </span><span class="s1">var result = {};</span><span class="s3">\n    </span><span class="s1">for (var _a = 0, objects_1 = objects; _a &lt; objects_1.length; _a++) {</span><span class="s3">\n        </span><span class="s1">var object = objects_1[_a];</span><span class="s3">\n        </span><span class="s1">if (object == null || object === false) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (var key in object) {</span><span class="s3">\n            </span><span class="s1">/** Falsy values except a explicit 0 is ignored */</span><span class="s3">\n            </span><span class="s1">var val = object[key];</span><span class="s3">\n            </span><span class="s1">if (!val &amp;&amp; val !== 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/** if nested media or pseudo selector */</span><span class="s3">\n            </span><span class="s1">if (key === '$nest' &amp;&amp; val) {</span><span class="s3">\n                </span><span class="s1">result[key] = result['$nest'] ? extend(result['$nest'], val) : val;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/** if freestyle sub key that needs merging. We come here due to our recursive calls */</span><span class="s3">\n            </span><span class="s1">else if ((key.indexOf('&amp;') !== -1 || key.indexOf('@media') === 0)) {</span><span class="s3">\n                </span><span class="s1">result[key] = result[key] ? extend(result[key], val) : val;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">result[key] = val;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.extend = extend;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility to help customize styles with media queries. e.g.</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">* style(</span><span class="s3">\n </span><span class="s1">*  media({maxWidth:500}, {color:'red'})</span><span class="s3">\n </span><span class="s1">* )</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.media = function (mediaQuery) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">var objects = [];</span><span class="s3">\n    </span><span class="s1">for (var _i = 1; _i &lt; arguments.length; _i++) {</span><span class="s3">\n        </span><span class="s1">objects[_i - 1] = arguments[_i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var mediaQuerySections = [];</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.type)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(mediaQuery.type);</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.orientation)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(</span><span class="s3">\&quot;</span><span class="s1">(orientation: </span><span class="s3">\&quot; </span><span class="s1">+ mediaQuery.orientation + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.minWidth)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(</span><span class="s3">\&quot;</span><span class="s1">(min-width: </span><span class="s3">\&quot; </span><span class="s1">+ mediaLength(mediaQuery.minWidth) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.maxWidth)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(</span><span class="s3">\&quot;</span><span class="s1">(max-width: </span><span class="s3">\&quot; </span><span class="s1">+ mediaLength(mediaQuery.maxWidth) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.minHeight)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(</span><span class="s3">\&quot;</span><span class="s1">(min-height: </span><span class="s3">\&quot; </span><span class="s1">+ mediaLength(mediaQuery.minHeight) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.maxHeight)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(</span><span class="s3">\&quot;</span><span class="s1">(max-height: </span><span class="s3">\&quot; </span><span class="s1">+ mediaLength(mediaQuery.maxHeight) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (mediaQuery.prefersColorScheme)</span><span class="s3">\n        </span><span class="s1">mediaQuerySections.push(</span><span class="s3">\&quot;</span><span class="s1">(prefers-color-scheme: </span><span class="s3">\&quot; </span><span class="s1">+ mediaQuery.prefersColorScheme + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">var stringMediaQuery = </span><span class="s3">\&quot;</span><span class="s1">@media </span><span class="s3">\&quot; </span><span class="s1">+ mediaQuerySections.join(' and ');</span><span class="s3">\n    </span><span class="s1">var object = {</span><span class="s3">\n        </span><span class="s1">$nest: (_a = {},</span><span class="s3">\n            </span><span class="s1">_a[stringMediaQuery] = extend.apply(void 0, objects),</span><span class="s3">\n            </span><span class="s1">_a)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var mediaLength = function (value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'string' ? value : value + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>