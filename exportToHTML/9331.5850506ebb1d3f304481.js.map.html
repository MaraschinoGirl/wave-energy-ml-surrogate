<html>
<head>
<title>9331.5850506ebb1d3f304481.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
9331.5850506ebb1d3f304481.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;9331.5850506ebb1d3f304481.js?v=5850506ebb1d3f304481&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,QAAQ;AAC5B;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/dylan.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function forEach(arr, f) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) f(arr[i], i)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function some(arr, f) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) if (f(arr[i], i)) return true</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Words</span><span class="s3">\n</span><span class="s1">var words = {</span><span class="s3">\n  </span><span class="s1">// Words that introduce unnamed definitions like </span><span class="s3">\&quot;</span><span class="s1">define interface</span><span class="s3">\&quot;\n  </span><span class="s1">unnamedDefinition: [</span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Words that introduce simple named definitions like </span><span class="s3">\&quot;</span><span class="s1">define library</span><span class="s3">\&quot;\n  </span><span class="s1">namedDefinition: [</span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">library</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">macro</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                    \&quot;</span><span class="s1">C-struct</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">C-union</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                    \&quot;</span><span class="s1">C-function</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">C-callable-wrapper</span><span class="s3">\&quot;\n                   </span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Words that introduce type definitions like </span><span class="s3">\&quot;</span><span class="s1">define class</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">// These are also parameterized like </span><span class="s3">\&quot;</span><span class="s1">define method</span><span class="s3">\&quot; </span><span class="s1">and are</span><span class="s3">\n  </span><span class="s1">// appended to otherParameterizedDefinitionWords</span><span class="s3">\n  </span><span class="s1">typeParameterizedDefinition: [</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">C-subtype</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">C-mapped-subtype</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Words that introduce trickier definitions like </span><span class="s3">\&quot;</span><span class="s1">define method</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">// These require special definitions to be added to startExpressions</span><span class="s3">\n  </span><span class="s1">otherParameterizedDefinition: [</span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                 \&quot;</span><span class="s1">C-variable</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">C-address</span><span class="s3">\&quot;\n                                </span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Words that introduce module constant definitions.</span><span class="s3">\n  </span><span class="s1">// These must also be simple definitions and are</span><span class="s3">\n  </span><span class="s1">// appended to otherSimpleDefinitionWords</span><span class="s3">\n  </span><span class="s1">constantSimpleDefinition: [</span><span class="s3">\&quot;</span><span class="s1">constant</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Words that introduce module variable definitions.</span><span class="s3">\n  </span><span class="s1">// These must also be simple definitions and are</span><span class="s3">\n  </span><span class="s1">// appended to otherSimpleDefinitionWords</span><span class="s3">\n  </span><span class="s1">variableSimpleDefinition: [</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Other words that introduce simple definitions</span><span class="s3">\n  </span><span class="s1">// (without implicit bodies).</span><span class="s3">\n  </span><span class="s1">otherSimpleDefinition: [</span><span class="s3">\&quot;</span><span class="s1">generic</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">domain</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                          \&quot;</span><span class="s1">C-pointer-type</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                          \&quot;</span><span class="s1">table</span><span class="s3">\&quot;\n                         </span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Words that begin statements with implicit bodies.</span><span class="s3">\n  </span><span class="s1">statement: [</span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">begin</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              \&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">when</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">unless</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">until</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              \&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">iterate</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">profiling</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dynamic-bind</span><span class="s3">\&quot;\n             </span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Patterns that act as separators in compound statements.</span><span class="s3">\n  </span><span class="s1">// This may include any general pattern that must be indented</span><span class="s3">\n  </span><span class="s1">// specially.</span><span class="s3">\n  </span><span class="s1">separator: [</span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">exception</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cleanup</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              \&quot;</span><span class="s1">elseif</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">afterwards</span><span class="s3">\&quot;\n             </span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Keywords that do not require special indentation handling,</span><span class="s3">\n  </span><span class="s1">// but which should be highlighted</span><span class="s3">\n  </span><span class="s1">other: [</span><span class="s3">\&quot;</span><span class="s1">above</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">below</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">by</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">handler</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          \&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">otherwise</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">slot</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          \&quot;</span><span class="s1">subclass</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">to</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">keyed-by</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">virtual</span><span class="s3">\&quot;\n         </span><span class="s1">],</span><span class="s3">\n\n  </span><span class="s1">// Condition signaling function calls</span><span class="s3">\n  </span><span class="s1">signalingCalls: [</span><span class="s3">\&quot;</span><span class="s1">signal</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cerror</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                   \&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">check-type</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">abort</span><span class="s3">\&quot;\n                  </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">otherDefinition</span><span class="s3">\&quot;</span><span class="s1">] =</span><span class="s3">\n  </span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">unnamedDefinition</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">namedDefinition</span><span class="s3">\&quot;</span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">otherParameterizedDefinition</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">] =</span><span class="s3">\n  </span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">typeParameterizedDefinition</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">otherDefinition</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">parameterizedDefinition</span><span class="s3">\&quot;</span><span class="s1">] =</span><span class="s3">\n  </span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">typeParameterizedDefinition</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">otherParameterizedDefinition</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">simpleDefinition</span><span class="s3">\&quot;</span><span class="s1">] =</span><span class="s3">\n  </span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">constantSimpleDefinition</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">variableSimpleDefinition</span><span class="s3">\&quot;</span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">otherSimpleDefinition</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">] =</span><span class="s3">\n  </span><span class="s1">words[</span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">separator</span><span class="s3">\&quot;</span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">.concat(words[</span><span class="s3">\&quot;</span><span class="s1">other</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">// Patterns</span><span class="s3">\n</span><span class="s1">var symbolPattern = </span><span class="s3">\&quot;</span><span class="s1">[-_a-zA-Z?!*@&lt;&gt;$%]+</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var symbol = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ symbolPattern);</span><span class="s3">\n</span><span class="s1">var patterns = {</span><span class="s3">\n  </span><span class="s1">// Symbols with special syntax</span><span class="s3">\n  </span><span class="s1">symbolKeyword: symbolPattern + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">symbolClass: </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot; </span><span class="s1">+ symbolPattern + </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">symbolGlobal: </span><span class="s3">\&quot;\\\\</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ symbolPattern + </span><span class="s3">\&quot;\\\\</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">symbolConstant: </span><span class="s3">\&quot;\\\\</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">+ symbolPattern</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var patternStyles = {</span><span class="s3">\n  </span><span class="s1">symbolKeyword: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">symbolClass: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">symbolGlobal: </span><span class="s3">\&quot;</span><span class="s1">variableName.standard</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">symbolConstant: </span><span class="s3">\&quot;</span><span class="s1">variableName.constant</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Compile all patterns to regular expressions</span><span class="s3">\n</span><span class="s1">for (var patternName in patterns)</span><span class="s3">\n  </span><span class="s1">if (patterns.hasOwnProperty(patternName))</span><span class="s3">\n    </span><span class="s1">patterns[patternName] = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ patterns[patternName]);</span><span class="s3">\n\n</span><span class="s1">// Names beginning </span><span class="s3">\&quot;</span><span class="s1">with-</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">without-</span><span class="s3">\&quot; </span><span class="s1">are commonly</span><span class="s3">\n</span><span class="s1">// used as statement macro</span><span class="s3">\n</span><span class="s1">patterns[</span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">] = [/^with(?:out)?-[-_a-zA-Z?!*@&lt;&gt;$%]+/];</span><span class="s3">\n\n</span><span class="s1">var styles = {};</span><span class="s3">\n</span><span class="s1">styles[</span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">styles[</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">styles[</span><span class="s3">\&quot;</span><span class="s1">simpleDefinition</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">styles[</span><span class="s3">\&quot;</span><span class="s1">signalingCalls</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">builtin</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// protected words lookup table</span><span class="s3">\n</span><span class="s1">var wordLookup = {};</span><span class="s3">\n</span><span class="s1">var styleLookup = {};</span><span class="s3">\n\n</span><span class="s1">forEach([</span><span class="s3">\n  \&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">simpleDefinition</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">signalingCalls</span><span class="s3">\&quot;\n</span><span class="s1">], function(type) {</span><span class="s3">\n  </span><span class="s1">forEach(words[type], function(word) {</span><span class="s3">\n    </span><span class="s1">wordLookup[word] = type;</span><span class="s3">\n    </span><span class="s1">styleLookup[word] = styles[type];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n\n</span><span class="s1">function chain(stream, state, f) {</span><span class="s3">\n  </span><span class="s1">state.tokenize = f;</span><span class="s3">\n  </span><span class="s1">return f(stream, state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n  </span><span class="s1">// String</span><span class="s3">\n  </span><span class="s1">var ch = stream.peek();</span><span class="s3">\n  </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">|| ch == '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return chain(stream, state, tokenString(ch, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Comment</span><span class="s3">\n  </span><span class="s1">else if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return chain(stream, state, tokenComment);</span><span class="s3">\n    </span><span class="s1">} else if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stream.backUp(1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Decimal</span><span class="s3">\n  </span><span class="s1">else if (/[+</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">.]/.test(ch)) {</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^[+-]?[0-9]*</span><span class="s3">\\</span><span class="s1">.[0-9]*([esdx][+-]?[0-9]+)?/i) ||</span><span class="s3">\n        </span><span class="s1">stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||</span><span class="s3">\n        </span><span class="s1">stream.match(/^[+-]?</span><span class="s3">\\</span><span class="s1">d+/)) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Hash</span><span class="s3">\n  </span><span class="s1">else if (ch == </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">// Symbol with string syntax</span><span class="s3">\n    </span><span class="s1">ch = stream.peek();</span><span class="s3">\n    </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">return chain(stream, state, tokenString('</span><span class="s3">\&quot;</span><span class="s1">', </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Binary number</span><span class="s3">\n    </span><span class="s1">else if (ch == </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[01]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Hex number</span><span class="s3">\n    </span><span class="s1">else if (ch == </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">da-f]/i);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Octal number</span><span class="s3">\n    </span><span class="s1">else if (ch == </span><span class="s3">\&quot;</span><span class="s1">o</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[0-7]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Token concatenation in macros</span><span class="s3">\n    </span><span class="s1">else if (ch == '#') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Sequence literals</span><span class="s3">\n    </span><span class="s1">else if ((ch == '[') || (ch == '(')) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bracket</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">// Hash symbol</span><span class="s3">\n    </span><span class="s1">} else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[-a-zA-Z]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">ch = stream.peek();</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">ch = stream.peek();</span><span class="s3">\n      </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">stream.next();</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">ch = stream.peek();</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\&quot;</span><span class="s1">[](){}</span><span class="s3">\&quot;</span><span class="s1">.indexOf(ch) != -1) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bracket</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\&quot;</span><span class="s1">.,</span><span class="s3">\&quot;</span><span class="s1">.indexOf(ch) != -1) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (stream.match(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var name in patterns) {</span><span class="s3">\n    </span><span class="s1">if (patterns.hasOwnProperty(name)) {</span><span class="s3">\n      </span><span class="s1">var pattern = patterns[name];</span><span class="s3">\n      </span><span class="s1">if ((pattern instanceof Array &amp;&amp; some(pattern, function(p) {</span><span class="s3">\n        </span><span class="s1">return stream.match(p);</span><span class="s3">\n      </span><span class="s1">})) || stream.match(pattern))</span><span class="s3">\n        </span><span class="s1">return patternStyles[name];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (/[+</span><span class="s3">\\</span><span class="s1">-*</span><span class="s3">\\</span><span class="s1">/^=&lt;&gt;&amp;|]/.test(ch)) {</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (stream.match(</span><span class="s3">\&quot;</span><span class="s1">define</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">-]/);</span><span class="s3">\n    </span><span class="s1">// Keyword</span><span class="s3">\n    </span><span class="s1">if (wordLookup.hasOwnProperty(stream.current())) {</span><span class="s3">\n      </span><span class="s1">return styleLookup[stream.current()];</span><span class="s3">\n    </span><span class="s1">} else if (stream.current().match(symbol)) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variableName.standard</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;</span><span class="s3">\n  </span><span class="s1">while ((ch = stream.next())) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n      </span><span class="s1">if (nestedCount &gt; 0) {</span><span class="s3">\n        </span><span class="s1">nestedCount--;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeNested) {</span><span class="s3">\n      </span><span class="s1">nestedCount++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">maybeNested = (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenString(quote, style) {</span><span class="s3">\n  </span><span class="s1">return function(stream, state) {</span><span class="s3">\n    </span><span class="s1">var escaped = false, next, end = false;</span><span class="s3">\n    </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (next == quote &amp;&amp; !escaped) {</span><span class="s3">\n        </span><span class="s1">end = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end || !escaped) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return style;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Interface</span><span class="s3">\n</span><span class="s1">export const dylan = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">dylan</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">startState: function() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">tokenize: tokenBase,</span><span class="s3">\n      </span><span class="s1">currentIndent: 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace())</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">var style = state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">return style;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">commentTokens: {block: {open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot;</span><span class="s1">}}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>