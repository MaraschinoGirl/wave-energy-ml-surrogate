<html>
<head>
<title>4588.d49449d586c134ece18f.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
4588.d49449d586c134ece18f.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;4588.d49449d586c134ece18f.js?v=d49449d586c134ece18f&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;AAAwE;AACrB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;;AAEA,2BAA2B,2BAAc;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,mCAAmC;AACrD;AACA,CAAC;;AAED,qBAAqB,8BAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA,IAAI;AACJ;AACA;AACA,CAAC,GAAG,iBAAiB;;AAErB;AACA,aAAa,8BAAiB;AAC9B,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,wBAAwB,uBAAS;AACjC,QAAQ,cAAI;AACZ,mDAAmD,cAAI;AACvD,WAAW,cAAI;AACf,iCAAiC,cAAI,UAAU,cAAI;AACnD,iBAAiB,cAAI;AACrB,kBAAkB,cAAI;AACtB,MAAM,cAAI;AACV,wCAAwC,cAAI;AAC5C,WAAW,cAAI;AACf,kBAAkB,cAAI;AACtB,eAAe,cAAI;AACnB,SAAS,cAAI,SAAS,cAAI;AAC1B,CAAC;;AAED;AACA,eAAe,qBAAQ;AACvB;AACA,8DAA8D,oIAAoI,IAAI,0EAA0E,IAAI,oPAAoP,IAAI,0DAA0D,gKAAgK,IAAI,0IAA0I,4BAA4B,IAAI;AACp5B,2CAA2C,iDAAiD,iFAAiF,WAAW,uNAAuN,2BAA2B;AAC1a,+CAA+C,2IAA2I;AAC1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,GAAG,gBAAgB,oDAAoD,IAAI,2JAA2J,KAAK,GAAG,KAAK,GAAG,iDAAiD,2BAA2B,KAAK,GAAG,4BAA4B,KAAK,GAAG,eAAe,YAAY,WAAW,KAAK,GAAG,eAAe,YAAY,cAAc,yDAAyD,KAAK,GAAG,8BAA8B,KAAK,GAAG,kCAAkC,KAAK,GAAG,oCAAoC,KAAK,GAAG,qBAAqB,uBAAuB,KAAK,GAAG,aAAa,mBAAmB,KAAK,GAAG,qBAAqB,cAAc,eAAe,GAAG,mBAAmB,KAAK,GAAG,iBAAiB,uCAAuC,KAAK,GAAG,mBAAmB,2BAA2B,KAAK,GAAG,iBAAiB,uCAAuC,KAAK,GAAG,aAAa,MAAM,2BAA2B,KAAK,GAAG,sBAAsB,eAAe,GAAG,kDAAkD,IAAI,0BAA0B,IAAI,6IAA6I,KAAK,GAAG,KAAK,GAAG,+CAA+C,UAAU,EAAE,2BAA2B,KAAK,GAAG,eAAe,WAAW,GAAG,oBAAoB,IAAI,mBAAmB,KAAK,GAAG,eAAe,WAAW,GAAG,IAAI,GAAG,KAAK,GAAG,eAAe,EAAE,WAAW,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,YAAY,IAAI,OAAO,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,+BAA+B,KAAK,GAAG,yBAAyB,GAAG,KAAK,GAAG,qBAAqB,cAAc,WAAW,KAAK,GAAG,eAAe,YAAY,mCAAmC,KAAK,GAAG,eAAe,mBAAmB,IAAI,KAAK,GAAG,YAAY,GAAG,mBAAmB,IAAI,KAAK,GAAG,YAAY,GAAG,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,YAAY,IAAI,OAAO,KAAK,GAAG,eAAe,aAAa,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,eAAe,uBAAuB,KAAK,GAAG,aAAa,EAAE,uBAAuB,KAAK,GAAG,kBAAkB,WAAW,KAAK,GAAG,mBAAmB,2BAA2B,KAAK,GAAG,mBAAmB,2BAA2B,KAAK,GAAG,iBAAiB,uCAAuC,KAAK,GAAG,oBAAoB,2BAA2B,KAAK,GAAG,iBAAiB,uCAAuC,KAAK,GAAG,iBAAiB,uCAAuC,KAAK,GAAG,mBAAmB,2BAA2B,KAAK,GAAG;AACjvG;AACA,aAAa,iBAAiB;AAC9B;AACA,CAAC;;AAEiB;;;;;;;;;AC9IkB;AACgG;AAChF;AACN;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAAU;AACvB,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,MAAM,YAAO;AACb;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,uBAAuB,KAAK,kBAAkB;AACpH,4DAA4D,sBAAsB,wBAAwB;AAC1G,6DAA6D,sBAAsB,yCAAyC;AAC5H,iEAAiE,sBAAsB,wBAAwB;AAC/G,oEAAoE,wBAAwB;AAC5F;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB,uBAAuB,KAAK,kBAAkB;AACzG;AACA;AACA,uCAAuC,WAAW,KAAK;AACvD;AACA,4CAA4C,WAAW,WAAW,WAAW,IAAI;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,sBAAsB,YAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,uCAAuC;AAC9J;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,wDAAwD;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAU;AAC3C;AACA,yBAAyB,MAAM;AAC/B;AACA,yBAAyB,6BAAc;AACvC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,yBAAyB,2BAAY;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb,yBAAyB,oCAAqB;AAC9C;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,yBAAyB,SAAS,8BAA8B;AAChE;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,8BAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAAU;AAC7C;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,cAAc,OAAO;AACrB;AACA,oBAAoB,6BAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA,2BAA2B,oCAAe;AAC1C,+BAA+B;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAE8D&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/xml/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-xml/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { ContextTracker, ExternalTokenizer, LRParser } from '@lezer/lr';</span><span class="s3">\n</span><span class="s1">import { styleTags, tags } from '@lezer/highlight';</span><span class="s3">\n\n</span><span class="s1">// This file was generated by lezer-generator. You probably shouldn't edit it.</span><span class="s3">\n</span><span class="s1">const StartTag = 1,</span><span class="s3">\n  </span><span class="s1">StartCloseTag = 2,</span><span class="s3">\n  </span><span class="s1">MissingCloseTag = 3,</span><span class="s3">\n  </span><span class="s1">mismatchedStartCloseTag = 4,</span><span class="s3">\n  </span><span class="s1">incompleteStartCloseTag = 5,</span><span class="s3">\n  </span><span class="s1">commentContent$1 = 35,</span><span class="s3">\n  </span><span class="s1">piContent$1 = 36,</span><span class="s3">\n  </span><span class="s1">cdataContent$1 = 37,</span><span class="s3">\n  </span><span class="s1">Element = 11,</span><span class="s3">\n  </span><span class="s1">OpenTag = 13;</span><span class="s3">\n\n</span><span class="s1">/* Hand-written tokenizer for XML tag matching. */</span><span class="s3">\n\n</span><span class="s1">function nameChar(ch) {</span><span class="s3">\n  </span><span class="s1">return ch == 45 || ch == 46 || ch == 58 || ch &gt;= 65 &amp;&amp; ch &lt;= 90 || ch == 95 || ch &gt;= 97 &amp;&amp; ch &lt;= 122 || ch &gt;= 161</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isSpace(ch) {</span><span class="s3">\n  </span><span class="s1">return ch == 9 || ch == 10 || ch == 13 || ch == 32</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let cachedName = null, cachedInput = null, cachedPos = 0;</span><span class="s3">\n</span><span class="s1">function tagNameAfter(input, offset) {</span><span class="s3">\n  </span><span class="s1">let pos = input.pos + offset;</span><span class="s3">\n  </span><span class="s1">if (cachedInput == input &amp;&amp; cachedPos == pos) return cachedName</span><span class="s3">\n  </span><span class="s1">while (isSpace(input.peek(offset))) offset++;</span><span class="s3">\n  </span><span class="s1">let name = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">for (;;) {</span><span class="s3">\n    </span><span class="s1">let next = input.peek(offset);</span><span class="s3">\n    </span><span class="s1">if (!nameChar(next)) break</span><span class="s3">\n    </span><span class="s1">name += String.fromCharCode(next);</span><span class="s3">\n    </span><span class="s1">offset++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">cachedInput = input; cachedPos = pos;</span><span class="s3">\n  </span><span class="s1">return cachedName = name || null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ElementContext(name, parent) {</span><span class="s3">\n  </span><span class="s1">this.name = name;</span><span class="s3">\n  </span><span class="s1">this.parent = parent;</span><span class="s3">\n  </span><span class="s1">this.hash = parent ? parent.hash : 0;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; name.length; i++) this.hash += (this.hash &lt;&lt; 4) + name.charCodeAt(i) + (name.charCodeAt(i) &lt;&lt; 8);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const elementContext = new ContextTracker({</span><span class="s3">\n  </span><span class="s1">start: null,</span><span class="s3">\n  </span><span class="s1">shift(context, term, stack, input) {</span><span class="s3">\n    </span><span class="s1">return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || </span><span class="s3">\&quot;\&quot;</span><span class="s1">, context) : context</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">reduce(context, term) {</span><span class="s3">\n    </span><span class="s1">return term == Element &amp;&amp; context ? context.parent : context</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">reuse(context, node, _stack, input) {</span><span class="s3">\n    </span><span class="s1">let type = node.type.id;</span><span class="s3">\n    </span><span class="s1">return type == StartTag || type == OpenTag</span><span class="s3">\n      </span><span class="s1">? new ElementContext(tagNameAfter(input, 1) || </span><span class="s3">\&quot;\&quot;</span><span class="s1">, context) : context</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hash(context) { return context ? context.hash : 0 },</span><span class="s3">\n  </span><span class="s1">strict: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">const startTag = new ExternalTokenizer((input, stack) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (input.next != 60 /* '&lt;' */) return</span><span class="s3">\n  </span><span class="s1">input.advance();</span><span class="s3">\n  </span><span class="s1">if (input.next == 47 /* '/' */) {</span><span class="s3">\n    </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">let name = tagNameAfter(input, 0);</span><span class="s3">\n    </span><span class="s1">if (!name) return input.acceptToken(incompleteStartCloseTag)</span><span class="s3">\n    </span><span class="s1">if (stack.context &amp;&amp; name == stack.context.name) return input.acceptToken(StartCloseTag)</span><span class="s3">\n    </span><span class="s1">for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return input.acceptToken(MissingCloseTag, -2)</span><span class="s3">\n    </span><span class="s1">input.acceptToken(mismatchedStartCloseTag);</span><span class="s3">\n  </span><span class="s1">} else if (input.next != 33 /* '!' */ &amp;&amp; input.next != 63 /* '?' */) {</span><span class="s3">\n    </span><span class="s1">return input.acceptToken(StartTag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {contextual: true});</span><span class="s3">\n\n</span><span class="s1">function scanTo(type, end) {</span><span class="s3">\n  </span><span class="s1">return new ExternalTokenizer(input =&gt; {</span><span class="s3">\n    </span><span class="s1">for (let endPos = 0, len = 0;; len++) {</span><span class="s3">\n      </span><span class="s1">if (input.next &lt; 0) {</span><span class="s3">\n        </span><span class="s1">if (len) input.acceptToken(type);</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">} </span><span class="s3">\n      </span><span class="s1">if (input.next == end.charCodeAt(endPos)) {</span><span class="s3">\n        </span><span class="s1">endPos++;</span><span class="s3">\n        </span><span class="s1">if (endPos == end.length) {</span><span class="s3">\n          </span><span class="s1">if (len &gt;= end.length) input.acceptToken(type, 1 - end.length);</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">endPos = input.next == end.charCodeAt(0) ? 1 : 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const commentContent = scanTo(commentContent$1, </span><span class="s3">\&quot;</span><span class="s1">--&gt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const piContent = scanTo(piContent$1, </span><span class="s3">\&quot;</span><span class="s1">?&gt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const cdataContent = scanTo(cdataContent$1, </span><span class="s3">\&quot;</span><span class="s1">]]&gt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">const xmlHighlighting = styleTags({</span><span class="s3">\n  </span><span class="s1">Text: tags.content,</span><span class="s3">\n  \&quot;</span><span class="s1">StartTag StartCloseTag EndTag SelfCloseEndTag</span><span class="s3">\&quot;</span><span class="s1">: tags.angleBracket,</span><span class="s3">\n  </span><span class="s1">TagName: tags.tagName,</span><span class="s3">\n  \&quot;</span><span class="s1">MismatchedCloseTag/Tagname</span><span class="s3">\&quot;</span><span class="s1">: [tags.tagName, tags.invalid],</span><span class="s3">\n  </span><span class="s1">AttributeName: tags.attributeName,</span><span class="s3">\n  </span><span class="s1">AttributeValue: tags.attributeValue,</span><span class="s3">\n  </span><span class="s1">Is: tags.definitionOperator,</span><span class="s3">\n  \&quot;</span><span class="s1">EntityReference CharacterReference</span><span class="s3">\&quot;</span><span class="s1">: tags.character,</span><span class="s3">\n  </span><span class="s1">Comment: tags.blockComment,</span><span class="s3">\n  </span><span class="s1">ProcessingInst: tags.processingInstruction,</span><span class="s3">\n  </span><span class="s1">DoctypeDecl: tags.documentMeta,</span><span class="s3">\n  </span><span class="s1">Cdata: tags.special(tags.string)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// This file was generated by lezer-generator. You probably shouldn't edit it.</span><span class="s3">\n</span><span class="s1">const parser = LRParser.deserialize({</span><span class="s3">\n  </span><span class="s1">version: 14,</span><span class="s3">\n  </span><span class="s1">states: </span><span class="s3">\&quot;</span><span class="s1">,SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&amp;VOpO,59ZO&amp;_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&amp;gOpO1G.zO&amp;gOpO1G.zOOOP1G.z1G.zO&amp;oO!bO7+$ZO&amp;}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO&lt;&lt;GuOOOP&lt;&lt;Gu&lt;&lt;GuOOOP&lt;&lt;G}&lt;&lt;G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP&lt;&lt;HQ&lt;&lt;HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP&lt;&lt;G{&lt;&lt;G{OOOO&lt;&lt;Gw&lt;&lt;GwOOOO-E6x-E6xOOOO1G.t1G.t</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">stateData: </span><span class="s3">\&quot;</span><span class="s1">)Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">goto: </span><span class="s3">\&quot;</span><span class="s1">%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">nodeNames: </span><span class="s3">\&quot;</span><span class="s1">⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">maxTerm: 47,</span><span class="s3">\n  </span><span class="s1">context: elementContext,</span><span class="s3">\n  </span><span class="s1">nodeProps: [</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">closedBy</span><span class="s3">\&quot;</span><span class="s1">, 1,</span><span class="s3">\&quot;</span><span class="s1">SelfCloseEndTag EndTag</span><span class="s3">\&quot;</span><span class="s1">,13,</span><span class="s3">\&quot;</span><span class="s1">CloseTag MissingCloseTag</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">openedBy</span><span class="s3">\&quot;</span><span class="s1">, 12,</span><span class="s3">\&quot;</span><span class="s1">StartTag StartCloseTag</span><span class="s3">\&quot;</span><span class="s1">,19,</span><span class="s3">\&quot;</span><span class="s1">OpenTag</span><span class="s3">\&quot;</span><span class="s1">,20,</span><span class="s3">\&quot;</span><span class="s1">StartTag</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">propSources: [xmlHighlighting],</span><span class="s3">\n  </span><span class="s1">skippedNodes: [0],</span><span class="s3">\n  </span><span class="s1">repeatNodeCount: 8,</span><span class="s3">\n  </span><span class="s1">tokenData: </span><span class="s3">\&quot;</span><span class="s1">IX~R!XOX$nXY&amp;kYZ&amp;kZ]$n]^&amp;k^p$npq&amp;kqr$nrs'ssv$nvw(Zw}$n}!O*l!O!P$n!P!Q,{!Q![$n![!].e!]!^$n!^!_1v!_!`Cz!`!aDm!a!bE`!b!c$n!c!}.e!}#P$n#P#QFx#Q#R$n#R#S.e#S#T$n#T#o.e#o%W$n%W%o.e%o%p$n%p&amp;a.e&amp;a&amp;b$n&amp;b1p.e1p4U$n4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Kh$n$Kh%#t.e%#t&amp;/x$n&amp;/x&amp;Et.e&amp;Et&amp;FV$n&amp;FV;'S.e;'S;:j1p;:j;=`&amp;e&lt;%l?&amp;r$n?&amp;r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s&lt;%lO%_P%vP;=`&lt;%l%_W&amp;OT{WOr%ysv%yw;'S%y;'S;=`&amp;_&lt;%lO%yW&amp;bP;=`&lt;%l%yX&amp;hP;=`&lt;%l$n_&amp;t_VP{WyUOX$nXY&amp;kYZ&amp;kZ]$n]^&amp;k^p$npq&amp;kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s&lt;%lO%_~(^VOp(sqs(sst)ht!](s!^;'S(s;'S;=`)b&lt;%lO(s~(vVOp(sqs(st!](s!]!^)]!^;'S(s;'S;=`)b&lt;%lO(s~)bOW~~)eP;=`&lt;%l(s~)kTOp)zq!])z!^;'S)z;'S;=`*f&lt;%lO)z~)}UOp)zq!])z!]!^*a!^;'S)z;'S;=`*f&lt;%lO)z~*fOX~~*iP;=`&lt;%l)zZ*sYVP{WOr$nrs%_sv$nw}$n}!O+c!O!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$nZ+jYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a,Y!a;'S$n;'S;=`&amp;e&lt;%lO$nZ,cW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$n]-SYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-r!a;'S$n;'S;=`&amp;e&lt;%lO$n]-{WdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$n_.p!O`S^QVP{WOr$nrs%_sv$nw}$n}!O.e!O!P.e!P!Q$n!Q![.e![!].e!]!^$n!^!_%y!_!c$n!c!}.e!}#R$n#R#S.e#S#T$n#T#o.e#o$}$n$}%O.e%O%W$n%W%o.e%o%p$n%p&amp;a.e&amp;a&amp;b$n&amp;b1p.e1p4U.e4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Je$n$Je$Jg.e$Jg$Kh$n$Kh%#t.e%#t&amp;/x$n&amp;/x&amp;Et.e&amp;Et&amp;FV$n&amp;FV;'S.e;'S;:j1p;:j;=`&amp;e&lt;%l?&amp;r$n?&amp;r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$n_1sP;=`&lt;%l.eX1{W{WOq%yqr2esv%yw!a%y!a!bCd!b;'S%y;'S;=`&amp;_&lt;%lO%yX2j]{WOr%ysv%yw}%y}!O3c!O!f%y!f!g4e!g!}%y!}#O9t#O#W%y#W#X@Q#X;'S%y;'S;=`&amp;_&lt;%lO%yX3hV{WOr%ysv%yw}%y}!O3}!O;'S%y;'S;=`&amp;_&lt;%lO%yX4UT}P{WOr%ysv%yw;'S%y;'S;=`&amp;_&lt;%lO%yX4jV{WOr%ysv%yw!q%y!q!r5P!r;'S%y;'S;=`&amp;_&lt;%lO%yX5UV{WOr%ysv%yw!e%y!e!f5k!f;'S%y;'S;=`&amp;_&lt;%lO%yX5pV{WOr%ysv%yw!v%y!v!w6V!w;'S%y;'S;=`&amp;_&lt;%lO%yX6[V{WOr%ysv%yw!{%y!{!|6q!|;'S%y;'S;=`&amp;_&lt;%lO%yX6vV{WOr%ysv%yw!r%y!r!s7]!s;'S%y;'S;=`&amp;_&lt;%lO%yX7bV{WOr%ysv%yw!g%y!g!h7w!h;'S%y;'S;=`&amp;_&lt;%lO%yX7|X{WOr7wrs8isv7wvw8iw!`7w!`!a9W!a;'S7w;'S;=`9n&lt;%lO7wP8lTO!`8i!`!a8{!a;'S8i;'S;=`9Q&lt;%lO8iP9QOiPP9TP;=`&lt;%l8iX9_TiP{WOr%ysv%yw;'S%y;'S;=`&amp;_&lt;%lO%yX9qP;=`&lt;%l7wX9yX{WOr%ysv%yw!e%y!e!f:f!f#V%y#V#W=t#W;'S%y;'S;=`&amp;_&lt;%lO%yX:kV{WOr%ysv%yw!f%y!f!g;Q!g;'S%y;'S;=`&amp;_&lt;%lO%yX;VV{WOr%ysv%yw!c%y!c!d;l!d;'S%y;'S;=`&amp;_&lt;%lO%yX;qV{WOr%ysv%yw!v%y!v!w&lt;W!w;'S%y;'S;=`&amp;_&lt;%lO%yX&lt;]V{WOr%ysv%yw!c%y!c!d&lt;r!d;'S%y;'S;=`&amp;_&lt;%lO%yX&lt;wV{WOr%ysv%yw!}%y!}#O=^#O;'S%y;'S;=`&amp;_&lt;%lO%yX=eT{WxPOr%ysv%yw;'S%y;'S;=`&amp;_&lt;%lO%yX=yV{WOr%ysv%yw#W%y#W#X&gt;`#X;'S%y;'S;=`&amp;_&lt;%lO%yX&gt;eV{WOr%ysv%yw#T%y#T#U&gt;z#U;'S%y;'S;=`&amp;_&lt;%lO%yX?PV{WOr%ysv%yw#h%y#h#i?f#i;'S%y;'S;=`&amp;_&lt;%lO%yX?kV{WOr%ysv%yw#T%y#T#U&lt;r#U;'S%y;'S;=`&amp;_&lt;%lO%yX@VV{WOr%ysv%yw#c%y#c#d@l#d;'S%y;'S;=`&amp;_&lt;%lO%yX@qV{WOr%ysv%yw#V%y#V#WAW#W;'S%y;'S;=`&amp;_&lt;%lO%yXA]V{WOr%ysv%yw#h%y#h#iAr#i;'S%y;'S;=`&amp;_&lt;%lO%yXAwV{WOr%ysv%yw#m%y#m#nB^#n;'S%y;'S;=`&amp;_&lt;%lO%yXBcV{WOr%ysv%yw#d%y#d#eBx#e;'S%y;'S;=`&amp;_&lt;%lO%yXB}V{WOr%ysv%yw#X%y#X#Y7w#Y;'S%y;'S;=`&amp;_&lt;%lO%yXCkT!PP{WOr%ysv%yw;'S%y;'S;=`&amp;_&lt;%lO%yZDTWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$n_DvW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$nZEgYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aFV!a;'S$n;'S;=`&amp;e&lt;%lO$nZF`W!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$nZGPYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QGo#Q;'S$n;'S;=`&amp;e&lt;%lO$nZGvYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aHf!a;'S$n;'S;=`&amp;e&lt;%lO$nZHoWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&amp;e&lt;%lO$n</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3],</span><span class="s3">\n  </span><span class="s1">topRules: {</span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;</span><span class="s1">:[0,6]},</span><span class="s3">\n  </span><span class="s1">tokenPrec: 0</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { parser };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parser } from '@lezer/xml';</span><span class="s3">\n</span><span class="s1">import { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';</span><span class="s3">\n</span><span class="s1">import { EditorSelection } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import { EditorView } from '@codemirror/view';</span><span class="s3">\n\n</span><span class="s1">function tagName(doc, tag) {</span><span class="s3">\n    </span><span class="s1">let name = tag &amp;&amp; tag.getChild(</span><span class="s3">\&quot;</span><span class="s1">TagName</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return name ? doc.sliceString(name.from, name.to) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function elementName$1(doc, tree) {</span><span class="s3">\n    </span><span class="s1">let tag = tree &amp;&amp; tree.firstChild;</span><span class="s3">\n    </span><span class="s1">return !tag || tag.name != </span><span class="s3">\&quot;</span><span class="s1">OpenTag</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: tagName(doc, tag);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function attrName(doc, tag, pos) {</span><span class="s3">\n    </span><span class="s1">let attr = tag &amp;&amp; tag.getChildren(</span><span class="s3">\&quot;</span><span class="s1">Attribute</span><span class="s3">\&quot;</span><span class="s1">).find(a =&gt; a.from &lt;= pos &amp;&amp; a.to &gt;= pos);</span><span class="s3">\n    </span><span class="s1">let name = attr &amp;&amp; attr.getChild(</span><span class="s3">\&quot;</span><span class="s1">AttributeName</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return name ? doc.sliceString(name.from, name.to) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findParentElement(tree) {</span><span class="s3">\n    </span><span class="s1">for (let cur = tree &amp;&amp; tree.parent; cur; cur = cur.parent)</span><span class="s3">\n        </span><span class="s1">if (cur.name == </span><span class="s3">\&quot;</span><span class="s1">Element</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return cur;</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findLocation(state, pos) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let at = syntaxTree(state).resolveInner(pos, -1), inTag = null;</span><span class="s3">\n    </span><span class="s1">for (let cur = at; !inTag &amp;&amp; cur.parent; cur = cur.parent)</span><span class="s3">\n        </span><span class="s1">if (cur.name == </span><span class="s3">\&quot;</span><span class="s1">OpenTag</span><span class="s3">\&quot; </span><span class="s1">|| cur.name == </span><span class="s3">\&quot;</span><span class="s1">CloseTag</span><span class="s3">\&quot; </span><span class="s1">|| cur.name == </span><span class="s3">\&quot;</span><span class="s1">SelfClosingTag</span><span class="s3">\&quot; </span><span class="s1">|| cur.name == </span><span class="s3">\&quot;</span><span class="s1">MismatchedCloseTag</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">inTag = cur;</span><span class="s3">\n    </span><span class="s1">if (inTag &amp;&amp; (inTag.to &gt; pos || inTag.lastChild.type.isError)) {</span><span class="s3">\n        </span><span class="s1">let elt = inTag.parent;</span><span class="s3">\n        </span><span class="s1">if (at.name == </span><span class="s3">\&quot;</span><span class="s1">TagName</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return inTag.name == </span><span class="s3">\&quot;</span><span class="s1">CloseTag</span><span class="s3">\&quot; </span><span class="s1">|| inTag.name == </span><span class="s3">\&quot;</span><span class="s1">MismatchedCloseTag</span><span class="s3">\&quot;\n                </span><span class="s1">? { type: </span><span class="s3">\&quot;</span><span class="s1">closeTag</span><span class="s3">\&quot;</span><span class="s1">, from: at.from, context: elt }</span><span class="s3">\n                </span><span class="s1">: { type: </span><span class="s3">\&quot;</span><span class="s1">openTag</span><span class="s3">\&quot;</span><span class="s1">, from: at.from, context: findParentElement(elt) };</span><span class="s3">\n        </span><span class="s1">if (at.name == </span><span class="s3">\&quot;</span><span class="s1">AttributeName</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">attrName</span><span class="s3">\&quot;</span><span class="s1">, from: at.from, context: inTag };</span><span class="s3">\n        </span><span class="s1">if (at.name == </span><span class="s3">\&quot;</span><span class="s1">AttributeValue</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">attrValue</span><span class="s3">\&quot;</span><span class="s1">, from: at.from, context: inTag };</span><span class="s3">\n        </span><span class="s1">let before = at == inTag || at.name == </span><span class="s3">\&quot;</span><span class="s1">Attribute</span><span class="s3">\&quot; </span><span class="s1">? at.childBefore(pos) : at;</span><span class="s3">\n        </span><span class="s1">if ((before === null || before === void 0 ? void 0 : before.name) == </span><span class="s3">\&quot;</span><span class="s1">StartTag</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">openTag</span><span class="s3">\&quot;</span><span class="s1">, from: pos, context: findParentElement(elt) };</span><span class="s3">\n        </span><span class="s1">if ((before === null || before === void 0 ? void 0 : before.name) == </span><span class="s3">\&quot;</span><span class="s1">StartCloseTag</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; before.to &lt;= pos)</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">closeTag</span><span class="s3">\&quot;</span><span class="s1">, from: pos, context: elt };</span><span class="s3">\n        </span><span class="s1">if ((before === null || before === void 0 ? void 0 : before.name) == </span><span class="s3">\&quot;</span><span class="s1">Is</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">attrValue</span><span class="s3">\&quot;</span><span class="s1">, from: pos, context: inTag };</span><span class="s3">\n        </span><span class="s1">if (before)</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">attrName</span><span class="s3">\&quot;</span><span class="s1">, from: pos, context: inTag };</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (at.name == </span><span class="s3">\&quot;</span><span class="s1">StartCloseTag</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">closeTag</span><span class="s3">\&quot;</span><span class="s1">, from: pos, context: at.parent };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (at.parent &amp;&amp; at.to == pos &amp;&amp; !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))</span><span class="s3">\n        </span><span class="s1">at = at.parent;</span><span class="s3">\n    </span><span class="s1">if (at.name == </span><span class="s3">\&quot;</span><span class="s1">Element</span><span class="s3">\&quot; </span><span class="s1">|| at.name == </span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot; </span><span class="s1">|| at.name == </span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">, from: pos, context: at.name == </span><span class="s3">\&quot;</span><span class="s1">Element</span><span class="s3">\&quot; </span><span class="s1">? at : findParentElement(at) };</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Element {</span><span class="s3">\n    </span><span class="s1">constructor(spec, attrs, attrValues) {</span><span class="s3">\n        </span><span class="s1">this.attrs = attrs;</span><span class="s3">\n        </span><span class="s1">this.attrValues = attrValues;</span><span class="s3">\n        </span><span class="s1">this.children = [];</span><span class="s3">\n        </span><span class="s1">this.name = spec.name;</span><span class="s3">\n        </span><span class="s1">this.completion = Object.assign(Object.assign({ type: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">}, spec.completion || {}), { label: this.name });</span><span class="s3">\n        </span><span class="s1">this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot; </span><span class="s1">+ this.name });</span><span class="s3">\n        </span><span class="s1">this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: </span><span class="s3">\&quot;</span><span class="s1">&lt;/</span><span class="s3">\&quot; </span><span class="s1">+ this.name + </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, boost: 2 });</span><span class="s3">\n        </span><span class="s1">this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.text = spec.textContent ? spec.textContent.map(s =&gt; ({ label: s, type: </span><span class="s3">\&quot;</span><span class="s1">text</span><span class="s3">\&quot; </span><span class="s1">})) : [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const Identifier = /^[:</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">u00b7-</span><span class="s3">\\</span><span class="s1">uffff]*$/;</span><span class="s3">\n</span><span class="s1">function attrCompletion(spec) {</span><span class="s3">\n    </span><span class="s1">return Object.assign(Object.assign({ type: </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot; </span><span class="s1">}, spec.completion || {}), { label: spec.name });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function valueCompletion(spec) {</span><span class="s3">\n    </span><span class="s1">return typeof spec == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? { label: `</span><span class="s3">\&quot;</span><span class="s1">${spec}</span><span class="s3">\&quot;</span><span class="s1">`, type: </span><span class="s3">\&quot;</span><span class="s1">constant</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: /^</span><span class="s3">\&quot;</span><span class="s1">/.test(spec.label) ? spec</span><span class="s3">\n            </span><span class="s1">: Object.assign(Object.assign({}, spec), { label: `</span><span class="s3">\&quot;</span><span class="s1">${spec.label}</span><span class="s3">\&quot;</span><span class="s1">` });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a completion source for the given schema.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function completeFromSchema(eltSpecs, attrSpecs) {</span><span class="s3">\n    </span><span class="s1">let allAttrs = [], globalAttrs = [];</span><span class="s3">\n    </span><span class="s1">let attrValues = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let s of attrSpecs) {</span><span class="s3">\n        </span><span class="s1">let completion = attrCompletion(s);</span><span class="s3">\n        </span><span class="s1">allAttrs.push(completion);</span><span class="s3">\n        </span><span class="s1">if (s.global)</span><span class="s3">\n            </span><span class="s1">globalAttrs.push(completion);</span><span class="s3">\n        </span><span class="s1">if (s.values)</span><span class="s3">\n            </span><span class="s1">attrValues[s.name] = s.values.map(valueCompletion);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let allElements = [], topElements = [];</span><span class="s3">\n    </span><span class="s1">let byName = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let s of eltSpecs) {</span><span class="s3">\n        </span><span class="s1">let attrs = globalAttrs, attrVals = attrValues;</span><span class="s3">\n        </span><span class="s1">if (s.attributes)</span><span class="s3">\n            </span><span class="s1">attrs = attrs.concat(s.attributes.map(s =&gt; {</span><span class="s3">\n                </span><span class="s1">if (typeof s == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">return allAttrs.find(a =&gt; a.label == s) || { label: s, type: </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">if (s.values) {</span><span class="s3">\n                    </span><span class="s1">if (attrVals == attrValues)</span><span class="s3">\n                        </span><span class="s1">attrVals = Object.create(attrVals);</span><span class="s3">\n                    </span><span class="s1">attrVals[s.name] = s.values.map(valueCompletion);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return attrCompletion(s);</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">let elt = new Element(s, attrs, attrVals);</span><span class="s3">\n        </span><span class="s1">byName[elt.name] = elt;</span><span class="s3">\n        </span><span class="s1">allElements.push(elt);</span><span class="s3">\n        </span><span class="s1">if (s.top)</span><span class="s3">\n            </span><span class="s1">topElements.push(elt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!topElements.length)</span><span class="s3">\n        </span><span class="s1">topElements = allElements;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; allElements.length; i++) {</span><span class="s3">\n        </span><span class="s1">let s = eltSpecs[i], elt = allElements[i];</span><span class="s3">\n        </span><span class="s1">if (s.children) {</span><span class="s3">\n            </span><span class="s1">for (let ch of s.children)</span><span class="s3">\n                </span><span class="s1">if (byName[ch])</span><span class="s3">\n                    </span><span class="s1">elt.children.push(byName[ch]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">elt.children = allElements;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cx =&gt; {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);</span><span class="s3">\n        </span><span class="s1">if (!loc || (loc.type == </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !cx.explicit))</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let { type, from, context } = loc;</span><span class="s3">\n        </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">openTag</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let children = topElements;</span><span class="s3">\n            </span><span class="s1">let parentName = elementName$1(doc, context);</span><span class="s3">\n            </span><span class="s1">if (parentName) {</span><span class="s3">\n                </span><span class="s1">let parent = byName[parentName];</span><span class="s3">\n                </span><span class="s1">children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">from,</span><span class="s3">\n                </span><span class="s1">options: children.map(ch =&gt; ch.completion),</span><span class="s3">\n                </span><span class="s1">validFor: Identifier</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">closeTag</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let parentName = elementName$1(doc, context);</span><span class="s3">\n            </span><span class="s1">return parentName ? {</span><span class="s3">\n                </span><span class="s1">from,</span><span class="s3">\n                </span><span class="s1">to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">? 1 : 0),</span><span class="s3">\n                </span><span class="s1">options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, type: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">}],</span><span class="s3">\n                </span><span class="s1">validFor: Identifier</span><span class="s3">\n            </span><span class="s1">} : null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">attrName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let parent = byName[tagName(doc, context)];</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">from,</span><span class="s3">\n                </span><span class="s1">options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,</span><span class="s3">\n                </span><span class="s1">validFor: Identifier</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">attrValue</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let attr = attrName(doc, context, from);</span><span class="s3">\n            </span><span class="s1">if (!attr)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">let parent = byName[tagName(doc, context)];</span><span class="s3">\n            </span><span class="s1">let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];</span><span class="s3">\n            </span><span class="s1">if (!values || !values.length)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">from,</span><span class="s3">\n                </span><span class="s1">to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '</span><span class="s3">\&quot;</span><span class="s1">' ? 1 : 0),</span><span class="s3">\n                </span><span class="s1">options: values,</span><span class="s3">\n                </span><span class="s1">validFor: /^</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">]*</span><span class="s3">\&quot;</span><span class="s1">?$/</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let parentName = elementName$1(doc, context), parent = byName[parentName];</span><span class="s3">\n            </span><span class="s1">let closing = [], last = context &amp;&amp; context.lastChild;</span><span class="s3">\n            </span><span class="s1">if (parentName &amp;&amp; (!last || last.name != </span><span class="s3">\&quot;</span><span class="s1">CloseTag</span><span class="s3">\&quot; </span><span class="s1">|| tagName(doc, last) != parentName))</span><span class="s3">\n                </span><span class="s1">closing.push(parent ? parent.closeCompletion : { label: </span><span class="s3">\&quot;</span><span class="s1">&lt;/</span><span class="s3">\&quot; </span><span class="s1">+ parentName + </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, type: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, boost: 2 });</span><span class="s3">\n            </span><span class="s1">let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e =&gt; e.openCompletion));</span><span class="s3">\n            </span><span class="s1">if (context &amp;&amp; (parent === null || parent === void 0 ? void 0 : parent.text.length)) {</span><span class="s3">\n                </span><span class="s1">let openTag = context.firstChild;</span><span class="s3">\n                </span><span class="s1">if (openTag.to &gt; cx.pos - 20 &amp;&amp; !/</span><span class="s3">\\</span><span class="s1">S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))</span><span class="s3">\n                    </span><span class="s1">options = options.concat(parent.text);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">from,</span><span class="s3">\n                </span><span class="s1">options,</span><span class="s3">\n                </span><span class="s1">validFor: /^&lt;</span><span class="s3">\\</span><span class="s1">/?[:</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">u00b7-</span><span class="s3">\\</span><span class="s1">uffff]*$/</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A language provider based on the [Lezer XML</span><span class="s3">\n</span><span class="s1">parser](https://github.com/lezer-parser/xml), extended with</span><span class="s3">\n</span><span class="s1">highlighting and indentation information.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const xmlLanguage = /*@__PURE__*/LRLanguage.define({</span><span class="s3">\n    </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">xml</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">parser: /*@__PURE__*/parser.configure({</span><span class="s3">\n        </span><span class="s1">props: [</span><span class="s3">\n            </span><span class="s1">/*@__PURE__*/indentNodeProp.add({</span><span class="s3">\n                </span><span class="s1">Element(context) {</span><span class="s3">\n                    </span><span class="s1">let closed = /^</span><span class="s3">\\</span><span class="s1">s*&lt;</span><span class="s3">\\</span><span class="s1">//.test(context.textAfter);</span><span class="s3">\n                    </span><span class="s1">return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                \&quot;</span><span class="s1">OpenTag CloseTag SelfClosingTag</span><span class="s3">\&quot;</span><span class="s1">(context) {</span><span class="s3">\n                    </span><span class="s1">return context.column(context.node.from) + context.unit;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">/*@__PURE__*/foldNodeProp.add({</span><span class="s3">\n                </span><span class="s1">Element(subtree) {</span><span class="s3">\n                    </span><span class="s1">let first = subtree.firstChild, last = subtree.lastChild;</span><span class="s3">\n                    </span><span class="s1">if (!first || first.name != </span><span class="s3">\&quot;</span><span class="s1">OpenTag</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">return null;</span><span class="s3">\n                    </span><span class="s1">return { from: first.to, to: last.name == </span><span class="s3">\&quot;</span><span class="s1">CloseTag</span><span class="s3">\&quot; </span><span class="s1">? last.from : subtree.to };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">/*@__PURE__*/bracketMatchingHandle.add({</span><span class="s3">\n                \&quot;</span><span class="s1">OpenTag CloseTag</span><span class="s3">\&quot;</span><span class="s1">: node =&gt; node.getChild(</span><span class="s3">\&quot;</span><span class="s1">TagName</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">languageData: {</span><span class="s3">\n        </span><span class="s1">commentTokens: { block: { open: </span><span class="s3">\&quot;</span><span class="s1">&lt;!--</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">--&gt;</span><span class="s3">\&quot; </span><span class="s1">} },</span><span class="s3">\n        </span><span class="s1">indentOnInput: /^</span><span class="s3">\\</span><span class="s1">s*&lt;</span><span class="s3">\\</span><span class="s1">/$/</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">XML language support. Includes schema-based autocompletion when</span><span class="s3">\n</span><span class="s1">configured.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function xml(conf = {}) {</span><span class="s3">\n    </span><span class="s1">let support = [xmlLanguage.data.of({</span><span class="s3">\n            </span><span class="s1">autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])</span><span class="s3">\n        </span><span class="s1">})];</span><span class="s3">\n    </span><span class="s1">if (conf.autoCloseTags !== false)</span><span class="s3">\n        </span><span class="s1">support.push(autoCloseTags);</span><span class="s3">\n    </span><span class="s1">return new LanguageSupport(xmlLanguage, support);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function elementName(doc, tree, max = doc.length) {</span><span class="s3">\n    </span><span class="s1">if (!tree)</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">let tag = tree.firstChild;</span><span class="s3">\n    </span><span class="s1">let name = tag &amp;&amp; tag.getChild(</span><span class="s3">\&quot;</span><span class="s1">TagName</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return name ? doc.sliceString(name.from, Math.min(name.to, max)) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Extension that will automatically insert close tags when a `&gt;` or</span><span class="s3">\n</span><span class="s1">`/` is typed.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, insertTransaction) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (view.composing || view.state.readOnly || from != to || (text != </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; text != </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">!xmlLanguage.isActiveAt(view.state, from, -1))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let base = insertTransaction(), { state } = base;</span><span class="s3">\n    </span><span class="s1">let closeTags = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">let { head } = range;</span><span class="s3">\n        </span><span class="s1">let didType = state.doc.sliceString(head - 1, head) == text;</span><span class="s3">\n        </span><span class="s1">let after = syntaxTree(state).resolveInner(head, -1), name;</span><span class="s3">\n        </span><span class="s1">if (didType &amp;&amp; text == </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; after.name == </span><span class="s3">\&quot;</span><span class="s1">EndTag</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let tag = after.parent;</span><span class="s3">\n            </span><span class="s1">if (((_b = (_a = tag.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != </span><span class="s3">\&quot;</span><span class="s1">CloseTag</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                </span><span class="s1">(name = elementName(state.doc, tag.parent, head))) {</span><span class="s3">\n                </span><span class="s1">let to = head + (state.doc.sliceString(head, head + 1) === </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">? 1 : 0);</span><span class="s3">\n                </span><span class="s1">let insert = `&lt;/${name}&gt;`;</span><span class="s3">\n                </span><span class="s1">return { range, changes: { from: head, to, insert } };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (didType &amp;&amp; text == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; after.name == </span><span class="s3">\&quot;</span><span class="s1">StartCloseTag</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let base = after.parent;</span><span class="s3">\n            </span><span class="s1">if (after.from == head - 2 &amp;&amp; ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != </span><span class="s3">\&quot;</span><span class="s1">CloseTag</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                </span><span class="s1">(name = elementName(state.doc, base, head))) {</span><span class="s3">\n                </span><span class="s1">let to = head + (state.doc.sliceString(head, head + 1) === </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">? 1 : 0);</span><span class="s3">\n                </span><span class="s1">let insert = `${name}&gt;`;</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">range: EditorSelection.cursor(head + insert.length, -1),</span><span class="s3">\n                    </span><span class="s1">changes: { from: head, to, insert }</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { range };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (closeTags.changes.empty)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">view.dispatch([</span><span class="s3">\n        </span><span class="s1">base,</span><span class="s3">\n        </span><span class="s1">state.update(closeTags, {</span><span class="s3">\n            </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.complete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">scrollIntoView: true</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { autoCloseTags, completeFromSchema, xml, xmlLanguage };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>