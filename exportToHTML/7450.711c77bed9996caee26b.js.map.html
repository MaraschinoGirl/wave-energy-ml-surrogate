<html>
<head>
<title>7450.711c77bed9996caee26b.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7450.711c77bed9996caee26b.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7450.711c77bed9996caee26b.js?v=711c77bed9996caee26b&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAsM;AAC7I;AACgF;AAChG;;AAEzC;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ,mDAAmD;AAC5E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,uFAAuF;AACvF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAA2E;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0BAA0B,gDAAgD,IAAI,+CAA+C;AAC7H,aAAa;AACb;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,yCAAyC,cAAc;AACvD,+BAA+B,gEAAgE,IAAI,oEAAoE;AACvK;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAoD;AACjF;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA,+BAA+B,+CAA+C;AAC9E;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,iCAAiC,yDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAK;AAC1C,mCAAmC,oDAAK;AACxC;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD,mCAAmC,yDAAU;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAW;AACrC;AACA;AACA,iCAAiC,0DAAW,kCAAkC,0DAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,wDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wDAAS,4CAA4C,yDAAU,+CAA+C,8DAAe,yDAAyD,8DAAe;AAClP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qIAAqI,0DAAW;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAA6C;AAC3F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+CAA+C;AACrD,MAAM,mEAAmE;AACzE,MAAM,wDAAwD;AAC9D,MAAM,wDAAwD;AAC9D,MAAM;AACN;;AAEA;AACA,WAAW,8DAAe;AAC1B;AACA;AACA,0BAA0B,sDAAsD;AAChF;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAe;AAC1B;AACA;AACA;AACA;AACA;AACA,mEAAmE,uDAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAgB;AAC1C,WAAW,8DAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA,cAAc,2DAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC,0BAA0B;AAC1B,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,2DAAY;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAe;AAC1C,uBAAuB,8DAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,cAAc,gEAAU;AACxB,gCAAgC,mDAAQ,YAAY,mDAAQ;AAC5D;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAa,uBAAuB,mEAAa;AACvF;AACA;AACA;AACA,WAAW,8DAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wDAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAU,uCAAuC,+CAA+C;AACrH;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8DAAe;AACtE;AACA;AACA;AACA,qDAAqD,8DAAe;AACpE;AACA;AACA,uBAAuB,mEAAa;AACpC,eAAe,mEAAa;AAC5B,kCAAkC,mEAAa;AAC/C,iDAAiD,mEAAa;AAC9D;AACA;AACA;AACA;AACA,wBAAwB,8DAAe,6BAA6B,8DAAe;AACnF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA,eAAe,8DAAe;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,8DAAe;AACxE;AACA;AACA;AACA,uDAAuD,8DAAe;AACtE;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,6BAA6B,8CAA8C;AAC3E;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,6BAA6B,6DAA6D;AAC1F;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC,4BAA4B,aAAa,mCAAmC,uBAAuB;AACnG;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,kDAAkD,UAAU,KAAK,8DAAe;AAChF,4BAA4B,WAAW,8DAAe,sCAAsC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA,mBAAmB,gEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,uBAAuB,8DAAe;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,oBAAoB,8DAAe;AACnC;AACA,oBAAoB,8DAAe,SAAS,8DAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ,IAAI,WAAW,UAAU,SAAS,8DAAe;AACvF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+CAA+C,wDAAU;AACzD,KAAK;AACL;AACA;AACA;AACA,0BAA0B,wDAAU;AACpC,8CAA8C,wDAAU;AACxD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,kBAAkB,8DAAW,sCAAsC,mEAAa,WAAW,mEAAa;AACxG,wBAAwB,kDAAkD;AAC1E;AACA;AACA;AACA;AACA,oBAAoB,mEAAgB;AACpC;AACA;AACA;AACA,wBAAwB,mEAAgB;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,iBAAiB,WAAW,wCAAwC,mDAAI,eAAe;AACvF,mBAAmB,8DAAe;AAClC,KAAK;AACL,qCAAqC,0CAA0C;AAC/E;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gDAAgD,mEAAgB;AAChE,4CAA4C,mEAAgB;AAC5D,iBAAiB,WAAW,+EAA+E;AAC3G,mBAAmB,8DAAe;AAClC,KAAK;AACL;AACA;AACA,qCAAqC,mDAAmD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAuD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC,IAAI,2DAA2D;AAC3H;AACA,4BAA4B,8DAAe;AAC3C;AACA;AACA,2BAA2B,qCAAqC,IAAI,yDAAyD;AAC7H;AACA,4BAA4B,8DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAe;AAClC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mFAAmF;AAC9G;AACA,2BAA2B,iFAAiF;AAC5G;AACA,4BAA4B,4DAA4D;AACxF;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ,iEAAiE,UAAU;AAC7F;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,oEAAoE;AACxF;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C,qEAAqE,0CAA0C;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA,uBAAuB,kEAAkE;AACzF,mBAAmB,8DAAe;AAClC;AACA,KAAK,KAAK,0CAA0C;AACpD;AACA;AACA;AACA,qBAAqB,EAAE;AACvB,iBAAiB;AACjB,kBAAkB,gEAAU;AAC5B;AACA;AACA,qCAAqC,mDAAQ;AAC7C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,yBAAyB,+DAAa,UAAU,qDAAqD;AACrG,yBAAyB,oEAAc;AACvC;AACA,yBAAyB,8DAAW;AACpC;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,8BAA8B,kEAAY;AAC1C;AACA,4BAA4B,kEAAY;AACxC,qBAAqB,WAAW,kBAAkB,mDAAI,aAAa;AACnE,uBAAuB,8DAAe;AACtC,SAAS;AACT,yCAAyC,0CAA0C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mBAAmB,8DAAe;AAClC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,sBAAsB,+DAAa,UAAU;AAC7C;AACA;AACA,WAAW;AACX;AACA,qBAAqB,oEAAc;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAY;AAC/B;AACA;AACA,2BAA2B,2DAA2D;AACtF;AACA,KAAK;AACL;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,uBAAuB,qCAAqC,4DAAU,GAAG;AACzE,KAAK,KAAK,2BAA2B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAW;AAC7B,qBAAqB,kEAAY,0BAA0B,mEAAa;AACxE;AACA;AACA,uBAAuB,kFAAkF;AACzG,KAAK,KAAK,4BAA4B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA,4BAA4B,iBAAiB;AAC7C,0DAA0D,0CAA0C;AACpG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iFAAiF;AACvF,MAAM,6DAA6D;AACnE,MAAM,uDAAuD;AAC7D,MAAM,2DAA2D;AACjE,MAAM,6DAA6D;AACnE,MAAM,yDAAyD;AAC/D,MAAM,uCAAuC;AAC7C,MAAM,wCAAwC;AAC9C,MAAM,qCAAqC;AAC3C,MAAM,6CAA6C;AACnD,MAAM,+BAA+B;AACrC,MAAM,oCAAoC;AAC1C,MAAM,oCAAoC;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,oFAAoF;AAC1F,MAAM,gHAAgH;AACtH,MAAM,wGAAwG;AAC9G,MAAM,uFAAuF;AAC7F,MAAM,oHAAoH;AAC1H,MAAM,2GAA2G;AACjH,MAAM,8EAA8E;AACpF,MAAM,gEAAgE;AACtE,MAAM,6DAA6D;AACnE,MAAM,oFAAoF;AAC1F,MAAM,8DAA8D;AACpE,MAAM,mEAAmE;AACzE,MAAM,uDAAuD;AAC7D,MAAM,6DAA6D;AACnE,MAAM,uGAAuG;AAC7G,MAAM,6DAA6D;AACnE,MAAM,oGAAoG;AAC1G,MAAM,wDAAwD;AAC9D,MAAM,0EAA0E;AAChF,MAAM,8BAA8B;AACpC,MAAM,sEAAsE;AAC5E,MAAM,uCAAuC;AAC7C,MAAM,sEAAsE;AAC5E,MAAM,+DAA+D;AACrE,MAAM,uDAAuD;AAC7D,MAAM;AACN,mDAAmD,wCAAwC;AAC3F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,6FAA6F;AACnG,MAAM,iGAAiG;AACvG,MAAM,qCAAqC;AAC3C,MAAM,2CAA2C;AACjD,MAAM,yCAAyC;AAC/C,MAAM,+CAA+C;AACrD,MAAM,uCAAuC;AAC7C,MAAM,wCAAwC;AAC9C,MAAM,8CAA8C;AACpD,MAAM,6DAA6D;AACnE,MAAM,+BAA+B;AACrC,MAAM,+BAA+B;AACrC,MAAM,yCAAyC;AAC/C,MAAM,qCAAqC;AAC3C,MAAM,iDAAiD;AACvD,MAAM,kCAAkC;AACxC,MAAM,uCAAuC;AAC7C,MAAM,4DAA4D;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAEw5D&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/commands/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect, Text, findClusterBreak, countColumn, CharCategory } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import { EditorView, Direction } from '@codemirror/view';</span><span class="s3">\n</span><span class="s1">import { IndentContext, getIndentation, indentString, matchBrackets, syntaxTree, getIndentUnit, indentUnit } from '@codemirror/language';</span><span class="s3">\n</span><span class="s1">import { NodeProp } from '@lezer/common';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Comment or uncomment the current selection. Will use line comments</span><span class="s3">\n</span><span class="s1">if available, otherwise falling back to block comments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toggleComment = target =&gt; {</span><span class="s3">\n    </span><span class="s1">let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);</span><span class="s3">\n    </span><span class="s1">return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function command(f, option) {</span><span class="s3">\n    </span><span class="s1">return ({ state, dispatch }) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (state.readOnly)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let tr = f(option, state);</span><span class="s3">\n        </span><span class="s1">if (!tr)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">dispatch(state.update(tr));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Comment or uncomment the current selection using line comments.</span><span class="s3">\n</span><span class="s1">The line comment syntax is taken from the</span><span class="s3">\n</span><span class="s1">[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language</span><span class="s3">\n</span><span class="s1">data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Comment the current selection using line comments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Uncomment the current selection using line comments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Comment or uncomment the current selection using block comments.</span><span class="s3">\n</span><span class="s1">The block comment syntax is taken from the</span><span class="s3">\n</span><span class="s1">[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language</span><span class="s3">\n</span><span class="s1">data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Comment the current selection using block comments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Uncomment the current selection using block comments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Comment or uncomment the lines around the current selection using</span><span class="s3">\n</span><span class="s1">block comments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toggleBlockCommentByLine = /*@__PURE__*/command((o, s) =&gt; changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);</span><span class="s3">\n</span><span class="s1">function getConfig(state, pos) {</span><span class="s3">\n    </span><span class="s1">let data = state.languageDataAt(</span><span class="s3">\&quot;</span><span class="s1">commentTokens</span><span class="s3">\&quot;</span><span class="s1">, pos);</span><span class="s3">\n    </span><span class="s1">return data.length ? data[0] : {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const SearchMargin = 50;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Determines if the given range is block-commented in the given</span><span class="s3">\n</span><span class="s1">state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findBlockComment(state, { open, close }, from, to) {</span><span class="s3">\n    </span><span class="s1">let textBefore = state.sliceDoc(from - SearchMargin, from);</span><span class="s3">\n    </span><span class="s1">let textAfter = state.sliceDoc(to, to + SearchMargin);</span><span class="s3">\n    </span><span class="s1">let spaceBefore = /</span><span class="s3">\\</span><span class="s1">s*$/.exec(textBefore)[0].length, spaceAfter = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(textAfter)[0].length;</span><span class="s3">\n    </span><span class="s1">let beforeOff = textBefore.length - spaceBefore;</span><span class="s3">\n    </span><span class="s1">if (textBefore.slice(beforeOff - open.length, beforeOff) == open &amp;&amp;</span><span class="s3">\n        </span><span class="s1">textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {</span><span class="s3">\n        </span><span class="s1">return { open: { pos: from - spaceBefore, margin: spaceBefore &amp;&amp; 1 },</span><span class="s3">\n            </span><span class="s1">close: { pos: to + spaceAfter, margin: spaceAfter &amp;&amp; 1 } };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let startText, endText;</span><span class="s3">\n    </span><span class="s1">if (to - from &lt;= 2 * SearchMargin) {</span><span class="s3">\n        </span><span class="s1">startText = endText = state.sliceDoc(from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">startText = state.sliceDoc(from, from + SearchMargin);</span><span class="s3">\n        </span><span class="s1">endText = state.sliceDoc(to - SearchMargin, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let startSpace = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(startText)[0].length, endSpace = /</span><span class="s3">\\</span><span class="s1">s*$/.exec(endText)[0].length;</span><span class="s3">\n    </span><span class="s1">let endOff = endText.length - endSpace - close.length;</span><span class="s3">\n    </span><span class="s1">if (startText.slice(startSpace, startSpace + open.length) == open &amp;&amp;</span><span class="s3">\n        </span><span class="s1">endText.slice(endOff, endOff + close.length) == close) {</span><span class="s3">\n        </span><span class="s1">return { open: { pos: from + startSpace + open.length,</span><span class="s3">\n                </span><span class="s1">margin: /</span><span class="s3">\\</span><span class="s1">s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },</span><span class="s3">\n            </span><span class="s1">close: { pos: to - endSpace - close.length,</span><span class="s3">\n                </span><span class="s1">margin: /</span><span class="s3">\\</span><span class="s1">s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function selectedLineRanges(state) {</span><span class="s3">\n    </span><span class="s1">let ranges = [];</span><span class="s3">\n    </span><span class="s1">for (let r of state.selection.ranges) {</span><span class="s3">\n        </span><span class="s1">let fromLine = state.doc.lineAt(r.from);</span><span class="s3">\n        </span><span class="s1">let toLine = r.to &lt;= fromLine.to ? fromLine : state.doc.lineAt(r.to);</span><span class="s3">\n        </span><span class="s1">if (toLine.from &gt; fromLine.from &amp;&amp; toLine.from == r.to)</span><span class="s3">\n            </span><span class="s1">toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);</span><span class="s3">\n        </span><span class="s1">let last = ranges.length - 1;</span><span class="s3">\n        </span><span class="s1">if (last &gt;= 0 &amp;&amp; ranges[last].to &gt; fromLine.from)</span><span class="s3">\n            </span><span class="s1">ranges[last].to = toLine.to;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">ranges.push({ from: fromLine.from + /^</span><span class="s3">\\</span><span class="s1">s*/.exec(fromLine.text)[0].length, to: toLine.to });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Performs toggle, comment and uncomment of block comments in</span><span class="s3">\n</span><span class="s1">// languages that support them.</span><span class="s3">\n</span><span class="s1">function changeBlockComment(option, state, ranges = state.selection.ranges) {</span><span class="s3">\n    </span><span class="s1">let tokens = ranges.map(r =&gt; getConfig(state, r.from).block);</span><span class="s3">\n    </span><span class="s1">if (!tokens.every(c =&gt; c))</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let comments = ranges.map((r, i) =&gt; findBlockComment(state, tokens[i], r.from, r.to));</span><span class="s3">\n    </span><span class="s1">if (option != 2 /* CommentOption.Uncomment */ &amp;&amp; !comments.every(c =&gt; c)) {</span><span class="s3">\n        </span><span class="s1">return { changes: state.changes(ranges.map((range, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (comments[i])</span><span class="s3">\n                    </span><span class="s1">return [];</span><span class="s3">\n                </span><span class="s1">return [{ from: range.from, insert: tokens[i].open + </span><span class="s3">\&quot; \&quot; </span><span class="s1">}, { from: range.to, insert: </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ tokens[i].close }];</span><span class="s3">\n            </span><span class="s1">})) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (option != 1 /* CommentOption.Comment */ &amp;&amp; comments.some(c =&gt; c)) {</span><span class="s3">\n        </span><span class="s1">let changes = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0, comment; i &lt; comments.length; i++)</span><span class="s3">\n            </span><span class="s1">if (comment = comments[i]) {</span><span class="s3">\n                </span><span class="s1">let token = tokens[i], { open, close } = comment;</span><span class="s3">\n                </span><span class="s1">changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { changes };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Performs toggle, comment and uncomment of line comments.</span><span class="s3">\n</span><span class="s1">function changeLineComment(option, state, ranges = state.selection.ranges) {</span><span class="s3">\n    </span><span class="s1">let lines = [];</span><span class="s3">\n    </span><span class="s1">let prevLine = -1;</span><span class="s3">\n    </span><span class="s1">for (let { from, to } of ranges) {</span><span class="s3">\n        </span><span class="s1">let startI = lines.length, minIndent = 1e9;</span><span class="s3">\n        </span><span class="s1">let token = getConfig(state, from).line;</span><span class="s3">\n        </span><span class="s1">if (!token)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">for (let pos = from; pos &lt;= to;) {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.lineAt(pos);</span><span class="s3">\n            </span><span class="s1">if (line.from &gt; prevLine &amp;&amp; (from == to || to &gt; line.from)) {</span><span class="s3">\n                </span><span class="s1">prevLine = line.from;</span><span class="s3">\n                </span><span class="s1">let indent = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(line.text)[0].length;</span><span class="s3">\n                </span><span class="s1">let empty = indent == line.length;</span><span class="s3">\n                </span><span class="s1">let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;</span><span class="s3">\n                </span><span class="s1">if (indent &lt; line.text.length &amp;&amp; indent &lt; minIndent)</span><span class="s3">\n                    </span><span class="s1">minIndent = indent;</span><span class="s3">\n                </span><span class="s1">lines.push({ line, comment, token, indent, empty, single: false });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos = line.to + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (minIndent &lt; 1e9)</span><span class="s3">\n            </span><span class="s1">for (let i = startI; i &lt; lines.length; i++)</span><span class="s3">\n                </span><span class="s1">if (lines[i].indent &lt; lines[i].line.text.length)</span><span class="s3">\n                    </span><span class="s1">lines[i].indent = minIndent;</span><span class="s3">\n        </span><span class="s1">if (lines.length == startI + 1)</span><span class="s3">\n            </span><span class="s1">lines[startI].single = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (option != 2 /* CommentOption.Uncomment */ &amp;&amp; lines.some(l =&gt; l.comment &lt; 0 &amp;&amp; (!l.empty || l.single))) {</span><span class="s3">\n        </span><span class="s1">let changes = [];</span><span class="s3">\n        </span><span class="s1">for (let { line, token, indent, empty, single } of lines)</span><span class="s3">\n            </span><span class="s1">if (single || !empty)</span><span class="s3">\n                </span><span class="s1">changes.push({ from: line.from + indent, insert: token + </span><span class="s3">\&quot; \&quot; </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let changeSet = state.changes(changes);</span><span class="s3">\n        </span><span class="s1">return { changes: changeSet, selection: state.selection.map(changeSet, 1) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (option != 1 /* CommentOption.Comment */ &amp;&amp; lines.some(l =&gt; l.comment &gt;= 0)) {</span><span class="s3">\n        </span><span class="s1">let changes = [];</span><span class="s3">\n        </span><span class="s1">for (let { line, comment, token } of lines)</span><span class="s3">\n            </span><span class="s1">if (comment &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">let from = line.from + comment, to = from + token.length;</span><span class="s3">\n                </span><span class="s1">if (line.text[to - line.from] == </span><span class="s3">\&quot; \&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">to++;</span><span class="s3">\n                </span><span class="s1">changes.push({ from, to });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { changes };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const fromHistory = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Transaction annotation that will prevent that transaction from</span><span class="s3">\n</span><span class="s1">being combined with other transactions in the undo history. Given</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;</span><span class="s1">`, it'll prevent merging with previous transactions. With</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">`, subsequent transactions won't be combined with this</span><span class="s3">\n</span><span class="s1">one. With `</span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot;</span><span class="s1">`, the transaction is isolated on both sides.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const isolateHistory = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This facet provides a way to register functions that, given a</span><span class="s3">\n</span><span class="s1">transaction, provide a set of effects that the history should</span><span class="s3">\n</span><span class="s1">store when inverting the transaction. This can be used to</span><span class="s3">\n</span><span class="s1">integrate some kinds of effects in the history, so that they can</span><span class="s3">\n</span><span class="s1">be undone (and redone again).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const invertedEffects = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const historyConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(configs, {</span><span class="s3">\n            </span><span class="s1">minDepth: 100,</span><span class="s3">\n            </span><span class="s1">newGroupDelay: 500,</span><span class="s3">\n            </span><span class="s1">joinToEvent: (_t, isAdjacent) =&gt; isAdjacent,</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n            </span><span class="s1">minDepth: Math.max,</span><span class="s3">\n            </span><span class="s1">newGroupDelay: Math.min,</span><span class="s3">\n            </span><span class="s1">joinToEvent: (a, b) =&gt; (tr, adj) =&gt; a(tr, adj) || b(tr, adj)</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const historyField_ = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() {</span><span class="s3">\n        </span><span class="s1">return HistoryState.empty;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">update(state, tr) {</span><span class="s3">\n        </span><span class="s1">let config = tr.state.facet(historyConfig);</span><span class="s3">\n        </span><span class="s1">let fromHist = tr.annotation(fromHistory);</span><span class="s3">\n        </span><span class="s1">if (fromHist) {</span><span class="s3">\n            </span><span class="s1">let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;</span><span class="s3">\n            </span><span class="s1">let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;</span><span class="s3">\n            </span><span class="s1">if (item)</span><span class="s3">\n                </span><span class="s1">other = updateBranch(other, other.length, config.minDepth, item);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">other = addSelection(other, tr.startState.selection);</span><span class="s3">\n            </span><span class="s1">return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let isolate = tr.annotation(isolateHistory);</span><span class="s3">\n        </span><span class="s1">if (isolate == </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">|| isolate == </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">state = state.isolate();</span><span class="s3">\n        </span><span class="s1">if (tr.annotation(Transaction.addToHistory) === false)</span><span class="s3">\n            </span><span class="s1">return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;</span><span class="s3">\n        </span><span class="s1">let event = HistEvent.fromTransaction(tr);</span><span class="s3">\n        </span><span class="s1">let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);</span><span class="s3">\n        </span><span class="s1">if (event)</span><span class="s3">\n            </span><span class="s1">state = state.addChanges(event, time, userEvent, config, tr);</span><span class="s3">\n        </span><span class="s1">else if (tr.selection)</span><span class="s3">\n            </span><span class="s1">state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);</span><span class="s3">\n        </span><span class="s1">if (isolate == </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">|| isolate == </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">state = state.isolate();</span><span class="s3">\n        </span><span class="s1">return state;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">toJSON(value) {</span><span class="s3">\n        </span><span class="s1">return { done: value.done.map(e =&gt; e.toJSON()), undone: value.undone.map(e =&gt; e.toJSON()) };</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fromJSON(json) {</span><span class="s3">\n        </span><span class="s1">return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a history extension with the given configuration.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function history(config = {}) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">historyField_,</span><span class="s3">\n        </span><span class="s1">historyConfig.of(config),</span><span class="s3">\n        </span><span class="s1">EditorView.domEventHandlers({</span><span class="s3">\n            </span><span class="s1">beforeinput(e, view) {</span><span class="s3">\n                </span><span class="s1">let command = e.inputType == </span><span class="s3">\&quot;</span><span class="s1">historyUndo</span><span class="s3">\&quot; </span><span class="s1">? undo : e.inputType == </span><span class="s3">\&quot;</span><span class="s1">historyRedo</span><span class="s3">\&quot; </span><span class="s1">? redo : null;</span><span class="s3">\n                </span><span class="s1">if (!command)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">e.preventDefault();</span><span class="s3">\n                </span><span class="s1">return command(view);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The state field used to store the history data. Should probably</span><span class="s3">\n</span><span class="s1">only be used when you want to</span><span class="s3">\n</span><span class="s1">[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or</span><span class="s3">\n</span><span class="s1">[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way</span><span class="s3">\n</span><span class="s1">that preserves history.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const historyField = historyField_;</span><span class="s3">\n</span><span class="s1">function cmd(side, selection) {</span><span class="s3">\n    </span><span class="s1">return function ({ state, dispatch }) {</span><span class="s3">\n        </span><span class="s1">if (!selection &amp;&amp; state.readOnly)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let historyState = state.field(historyField_, false);</span><span class="s3">\n        </span><span class="s1">if (!historyState)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let tr = historyState.pop(side, state, selection);</span><span class="s3">\n        </span><span class="s1">if (!tr)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">dispatch(tr);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Undo a single group of history events. Returns false if no group</span><span class="s3">\n</span><span class="s1">was available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Redo a group of history events. Returns false if no group was</span><span class="s3">\n</span><span class="s1">available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Undo a change or selection change.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Redo a change or selection change.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);</span><span class="s3">\n</span><span class="s1">function depth(side) {</span><span class="s3">\n    </span><span class="s1">return function (state) {</span><span class="s3">\n        </span><span class="s1">let histState = state.field(historyField_, false);</span><span class="s3">\n        </span><span class="s1">if (!histState)</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;</span><span class="s3">\n        </span><span class="s1">return branch.length - (branch.length &amp;&amp; !branch[0].changes ? 1 : 0);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The amount of undoable change events available in a given state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The amount of redoable change events available in a given state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);</span><span class="s3">\n</span><span class="s1">// History events store groups of changes or effects that need to be</span><span class="s3">\n</span><span class="s1">// undone/redone together.</span><span class="s3">\n</span><span class="s1">class HistEvent {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">// The changes in this event. Normal events hold at least one</span><span class="s3">\n    </span><span class="s1">// change or effect. But it may be necessary to store selection</span><span class="s3">\n    </span><span class="s1">// events before the first change, in which case a special type of</span><span class="s3">\n    </span><span class="s1">// instance is created which doesn't hold any changes, with</span><span class="s3">\n    </span><span class="s1">// changes == startSelection == undefined</span><span class="s3">\n    </span><span class="s1">changes, </span><span class="s3">\n    </span><span class="s1">// The effects associated with this event</span><span class="s3">\n    </span><span class="s1">effects, </span><span class="s3">\n    </span><span class="s1">// Accumulated mapping (from addToHistory==false) that should be</span><span class="s3">\n    </span><span class="s1">// applied to events below this one.</span><span class="s3">\n    </span><span class="s1">mapped, </span><span class="s3">\n    </span><span class="s1">// The selection before this event</span><span class="s3">\n    </span><span class="s1">startSelection, </span><span class="s3">\n    </span><span class="s1">// Stores selection changes after this event, to be used for</span><span class="s3">\n    </span><span class="s1">// selection undo/redo.</span><span class="s3">\n    </span><span class="s1">selectionsAfter) {</span><span class="s3">\n        </span><span class="s1">this.changes = changes;</span><span class="s3">\n        </span><span class="s1">this.effects = effects;</span><span class="s3">\n        </span><span class="s1">this.mapped = mapped;</span><span class="s3">\n        </span><span class="s1">this.startSelection = startSelection;</span><span class="s3">\n        </span><span class="s1">this.selectionsAfter = selectionsAfter;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setSelAfter(after) {</span><span class="s3">\n        </span><span class="s1">return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),</span><span class="s3">\n            </span><span class="s1">mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),</span><span class="s3">\n            </span><span class="s1">startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),</span><span class="s3">\n            </span><span class="s1">selectionsAfter: this.selectionsAfter.map(s =&gt; s.toJSON())</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static fromJSON(json) {</span><span class="s3">\n        </span><span class="s1">return new HistEvent(json.changes &amp;&amp; ChangeSet.fromJSON(json.changes), [], json.mapped &amp;&amp; ChangeDesc.fromJSON(json.mapped), json.startSelection &amp;&amp; EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// This does not check `addToHistory` and such, it assumes the</span><span class="s3">\n    </span><span class="s1">// transaction needs to be converted to an item. Returns null when</span><span class="s3">\n    </span><span class="s1">// there are no changes or effects in the transaction.</span><span class="s3">\n    </span><span class="s1">static fromTransaction(tr, selection) {</span><span class="s3">\n        </span><span class="s1">let effects = none;</span><span class="s3">\n        </span><span class="s1">for (let invert of tr.startState.facet(invertedEffects)) {</span><span class="s3">\n            </span><span class="s1">let result = invert(tr);</span><span class="s3">\n            </span><span class="s1">if (result.length)</span><span class="s3">\n                </span><span class="s1">effects = effects.concat(result);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!effects.length &amp;&amp; tr.changes.empty)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static selection(selections) {</span><span class="s3">\n        </span><span class="s1">return new HistEvent(undefined, none, undefined, undefined, selections);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function updateBranch(branch, to, maxLen, newEvent) {</span><span class="s3">\n    </span><span class="s1">let start = to + 1 &gt; maxLen + 20 ? to - maxLen - 1 : 0;</span><span class="s3">\n    </span><span class="s1">let newBranch = branch.slice(start, to);</span><span class="s3">\n    </span><span class="s1">newBranch.push(newEvent);</span><span class="s3">\n    </span><span class="s1">return newBranch;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isAdjacent(a, b) {</span><span class="s3">\n    </span><span class="s1">let ranges = [], isAdjacent = false;</span><span class="s3">\n    </span><span class="s1">a.iterChangedRanges((f, t) =&gt; ranges.push(f, t));</span><span class="s3">\n    </span><span class="s1">b.iterChangedRanges((_f, _t, f, t) =&gt; {</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; ranges.length;) {</span><span class="s3">\n            </span><span class="s1">let from = ranges[i++], to = ranges[i++];</span><span class="s3">\n            </span><span class="s1">if (t &gt;= from &amp;&amp; f &lt;= to)</span><span class="s3">\n                </span><span class="s1">isAdjacent = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return isAdjacent;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function eqSelectionShape(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.ranges.length == b.ranges.length &amp;&amp;</span><span class="s3">\n        </span><span class="s1">a.ranges.filter((r, i) =&gt; r.empty != b.ranges[i].empty).length === 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function conc(a, b) {</span><span class="s3">\n    </span><span class="s1">return !a.length ? b : !b.length ? a : a.concat(b);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const none = [];</span><span class="s3">\n</span><span class="s1">const MaxSelectionsPerEvent = 200;</span><span class="s3">\n</span><span class="s1">function addSelection(branch, selection) {</span><span class="s3">\n    </span><span class="s1">if (!branch.length) {</span><span class="s3">\n        </span><span class="s1">return [HistEvent.selection([selection])];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let lastEvent = branch[branch.length - 1];</span><span class="s3">\n        </span><span class="s1">let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));</span><span class="s3">\n        </span><span class="s1">if (sels.length &amp;&amp; sels[sels.length - 1].eq(selection))</span><span class="s3">\n            </span><span class="s1">return branch;</span><span class="s3">\n        </span><span class="s1">sels.push(selection);</span><span class="s3">\n        </span><span class="s1">return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Assumes the top item has one or more selectionAfter values</span><span class="s3">\n</span><span class="s1">function popSelection(branch) {</span><span class="s3">\n    </span><span class="s1">let last = branch[branch.length - 1];</span><span class="s3">\n    </span><span class="s1">let newBranch = branch.slice();</span><span class="s3">\n    </span><span class="s1">newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));</span><span class="s3">\n    </span><span class="s1">return newBranch;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Add a mapping to the top event in the given branch. If this maps</span><span class="s3">\n</span><span class="s1">// away all the changes and effects in that item, drop it and</span><span class="s3">\n</span><span class="s1">// propagate the mapping to the next item.</span><span class="s3">\n</span><span class="s1">function addMappingToBranch(branch, mapping) {</span><span class="s3">\n    </span><span class="s1">if (!branch.length)</span><span class="s3">\n        </span><span class="s1">return branch;</span><span class="s3">\n    </span><span class="s1">let length = branch.length, selections = none;</span><span class="s3">\n    </span><span class="s1">while (length) {</span><span class="s3">\n        </span><span class="s1">let event = mapEvent(branch[length - 1], mapping, selections);</span><span class="s3">\n        </span><span class="s1">if (event.changes &amp;&amp; !event.changes.empty || event.effects.length) { // Event survived mapping</span><span class="s3">\n            </span><span class="s1">let result = branch.slice(0, length);</span><span class="s3">\n            </span><span class="s1">result[length - 1] = event;</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else { // Drop this event, since there's no changes or effects left</span><span class="s3">\n            </span><span class="s1">mapping = event.mapped;</span><span class="s3">\n            </span><span class="s1">length--;</span><span class="s3">\n            </span><span class="s1">selections = event.selectionsAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return selections.length ? [HistEvent.selection(selections)] : none;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapEvent(event, mapping, extraSelections) {</span><span class="s3">\n    </span><span class="s1">let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s =&gt; s.map(mapping)) : none, extraSelections);</span><span class="s3">\n    </span><span class="s1">// Change-less events don't store mappings (they are always the last event in a branch)</span><span class="s3">\n    </span><span class="s1">if (!event.changes)</span><span class="s3">\n        </span><span class="s1">return HistEvent.selection(selections);</span><span class="s3">\n    </span><span class="s1">let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);</span><span class="s3">\n    </span><span class="s1">let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;</span><span class="s3">\n    </span><span class="s1">return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const joinableUserEvent = /^(input</span><span class="s3">\\</span><span class="s1">.type|delete)($|</span><span class="s3">\\</span><span class="s1">.)/;</span><span class="s3">\n</span><span class="s1">class HistoryState {</span><span class="s3">\n    </span><span class="s1">constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {</span><span class="s3">\n        </span><span class="s1">this.done = done;</span><span class="s3">\n        </span><span class="s1">this.undone = undone;</span><span class="s3">\n        </span><span class="s1">this.prevTime = prevTime;</span><span class="s3">\n        </span><span class="s1">this.prevUserEvent = prevUserEvent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isolate() {</span><span class="s3">\n        </span><span class="s1">return this.prevTime ? new HistoryState(this.done, this.undone) : this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addChanges(event, time, userEvent, config, tr) {</span><span class="s3">\n        </span><span class="s1">let done = this.done, lastEvent = done[done.length - 1];</span><span class="s3">\n        </span><span class="s1">if (lastEvent &amp;&amp; lastEvent.changes &amp;&amp; !lastEvent.changes.empty &amp;&amp; event.changes &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(!userEvent || joinableUserEvent.test(userEvent)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">((!lastEvent.selectionsAfter.length &amp;&amp;</span><span class="s3">\n                </span><span class="s1">time - this.prevTime &lt; config.newGroupDelay &amp;&amp;</span><span class="s3">\n                </span><span class="s1">config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||</span><span class="s3">\n                </span><span class="s1">// For compose (but not compose.start) events, always join with previous event</span><span class="s3">\n                </span><span class="s1">userEvent == </span><span class="s3">\&quot;</span><span class="s1">input.type.compose</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">done = updateBranch(done, done.length, config.minDepth, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new HistoryState(done, none, time, userEvent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addSelection(selection, time, userEvent, newGroupDelay) {</span><span class="s3">\n        </span><span class="s1">let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;</span><span class="s3">\n        </span><span class="s1">if (last.length &gt; 0 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">time - this.prevTime &lt; newGroupDelay &amp;&amp;</span><span class="s3">\n            </span><span class="s1">userEvent == this.prevUserEvent &amp;&amp; userEvent &amp;&amp; /^select($|</span><span class="s3">\\</span><span class="s1">.)/.test(userEvent) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">eqSelectionShape(last[last.length - 1], selection))</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addMapping(mapping) {</span><span class="s3">\n        </span><span class="s1">return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">pop(side, state, onlySelection) {</span><span class="s3">\n        </span><span class="s1">let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;</span><span class="s3">\n        </span><span class="s1">if (branch.length == 0)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;</span><span class="s3">\n        </span><span class="s1">if (onlySelection &amp;&amp; event.selectionsAfter.length) {</span><span class="s3">\n            </span><span class="s1">return state.update({</span><span class="s3">\n                </span><span class="s1">selection: event.selectionsAfter[event.selectionsAfter.length - 1],</span><span class="s3">\n                </span><span class="s1">annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),</span><span class="s3">\n                </span><span class="s1">userEvent: side == 0 /* BranchName.Done */ ? </span><span class="s3">\&quot;</span><span class="s1">select.undo</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">select.redo</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">scrollIntoView: true</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!event.changes) {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);</span><span class="s3">\n            </span><span class="s1">if (event.mapped)</span><span class="s3">\n                </span><span class="s1">rest = addMappingToBranch(rest, event.mapped);</span><span class="s3">\n            </span><span class="s1">return state.update({</span><span class="s3">\n                </span><span class="s1">changes: event.changes,</span><span class="s3">\n                </span><span class="s1">selection: event.startSelection,</span><span class="s3">\n                </span><span class="s1">effects: event.effects,</span><span class="s3">\n                </span><span class="s1">annotations: fromHistory.of({ side, rest, selection }),</span><span class="s3">\n                </span><span class="s1">filter: false,</span><span class="s3">\n                </span><span class="s1">userEvent: side == 0 /* BranchName.Done */ ? </span><span class="s3">\&quot;</span><span class="s1">undo</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">redo</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">scrollIntoView: true</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">HistoryState.empty = /*@__PURE__*/new HistoryState(none, none);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Default key bindings for the undo history.</span><span class="s3">\n\n</span><span class="s1">- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).</span><span class="s3">\n</span><span class="s1">- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).</span><span class="s3">\n</span><span class="s1">- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).</span><span class="s3">\n</span><span class="s1">- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const historyKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-z</span><span class="s3">\&quot;</span><span class="s1">, run: undo, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-y</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Mod-Shift-z</span><span class="s3">\&quot;</span><span class="s1">, run: redo, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ linux: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Shift-z</span><span class="s3">\&quot;</span><span class="s1">, run: redo, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-u</span><span class="s3">\&quot;</span><span class="s1">, run: undoSelection, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-u</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Mod-Shift-u</span><span class="s3">\&quot;</span><span class="s1">, run: redoSelection, preventDefault: true }</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">function updateSel(sel, by) {</span><span class="s3">\n    </span><span class="s1">return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function setSel(state, selection) {</span><span class="s3">\n    </span><span class="s1">return state.update({ selection, scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveSel({ state, dispatch }, how) {</span><span class="s3">\n    </span><span class="s1">let selection = updateSel(state.selection, how);</span><span class="s3">\n    </span><span class="s1">if (selection.eq(state.selection, true))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, selection));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function rangeEnd(range, forward) {</span><span class="s3">\n    </span><span class="s1">return EditorSelection.cursor(forward ? range.to : range.from);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cursorByChar(view, forward) {</span><span class="s3">\n    </span><span class="s1">return moveSel(view, range =&gt; range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ltrAtCursor(view) {</span><span class="s3">\n    </span><span class="s1">return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one character to the left (which is backward in</span><span class="s3">\n</span><span class="s1">left-to-right text, forward in right-to-left text).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorCharLeft = view =&gt; cursorByChar(view, !ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one character to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorCharRight = view =&gt; cursorByChar(view, ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one character forward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorCharForward = view =&gt; cursorByChar(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one character backward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorCharBackward = view =&gt; cursorByChar(view, false);</span><span class="s3">\n</span><span class="s1">function byCharLogical(state, range, forward) {</span><span class="s3">\n    </span><span class="s1">let pos = range.head, line = state.doc.lineAt(pos);</span><span class="s3">\n    </span><span class="s1">if (pos == (forward ? line.to : line.from))</span><span class="s3">\n        </span><span class="s1">pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">pos = line.from + findClusterBreak(line.text, pos - line.from, forward);</span><span class="s3">\n    </span><span class="s1">return EditorSelection.cursor(pos, forward ? -1 : 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveByCharLogical(target, forward) {</span><span class="s3">\n    </span><span class="s1">return moveSel(target, range =&gt; range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one character forward, in logical</span><span class="s3">\n</span><span class="s1">(non-text-direction-aware) string index order.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorCharForwardLogical = target =&gt; moveByCharLogical(target, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one character backward, in logical string index</span><span class="s3">\n</span><span class="s1">order.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorCharBackwardLogical = target =&gt; moveByCharLogical(target, false);</span><span class="s3">\n</span><span class="s1">function cursorByGroup(view, forward) {</span><span class="s3">\n    </span><span class="s1">return moveSel(view, range =&gt; range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the left across one group of word or</span><span class="s3">\n</span><span class="s1">non-word (but also non-space) characters.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorGroupLeft = view =&gt; cursorByGroup(view, !ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one group to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorGroupRight = view =&gt; cursorByGroup(view, ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one group forward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorGroupForward = view =&gt; cursorByGroup(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one group backward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorGroupBackward = view =&gt; cursorByGroup(view, false);</span><span class="s3">\n</span><span class="s1">const segmenter = typeof Intl != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; Intl.Segmenter ?</span><span class="s3">\n    </span><span class="s1">/*@__PURE__*/new (Intl.Segmenter)(undefined, { granularity: </span><span class="s3">\&quot;</span><span class="s1">word</span><span class="s3">\&quot; </span><span class="s1">}) : null;</span><span class="s3">\n</span><span class="s1">function moveBySubword(view, range, forward) {</span><span class="s3">\n    </span><span class="s1">let categorize = view.state.charCategorizer(range.from);</span><span class="s3">\n    </span><span class="s1">let cat = CharCategory.Space, pos = range.from, steps = 0;</span><span class="s3">\n    </span><span class="s1">let done = false, sawUpper = false, sawLower = false;</span><span class="s3">\n    </span><span class="s1">let step = (next) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (done)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">pos += forward ? next.length : -next.length;</span><span class="s3">\n        </span><span class="s1">let nextCat = categorize(next), ahead;</span><span class="s3">\n        </span><span class="s1">if (nextCat == CharCategory.Word &amp;&amp; next.charCodeAt(0) &lt; 128 &amp;&amp; /[</span><span class="s3">\\</span><span class="s1">W_]/.test(next))</span><span class="s3">\n            </span><span class="s1">nextCat = -1; // Treat word punctuation specially</span><span class="s3">\n        </span><span class="s1">if (cat == CharCategory.Space)</span><span class="s3">\n            </span><span class="s1">cat = nextCat;</span><span class="s3">\n        </span><span class="s1">if (cat != nextCat)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (cat == CharCategory.Word) {</span><span class="s3">\n            </span><span class="s1">if (next.toLowerCase() == next) {</span><span class="s3">\n                </span><span class="s1">if (!forward &amp;&amp; sawUpper)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">sawLower = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (sawLower) {</span><span class="s3">\n                </span><span class="s1">if (forward)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">done = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (sawUpper &amp;&amp; forward &amp;&amp; categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">ahead.toLowerCase() == ahead)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">sawUpper = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">steps++;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">let end = view.moveByChar(range, forward, start =&gt; {</span><span class="s3">\n        </span><span class="s1">step(start);</span><span class="s3">\n        </span><span class="s1">return step;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (segmenter &amp;&amp; cat == CharCategory.Word &amp;&amp; end.from == range.from + steps * (forward ? 1 : -1)) {</span><span class="s3">\n        </span><span class="s1">let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);</span><span class="s3">\n        </span><span class="s1">let skipped = view.state.sliceDoc(from, to);</span><span class="s3">\n        </span><span class="s1">if (skipped.length &gt; 1 &amp;&amp; /[</span><span class="s3">\\</span><span class="s1">u4E00-</span><span class="s3">\\</span><span class="s1">uffff]/.test(skipped)) {</span><span class="s3">\n            </span><span class="s1">let segments = Array.from(segmenter.segment(skipped));</span><span class="s3">\n            </span><span class="s1">if (segments.length &gt; 1) {</span><span class="s3">\n                </span><span class="s1">if (forward)</span><span class="s3">\n                    </span><span class="s1">return EditorSelection.cursor(range.head + segments[1].index, -1);</span><span class="s3">\n                </span><span class="s1">return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return end;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cursorBySubword(view, forward) {</span><span class="s3">\n    </span><span class="s1">return moveSel(view, range =&gt; range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one group or camel-case subword forward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorSubwordForward = view =&gt; cursorBySubword(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one group or camel-case subword backward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorSubwordBackward = view =&gt; cursorBySubword(view, false);</span><span class="s3">\n</span><span class="s1">function interestingNode(state, node, bracketProp) {</span><span class="s3">\n    </span><span class="s1">if (node.type.prop(bracketProp))</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">let len = node.to - node.from;</span><span class="s3">\n    </span><span class="s1">return len &amp;&amp; (len &gt; 2 || /[^</span><span class="s3">\\</span><span class="s1">s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveBySyntax(state, start, forward) {</span><span class="s3">\n    </span><span class="s1">let pos = syntaxTree(state).resolveInner(start.head);</span><span class="s3">\n    </span><span class="s1">let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;</span><span class="s3">\n    </span><span class="s1">// Scan forward through child nodes to see if there's an interesting</span><span class="s3">\n    </span><span class="s1">// node ahead.</span><span class="s3">\n    </span><span class="s1">for (let at = start.head;;) {</span><span class="s3">\n        </span><span class="s1">let next = forward ? pos.childAfter(at) : pos.childBefore(at);</span><span class="s3">\n        </span><span class="s1">if (!next)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (interestingNode(state, next, bracketProp))</span><span class="s3">\n            </span><span class="s1">pos = next;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">at = forward ? next.to : next.from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let bracket = pos.type.prop(bracketProp), match, newPos;</span><span class="s3">\n    </span><span class="s1">if (bracket &amp;&amp; (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) &amp;&amp; match.matched)</span><span class="s3">\n        </span><span class="s1">newPos = forward ? match.end.to : match.end.from;</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">newPos = forward ? pos.to : pos.from;</span><span class="s3">\n    </span><span class="s1">return EditorSelection.cursor(newPos, forward ? -1 : 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the cursor over the next syntactic element to the left.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorSyntaxLeft = view =&gt; moveSel(view, range =&gt; moveBySyntax(view.state, range, !ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the cursor over the next syntactic element to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorSyntaxRight = view =&gt; moveSel(view, range =&gt; moveBySyntax(view.state, range, ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">function cursorByLine(view, forward) {</span><span class="s3">\n    </span><span class="s1">return moveSel(view, range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!range.empty)</span><span class="s3">\n            </span><span class="s1">return rangeEnd(range, forward);</span><span class="s3">\n        </span><span class="s1">let moved = view.moveVertically(range, forward);</span><span class="s3">\n        </span><span class="s1">return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one line up.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineUp = view =&gt; cursorByLine(view, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one line down.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineDown = view =&gt; cursorByLine(view, true);</span><span class="s3">\n</span><span class="s1">function pageInfo(view) {</span><span class="s3">\n    </span><span class="s1">let selfScroll = view.scrollDOM.clientHeight &lt; view.scrollDOM.scrollHeight - 2;</span><span class="s3">\n    </span><span class="s1">let marginTop = 0, marginBottom = 0, height;</span><span class="s3">\n    </span><span class="s1">if (selfScroll) {</span><span class="s3">\n        </span><span class="s1">for (let source of view.state.facet(EditorView.scrollMargins)) {</span><span class="s3">\n            </span><span class="s1">let margins = source(view);</span><span class="s3">\n            </span><span class="s1">if (margins === null || margins === void 0 ? void 0 : margins.top)</span><span class="s3">\n                </span><span class="s1">marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);</span><span class="s3">\n            </span><span class="s1">if (margins === null || margins === void 0 ? void 0 : margins.bottom)</span><span class="s3">\n                </span><span class="s1">marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">height = view.scrollDOM.clientHeight - marginTop - marginBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">height = (view.dom.ownerDocument.defaultView || window).innerHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { marginTop, marginBottom, selfScroll,</span><span class="s3">\n        </span><span class="s1">height: Math.max(view.defaultLineHeight, height - 5) };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cursorByPage(view, forward) {</span><span class="s3">\n    </span><span class="s1">let page = pageInfo(view);</span><span class="s3">\n    </span><span class="s1">let { state } = view, selection = updateSel(state.selection, range =&gt; {</span><span class="s3">\n        </span><span class="s1">return range.empty ? view.moveVertically(range, forward, page.height)</span><span class="s3">\n            </span><span class="s1">: rangeEnd(range, forward);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (selection.eq(state.selection))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let effect;</span><span class="s3">\n    </span><span class="s1">if (page.selfScroll) {</span><span class="s3">\n        </span><span class="s1">let startPos = view.coordsAtPos(state.selection.main.head);</span><span class="s3">\n        </span><span class="s1">let scrollRect = view.scrollDOM.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;</span><span class="s3">\n        </span><span class="s1">if (startPos &amp;&amp; startPos.top &gt; scrollTop &amp;&amp; startPos.bottom &lt; scrollBottom)</span><span class="s3">\n            </span><span class="s1">effect = EditorView.scrollIntoView(selection.main.head, { y: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, yMargin: startPos.top - scrollTop });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">view.dispatch(setSel(state, selection), { effects: effect });</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one page up.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorPageUp = view =&gt; cursorByPage(view, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one page down.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorPageDown = view =&gt; cursorByPage(view, true);</span><span class="s3">\n</span><span class="s1">function moveByLineBoundary(view, start, forward) {</span><span class="s3">\n    </span><span class="s1">let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);</span><span class="s3">\n    </span><span class="s1">if (moved.head == start.head &amp;&amp; moved.head != (forward ? line.to : line.from))</span><span class="s3">\n        </span><span class="s1">moved = view.moveToLineBoundary(start, forward, false);</span><span class="s3">\n    </span><span class="s1">if (!forward &amp;&amp; moved.head == line.from &amp;&amp; line.length) {</span><span class="s3">\n        </span><span class="s1">let space = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;</span><span class="s3">\n        </span><span class="s1">if (space &amp;&amp; start.head != line.from + space)</span><span class="s3">\n            </span><span class="s1">moved = EditorSelection.cursor(line.from + space);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return moved;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the next line wrap point, or to the end of</span><span class="s3">\n</span><span class="s1">the line if there isn't one left on this line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineBoundaryForward = view =&gt; moveSel(view, range =&gt; moveByLineBoundary(view, range, true));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to previous line wrap point, or failing that to</span><span class="s3">\n</span><span class="s1">the start of the line. If the line is indented, and the cursor</span><span class="s3">\n</span><span class="s1">isn't already at the end of the indentation, this will move to the</span><span class="s3">\n</span><span class="s1">end of the indentation instead of the start of the line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineBoundaryBackward = view =&gt; moveSel(view, range =&gt; moveByLineBoundary(view, range, false));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one line wrap point to the left.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineBoundaryLeft = view =&gt; moveSel(view, range =&gt; moveByLineBoundary(view, range, !ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection one line wrap point to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineBoundaryRight = view =&gt; moveSel(view, range =&gt; moveByLineBoundary(view, range, ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the start of the line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineStart = view =&gt; moveSel(view, range =&gt; EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the end of the line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorLineEnd = view =&gt; moveSel(view, range =&gt; EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));</span><span class="s3">\n</span><span class="s1">function toMatchingBracket(state, dispatch, extend) {</span><span class="s3">\n    </span><span class="s1">let found = false, selection = updateSel(state.selection, range =&gt; {</span><span class="s3">\n        </span><span class="s1">let matching = matchBrackets(state, range.head, -1)</span><span class="s3">\n            </span><span class="s1">|| matchBrackets(state, range.head, 1)</span><span class="s3">\n            </span><span class="s1">|| (range.head &gt; 0 &amp;&amp; matchBrackets(state, range.head - 1, 1))</span><span class="s3">\n            </span><span class="s1">|| (range.head &lt; state.doc.length &amp;&amp; matchBrackets(state, range.head + 1, -1));</span><span class="s3">\n        </span><span class="s1">if (!matching || !matching.end)</span><span class="s3">\n            </span><span class="s1">return range;</span><span class="s3">\n        </span><span class="s1">found = true;</span><span class="s3">\n        </span><span class="s1">let head = matching.start.from == range.head ? matching.end.to : matching.end.from;</span><span class="s3">\n        </span><span class="s1">return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!found)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, selection));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the bracket matching the one it is currently</span><span class="s3">\n</span><span class="s1">on, if any.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorMatchingBracket = ({ state, dispatch }) =&gt; toMatchingBracket(state, dispatch, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Extend the selection to the bracket matching the one the selection</span><span class="s3">\n</span><span class="s1">head is currently on, if any.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectMatchingBracket = ({ state, dispatch }) =&gt; toMatchingBracket(state, dispatch, true);</span><span class="s3">\n</span><span class="s1">function extendSel(target, how) {</span><span class="s3">\n    </span><span class="s1">let selection = updateSel(target.state.selection, range =&gt; {</span><span class="s3">\n        </span><span class="s1">let head = how(range);</span><span class="s3">\n        </span><span class="s1">return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (selection.eq(target.state.selection))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">target.dispatch(setSel(target.state, selection));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function selectByChar(view, forward) {</span><span class="s3">\n    </span><span class="s1">return extendSel(view, range =&gt; view.moveByChar(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one character to the left, while leaving</span><span class="s3">\n</span><span class="s1">the anchor in place.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectCharLeft = view =&gt; selectByChar(view, !ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one character to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectCharRight = view =&gt; selectByChar(view, ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one character forward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectCharForward = view =&gt; selectByChar(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one character backward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectCharBackward = view =&gt; selectByChar(view, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one character forward by logical</span><span class="s3">\n</span><span class="s1">(non-direction aware) string index order.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectCharForwardLogical = target =&gt; extendSel(target, range =&gt; byCharLogical(target.state, range, true));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one character backward by logical string</span><span class="s3">\n</span><span class="s1">index order.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectCharBackwardLogical = target =&gt; extendSel(target, range =&gt; byCharLogical(target.state, range, false));</span><span class="s3">\n</span><span class="s1">function selectByGroup(view, forward) {</span><span class="s3">\n    </span><span class="s1">return extendSel(view, range =&gt; view.moveByGroup(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to</span><span class="s3">\n</span><span class="s1">the left.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectGroupLeft = view =&gt; selectByGroup(view, !ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one group to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectGroupRight = view =&gt; selectByGroup(view, ltrAtCursor(view));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one group forward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectGroupForward = view =&gt; selectByGroup(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one group backward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectGroupBackward = view =&gt; selectByGroup(view, false);</span><span class="s3">\n</span><span class="s1">function selectBySubword(view, forward) {</span><span class="s3">\n    </span><span class="s1">return extendSel(view, range =&gt; moveBySubword(view, range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one group or camel-case subword forward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectSubwordForward = view =&gt; selectBySubword(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one group or subword backward.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectSubwordBackward = view =&gt; selectBySubword(view, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head over the next syntactic element to the left.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectSyntaxLeft = view =&gt; extendSel(view, range =&gt; moveBySyntax(view.state, range, !ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head over the next syntactic element to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectSyntaxRight = view =&gt; extendSel(view, range =&gt; moveBySyntax(view.state, range, ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">function selectByLine(view, forward) {</span><span class="s3">\n    </span><span class="s1">return extendSel(view, range =&gt; view.moveVertically(range, forward));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one line up.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineUp = view =&gt; selectByLine(view, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one line down.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineDown = view =&gt; selectByLine(view, true);</span><span class="s3">\n</span><span class="s1">function selectByPage(view, forward) {</span><span class="s3">\n    </span><span class="s1">return extendSel(view, range =&gt; view.moveVertically(range, forward, pageInfo(view).height));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one page up.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectPageUp = view =&gt; selectByPage(view, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one page down.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectPageDown = view =&gt; selectByPage(view, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head to the next line boundary.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineBoundaryForward = view =&gt; extendSel(view, range =&gt; moveByLineBoundary(view, range, true));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head to the previous line boundary.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineBoundaryBackward = view =&gt; extendSel(view, range =&gt; moveByLineBoundary(view, range, false));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one line boundary to the left.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineBoundaryLeft = view =&gt; extendSel(view, range =&gt; moveByLineBoundary(view, range, !ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head one line boundary to the right.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineBoundaryRight = view =&gt; extendSel(view, range =&gt; moveByLineBoundary(view, range, ltrAtCursor(view)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head to the start of the line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineStart = view =&gt; extendSel(view, range =&gt; EditorSelection.cursor(view.lineBlockAt(range.head).from));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head to the end of the line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLineEnd = view =&gt; extendSel(view, range =&gt; EditorSelection.cursor(view.lineBlockAt(range.head).to));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the start of the document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorDocStart = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, { anchor: 0 }));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the end of the document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cursorDocEnd = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, { anchor: state.doc.length }));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head to the start of the document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectDocStart = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection head to the end of the document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectDocEnd = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Select the entire document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectAll = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: </span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Expand the selection to cover entire lines.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectLine = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let ranges = selectedLineBlocks(state).map(({ from, to }) =&gt; EditorSelection.range(from, Math.min(to + 1, state.doc.length)));</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: </span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Select the next syntactic construct that is larger than the</span><span class="s3">\n</span><span class="s1">selection. Note that this will only work insofar as the language</span><span class="s3">\n</span><span class="s1">[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full</span><span class="s3">\n</span><span class="s1">syntax tree.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectParentSyntax = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let selection = updateSel(state.selection, range =&gt; {</span><span class="s3">\n        </span><span class="s1">let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);</span><span class="s3">\n        </span><span class="s1">if (range.empty) {</span><span class="s3">\n            </span><span class="s1">let stackBefore = tree.resolveStack(range.from, -1);</span><span class="s3">\n            </span><span class="s1">if (stackBefore.node.from &gt;= stack.node.from &amp;&amp; stackBefore.node.to &lt;= stack.node.to)</span><span class="s3">\n                </span><span class="s1">stack = stackBefore;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let cur = stack; cur; cur = cur.next) {</span><span class="s3">\n            </span><span class="s1">let { node } = cur;</span><span class="s3">\n            </span><span class="s1">if (((node.from &lt; range.from &amp;&amp; node.to &gt;= range.to) ||</span><span class="s3">\n                </span><span class="s1">(node.to &gt; range.to &amp;&amp; node.from &lt;= range.from)) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">cur.next)</span><span class="s3">\n                </span><span class="s1">return EditorSelection.range(node.to, node.from);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return range;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (selection.eq(state.selection))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, selection));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Simplify the current selection. When multiple ranges are selected,</span><span class="s3">\n</span><span class="s1">reduce it to its main range. Otherwise, if the selection is</span><span class="s3">\n</span><span class="s1">non-empty, convert it to a cursor selection.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const simplifySelection = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let cur = state.selection, selection = null;</span><span class="s3">\n    </span><span class="s1">if (cur.ranges.length &gt; 1)</span><span class="s3">\n        </span><span class="s1">selection = EditorSelection.create([cur.main]);</span><span class="s3">\n    </span><span class="s1">else if (!cur.main.empty)</span><span class="s3">\n        </span><span class="s1">selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);</span><span class="s3">\n    </span><span class="s1">if (!selection)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(setSel(state, selection));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function deleteBy(target, by) {</span><span class="s3">\n    </span><span class="s1">if (target.state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let event = </span><span class="s3">\&quot;</span><span class="s1">delete.selection</span><span class="s3">\&quot;</span><span class="s1">, { state } = target;</span><span class="s3">\n    </span><span class="s1">let changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">let { from, to } = range;</span><span class="s3">\n        </span><span class="s1">if (from == to) {</span><span class="s3">\n            </span><span class="s1">let towards = by(range);</span><span class="s3">\n            </span><span class="s1">if (towards &lt; from) {</span><span class="s3">\n                </span><span class="s1">event = </span><span class="s3">\&quot;</span><span class="s1">delete.backward</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">towards = skipAtomic(target, towards, false);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (towards &gt; from) {</span><span class="s3">\n                </span><span class="s1">event = </span><span class="s3">\&quot;</span><span class="s1">delete.forward</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">towards = skipAtomic(target, towards, true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">from = Math.min(from, towards);</span><span class="s3">\n            </span><span class="s1">to = Math.max(to, towards);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">from = skipAtomic(target, from, false);</span><span class="s3">\n            </span><span class="s1">to = skipAtomic(target, to, true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from &lt; range.head ? -1 : 1) };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (changes.changes.empty)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">target.dispatch(state.update(changes, {</span><span class="s3">\n        </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n        </span><span class="s1">userEvent: event,</span><span class="s3">\n        </span><span class="s1">effects: event == </span><span class="s3">\&quot;</span><span class="s1">delete.selection</span><span class="s3">\&quot; </span><span class="s1">? EditorView.announce.of(state.phrase(</span><span class="s3">\&quot;</span><span class="s1">Selection deleted</span><span class="s3">\&quot;</span><span class="s1">)) : undefined</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function skipAtomic(target, pos, forward) {</span><span class="s3">\n    </span><span class="s1">if (target instanceof EditorView)</span><span class="s3">\n        </span><span class="s1">for (let ranges of target.state.facet(EditorView.atomicRanges).map(f =&gt; f(target)))</span><span class="s3">\n            </span><span class="s1">ranges.between(pos, pos, (from, to) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (from &lt; pos &amp;&amp; to &gt; pos)</span><span class="s3">\n                    </span><span class="s1">pos = forward ? to : from;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const deleteByChar = (target, forward, byIndentUnit) =&gt; deleteBy(target, range =&gt; {</span><span class="s3">\n    </span><span class="s1">let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;</span><span class="s3">\n    </span><span class="s1">if (byIndentUnit &amp;&amp; !forward &amp;&amp; pos &gt; line.from &amp;&amp; pos &lt; line.from + 200 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!/[^ </span><span class="s3">\\</span><span class="s1">t]/.test(before = line.text.slice(0, pos - line.from))) {</span><span class="s3">\n        </span><span class="s1">if (before[before.length - 1] == </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return pos - 1;</span><span class="s3">\n        </span><span class="s1">let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; drop &amp;&amp; before[before.length - 1 - i] == </span><span class="s3">\&quot; \&quot;</span><span class="s1">; i++)</span><span class="s3">\n            </span><span class="s1">pos--;</span><span class="s3">\n        </span><span class="s1">targetPos = pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;</span><span class="s3">\n        </span><span class="s1">if (targetPos == pos &amp;&amp; line.number != (forward ? state.doc.lines : 1))</span><span class="s3">\n            </span><span class="s1">targetPos += forward ? 1 : -1;</span><span class="s3">\n        </span><span class="s1">else if (!forward &amp;&amp; /[</span><span class="s3">\\</span><span class="s1">ufe00-</span><span class="s3">\\</span><span class="s1">ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))</span><span class="s3">\n            </span><span class="s1">targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return targetPos;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection, or, for cursor selections, the character or</span><span class="s3">\n</span><span class="s1">indentation unit before the cursor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteCharBackward = view =&gt; deleteByChar(view, false, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection or the character before the cursor. Does not</span><span class="s3">\n</span><span class="s1">implement any extended behavior like deleting whole indentation</span><span class="s3">\n</span><span class="s1">units in one go.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteCharBackwardStrict = view =&gt; deleteByChar(view, false, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection or the character after the cursor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteCharForward = view =&gt; deleteByChar(view, true, false);</span><span class="s3">\n</span><span class="s1">const deleteByGroup = (target, forward) =&gt; deleteBy(target, range =&gt; {</span><span class="s3">\n    </span><span class="s1">let pos = range.head, { state } = target, line = state.doc.lineAt(pos);</span><span class="s3">\n    </span><span class="s1">let categorize = state.charCategorizer(pos);</span><span class="s3">\n    </span><span class="s1">for (let cat = null;;) {</span><span class="s3">\n        </span><span class="s1">if (pos == (forward ? line.to : line.from)) {</span><span class="s3">\n            </span><span class="s1">if (pos == range.head &amp;&amp; line.number != (forward ? state.doc.lines : 1))</span><span class="s3">\n                </span><span class="s1">pos += forward ? 1 : -1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;</span><span class="s3">\n        </span><span class="s1">let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);</span><span class="s3">\n        </span><span class="s1">let nextCat = categorize(nextChar);</span><span class="s3">\n        </span><span class="s1">if (cat != null &amp;&amp; nextCat != cat)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (nextChar != </span><span class="s3">\&quot; \&quot; </span><span class="s1">|| pos != range.head)</span><span class="s3">\n            </span><span class="s1">cat = nextCat;</span><span class="s3">\n        </span><span class="s1">pos = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection or backward until the end of the next</span><span class="s3">\n</span><span class="s1">[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of</span><span class="s3">\n</span><span class="s1">whitespace when they consist of a single space.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteGroupBackward = target =&gt; deleteByGroup(target, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection or forward until the end of the next group.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteGroupForward = target =&gt; deleteByGroup(target, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection, or, if it is a cursor selection, delete to</span><span class="s3">\n</span><span class="s1">the end of the line. If the cursor is directly at the end of the</span><span class="s3">\n</span><span class="s1">line, delete the line break after it.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteToLineEnd = view =&gt; deleteBy(view, range =&gt; {</span><span class="s3">\n    </span><span class="s1">let lineEnd = view.lineBlockAt(range.head).to;</span><span class="s3">\n    </span><span class="s1">return range.head &lt; lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection, or, if it is a cursor selection, delete to</span><span class="s3">\n</span><span class="s1">the start of the line. If the cursor is directly at the start of the</span><span class="s3">\n</span><span class="s1">line, delete the line break before it.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteToLineStart = view =&gt; deleteBy(view, range =&gt; {</span><span class="s3">\n    </span><span class="s1">let lineStart = view.lineBlockAt(range.head).from;</span><span class="s3">\n    </span><span class="s1">return range.head &gt; lineStart ? lineStart : Math.max(0, range.head - 1);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection, or, if it is a cursor selection, delete to</span><span class="s3">\n</span><span class="s1">the start of the line or the next line wrap before the cursor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteLineBoundaryBackward = view =&gt; deleteBy(view, range =&gt; {</span><span class="s3">\n    </span><span class="s1">let lineStart = view.moveToLineBoundary(range, false).head;</span><span class="s3">\n    </span><span class="s1">return range.head &gt; lineStart ? lineStart : Math.max(0, range.head - 1);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete the selection, or, if it is a cursor selection, delete to</span><span class="s3">\n</span><span class="s1">the end of the line or the next line wrap after the cursor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteLineBoundaryForward = view =&gt; deleteBy(view, range =&gt; {</span><span class="s3">\n    </span><span class="s1">let lineStart = view.moveToLineBoundary(range, true).head;</span><span class="s3">\n    </span><span class="s1">return range.head &lt; lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete all whitespace directly before a line end from the</span><span class="s3">\n</span><span class="s1">document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteTrailingWhitespace = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let changes = [];</span><span class="s3">\n    </span><span class="s1">for (let pos = 0, prev = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, iter = state.doc.iter();;) {</span><span class="s3">\n        </span><span class="s1">iter.next();</span><span class="s3">\n        </span><span class="s1">if (iter.lineBreak || iter.done) {</span><span class="s3">\n            </span><span class="s1">let trailing = prev.search(/</span><span class="s3">\\</span><span class="s1">s+$/);</span><span class="s3">\n            </span><span class="s1">if (trailing &gt; -1)</span><span class="s3">\n                </span><span class="s1">changes.push({ from: pos - (prev.length - trailing), to: pos });</span><span class="s3">\n            </span><span class="s1">if (iter.done)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">prev = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">prev = iter.value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pos += iter.value.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!changes.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({ changes, userEvent: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Replace each selection range with a line break, leaving the cursor</span><span class="s3">\n</span><span class="s1">on the line before the break.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const splitLine = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">return { changes: { from: range.from, to: range.to, insert: Text.of([</span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">]) },</span><span class="s3">\n            </span><span class="s1">range: EditorSelection.cursor(range.from) };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(changes, { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Flip the characters before and after the cursor(s).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const transposeChars = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!range.empty || range.from == 0 || range.from == state.doc.length)</span><span class="s3">\n            </span><span class="s1">return { range };</span><span class="s3">\n        </span><span class="s1">let pos = range.from, line = state.doc.lineAt(pos);</span><span class="s3">\n        </span><span class="s1">let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;</span><span class="s3">\n        </span><span class="s1">let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;</span><span class="s3">\n        </span><span class="s1">return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },</span><span class="s3">\n            </span><span class="s1">range: EditorSelection.cursor(to) };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (changes.changes.empty)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(changes, { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">move.character</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function selectedLineBlocks(state) {</span><span class="s3">\n    </span><span class="s1">let blocks = [], upto = -1;</span><span class="s3">\n    </span><span class="s1">for (let range of state.selection.ranges) {</span><span class="s3">\n        </span><span class="s1">let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);</span><span class="s3">\n        </span><span class="s1">if (!range.empty &amp;&amp; range.to == endLine.from)</span><span class="s3">\n            </span><span class="s1">endLine = state.doc.lineAt(range.to - 1);</span><span class="s3">\n        </span><span class="s1">if (upto &gt;= startLine.number) {</span><span class="s3">\n            </span><span class="s1">let prev = blocks[blocks.length - 1];</span><span class="s3">\n            </span><span class="s1">prev.to = endLine.to;</span><span class="s3">\n            </span><span class="s1">prev.ranges.push(range);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">upto = endLine.number + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return blocks;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveLine(state, dispatch, forward) {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let changes = [], ranges = [];</span><span class="s3">\n    </span><span class="s1">for (let block of selectedLineBlocks(state)) {</span><span class="s3">\n        </span><span class="s1">if (forward ? block.to == state.doc.length : block.from == 0)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);</span><span class="s3">\n        </span><span class="s1">let size = nextLine.length + 1;</span><span class="s3">\n        </span><span class="s1">if (forward) {</span><span class="s3">\n            </span><span class="s1">changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });</span><span class="s3">\n            </span><span class="s1">for (let r of block.ranges)</span><span class="s3">\n                </span><span class="s1">ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });</span><span class="s3">\n            </span><span class="s1">for (let r of block.ranges)</span><span class="s3">\n                </span><span class="s1">ranges.push(EditorSelection.range(r.anchor - size, r.head - size));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!changes.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({</span><span class="s3">\n        </span><span class="s1">changes,</span><span class="s3">\n        </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n        </span><span class="s1">selection: EditorSelection.create(ranges, state.selection.mainIndex),</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">move.line</span><span class="s3">\&quot;\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selected lines up one line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const moveLineUp = ({ state, dispatch }) =&gt; moveLine(state, dispatch, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selected lines down one line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const moveLineDown = ({ state, dispatch }) =&gt; moveLine(state, dispatch, true);</span><span class="s3">\n</span><span class="s1">function copyLine(state, dispatch, forward) {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let changes = [];</span><span class="s3">\n    </span><span class="s1">for (let block of selectedLineBlocks(state)) {</span><span class="s3">\n        </span><span class="s1">if (forward)</span><span class="s3">\n            </span><span class="s1">changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({ changes, scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.copyline</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a copy of the selected lines. Keep the selection in the top copy.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const copyLineUp = ({ state, dispatch }) =&gt; copyLine(state, dispatch, false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a copy of the selected lines. Keep the selection in the bottom copy.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const copyLineDown = ({ state, dispatch }) =&gt; copyLine(state, dispatch, true);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Delete selected lines.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteLine = view =&gt; {</span><span class="s3">\n    </span><span class="s1">if (view.state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (from &gt; 0)</span><span class="s3">\n            </span><span class="s1">from--;</span><span class="s3">\n        </span><span class="s1">else if (to &lt; state.doc.length)</span><span class="s3">\n            </span><span class="s1">to++;</span><span class="s3">\n        </span><span class="s1">return { from, to };</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">let selection = updateSel(state.selection, range =&gt; {</span><span class="s3">\n        </span><span class="s1">let dist = undefined;</span><span class="s3">\n        </span><span class="s1">if (view.lineWrapping) {</span><span class="s3">\n            </span><span class="s1">let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);</span><span class="s3">\n            </span><span class="s1">if (pos)</span><span class="s3">\n                </span><span class="s1">dist = (block.bottom + view.documentTop) - pos.bottom + view.defaultLineHeight / 2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return view.moveVertically(range, true, dist);</span><span class="s3">\n    </span><span class="s1">}).map(changes);</span><span class="s3">\n    </span><span class="s1">view.dispatch({ changes, selection, scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">delete.line</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Replace the selection with a newline.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertNewline = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Replace the selection with a newline and the same amount of</span><span class="s3">\n</span><span class="s1">indentation as the line above.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertNewlineKeepIndent = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">let indent = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(state.doc.lineAt(range.from).text)[0];</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">changes: { from: range.from, to: range.to, insert: state.lineBreak + indent },</span><span class="s3">\n            </span><span class="s1">range: EditorSelection.cursor(range.from + indent.length + 1)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}), { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function isBetweenBrackets(state, pos) {</span><span class="s3">\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">)|</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]|</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">}/.test(state.sliceDoc(pos - 1, pos + 1)))</span><span class="s3">\n        </span><span class="s1">return { from: pos, to: pos };</span><span class="s3">\n    </span><span class="s1">let context = syntaxTree(state).resolveInner(pos);</span><span class="s3">\n    </span><span class="s1">let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;</span><span class="s3">\n    </span><span class="s1">if (before &amp;&amp; after &amp;&amp; before.to &lt;= pos &amp;&amp; after.from &gt;= pos &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(closedBy = before.type.prop(NodeProp.closedBy)) &amp;&amp; closedBy.indexOf(after.name) &gt; -1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!/</span><span class="s3">\\</span><span class="s1">S/.test(state.sliceDoc(before.to, after.from)))</span><span class="s3">\n        </span><span class="s1">return { from: before.to, to: after.from };</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Replace the selection with a newline and indent the newly created</span><span class="s3">\n</span><span class="s1">line(s). If the current line consists only of whitespace, this</span><span class="s3">\n</span><span class="s1">will also delete that whitespace. When the cursor is between</span><span class="s3">\n</span><span class="s1">matching brackets, an additional newline will be inserted after</span><span class="s3">\n</span><span class="s1">the cursor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a blank, indented line below the current line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertBlankLine = /*@__PURE__*/newlineAndIndent(true);</span><span class="s3">\n</span><span class="s1">function newlineAndIndent(atEof) {</span><span class="s3">\n    </span><span class="s1">return ({ state, dispatch }) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (state.readOnly)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let changes = state.changeByRange(range =&gt; {</span><span class="s3">\n            </span><span class="s1">let { from, to } = range, line = state.doc.lineAt(from);</span><span class="s3">\n            </span><span class="s1">let explode = !atEof &amp;&amp; from == to &amp;&amp; isBetweenBrackets(state, from);</span><span class="s3">\n            </span><span class="s1">if (atEof)</span><span class="s3">\n                </span><span class="s1">from = to = (to &lt;= line.to ? line : state.doc.lineAt(to)).to;</span><span class="s3">\n            </span><span class="s1">let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });</span><span class="s3">\n            </span><span class="s1">let indent = getIndentation(cx, from);</span><span class="s3">\n            </span><span class="s1">if (indent == null)</span><span class="s3">\n                </span><span class="s1">indent = countColumn(/^</span><span class="s3">\\</span><span class="s1">s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);</span><span class="s3">\n            </span><span class="s1">while (to &lt; line.to &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(line.text[to - line.from]))</span><span class="s3">\n                </span><span class="s1">to++;</span><span class="s3">\n            </span><span class="s1">if (explode)</span><span class="s3">\n                </span><span class="s1">({ from, to } = explode);</span><span class="s3">\n            </span><span class="s1">else if (from &gt; line.from &amp;&amp; from &lt; line.from + 100 &amp;&amp; !/</span><span class="s3">\\</span><span class="s1">S/.test(line.text.slice(0, from)))</span><span class="s3">\n                </span><span class="s1">from = line.from;</span><span class="s3">\n            </span><span class="s1">let insert = [</span><span class="s3">\&quot;\&quot;</span><span class="s1">, indentString(state, indent)];</span><span class="s3">\n            </span><span class="s1">if (explode)</span><span class="s3">\n                </span><span class="s1">insert.push(indentString(state, cx.lineIndent(line.from, -1)));</span><span class="s3">\n            </span><span class="s1">return { changes: { from, to, insert: Text.of(insert) },</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.cursor(from + 1 + insert[1].length) };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">dispatch(state.update(changes, { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function changeBySelectedLine(state, f) {</span><span class="s3">\n    </span><span class="s1">let atLine = -1;</span><span class="s3">\n    </span><span class="s1">return state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">let changes = [];</span><span class="s3">\n        </span><span class="s1">for (let pos = range.from; pos &lt;= range.to;) {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.lineAt(pos);</span><span class="s3">\n            </span><span class="s1">if (line.number &gt; atLine &amp;&amp; (range.empty || range.to &gt; line.from)) {</span><span class="s3">\n                </span><span class="s1">f(line, changes, range);</span><span class="s3">\n                </span><span class="s1">atLine = line.number;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos = line.to + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let changeSet = state.changes(changes);</span><span class="s3">\n        </span><span class="s1">return { changes,</span><span class="s3">\n            </span><span class="s1">range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Auto-indent the selected lines. This uses the [indentation service</span><span class="s3">\n</span><span class="s1">facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent</span><span class="s3">\n</span><span class="s1">information.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentSelection = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let updated = Object.create(null);</span><span class="s3">\n    </span><span class="s1">let context = new IndentContext(state, { overrideIndentation: start =&gt; {</span><span class="s3">\n            </span><span class="s1">let found = updated[start];</span><span class="s3">\n            </span><span class="s1">return found == null ? -1 : found;</span><span class="s3">\n        </span><span class="s1">} });</span><span class="s3">\n    </span><span class="s1">let changes = changeBySelectedLine(state, (line, changes, range) =&gt; {</span><span class="s3">\n        </span><span class="s1">let indent = getIndentation(context, line.from);</span><span class="s3">\n        </span><span class="s1">if (indent == null)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (!/</span><span class="s3">\\</span><span class="s1">S/.test(line.text))</span><span class="s3">\n            </span><span class="s1">indent = 0;</span><span class="s3">\n        </span><span class="s1">let cur = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(line.text)[0];</span><span class="s3">\n        </span><span class="s1">let norm = indentString(state, indent);</span><span class="s3">\n        </span><span class="s1">if (cur != norm || range.from &lt; line.from + cur.length) {</span><span class="s3">\n            </span><span class="s1">updated[line.from] = indent;</span><span class="s3">\n            </span><span class="s1">changes.push({ from: line.from, to: line.from + cur.length, insert: norm });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!changes.changes.empty)</span><span class="s3">\n        </span><span class="s1">dispatch(state.update(changes, { userEvent: </span><span class="s3">\&quot;</span><span class="s1">indent</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected</span><span class="s3">\n</span><span class="s1">lines.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentMore = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(changeBySelectedLine(state, (line, changes) =&gt; {</span><span class="s3">\n        </span><span class="s1">changes.push({ from: line.from, insert: state.facet(indentUnit) });</span><span class="s3">\n    </span><span class="s1">}), { userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.indent</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all</span><span class="s3">\n</span><span class="s1">selected lines.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentLess = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(changeBySelectedLine(state, (line, changes) =&gt; {</span><span class="s3">\n        </span><span class="s1">let space = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(line.text)[0];</span><span class="s3">\n        </span><span class="s1">if (!space)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let col = countColumn(space, state.tabSize), keep = 0;</span><span class="s3">\n        </span><span class="s1">let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));</span><span class="s3">\n        </span><span class="s1">while (keep &lt; space.length &amp;&amp; keep &lt; insert.length &amp;&amp; space.charCodeAt(keep) == insert.charCodeAt(keep))</span><span class="s3">\n            </span><span class="s1">keep++;</span><span class="s3">\n        </span><span class="s1">changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });</span><span class="s3">\n    </span><span class="s1">}), { userEvent: </span><span class="s3">\&quot;</span><span class="s1">delete.dedent</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Enables or disables</span><span class="s3">\n</span><span class="s1">[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this</span><span class="s3">\n</span><span class="s1">prevents the editor's key bindings from capturing Tab or</span><span class="s3">\n</span><span class="s1">Shift-Tab, making it possible for the user to move focus out of</span><span class="s3">\n</span><span class="s1">the editor with the keyboard.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toggleTabFocusMode = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.setTabFocusMode();</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Temporarily enables [tab-focus</span><span class="s3">\n</span><span class="s1">mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until</span><span class="s3">\n</span><span class="s1">another key is pressed.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const temporarilySetTabFocusMode = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.setTabFocusMode(2000);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Insert a tab character at the cursor or, if something is selected,</span><span class="s3">\n</span><span class="s1">use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire</span><span class="s3">\n</span><span class="s1">selection.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertTab = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.selection.ranges.some(r =&gt; !r.empty))</span><span class="s3">\n        </span><span class="s1">return indentMore({ state, dispatch });</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(state.replaceSelection(</span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">), { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Array of key bindings containing the Emacs-style bindings that are</span><span class="s3">\n</span><span class="s1">available on macOS by default.</span><span class="s3">\n\n </span><span class="s1">- Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)</span><span class="s3">\n </span><span class="s1">- Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)</span><span class="s3">\n </span><span class="s1">- Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)</span><span class="s3">\n </span><span class="s1">- Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)</span><span class="s3">\n </span><span class="s1">- Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)</span><span class="s3">\n </span><span class="s1">- Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)</span><span class="s3">\n </span><span class="s1">- Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)</span><span class="s3">\n </span><span class="s1">- Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const emacsStyleKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-b</span><span class="s3">\&quot;</span><span class="s1">, run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-f</span><span class="s3">\&quot;</span><span class="s1">, run: cursorCharRight, shift: selectCharRight },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-p</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineUp, shift: selectLineUp },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-n</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineDown, shift: selectLineDown },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-a</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineStart, shift: selectLineStart },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-e</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineEnd, shift: selectLineEnd },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-d</span><span class="s3">\&quot;</span><span class="s1">, run: deleteCharForward },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-h</span><span class="s3">\&quot;</span><span class="s1">, run: deleteCharBackward },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-k</span><span class="s3">\&quot;</span><span class="s1">, run: deleteToLineEnd },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Alt-h</span><span class="s3">\&quot;</span><span class="s1">, run: deleteGroupBackward },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-o</span><span class="s3">\&quot;</span><span class="s1">, run: splitLine },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-t</span><span class="s3">\&quot;</span><span class="s1">, run: transposeChars },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-v</span><span class="s3">\&quot;</span><span class="s1">, run: cursorPageDown },</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An array of key bindings closely sticking to platform-standard or</span><span class="s3">\n</span><span class="s1">widely used bindings. (This includes the bindings from</span><span class="s3">\n</span><span class="s1">[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`</span><span class="s3">\n</span><span class="s1">property changed to `mac`.)</span><span class="s3">\n\n </span><span class="s1">- ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)</span><span class="s3">\n </span><span class="s1">- ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)</span><span class="s3">\n </span><span class="s1">- Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)</span><span class="s3">\n </span><span class="s1">- Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)</span><span class="s3">\n </span><span class="s1">- ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)</span><span class="s3">\n </span><span class="s1">- ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)</span><span class="s3">\n </span><span class="s1">- Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)</span><span class="s3">\n </span><span class="s1">- Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)</span><span class="s3">\n </span><span class="s1">- PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)</span><span class="s3">\n </span><span class="s1">- PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)</span><span class="s3">\n </span><span class="s1">- Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)</span><span class="s3">\n </span><span class="s1">- End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)</span><span class="s3">\n </span><span class="s1">- Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)</span><span class="s3">\n </span><span class="s1">- Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)</span><span class="s3">\n </span><span class="s1">- Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)</span><span class="s3">\n </span><span class="s1">- Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)</span><span class="s3">\n </span><span class="s1">- Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)</span><span class="s3">\n </span><span class="s1">- Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)</span><span class="s3">\n </span><span class="s1">- Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)</span><span class="s3">\n </span><span class="s1">- Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).</span><span class="s3">\n </span><span class="s1">- Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const standardKeymap = /*@__PURE__*/[</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">, run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Alt-ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">, run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Cmd-ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">ArrowRight</span><span class="s3">\&quot;</span><span class="s1">, run: cursorCharRight, shift: selectCharRight, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-ArrowRight</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Alt-ArrowRight</span><span class="s3">\&quot;</span><span class="s1">, run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Cmd-ArrowRight</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">ArrowUp</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineUp, shift: selectLineUp, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Cmd-ArrowUp</span><span class="s3">\&quot;</span><span class="s1">, run: cursorDocStart, shift: selectDocStart },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-ArrowUp</span><span class="s3">\&quot;</span><span class="s1">, run: cursorPageUp, shift: selectPageUp },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">ArrowDown</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineDown, shift: selectLineDown, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Cmd-ArrowDown</span><span class="s3">\&quot;</span><span class="s1">, run: cursorDocEnd, shift: selectDocEnd },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-ArrowDown</span><span class="s3">\&quot;</span><span class="s1">, run: cursorPageDown, shift: selectPageDown },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">PageUp</span><span class="s3">\&quot;</span><span class="s1">, run: cursorPageUp, shift: selectPageUp },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">PageDown</span><span class="s3">\&quot;</span><span class="s1">, run: cursorPageDown, shift: selectPageDown },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Home</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Home</span><span class="s3">\&quot;</span><span class="s1">, run: cursorDocStart, shift: selectDocStart },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">End</span><span class="s3">\&quot;</span><span class="s1">, run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-End</span><span class="s3">\&quot;</span><span class="s1">, run: cursorDocEnd, shift: selectDocEnd },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">, run: insertNewlineAndIndent, shift: insertNewlineAndIndent },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-a</span><span class="s3">\&quot;</span><span class="s1">, run: selectAll },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot;</span><span class="s1">, run: deleteCharBackward, shift: deleteCharBackward },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Delete</span><span class="s3">\&quot;</span><span class="s1">, run: deleteCharForward },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Backspace</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Alt-Backspace</span><span class="s3">\&quot;</span><span class="s1">, run: deleteGroupBackward },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Delete</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Alt-Delete</span><span class="s3">\&quot;</span><span class="s1">, run: deleteGroupForward },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Mod-Backspace</span><span class="s3">\&quot;</span><span class="s1">, run: deleteLineBoundaryBackward },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Mod-Delete</span><span class="s3">\&quot;</span><span class="s1">, run: deleteLineBoundaryForward }</span><span class="s3">\n</span><span class="s1">].concat(/*@__PURE__*/emacsStyleKeymap.map(b =&gt; ({ mac: b.key, run: b.run, shift: b.shift })));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The default keymap. Includes all bindings from</span><span class="s3">\n</span><span class="s1">[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:</span><span class="s3">\n\n</span><span class="s1">- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)</span><span class="s3">\n</span><span class="s1">- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)</span><span class="s3">\n</span><span class="s1">- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)</span><span class="s3">\n</span><span class="s1">- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)</span><span class="s3">\n</span><span class="s1">- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)</span><span class="s3">\n</span><span class="s1">- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)</span><span class="s3">\n</span><span class="s1">- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)</span><span class="s3">\n</span><span class="s1">- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)</span><span class="s3">\n</span><span class="s1">- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)</span><span class="s3">\n</span><span class="s1">- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)</span><span class="s3">\n</span><span class="s1">- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)</span><span class="s3">\n</span><span class="s1">- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)</span><span class="s3">\n</span><span class="s1">- Ctrl-Alt-</span><span class="s3">\\\\ </span><span class="s1">(Cmd-Alt-</span><span class="s3">\\\\ </span><span class="s1">on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)</span><span class="s3">\n</span><span class="s1">- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)</span><span class="s3">\n</span><span class="s1">- Shift-Ctrl-</span><span class="s3">\\\\ </span><span class="s1">(Shift-Cmd-</span><span class="s3">\\\\ </span><span class="s1">on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)</span><span class="s3">\n</span><span class="s1">- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).</span><span class="s3">\n</span><span class="s1">- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).</span><span class="s3">\n</span><span class="s1">- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const defaultKeymap = /*@__PURE__*/[</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">, run: cursorSyntaxLeft, shift: selectSyntaxLeft },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-ArrowRight</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-ArrowRight</span><span class="s3">\&quot;</span><span class="s1">, run: cursorSyntaxRight, shift: selectSyntaxRight },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-ArrowUp</span><span class="s3">\&quot;</span><span class="s1">, run: moveLineUp },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Shift-Alt-ArrowUp</span><span class="s3">\&quot;</span><span class="s1">, run: copyLineUp },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-ArrowDown</span><span class="s3">\&quot;</span><span class="s1">, run: moveLineDown },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Shift-Alt-ArrowDown</span><span class="s3">\&quot;</span><span class="s1">, run: copyLineDown },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">, run: simplifySelection },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Enter</span><span class="s3">\&quot;</span><span class="s1">, run: insertBlankLine },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-l</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-l</span><span class="s3">\&quot;</span><span class="s1">, run: selectLine },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-i</span><span class="s3">\&quot;</span><span class="s1">, run: selectParentSyntax, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-[</span><span class="s3">\&quot;</span><span class="s1">, run: indentLess },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-]</span><span class="s3">\&quot;</span><span class="s1">, run: indentMore },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Alt-</span><span class="s3">\\\\\&quot;</span><span class="s1">, run: indentSelection },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Shift-Mod-k</span><span class="s3">\&quot;</span><span class="s1">, run: deleteLine },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Shift-Mod-</span><span class="s3">\\\\\&quot;</span><span class="s1">, run: cursorMatchingBracket },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-/</span><span class="s3">\&quot;</span><span class="s1">, run: toggleComment },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Alt-A</span><span class="s3">\&quot;</span><span class="s1">, run: toggleBlockComment },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-m</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Shift-Alt-m</span><span class="s3">\&quot;</span><span class="s1">, run: toggleTabFocusMode },</span><span class="s3">\n</span><span class="s1">].concat(standardKeymap);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and</span><span class="s3">\n</span><span class="s1">Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).</span><span class="s3">\n</span><span class="s1">Please see the [Tab example](../../examples/tab/) before using</span><span class="s3">\n</span><span class="s1">this.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentWithTab = { key: </span><span class="s3">\&quot;</span><span class="s1">Tab</span><span class="s3">\&quot;</span><span class="s1">, run: indentMore, shift: indentLess };</span><span class="s3">\n\n</span><span class="s1">export { blockComment, blockUncomment, copyLineDown, copyLineUp, cursorCharBackward, cursorCharBackwardLogical, cursorCharForward, cursorCharForwardLogical, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharBackwardStrict, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteLineBoundaryBackward, deleteLineBoundaryForward, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, history, historyField, historyKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertNewlineKeepIndent, insertTab, invertedEffects, isolateHistory, lineComment, lineUncomment, moveLineDown, moveLineUp, redo, redoDepth, redoSelection, selectAll, selectCharBackward, selectCharBackwardLogical, selectCharForward, selectCharForwardLogical, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, temporarilySetTabFocusMode, toggleBlockComment, toggleBlockCommentByLine, toggleComment, toggleLineComment, toggleTabFocusMode, transposeChars, undo, undoDepth, undoSelection };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>