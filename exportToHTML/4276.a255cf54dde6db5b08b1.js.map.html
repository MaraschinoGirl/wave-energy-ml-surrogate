<html>
<head>
<title>4276.a255cf54dde6db5b08b1.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
4276.a255cf54dde6db5b08b1.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;4276.a255cf54dde6db5b08b1.js?v=a255cf54dde6db5b08b1&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;AAAqC;;AAErC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qCAAQ;AACjB;;AAEA,yDAAe,QAAQ,EAAC;;;;;;;;;AC3BxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAe,SAAS,EAAC;;;;;;;AC3Be;AACU;AACb;;AAErC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,2CAA2C,kCAAc;AACzD;AACA;AACA;AACA,YAAY,2BAAQ;AACpB;AACA;AACA;AACA,MAAM;AACN,YAAY,2BAAQ;AACpB;AACA,yDAAyD,2BAAQ;AACjE,WAAW,UAAS;AACpB;AACA;;AAEA,mDAAe,WAAW,EAAC;;;AC7BiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAW;;AAEvB,sDAAe,KAAK,EAAC;;;;;AC7CrB;AACA;AACA;AACA;;AAEgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;ACtD+B;AACc;AACP;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACqB;;AAErB,wBAAwB,uBAAU;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,sBAAS;AAClB,IAAI,kBAAK;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,EAAE,sBAAS;AACX;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;;AAEA;AACA;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA,qBAAqB,qBAAK;AAC1B;AACA;;AAEA,EAAE,sBAAS;AACX,0BAA0B,qBAAqB;AAC/C,GAAG;;AAEH;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,gBAAgB,eAAO;AACvB,eAAe,IAAI;AACnB,GAAG;AACH;;AAEA,EAAE,sBAAS;AACX;AACA,GAAG;;AAEH,WAAW;AACX;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;;AC7H+B;AACa;;AAEvB;;AAErB;AACA,+CAA+C,SAAS;AACxD,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA,+BAA+B,kBAAU;AACzC,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sBAAS;AACb;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA,EAAE,sBAAS;AACX;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;AC3D0C;AACX;;AAE/B;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,SAAS,8BAAU;AACnB,WAAW,wBAAK;AAChB,GAAG;AACH;;AAEA,gDAAe,QAAQ,EAAC;;;;;;;AClBW;AACG;AACM;;AAE5C;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA,SAAS,+BAAW,CAAC,4BAAQ,kBAAkB,sBAAO;AACtD;;AAEA,gDAAe,QAAQ,EAAC;;;ACfc;AACA;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,sBAAsB;AACjC,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,WAAW;AACX;AACA,WAAW,SAAQ;AACnB,6BAA6B,EAAE,SAAQ;AACvC,CAAC;;AAED,qDAAe,IAAI,EAAC;;;;;;;ACxBpB;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,8CAAe,MAAM,EAAC;;;;;ACbwB;AACZ;AACG;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gCAAY,QAAQ,uBAAQ,EAAE,OAAM;AAC1C;AACA;;AAEA,oDAAe,GAAG,EAAC;;;;;;;;;;;AC5BiC;AACV;AACI;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,kBAAkB;AAClB;AACA;AACA,oCAAoC,eAAe;AACnD,WAAW,2BAA2B;AACtC;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA,aAAa,gCAAY;;AAEzB,EAAE,8BAAU;AACZ,IAAI,mCAAe;AACnB,GAAG;AACH;AACA;;AAEA,0DAAe,SAAS,EAAC;;;;;;;;;;;AC1CK;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,SAAS,oBAAI;AACb;;AAEA,oDAAe,GAAG,EAAC;;;ACtBY;AACc;;AAiB3C;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kBAAU;AAClB,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAK;AAC5B,EAAE,sBAAS;AACX;AACA,GAAG;AACH,EAAE,sBAAS;AACX,qDAAqD;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,uBAAuB,qBAAK,GAAG,8BAA8B;AAC7D,EAAE,sBAAS;AACX;AACA;AACA;AACA,GAAG;AACH,EAAE,sBAAS;AACX;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA,0CAA0C,KAAK;AAC/C,KAAK,oBAAoB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAK,CAAC,eAAO,CAAC,YAAO;AACtC;AACA,GAAG;AACH,EAAE,sBAAS;AACX;AACA;AACA,SAAS,0BAAa;AACtB;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAAK;AACjB,IAAI,kBAAK;AACT;AACA,KAAK;AACL;AACA,EAAE,sBAAS;AACX;AACA,QAAQ,kBAAK;AACb;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,eAAe,4BAAK;AACpB,IAAI,kBAAK;AACT;AACA,KAAK;AACL;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,EAAE,sBAAS;AACX,QAAQ,0BAAa;AACrB;AACA,MAAM;AACN,MAAM,sBAAS;AACf;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,YAAO;AAChB,SAAS,aAAK;AACd,IAAI,kBAAK;AACT;AACA,WAAW,0BAAa;AACxB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,EAAE,sBAAS;AACX;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,SAAI;AACb,cAAc,aAAK;AACnB;AACA;AACA,IAAI;AACJ,oCAAoC,aAAK;AACzC;AACA;;AAEA;AACA;AACA;;;ACzP+B;AACG;;AAEL;;AAE7B;AACA;AACA;AACA;AACA;AACA,MAAM,sBAAS;AACf;;AAEA;AACA;AACA;AACA,gEAAgE,gBAAgB;AAChF,QAAQ,iCAAa;AACrB,QAAQ,iCAAa;AACrB;AACA;AACA;;AAEA,EAAE,sBAAS;AACX;;AAEA,SAAS,iCAAa;AACtB,gBAAgB;AAChB;AACA,aAAa,YAAiB;AAC9B;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;;;ACnC+B;;AAEP;;AAExB;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,sBAAI;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;AACH,EAAE,sBAAS;AACX;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA,IAAI,sBAAS;AACb;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA,IAAI,sBAAS;AACb;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;;AC1EA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AAC+B;AACG;;AAEb;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAG;AACZ;AACA,EAAE,sBAAS;AACX;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,2BAA2B;AAC3C,gBAAgB,KAAK;AACrB,gBAAgB,mCAAmC;AACnD,gBAAgB,QAAQ;AACxB,gBAAgB,uCAAuC;AACvD;;AAEA,aAAa,mBAAmB;AAChC;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;;AAEA,SAAS,cAAI;AACb,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;AC7G8C;AACA;AACZ;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,GAAG;AAChB;AACA;AACA,oBAAoB,QAAQ,IAAI,QAAQ;AACxC;AACA,kCAAkC,aAAa;AAC/C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM,gCAAY,QAAQ,gCAAY,eAAe,sBAAM;AAC3D;AACA;;AAEA,sDAAe,KAAK,EAAC;;;ACjCU;;AAED;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,4BAAK;AACpB,MAAM,kBAAK;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE,sBAAS;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9D+B;AACiB;AACd;;AAEV;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAK,GAAG,iBAAiB;;AAEvC;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,gCAAgC,KAAK,aAAa,KAAK;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sBAAS;AACb;AACA;AACA,4BAA4B,KAAK;AACjC,uBAAuB;AACvB,0BAA0B;AAC1B;AACA;AACA,KAAK;AACL;;AAEA,EAAE,sBAAS;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAO;AAChB;AACA,aAAa,KAAK;AAClB;AACA,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;AACH;;;;;;;ACtF+B;AAC2B;;AAEtC;;AAEpB,0BAA0B,uBAAU;;AAEpC,SAAS,iBAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AChE+B;AACU;;AAElB;;AAEvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;;;ACb+B;;AAEN;;AAEzB,IAAI,kCAAmB,GAAG,uBAAU;;AAEpC;AACA;AACA;AACA,gBAAgB,kCAAmB;AACnC;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB;AACxB,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACtD8C;;AAE9C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,gBAAgB,gCAAY;;AAE5B,iDAAe,SAAS,EAAC;;;ACXzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;ACzB1B;AACA,IAAI,0BAAa;AACjB,IAAI,8BAAiB;AACrB,IAAI,kCAAqB;AACzB,IAAI,gCAAmB;AACvB,IAAI,yBAAY,GAAG,8BAAiB,GAAG,kCAAqB,GAAG,gCAAmB;AAClF,IAAI,uBAAU;;AAEd;AACA,qBAAqB,0BAAa;AAClC,oBAAoB,yBAAY;AAChC;AACA;AACA,yBAAyB,0BAAa;AACtC,+CAA+C,EAAE;AACjD;AACA,IAAI,kBAAK;;AAET;AACA;AACA,qBAAqB,uBAAU;AAC/B,wBAAwB,kBAAK;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAe,WAAW,EAAC;;;AC3Ca;AACE;AACE;;AAE5C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA,SAAS,WAAU;AACnB,MAAM,YAAW;AACjB,MAAM,UAAS;AACf;;AAEA,kDAAe,UAAU,EAAC;;;ACjBY;AACJ;AACS;AACN;AACK;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8BAAW;AACjB,WAAW,2BAAQ,eAAe,WAAU;AAC5C;AACA,YAAY,0BAAM;AAClB;AACA;AACA;AACA,SAAS,4BAAQ;AACjB;;AAEA,qDAAe,IAAI,EAAC;;;AC7CW;;AAEI;;AAEnC,eAAO,kBAAkB,sBAAc;;AAEvC,SAAS,eAAO;AAChB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,sBAAc;AAC9B;;AAEA;AACA;AACA;AACA,MAAM,sBAAM;AACZ;AACA;AACA;AACA;;AAEA,EAAE,sBAAM;;AAER,MAAM,cAAM;AACZ,cAAc,sBAAc;AAC5B;;AAEA;AACA;;AAEA,SAAS,sBAAc;AACvB,sBAAc,0BAA0B;;;ACnCe;;AAElC;;AAErB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACd+B;;AAEhB;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,sBAAS;AAChB;AACA;;AAEA;;AAEA;AACA;AACA,EAAE,sBAAM;AACR;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,sBAAM;AACV;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AC7C+B;;AAEV;;AAErB;AACA,SAAS,GAAG;AACZ;;;ACN+B;;AAEX;;AAEpB;AACA,SAAS,GAAG;AACZ;;;;;ACN+B;AAC2B;AACtB;;AAEpB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;;ACnD6C;AACJ;AACO;AACF;AACM;AACR;AACD;AACF;AACR;AACI;AACE;;AAcrC;;;ACxB6B;AACoB;AACb;AACY;AACH;;AAErB;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,QAAQ;AACd,EAAE,WAAW;AACb,UAAU,YAAY;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAa;AACxB;AACA,EAAE,sBAAS;AACX;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE,sBAAS;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,mBAAM;AACf;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAQ;AAC3B;AACA;AACA;AACA;AACA,GAAG;;AAEH,SAAS,eAAO;AAChB,WAAW,KAAK;AAChB,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAM;AACnB;AACA,GAAG;AACH,WAAW,QAAY;AACvB;AACA,EAAE,sBAAS;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3OkD;AACI;AACd;;AAExB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,WAAW;;AAEnC;AACA,EAAE,WAAW;AACb,EAAE,YAAY;AACd;;AAEA;AACA,EAAE,cAAc;AAChB;;;;;;;ACnD+B;AACG;;AAEV;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAG;AACZ,aAAa,YAAiB,cAAc;AAC5C;AACA,eAAe,aAAK,CAAC,qBAAQ,eAAe;AAC5C;;AAEA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,EAAE,sBAAS;AACX,IAAI,iBAAG;AACP,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,SAAS,iBAAG;AACZ;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;;AAEA,YAAY,aAAkB;AAC9B,eAAe,aAAkB;AACjC;;AAEA;AACA;AACA;AACA;;AAEA,EAAE,sBAAS;AACX,IAAI,iBAAG;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,2BAA2B,uCAAuC;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,sBAAS;AACf;AACA,OAAO;AACP;AACA;AACA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;AACH;AACA;;AAEA;AACA,SAAS,qBAAQ;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;ACxIwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6BAAS;AAClB;;AAEA,0DAAe,SAAS,EAAC;;;AC5BM;;AAEG;;AAElC;AACA,eAAe;AACf;;AAEA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpD+B;AACiB;;AAErB;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAK,GAAG,gBAAgB;AACzC,kBAAkB,YAAY;AAC9B;AACA;AACA,OAAO;;AAEP,EAAE,sBAAS;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,sBAAS;AACf;AACA;AACA,oBAAoB,0BAAa;AACjC,+BAA+B,mCAAmC;AAClE,OAAO;;AAEP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,wBAAwB,kBAAU;AAClC;AACA;;;;;AC3EA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAe,aAAa,EAAC;;;ACtBe;AACI;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS,cAAa,4BAA4B,2BAAW;AAC7D;;AAEA,0DAAe,SAAS,EAAC;;;;;;;;;;;ACvBzB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;;;;;ACpBW;;AAErC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAAQ;;AAE9B;AACA;AACA;AACA,sBAAsB,2BAAQ;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAe,gBAAgB,EAAC;;;ACxCsB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAe,eAAe,EAAC;;;AC3CO;AACF;AACU;AACV;AACM;AACF;AACY;AACf;AACF;;AAEnC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,8BAA8B;AACzC,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,gBAAgB,4BAAQ;AACxB,UAAU,0BAAO;AACjB;AACA,iBAAiB,2BAAO;AACxB;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,iBAAiB,uBAAQ;AACzB;;AAEA;AACA,cAAc,4BAAQ,YAAY,6BAAS,CAAC,4BAAY;;AAExD,eAAe,2BAAO;AACtB,mBAAmB,4BAAQ;AAC3B;AACA,KAAK;AACL,aAAa;AACb,GAAG;;AAEH,SAAS,WAAU;AACnB,WAAW,gBAAe;AAC1B,GAAG;AACH;;AAEA,mDAAe,WAAW,EAAC;;;;;AChDiB;AACA;AACN;AACY;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,0BAA0B;AACrC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,OAAO,6BAA6B;AACpC,OAAO,6BAA6B;AACpC,OAAO,6BAA6B;AACpC,OAAO;AACP;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa,4BAAQ;AACrB;AACA;AACA;AACA;AACA,oBAAoB,kCAAc;AAClC;AACA,IAAI,uBAAuB,kCAAc;AACzC;AACA;AACA,SAAS,YAAW,aAAa,+BAAW;AAC5C,CAAC;;AAED,uDAAe,MAAM,EAAC;;;AC/CS;;AAET;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,mBAAW;AAC5B;AACA,IAAI,kBAAK;AACT;AACA,KAAK;AACL;AACA,qBAAqB,sBAAS;AAC9B,IAAI,kBAAK;AACT,aAAa,gBAAQ;AACrB,QAAQ,kBAAK;AACb,mBAAmB;AACnB,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAK;AAClB;AACA,GAAG;;AAEH;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;ACjF+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,qBAAQ;AAC5B;AACA,GAAG;AACH,gBAAgB,aAAK;AACrB,IAAI,kBAAK;AACT;AACA,KAAK;AACL;AACA,eAAe,kBAAK,CAAC,eAAO;AAC5B;AACA,GAAG;;AAEH;AACA,QAAQ,kBAAK;AACb;AACA;AACA;AACA,IAAI,sBAAS;AACb;;AAEA,kBAAkB,gBAAQ;AAC1B;AACA,GAAG;AACH,EAAE,sBAAS;;AAEX;AACA;;;ACzC+B;;AAET;;AAEtB;AACA,SAAS,kBAAK;AACd;AACA;AACA,eAAe;AACf,MAAM;AACN,mBAAmB,qBAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,UAAU,mBAAmB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AC9B+B;;AAEH;;AAE5B;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD,8BAA8B,EAAE;AAChC;AACA;AACA;AACA,yCAAyC,0BAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,SAAS,0BAAa;AACtB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA;AACA,SAAS,0BAAa,aAAa,0BAAa;AAChD;AACA;AACA;AACA,GAAG;;AAEH,kBAAkB,qBAAQ;AAC1B;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAa;AACrB,QAAQ,0BAAa;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,sBAAS;AACb,IAAI,sBAAS;AACb;;AAEA,SAAS,kBAAK;AACd,IAAI,qBAAQ;AACZ;AACA,KAAK;AACL;AACA,aAAa,cAAM;AACnB,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AC/H+B;AACI;;AAEnB;;AAEhB;AACA,cAAc,SAAc;AAC5B;AACA,GAAG;AACH;AACA,iBAAiB,gBAAQ;AACzB;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,iBAAiB,IAAI,sBAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,6BAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;;AC1D+B;AACc;AACa;AACzB;;AAET;;AAExB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,qBAAQ;AACtB;AACA,KAAK;AACL;;AAEA,oBAAoB,UAAU;AAC9B,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,gBAAgB,gBAAgB;AAChC;;AAEA,eAAe,IAAI;;AAEnB;AACA,gBAAgB,sBAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX,eAAe,sBAAS;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA,OAAO,0BAAa;AACpB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AC7E+B;AACiB;AACb;AACoC;AACd;AACX;AACF;AACM;;AAEjC;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,0CAA0C,eAAO;AACjD,wCAAwC,eAAO;;AAE/C,iBAAiB,SAAS;AAC1B;;AAEA;AACA;;AAEA,gCAAgC,cAAc;AAC9C;;AAEA,eAAe,gBAAqB;AACpC,aAAa,UAAU;AACvB;AACA;AACA,aAAa,mBAAW;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,kBAAK;AACd,WAAW,eAAe;AAC1B,GAAG;AACH;;AAEA;AACA,eAAe,qBAAK;AACpB,EAAE,sBAAS;AACX;AACA,iBAAiB,YAAY;AAC7B,IAAI,sBAAS;AACb;AACA,KAAK;AACL,IAAI,sBAAsB;AAC1B,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX,IAAI,sBAAS;AACb;AACA,KAAK;AACL,GAAG;AACH;;;AC5E+B;;AAEF;;AAE7B;AACA,sBAAsB,6BAAS;;AAE/B,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA,SAAS,6BAAS;AAClB;AACA;;AAEA;AACA;AACA,IAAI,sBAAS;AACb,kBAAkB;AAClB;AACA,EAAE,sBAAS;;AAEX;AACA;;;;;ACrF0C;AACI;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,mBAAmB,8BAAU,SAAS,gCAAY;AAClD;;AAEA,uDAAe,MAAM,EAAC;;;;;;;ACnCc;AACU;AACb;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM,2BAAO,SAAS,gCAAY,YAAY,qBAAM;AACpD;;AAEA,sDAAe,KAAK,EAAC;;;ACtCU;AACiB;AACb;;AAEnC;AACA;AACA;AACA;;AAaE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAAM;;AAEvB,IAAI,sBAAS;AACb;AACA;;AAEA;AACA,QAAQ,sBAAS;AACjB,UAAU,sBAAS;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,EAAE,qBAAQ;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI,sBAAS,CAAC,eAAO;AACrB;AACA;AACA,QAAQ,sBAAS;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,IAAI,sBAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,EAAE,qBAAQ;AACV;AACA;;AAEA;AACA;AACA,WAAW,mBAAM;AACjB;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;;AAEA;AACA;AACA;AACA,EAAE,sBAAS;AACX,IAAI,sBAAS;AACb;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA,IAAI,sBAAS;AACb;AACA;AACA,aAAa,gBAAQ;AACrB;AACA,SAAS;AACT;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,uBAAuB,qBAAK;AAC5B;AACA;;AAEA,EAAE,sBAAS;AACX;AACA,IAAI,sBAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,eAAO,CAAC,qBAAQ;AACzB;AACA;;AAEA,IAAI,eAAO;AACX;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAQ;AAC5B,iBAAiB,4BAAK;AACtB,iBAAiB,aAAK;;AAEtB,EAAE,sBAAS;AACX,IAAI,sBAAS;AACb;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAQ;AAC3B,2CAA2C,4BAAK,wBAAwB,aAAK;;AAE7E;AACA,yBAAyB,mBAAW;AACpC;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,SAAS,mBAAW;AACpB;AACA;AACA,MAAM;AACN,eAAe,gBAAQ,CAAC,kBAAK;AAC7B;AACA;AACA,GAAG;AACH;;AAEA;AACA,iBAAiB,gBAAqB;AACtC,kBAAkB,oBAAO;;AAEzB;AACA;AACA,EAAE,sBAAS;AACX,iDAAiD,qBAAQ;AACzD,IAAI,sBAAS;AACb;AACA,2BAA2B,kBAAK;AAChC,iBAAiB,qBAAQ;AACzB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,aAAa,mBAAW;AACxB;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;ACta+B;AACI;AACC;;AAEhB;;AAEpB;AACA,MAAM,kBAAuB;;AAE7B;AACA,EAAE,gBAAQ,CAAC,SAAS;AACpB;AACA,GAAG;AACH;;AAEA;AACA,iBAAiB,gBAAqB;AACtC;AACA;AACA,EAAE,sBAAS;AACX,oBAAoB,aAAK;AACzB,MAAM,kBAAK;AACX;AACA,OAAO;AACP;AACA,IAAI,sBAAS;AACb;AACA,KAAK;AACL;AACA,GAAG;AACH;;;AC9B+B;AACc;AACgB;AACF;AACnB;AACI;AACL;AACY;AACV;AACoB;AACd;AACb;;AAEhB;;AAElB;AACA,wCAAwC,SAAS,GAAG,MAAW;AAC/D;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,4BAA4B,GAAW;AACvC,qCAAqC,iBAAgB;AACrD,yBAAyB,IAAI,CAAC,kBAAuB;AACrD;AACA,qCAAqC,gBAAqB;AAC1D,yCAAyC,OAAoB;AAC7D,mCAAmC,cAAmB;AACtD;AACA;AACA,kCAAkC,aAAa;AAC/C,sCAAsC,iBAAiB;AACvD,sCAAsC,iBAAiB;AACvD,0BAA0B,KAAK;AAC/B;AACA,2CAA2C,MAAuB;AAClE,6BAA6B,QAAQ;AACrC;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,yCAAyC,sBAAqB;AAC9D;AACA;AACA;AACA,iCAAiC,IAAY;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sBAAS;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAK,GAAG,kCAAkC;AACxD;;AAEA;AACA,IAAI,oBAAO,GAAG,0DAA0D,cAAM;AAC9E;;AAEA,EAAE,sBAAS;AACX;AACA,iBAAiB,uBAAU;AAC3B;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA;AACA;AACA,MAAM,oBAAO,GAAG,uDAAuD,cAAM;AAC7E;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA,oBAAoB;AACpB,MAAM,YAAiB;AACvB;AACA,GAAG;AACH;;AAEA;AACA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAK;AACrB;AACA,GAAG;AACH;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,sBAAS;AACX;AACA,GAAG;AACH,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,EAAE,sBAAS;AACX;AACA;AACA;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA,IAAI,sBAAS;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wBAAwB,aAAkB;AAC1C,qBAAqB,aAAkB;AACvC,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA,qBAAqB,6BAAM;AAC3B,qBAAqB,6BAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,sBAAS;AACX;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,GAAG;AACH;;AAEA;AACA,eAAe,gBAAqB;AACpC,EAAE,sBAAS;AACX;AACA,IAAI,sBAAS;AACb;AACA;AACA,MAAM,sBAAS;AACf,QAAQ,YAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,EAAE,sBAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,gCAAgC;AAC1C,UAAU,iBAAiB;AAC3B,UAAU,gCAAgC;AAC1C,UAAU,gCAAgC;AAC1C;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,SAAS,mBAAW,CAAC,cAAM;AAC3B;;AAEA;AACA;AACA,EAAE,sBAAS;AACX;AACA,GAAG;AACH;AACA;;;ACrZwC;AACH;AACO;AACL;;AAEK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACN;AACA;AACiB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,4BAAQ;AACpB,SAAS,4BAAQ,CAAC,+BAAW,YAAY,gCAAiB;AAC1D,CAAC;;AAED,sDAAe,KAAK,EAAC;;;;;;;ACzBU;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,WAAW;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,WAAW;AAC/E;AACA;AACA;AACA;AACO;AACP,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,uBAAU;;AAEzC;AACA,+BAA+B,uBAAU;;AAEzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yBAAY;AACrB,mBAAmB,uBAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAM;AACjB;AACA;AACA;AACA,WAAW,qBAAQ;AACnB,aAAa,sBAAS;AACtB,KAAK;AACL;AACA;AACA;AACA,WAAW,qBAAQ;AACnB,aAAa,sBAAS;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,sBAAM;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sBAAM;AACd;AACA,SAAS;AACT;AACA;AACA,MAAM,sBAAM,CAAC,mBAAM;AACnB;AACA;AACA,MAAM,sBAAM,CAAC,mBAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,0BAAa;AACrB;AACA,MAAM;AACN;AACA;AACA,kCAAkC,CAAC,0BAAa,YAAY;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAa;AACrB;AACA;;AAEA;AACA;AACA;AACA,eAAe,mBAAM;AACrB;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAM;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAM;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,eAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,IAAI,sBAAM;AACV;AACA;AACA;AACA,KAAK;;AAEL,IAAI,sBAAM;AACV;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM,sBAAM;AACZ;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS,yBAAY;AACrB,mBAAmB,uBAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAQ;AACnB;AACA;AACA;AACA;AACA,IAAI,qBAAQ;AACZ;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,0BAAa;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,0BAAa;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAQ;AAC1B;AACA;AACA;AACA,aAAa,qBAAQ;AACrB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAQ;AAC1B;AACA;AACA;AACA,aAAa,qBAAQ;AACrB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAAa;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChgBA;;AAEmC;;AAEnC;;AAE0B;;;;;;;;;;;;ACNW;;AAErC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,iEAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,YAAY,EAAC;;;;;;;;;;;AC/B5B;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;ACbgB;AACK;;AAE3C;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,eAAe,oEAAW;;AAE1B,EAAE,iEAAQ;AACV;AACA,GAAG;AACH;AACA;;AAEA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBqB;AACN;AACF;AACC;AACL;;AAEhC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,OAAO,2BAAQ;AACf;AACA;AACA,SAAS,4BAAQ;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,cAAc,yBAAK;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,2BAAQ;AAC3B;AACA,aAAa,2BAAO,2BAA2B;AAC/C;AACA;AACA,IAAI,+BAAW;AACf;AACA;AACA;AACA;;AAEA,+CAAe,OAAO,EAAC;;;AClDa;AACA;AACE;;AAEtC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2BAAO;;AAEvB;AACA,MAAM,QAAO,SAAS,4BAAQ;AAC9B;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;;;;;;;;;;;;;AC7BY;AACb;AACyB;AACjB;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,gBAAgB,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAChD,WAAW;AACX;AACA,eAAe,iEAAQ;AACvB;;AAEA;AACA;AACA;;AAEA,eAAe,uEAAc;AAC7B;AACA;;AAEA;AACA;AACA,gBAAgB,+DAAM;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,2DAAE;AACb;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;;;AC/DsB;AACH;AACd;;AAE7B;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,SAAS,8BAAW;AACpB,qBAAqB,gCAAY;AACjC,mBAAmB,uBAAI;AACvB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;;;;;ACxBsB;AACF;AACP;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,OAAO,oCAAoC;AAC3C,OAAO,oCAAoC;AAC3C,OAAO;AACP;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4BAAS;AAC/C;AACA;AACA;AACA,SAAS,iCAAa,QAAQ,gCAAY;AAC1C;;AAEA,0DAAe,SAAS,EAAC;;;ACtDiB;AACH;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA,OAAO,8CAA8C;AACrD,OAAO,+CAA+C;AACtD,OAAO;AACP;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAU,CAAC,mBAAS;;AAE/B,qDAAe,IAAI,EAAC;;;;;;;;;;;;ACzCwB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAW;AAC7B;;AAEA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;ACrBvB;AACA;;AAEA;AACA,IAAI,uBAAc;;AAElB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,2BAA2B,uBAAc;AACzC;;AAEA,+CAAe,OAAO,EAAC;;;;;AClBa;AACA;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,OAAO;AACzB,0BAA0B,gBAAgB,QAAQ,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAAO,eAAe,QAAO;AACxD;;AAEA,oDAAe,GAAG,EAAC;;;;;;;;;;;;;;AClCuB;AACP;AACU;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gEAAO,WAAW,qEAAY,WAAW,mEAAU;AACzD;;AAEA,iEAAe,QAAQ,EAAC;;;;;;;;;;;AC7BxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;ACnBkB;AACQ;AACV;AACD;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,OAAO,kBAAkB;AACzB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAO,eAAe,6DAAQ,GAAG,4DAAO;AACrD,0BAA0B,qEAAY;AACtC;;AAEA,iEAAe,GAAG,EAAC;;;;;;;;;;;;;;ACpD2B;AACZ;AACG;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qEAAY,QAAQ,6DAAQ,EAAE,2DAAM;AAC1C;AACA;;AAEA,iEAAe,GAAG,EAAC;;;;;;;;;;;;;;;AC5BnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAe,eAAe,EAAC;;;AClBqB;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,sBAAsB,gBAAe;AACrC;AACA;;AAEA,gDAAe,QAAQ,EAAC;;;;;;;AClBc;AACD;AACA;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,2BAAQ;AACd;AACA;AACA,MAAM,2BAAQ;AACd;AACA,YAAY,2BAAQ;AACpB;AACA;AACA;AACA;AACA,UAAU,SAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA,yDAAe,QAAQ,EAAC;;;AC/Da;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,QAAQ,EAAC;;;;;;;;;;;;ACzCa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAQ;AACvB;;AAEA;AACA;;AAEA,iEAAe,SAAS,EAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/uniqueId.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseRange.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_createRange.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/range.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/data/list.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/greedy-fas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/acyclic.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_basePick.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_flatRest.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/pick.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseGt.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/max.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/mapValues.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/now.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/util.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/add-border-segments.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/coordinate-system.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/normalize.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/minBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/rank/util.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/rank/feasible-tree.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/dijkstra.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/dijkstra-all.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/floyd-warshall.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_asciiSize.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_hasUnicode.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_unicodeSize.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_stringSize.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/size.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/topsort.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/is-acyclic.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/dfs.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/postorder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/preorder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/prim.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/alg/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/rank/network-simplex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/rank/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/nesting-graph.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/cloneDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/add-subgraph-constraints.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/build-layer-graph.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseZipObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/zipObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseSortBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_compareAscending.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_compareMultiple.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseOrderBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/sortBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/cross-count.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/init-order.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/barycenter.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/resolve-conflicts.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/sort.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/sort-subgraph.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/order/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/parent-dummy-chains.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/forOwn.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/forIn.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/position/bk.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/position/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/layout.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/dagre/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/union.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/graph.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseExtremum.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseLt.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseSet.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_basePickBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/defaults.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_createFind.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/findIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/find.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/flatten.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseHas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/has.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/isString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/last.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/map.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_trimmedEndIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseTrim.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/toNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/toFinite.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/toInteger.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import toString from './toString.js';</span><span class="s3">\n\n</span><span class="s1">/** Used to generate unique IDs. */</span><span class="s3">\n</span><span class="s1">var idCounter = 0;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a unique ID. If `prefix` is given, the ID is appended to it.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @param {string} [prefix=''] The value to prefix the ID with.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the unique ID.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.uniqueId('contact_');</span><span class="s3">\n </span><span class="s1">* // =&gt; 'contact_104'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.uniqueId();</span><span class="s3">\n </span><span class="s1">* // =&gt; '105'</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function uniqueId(prefix) {</span><span class="s3">\n  </span><span class="s1">var id = ++idCounter;</span><span class="s3">\n  </span><span class="s1">return toString(prefix) + id;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default uniqueId;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeCeil = Math.ceil,</span><span class="s3">\n    </span><span class="s1">nativeMax = Math.max;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.range` and `_.rangeRight` which doesn't</span><span class="s3">\n </span><span class="s1">* coerce arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {number} start The start of the range.</span><span class="s3">\n </span><span class="s1">* @param {number} end The end of the range.</span><span class="s3">\n </span><span class="s1">* @param {number} step The value to increment or decrement by.</span><span class="s3">\n </span><span class="s1">* @param {boolean} [fromRight] Specify iterating from right to left.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the range of numbers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseRange(start, end, step, fromRight) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),</span><span class="s3">\n      </span><span class="s1">result = Array(length);</span><span class="s3">\n\n  </span><span class="s1">while (length--) {</span><span class="s3">\n    </span><span class="s1">result[fromRight ? length : ++index] = start;</span><span class="s3">\n    </span><span class="s1">start += step;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseRange;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseRange from './_baseRange.js';</span><span class="s3">\n</span><span class="s1">import isIterateeCall from './_isIterateeCall.js';</span><span class="s3">\n</span><span class="s1">import toFinite from './toFinite.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a `_.range` or `_.rangeRight` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {boolean} [fromRight] Specify iterating from right to left.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new range function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createRange(fromRight) {</span><span class="s3">\n  </span><span class="s1">return function(start, end, step) {</span><span class="s3">\n    </span><span class="s1">if (step &amp;&amp; typeof step != 'number' &amp;&amp; isIterateeCall(start, end, step)) {</span><span class="s3">\n      </span><span class="s1">end = step = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Ensure the sign of `-0` is preserved.</span><span class="s3">\n    </span><span class="s1">start = toFinite(start);</span><span class="s3">\n    </span><span class="s1">if (end === undefined) {</span><span class="s3">\n      </span><span class="s1">end = start;</span><span class="s3">\n      </span><span class="s1">start = 0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">end = toFinite(end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">step = step === undefined ? (start &lt; end ? 1 : -1) : toFinite(step);</span><span class="s3">\n    </span><span class="s1">return baseRange(start, end, step, fromRight);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default createRange;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import createRange from './_createRange.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of numbers (positive and/or negative) progressing from</span><span class="s3">\n </span><span class="s1">* `start` up to, but not including, `end`. A step of `-1` is used if a negative</span><span class="s3">\n </span><span class="s1">* `start` is specified without an `end` or `step`. If `end` is not specified,</span><span class="s3">\n </span><span class="s1">* it's set to `start` with `start` then set to `0`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** JavaScript follows the IEEE-754 standard for resolving</span><span class="s3">\n </span><span class="s1">* floating-point values which can produce unexpected results.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @param {number} [start=0] The start of the range.</span><span class="s3">\n </span><span class="s1">* @param {number} end The end of the range.</span><span class="s3">\n </span><span class="s1">* @param {number} [step=1] The value to increment or decrement by.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the range of numbers.</span><span class="s3">\n </span><span class="s1">* @see _.inRange, _.rangeRight</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(4);</span><span class="s3">\n </span><span class="s1">* // =&gt; [0, 1, 2, 3]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(-4);</span><span class="s3">\n </span><span class="s1">* // =&gt; [0, -1, -2, -3]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(1, 5);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, 3, 4]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(0, 20, 5);</span><span class="s3">\n </span><span class="s1">* // =&gt; [0, 5, 10, 15]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(0, -4, -1);</span><span class="s3">\n </span><span class="s1">* // =&gt; [0, -1, -2, -3]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(1, 4, 0);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 1, 1]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.range(0);</span><span class="s3">\n </span><span class="s1">* // =&gt; []</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var range = createRange();</span><span class="s3">\n\n</span><span class="s1">export default range;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/*</span><span class="s3">\n </span><span class="s1">* Simple doubly linked list implementation derived from Cormen, et al.,</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Introduction to Algorithms</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export { List };</span><span class="s3">\n\n</span><span class="s1">class List {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">var sentinel = {};</span><span class="s3">\n    </span><span class="s1">sentinel._next = sentinel._prev = sentinel;</span><span class="s3">\n    </span><span class="s1">this._sentinel = sentinel;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dequeue() {</span><span class="s3">\n    </span><span class="s1">var sentinel = this._sentinel;</span><span class="s3">\n    </span><span class="s1">var entry = sentinel._prev;</span><span class="s3">\n    </span><span class="s1">if (entry !== sentinel) {</span><span class="s3">\n      </span><span class="s1">unlink(entry);</span><span class="s3">\n      </span><span class="s1">return entry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">enqueue(entry) {</span><span class="s3">\n    </span><span class="s1">var sentinel = this._sentinel;</span><span class="s3">\n    </span><span class="s1">if (entry._prev &amp;&amp; entry._next) {</span><span class="s3">\n      </span><span class="s1">unlink(entry);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">entry._next = sentinel._next;</span><span class="s3">\n    </span><span class="s1">sentinel._next._prev = entry;</span><span class="s3">\n    </span><span class="s1">sentinel._next = entry;</span><span class="s3">\n    </span><span class="s1">entry._prev = sentinel;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">var strs = [];</span><span class="s3">\n    </span><span class="s1">var sentinel = this._sentinel;</span><span class="s3">\n    </span><span class="s1">var curr = sentinel._prev;</span><span class="s3">\n    </span><span class="s1">while (curr !== sentinel) {</span><span class="s3">\n      </span><span class="s1">strs.push(JSON.stringify(curr, filterOutLinks));</span><span class="s3">\n      </span><span class="s1">curr = curr._prev;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return '[' + strs.join(', ') + ']';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unlink(entry) {</span><span class="s3">\n  </span><span class="s1">entry._prev._next = entry._next;</span><span class="s3">\n  </span><span class="s1">entry._next._prev = entry._prev;</span><span class="s3">\n  </span><span class="s1">delete entry._next;</span><span class="s3">\n  </span><span class="s1">delete entry._prev;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function filterOutLinks(k, v) {</span><span class="s3">\n  </span><span class="s1">if (k !== '_next' &amp;&amp; k !== '_prev') {</span><span class="s3">\n    </span><span class="s1">return v;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../graphlib/index.js';</span><span class="s3">\n</span><span class="s1">import { List } from './data/list.js';</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* A greedy heuristic for finding a feedback arc set for a graph. A feedback</span><span class="s3">\n </span><span class="s1">* arc set is a set of edges that can be removed to make a graph acyclic.</span><span class="s3">\n </span><span class="s1">* The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, </span><span class="s3">\&quot;</span><span class="s1">A fast and</span><span class="s3">\n </span><span class="s1">* effective heuristic for the feedback arc set problem.</span><span class="s3">\&quot; </span><span class="s1">This implementation</span><span class="s3">\n </span><span class="s1">* adjusts that from the paper to allow for weighted edges.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export { greedyFAS };</span><span class="s3">\n\n</span><span class="s1">var DEFAULT_WEIGHT_FN = _.constant(1);</span><span class="s3">\n\n</span><span class="s1">function greedyFAS(g, weightFn) {</span><span class="s3">\n  </span><span class="s1">if (g.nodeCount() &lt;= 1) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);</span><span class="s3">\n  </span><span class="s1">var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);</span><span class="s3">\n\n  </span><span class="s1">// Expand multi-edges</span><span class="s3">\n  </span><span class="s1">return _.flatten(</span><span class="s3">\n    </span><span class="s1">_.map(results, function (e) {</span><span class="s3">\n      </span><span class="s1">return g.outEdges(e.v, e.w);</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function doGreedyFAS(g, buckets, zeroIdx) {</span><span class="s3">\n  </span><span class="s1">var results = [];</span><span class="s3">\n  </span><span class="s1">var sources = buckets[buckets.length - 1];</span><span class="s3">\n  </span><span class="s1">var sinks = buckets[0];</span><span class="s3">\n\n  </span><span class="s1">var entry;</span><span class="s3">\n  </span><span class="s1">while (g.nodeCount()) {</span><span class="s3">\n    </span><span class="s1">while ((entry = sinks.dequeue())) {</span><span class="s3">\n      </span><span class="s1">removeNode(g, buckets, zeroIdx, entry);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while ((entry = sources.dequeue())) {</span><span class="s3">\n      </span><span class="s1">removeNode(g, buckets, zeroIdx, entry);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (g.nodeCount()) {</span><span class="s3">\n      </span><span class="s1">for (var i = buckets.length - 2; i &gt; 0; --i) {</span><span class="s3">\n        </span><span class="s1">entry = buckets[i].dequeue();</span><span class="s3">\n        </span><span class="s1">if (entry) {</span><span class="s3">\n          </span><span class="s1">results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return results;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {</span><span class="s3">\n  </span><span class="s1">var results = collectPredecessors ? [] : undefined;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.inEdges(entry.v), function (edge) {</span><span class="s3">\n    </span><span class="s1">var weight = g.edge(edge);</span><span class="s3">\n    </span><span class="s1">var uEntry = g.node(edge.v);</span><span class="s3">\n\n    </span><span class="s1">if (collectPredecessors) {</span><span class="s3">\n      </span><span class="s1">results.push({ v: edge.v, w: edge.w });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">uEntry.out -= weight;</span><span class="s3">\n    </span><span class="s1">assignBucket(buckets, zeroIdx, uEntry);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.outEdges(entry.v), function (edge) {</span><span class="s3">\n    </span><span class="s1">var weight = g.edge(edge);</span><span class="s3">\n    </span><span class="s1">var w = edge.w;</span><span class="s3">\n    </span><span class="s1">var wEntry = g.node(w);</span><span class="s3">\n    </span><span class="s1">wEntry['in'] -= weight;</span><span class="s3">\n    </span><span class="s1">assignBucket(buckets, zeroIdx, wEntry);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">g.removeNode(entry.v);</span><span class="s3">\n\n  </span><span class="s1">return results;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildState(g, weightFn) {</span><span class="s3">\n  </span><span class="s1">var fasGraph = new Graph();</span><span class="s3">\n  </span><span class="s1">var maxIn = 0;</span><span class="s3">\n  </span><span class="s1">var maxOut = 0;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">fasGraph.setNode(v, { v: v, in: 0, out: 0 });</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Aggregate weights on nodes, but also sum the weights across multi-edges</span><span class="s3">\n  </span><span class="s1">// into a single edge for the fasGraph.</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var prevWeight = fasGraph.edge(e.v, e.w) || 0;</span><span class="s3">\n    </span><span class="s1">var weight = weightFn(e);</span><span class="s3">\n    </span><span class="s1">var edgeWeight = prevWeight + weight;</span><span class="s3">\n    </span><span class="s1">fasGraph.setEdge(e.v, e.w, edgeWeight);</span><span class="s3">\n    </span><span class="s1">maxOut = Math.max(maxOut, (fasGraph.node(e.v).out += weight));</span><span class="s3">\n    </span><span class="s1">maxIn = Math.max(maxIn, (fasGraph.node(e.w)['in'] += weight));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var buckets = _.range(maxOut + maxIn + 3).map(function () {</span><span class="s3">\n    </span><span class="s1">return new List();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var zeroIdx = maxIn + 1;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(fasGraph.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">assignBucket(buckets, zeroIdx, fasGraph.node(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assignBucket(buckets, zeroIdx, entry) {</span><span class="s3">\n  </span><span class="s1">if (!entry.out) {</span><span class="s3">\n    </span><span class="s1">buckets[0].enqueue(entry);</span><span class="s3">\n  </span><span class="s1">} else if (!entry['in']) {</span><span class="s3">\n    </span><span class="s1">buckets[buckets.length - 1].enqueue(entry);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { greedyFAS } from './greedy-fas.js';</span><span class="s3">\n\n</span><span class="s1">export { run, undo };</span><span class="s3">\n\n</span><span class="s1">function run(g) {</span><span class="s3">\n  </span><span class="s1">var fas = g.graph().acyclicer === 'greedy' ? greedyFAS(g, weightFn(g)) : dfsFAS(g);</span><span class="s3">\n  </span><span class="s1">_.forEach(fas, function (e) {</span><span class="s3">\n    </span><span class="s1">var label = g.edge(e);</span><span class="s3">\n    </span><span class="s1">g.removeEdge(e);</span><span class="s3">\n    </span><span class="s1">label.forwardName = e.name;</span><span class="s3">\n    </span><span class="s1">label.reversed = true;</span><span class="s3">\n    </span><span class="s1">g.setEdge(e.w, e.v, label, _.uniqueId('rev'));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">function weightFn(g) {</span><span class="s3">\n    </span><span class="s1">return function (e) {</span><span class="s3">\n      </span><span class="s1">return g.edge(e).weight;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function dfsFAS(g) {</span><span class="s3">\n  </span><span class="s1">var fas = [];</span><span class="s3">\n  </span><span class="s1">var stack = {};</span><span class="s3">\n  </span><span class="s1">var visited = {};</span><span class="s3">\n\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(visited, v)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visited[v] = true;</span><span class="s3">\n    </span><span class="s1">stack[v] = true;</span><span class="s3">\n    </span><span class="s1">_.forEach(g.outEdges(v), function (e) {</span><span class="s3">\n      </span><span class="s1">if (Object.prototype.hasOwnProperty.call(stack, e.w)) {</span><span class="s3">\n        </span><span class="s1">fas.push(e);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dfs(e.w);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">delete stack[v];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodes(), dfs);</span><span class="s3">\n  </span><span class="s1">return fas;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function undo(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var label = g.edge(e);</span><span class="s3">\n    </span><span class="s1">if (label.reversed) {</span><span class="s3">\n      </span><span class="s1">g.removeEdge(e);</span><span class="s3">\n\n      </span><span class="s1">var forwardName = label.forwardName;</span><span class="s3">\n      </span><span class="s1">delete label.reversed;</span><span class="s3">\n      </span><span class="s1">delete label.forwardName;</span><span class="s3">\n      </span><span class="s1">g.setEdge(e.w, e.v, label, forwardName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import basePickBy from './_basePickBy.js';</span><span class="s3">\n</span><span class="s1">import hasIn from './hasIn.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.pick` without support for individual</span><span class="s3">\n </span><span class="s1">* property identifiers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {string[]} paths The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePick(object, paths) {</span><span class="s3">\n  </span><span class="s1">return basePickBy(object, paths, function(value, path) {</span><span class="s3">\n    </span><span class="s1">return hasIn(object, path);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default basePick;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import flatten from './flatten.js';</span><span class="s3">\n</span><span class="s1">import overRest from './_overRest.js';</span><span class="s3">\n</span><span class="s1">import setToString from './_setToString.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseRest` which flattens the rest array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to apply a rest parameter to.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function flatRest(func) {</span><span class="s3">\n  </span><span class="s1">return setToString(overRest(func, undefined, flatten), func + '');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default flatRest;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import basePick from './_basePick.js';</span><span class="s3">\n</span><span class="s1">import flatRest from './_flatRest.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an object composed of the picked `object` properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {...(string|string[])} [paths] The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1, 'b': '2', 'c': 3 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.pick(object, ['a', 'c']);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'c': 3 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var pick = flatRest(function(object, paths) {</span><span class="s3">\n  </span><span class="s1">return object == null ? {} : basePick(object, paths);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default pick;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.gt` which doesn't coerce arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is greater than `other`,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseGt(value, other) {</span><span class="s3">\n  </span><span class="s1">return value &gt; other;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseGt;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseExtremum from './_baseExtremum.js';</span><span class="s3">\n</span><span class="s1">import baseGt from './_baseGt.js';</span><span class="s3">\n</span><span class="s1">import identity from './identity.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Computes the maximum value of `array`. If `array` is empty or falsey,</span><span class="s3">\n </span><span class="s1">* `undefined` is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Math</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the maximum value.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.max([4, 2, 8, 6]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 8</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.max([]);</span><span class="s3">\n </span><span class="s1">* // =&gt; undefined</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function max(array) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length)</span><span class="s3">\n    </span><span class="s1">? baseExtremum(array, identity, baseGt)</span><span class="s3">\n    </span><span class="s1">: undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default max;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseAssignValue from './_baseAssignValue.js';</span><span class="s3">\n</span><span class="s1">import baseForOwn from './_baseForOwn.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an object with the same keys as `object` and values generated</span><span class="s3">\n </span><span class="s1">* by running each own enumerable string keyed property of `object` thru</span><span class="s3">\n </span><span class="s1">* `iteratee`. The iteratee is invoked with three arguments:</span><span class="s3">\n </span><span class="s1">* (value, key, object).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 2.4.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new mapped object.</span><span class="s3">\n </span><span class="s1">* @see _.mapKeys</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = {</span><span class="s3">\n </span><span class="s1">*   'fred':    { 'user': 'fred',    'age': 40 },</span><span class="s3">\n </span><span class="s1">*   'pebbles': { 'user': 'pebbles', 'age': 1 }</span><span class="s3">\n </span><span class="s1">* };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.mapValues(users, function(o) { return o.age; });</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.mapValues(users, 'age');</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapValues(object, iteratee) {</span><span class="s3">\n  </span><span class="s1">var result = {};</span><span class="s3">\n  </span><span class="s1">iteratee = baseIteratee(iteratee, 3);</span><span class="s3">\n\n  </span><span class="s1">baseForOwn(object, function(value, key, object) {</span><span class="s3">\n    </span><span class="s1">baseAssignValue(result, key, iteratee(value, key, object));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default mapValues;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import root from './_root.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the timestamp of the number of milliseconds that have elapsed since</span><span class="s3">\n </span><span class="s1">* the Unix epoch (1 January 1970 00:00:00 UTC).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 2.4.0</span><span class="s3">\n </span><span class="s1">* @category Date</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the timestamp.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.defer(function(stamp) {</span><span class="s3">\n </span><span class="s1">*   console.log(_.now() - stamp);</span><span class="s3">\n </span><span class="s1">* }, _.now());</span><span class="s3">\n </span><span class="s1">* // =&gt; Logs the number of milliseconds it took for the deferred invocation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var now = function() {</span><span class="s3">\n  </span><span class="s1">return root.Date.now();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default now;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../graphlib/index.js';</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">addDummyNode,</span><span class="s3">\n  </span><span class="s1">simplify,</span><span class="s3">\n  </span><span class="s1">asNonCompoundGraph,</span><span class="s3">\n  </span><span class="s1">successorWeights,</span><span class="s3">\n  </span><span class="s1">predecessorWeights,</span><span class="s3">\n  </span><span class="s1">intersectRect,</span><span class="s3">\n  </span><span class="s1">buildLayerMatrix,</span><span class="s3">\n  </span><span class="s1">normalizeRanks,</span><span class="s3">\n  </span><span class="s1">removeEmptyRanks,</span><span class="s3">\n  </span><span class="s1">addBorderNode,</span><span class="s3">\n  </span><span class="s1">maxRank,</span><span class="s3">\n  </span><span class="s1">partition,</span><span class="s3">\n  </span><span class="s1">time,</span><span class="s3">\n  </span><span class="s1">notime,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Adds a dummy node to the graph and return v.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function addDummyNode(g, type, attrs, name) {</span><span class="s3">\n  </span><span class="s1">var v;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">v = _.uniqueId(name);</span><span class="s3">\n  </span><span class="s1">} while (g.hasNode(v));</span><span class="s3">\n\n  </span><span class="s1">attrs.dummy = type;</span><span class="s3">\n  </span><span class="s1">g.setNode(v, attrs);</span><span class="s3">\n  </span><span class="s1">return v;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Returns a new graph with only simple edges. Handles aggregation of data</span><span class="s3">\n </span><span class="s1">* associated with multi-edges.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function simplify(g) {</span><span class="s3">\n  </span><span class="s1">var simplified = new Graph().setGraph(g.graph());</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">simplified.setNode(v, g.node(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };</span><span class="s3">\n    </span><span class="s1">var label = g.edge(e);</span><span class="s3">\n    </span><span class="s1">simplified.setEdge(e.v, e.w, {</span><span class="s3">\n      </span><span class="s1">weight: simpleLabel.weight + label.weight,</span><span class="s3">\n      </span><span class="s1">minlen: Math.max(simpleLabel.minlen, label.minlen),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return simplified;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function asNonCompoundGraph(g) {</span><span class="s3">\n  </span><span class="s1">var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">if (!g.children(v).length) {</span><span class="s3">\n      </span><span class="s1">simplified.setNode(v, g.node(v));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">simplified.setEdge(e, g.edge(e));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return simplified;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function successorWeights(g) {</span><span class="s3">\n  </span><span class="s1">var weightMap = _.map(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var sucs = {};</span><span class="s3">\n    </span><span class="s1">_.forEach(g.outEdges(v), function (e) {</span><span class="s3">\n      </span><span class="s1">sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return sucs;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return _.zipObject(g.nodes(), weightMap);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function predecessorWeights(g) {</span><span class="s3">\n  </span><span class="s1">var weightMap = _.map(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var preds = {};</span><span class="s3">\n    </span><span class="s1">_.forEach(g.inEdges(v), function (e) {</span><span class="s3">\n      </span><span class="s1">preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return preds;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return _.zipObject(g.nodes(), weightMap);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Finds where a line starting at point ({x, y}) would intersect a rectangle</span><span class="s3">\n </span><span class="s1">* ({x, y, width, height}) if it were pointing at the rectangle's center.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function intersectRect(rect, point) {</span><span class="s3">\n  </span><span class="s1">var x = rect.x;</span><span class="s3">\n  </span><span class="s1">var y = rect.y;</span><span class="s3">\n\n  </span><span class="s1">// Rectangle intersection algorithm from:</span><span class="s3">\n  </span><span class="s1">// http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes</span><span class="s3">\n  </span><span class="s1">var dx = point.x - x;</span><span class="s3">\n  </span><span class="s1">var dy = point.y - y;</span><span class="s3">\n  </span><span class="s1">var w = rect.width / 2;</span><span class="s3">\n  </span><span class="s1">var h = rect.height / 2;</span><span class="s3">\n\n  </span><span class="s1">if (!dx &amp;&amp; !dy) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Not possible to find intersection inside of the rectangle');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var sx, sy;</span><span class="s3">\n  </span><span class="s1">if (Math.abs(dy) * w &gt; Math.abs(dx) * h) {</span><span class="s3">\n    </span><span class="s1">// Intersection is top or bottom of rect.</span><span class="s3">\n    </span><span class="s1">if (dy &lt; 0) {</span><span class="s3">\n      </span><span class="s1">h = -h;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sx = (h * dx) / dy;</span><span class="s3">\n    </span><span class="s1">sy = h;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Intersection is left or right of rect.</span><span class="s3">\n    </span><span class="s1">if (dx &lt; 0) {</span><span class="s3">\n      </span><span class="s1">w = -w;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sx = w;</span><span class="s3">\n    </span><span class="s1">sy = (w * dy) / dx;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { x: x + sx, y: y + sy };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Given a DAG with each node assigned </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">order</span><span class="s3">\&quot; </span><span class="s1">properties, this</span><span class="s3">\n </span><span class="s1">* function will produce a matrix with the ids of each node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildLayerMatrix(g) {</span><span class="s3">\n  </span><span class="s1">var layering = _.map(_.range(maxRank(g) + 1), function () {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">var rank = node.rank;</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(rank)) {</span><span class="s3">\n      </span><span class="s1">layering[rank][node.order] = v;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return layering;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Adjusts the ranks for all nodes in the graph such that all nodes v have</span><span class="s3">\n </span><span class="s1">* rank(v) &gt;= 0 and at least one node w has rank(w) = 0.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function normalizeRanks(g) {</span><span class="s3">\n  </span><span class="s1">var min = _.min(</span><span class="s3">\n    </span><span class="s1">_.map(g.nodes(), function (v) {</span><span class="s3">\n      </span><span class="s1">return g.node(v).rank;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">if (_.has(node, 'rank')) {</span><span class="s3">\n      </span><span class="s1">node.rank -= min;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeEmptyRanks(g) {</span><span class="s3">\n  </span><span class="s1">// Ranks may not start at 0, so we need to offset them</span><span class="s3">\n  </span><span class="s1">var offset = _.min(</span><span class="s3">\n    </span><span class="s1">_.map(g.nodes(), function (v) {</span><span class="s3">\n      </span><span class="s1">return g.node(v).rank;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">var layers = [];</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var rank = g.node(v).rank - offset;</span><span class="s3">\n    </span><span class="s1">if (!layers[rank]) {</span><span class="s3">\n      </span><span class="s1">layers[rank] = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">layers[rank].push(v);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var delta = 0;</span><span class="s3">\n  </span><span class="s1">var nodeRankFactor = g.graph().nodeRankFactor;</span><span class="s3">\n  </span><span class="s1">_.forEach(layers, function (vs, i) {</span><span class="s3">\n    </span><span class="s1">if (_.isUndefined(vs) &amp;&amp; i % nodeRankFactor !== 0) {</span><span class="s3">\n      </span><span class="s1">--delta;</span><span class="s3">\n    </span><span class="s1">} else if (delta) {</span><span class="s3">\n      </span><span class="s1">_.forEach(vs, function (v) {</span><span class="s3">\n        </span><span class="s1">g.node(v).rank += delta;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addBorderNode(g, prefix, rank, order) {</span><span class="s3">\n  </span><span class="s1">var node = {</span><span class="s3">\n    </span><span class="s1">width: 0,</span><span class="s3">\n    </span><span class="s1">height: 0,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (arguments.length &gt;= 4) {</span><span class="s3">\n    </span><span class="s1">node.rank = rank;</span><span class="s3">\n    </span><span class="s1">node.order = order;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return addDummyNode(g, 'border', node, prefix);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function maxRank(g) {</span><span class="s3">\n  </span><span class="s1">return _.max(</span><span class="s3">\n    </span><span class="s1">_.map(g.nodes(), function (v) {</span><span class="s3">\n      </span><span class="s1">var rank = g.node(v).rank;</span><span class="s3">\n      </span><span class="s1">if (!_.isUndefined(rank)) {</span><span class="s3">\n        </span><span class="s1">return rank;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Partition a collection into two groups: `lhs` and `rhs`. If the supplied</span><span class="s3">\n </span><span class="s1">* function returns true for an entry it goes into `lhs`. Otherwise it goes</span><span class="s3">\n </span><span class="s1">* into `rhs.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function partition(collection, fn) {</span><span class="s3">\n  </span><span class="s1">var result = { lhs: [], rhs: [] };</span><span class="s3">\n  </span><span class="s1">_.forEach(collection, function (value) {</span><span class="s3">\n    </span><span class="s1">if (fn(value)) {</span><span class="s3">\n      </span><span class="s1">result.lhs.push(value);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">result.rhs.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Returns a new function that wraps `fn` with a timer. The wrapper logs the</span><span class="s3">\n </span><span class="s1">* time it takes to execute the function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function time(name, fn) {</span><span class="s3">\n  </span><span class="s1">var start = _.now();</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return fn();</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">console.log(name + ' time: ' + (_.now() - start) + 'ms');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function notime(name, fn) {</span><span class="s3">\n  </span><span class="s1">return fn();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import * as util from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { addBorderSegments };</span><span class="s3">\n\n</span><span class="s1">function addBorderSegments(g) {</span><span class="s3">\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">var children = g.children(v);</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">if (children.length) {</span><span class="s3">\n      </span><span class="s1">_.forEach(children, dfs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(node, 'minRank')) {</span><span class="s3">\n      </span><span class="s1">node.borderLeft = [];</span><span class="s3">\n      </span><span class="s1">node.borderRight = [];</span><span class="s3">\n      </span><span class="s1">for (var rank = node.minRank, maxRank = node.maxRank + 1; rank &lt; maxRank; ++rank) {</span><span class="s3">\n        </span><span class="s1">addBorderNode(g, 'borderLeft', '_bl', v, node, rank);</span><span class="s3">\n        </span><span class="s1">addBorderNode(g, 'borderRight', '_br', v, node, rank);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.children(), dfs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addBorderNode(g, prop, prefix, sg, sgNode, rank) {</span><span class="s3">\n  </span><span class="s1">var label = { width: 0, height: 0, rank: rank, borderType: prop };</span><span class="s3">\n  </span><span class="s1">var prev = sgNode[prop][rank - 1];</span><span class="s3">\n  </span><span class="s1">var curr = util.addDummyNode(g, 'border', label, prefix);</span><span class="s3">\n  </span><span class="s1">sgNode[prop][rank] = curr;</span><span class="s3">\n  </span><span class="s1">g.setParent(curr, sg);</span><span class="s3">\n  </span><span class="s1">if (prev) {</span><span class="s3">\n    </span><span class="s1">g.setEdge(prev, curr, { weight: 1 });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { adjust, undo };</span><span class="s3">\n\n</span><span class="s1">function adjust(g) {</span><span class="s3">\n  </span><span class="s1">var rankDir = g.graph().rankdir.toLowerCase();</span><span class="s3">\n  </span><span class="s1">if (rankDir === 'lr' || rankDir === 'rl') {</span><span class="s3">\n    </span><span class="s1">swapWidthHeight(g);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function undo(g) {</span><span class="s3">\n  </span><span class="s1">var rankDir = g.graph().rankdir.toLowerCase();</span><span class="s3">\n  </span><span class="s1">if (rankDir === 'bt' || rankDir === 'rl') {</span><span class="s3">\n    </span><span class="s1">reverseY(g);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (rankDir === 'lr' || rankDir === 'rl') {</span><span class="s3">\n    </span><span class="s1">swapXY(g);</span><span class="s3">\n    </span><span class="s1">swapWidthHeight(g);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function swapWidthHeight(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">swapWidthHeightOne(g.node(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">swapWidthHeightOne(g.edge(e));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function swapWidthHeightOne(attrs) {</span><span class="s3">\n  </span><span class="s1">var w = attrs.width;</span><span class="s3">\n  </span><span class="s1">attrs.width = attrs.height;</span><span class="s3">\n  </span><span class="s1">attrs.height = w;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function reverseY(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">reverseYOne(g.node(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">_.forEach(edge.points, reverseYOne);</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(edge, 'y')) {</span><span class="s3">\n      </span><span class="s1">reverseYOne(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function reverseYOne(attrs) {</span><span class="s3">\n  </span><span class="s1">attrs.y = -attrs.y;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function swapXY(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">swapXYOne(g.node(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">_.forEach(edge.points, swapXYOne);</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(edge, 'x')) {</span><span class="s3">\n      </span><span class="s1">swapXYOne(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function swapXYOne(attrs) {</span><span class="s3">\n  </span><span class="s1">var x = attrs.x;</span><span class="s3">\n  </span><span class="s1">attrs.x = attrs.y;</span><span class="s3">\n  </span><span class="s1">attrs.y = x;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* TypeScript type imports:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @import { Graph } from '../graphlib/graph.js';</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import * as util from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { run, undo };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Breaks any long edges in the graph into short segments that span 1 layer</span><span class="s3">\n </span><span class="s1">* each. This operation is undoable with the denormalize function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. The input graph is a DAG.</span><span class="s3">\n </span><span class="s1">*    2. Each node in the graph has a </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">property.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-condition:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. All edges in the graph have a length of 1.</span><span class="s3">\n </span><span class="s1">*    2. Dummy nodes are added where edges have been split into segments.</span><span class="s3">\n </span><span class="s1">*    3. The graph is augmented with a </span><span class="s3">\&quot;</span><span class="s1">dummyChains</span><span class="s3">\&quot; </span><span class="s1">attribute which contains</span><span class="s3">\n </span><span class="s1">*       the first dummy in each chain of dummy nodes produced.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function run(g) {</span><span class="s3">\n  </span><span class="s1">g.graph().dummyChains = [];</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (edge) {</span><span class="s3">\n    </span><span class="s1">normalizeEdge(g, edge);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Graph} g</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function normalizeEdge(g, e) {</span><span class="s3">\n  </span><span class="s1">var v = e.v;</span><span class="s3">\n  </span><span class="s1">var vRank = g.node(v).rank;</span><span class="s3">\n  </span><span class="s1">var w = e.w;</span><span class="s3">\n  </span><span class="s1">var wRank = g.node(w).rank;</span><span class="s3">\n  </span><span class="s1">var name = e.name;</span><span class="s3">\n  </span><span class="s1">var edgeLabel = g.edge(e);</span><span class="s3">\n  </span><span class="s1">var labelRank = edgeLabel.labelRank;</span><span class="s3">\n\n  </span><span class="s1">if (wRank === vRank + 1) return;</span><span class="s3">\n\n  </span><span class="s1">g.removeEdge(e);</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @typedef {Object} Attrs</span><span class="s3">\n   </span><span class="s1">* @property {number} width</span><span class="s3">\n   </span><span class="s1">* @property {number} height</span><span class="s3">\n   </span><span class="s1">* @property {ReturnType&lt;Graph[</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">]&gt;} edgeLabel</span><span class="s3">\n   </span><span class="s1">* @property {any} edgeObj</span><span class="s3">\n   </span><span class="s1">* @property {ReturnType&lt;Graph[</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">]&gt;[</span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot;</span><span class="s1">]} rank</span><span class="s3">\n   </span><span class="s1">* @property {string} [dummy]</span><span class="s3">\n   </span><span class="s1">* @property {ReturnType&lt;Graph[</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">]&gt;[</span><span class="s3">\&quot;</span><span class="s1">labelpos</span><span class="s3">\&quot;</span><span class="s1">]} [labelpos]</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">/** @type {Attrs | undefined} */</span><span class="s3">\n  </span><span class="s1">var attrs = undefined;</span><span class="s3">\n  </span><span class="s1">var dummy, i;</span><span class="s3">\n  </span><span class="s1">for (i = 0, ++vRank; vRank &lt; wRank; ++i, ++vRank) {</span><span class="s3">\n    </span><span class="s1">edgeLabel.points = [];</span><span class="s3">\n    </span><span class="s1">attrs = {</span><span class="s3">\n      </span><span class="s1">width: 0,</span><span class="s3">\n      </span><span class="s1">height: 0,</span><span class="s3">\n      </span><span class="s1">edgeLabel: edgeLabel,</span><span class="s3">\n      </span><span class="s1">edgeObj: e,</span><span class="s3">\n      </span><span class="s1">rank: vRank,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">dummy = util.addDummyNode(g, 'edge', attrs, '_d');</span><span class="s3">\n    </span><span class="s1">if (vRank === labelRank) {</span><span class="s3">\n      </span><span class="s1">attrs.width = edgeLabel.width;</span><span class="s3">\n      </span><span class="s1">attrs.height = edgeLabel.height;</span><span class="s3">\n      </span><span class="s1">attrs.dummy = 'edge-label';</span><span class="s3">\n      </span><span class="s1">attrs.labelpos = edgeLabel.labelpos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);</span><span class="s3">\n    </span><span class="s1">if (i === 0) {</span><span class="s3">\n      </span><span class="s1">g.graph().dummyChains.push(dummy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">v = dummy;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">g.setEdge(v, w, { weight: edgeLabel.weight }, name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function undo(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.graph().dummyChains, function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">var origLabel = node.edgeLabel;</span><span class="s3">\n    </span><span class="s1">var w;</span><span class="s3">\n    </span><span class="s1">g.setEdge(node.edgeObj, origLabel);</span><span class="s3">\n    </span><span class="s1">while (node.dummy) {</span><span class="s3">\n      </span><span class="s1">w = g.successors(v)[0];</span><span class="s3">\n      </span><span class="s1">g.removeNode(v);</span><span class="s3">\n      </span><span class="s1">origLabel.points.push({ x: node.x, y: node.y });</span><span class="s3">\n      </span><span class="s1">if (node.dummy === 'edge-label') {</span><span class="s3">\n        </span><span class="s1">origLabel.x = node.x;</span><span class="s3">\n        </span><span class="s1">origLabel.y = node.y;</span><span class="s3">\n        </span><span class="s1">origLabel.width = node.width;</span><span class="s3">\n        </span><span class="s1">origLabel.height = node.height;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">v = w;</span><span class="s3">\n      </span><span class="s1">node = g.node(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseExtremum from './_baseExtremum.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import baseLt from './_baseLt.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.min` except that it accepts `iteratee` which is</span><span class="s3">\n </span><span class="s1">* invoked for each element in `array` to generate the criterion by which</span><span class="s3">\n </span><span class="s1">* the value is ranked. The iteratee is invoked with one argument: (value).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Math</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the minimum value.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [{ 'n': 1 }, { 'n': 2 }];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.minBy(objects, function(o) { return o.n; });</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'n': 1 }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.minBy(objects, 'n');</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'n': 1 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function minBy(array, iteratee) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length)</span><span class="s3">\n    </span><span class="s1">? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)</span><span class="s3">\n    </span><span class="s1">: undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default minBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { longestPath, slack };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Initializes ranks for the input graph using the longest path algorithm. This</span><span class="s3">\n </span><span class="s1">* algorithm scales well and is fast in practice, it yields rather poor</span><span class="s3">\n </span><span class="s1">* solutions. Nodes are pushed to the lowest layer possible, leaving the bottom</span><span class="s3">\n </span><span class="s1">* ranks wide and leaving edges longer than necessary. However, due to its</span><span class="s3">\n </span><span class="s1">* speed, this algorithm is good for getting an initial ranking that can be fed</span><span class="s3">\n </span><span class="s1">* into other algorithms.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This algorithm does not normalize layers because it will be used by other</span><span class="s3">\n </span><span class="s1">* algorithms in most cases. If using this algorithm directly, be sure to</span><span class="s3">\n </span><span class="s1">* run normalize at the end.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Input graph is a DAG.</span><span class="s3">\n </span><span class="s1">*    2. Input graph node labels can be assigned properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Each node will be assign an (unnormalized) </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">property.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function longestPath(g) {</span><span class="s3">\n  </span><span class="s1">var visited = {};</span><span class="s3">\n\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">var label = g.node(v);</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(visited, v)) {</span><span class="s3">\n      </span><span class="s1">return label.rank;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visited[v] = true;</span><span class="s3">\n\n    </span><span class="s1">var rank = _.min(</span><span class="s3">\n      </span><span class="s1">_.map(g.outEdges(v), function (e) {</span><span class="s3">\n        </span><span class="s1">return dfs(e.w) - g.edge(e).minlen;</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3</span><span class="s3">\n      </span><span class="s1">rank === undefined || // return value of _.map([]) for Lodash 4</span><span class="s3">\n      </span><span class="s1">rank === null</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// return value of _.map([null])</span><span class="s3">\n      </span><span class="s1">rank = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return (label.rank = rank);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.sources(), dfs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Returns the amount of slack for the given edge. The slack is defined as the</span><span class="s3">\n </span><span class="s1">* difference between the length of the edge and its minimum length.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function slack(g, e) {</span><span class="s3">\n  </span><span class="s1">return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../../graphlib/index.js';</span><span class="s3">\n</span><span class="s1">import { slack } from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { feasibleTree };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Constructs a spanning tree with tight edges and adjusted the input node's</span><span class="s3">\n </span><span class="s1">* ranks to achieve this. A tight edge is one that is has a length that matches</span><span class="s3">\n </span><span class="s1">* its </span><span class="s3">\&quot;</span><span class="s1">minlen</span><span class="s3">\&quot; </span><span class="s1">attribute.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The basic structure for this function is derived from Gansner, et al., </span><span class="s3">\&quot;</span><span class="s1">A</span><span class="s3">\n </span><span class="s1">* Technique for Drawing Directed Graphs.</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Graph must be a DAG.</span><span class="s3">\n </span><span class="s1">*    2. Graph must be connected.</span><span class="s3">\n </span><span class="s1">*    3. Graph must have at least one node.</span><span class="s3">\n </span><span class="s1">*    5. Graph nodes must have been previously assigned a </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">property that</span><span class="s3">\n </span><span class="s1">*       respects the </span><span class="s3">\&quot;</span><span class="s1">minlen</span><span class="s3">\&quot; </span><span class="s1">property of incident edges.</span><span class="s3">\n </span><span class="s1">*    6. Graph edges must have a </span><span class="s3">\&quot;</span><span class="s1">minlen</span><span class="s3">\&quot; </span><span class="s1">property.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    - Graph nodes will have their rank adjusted to ensure that all edges are</span><span class="s3">\n </span><span class="s1">*      tight.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returns a tree (undirected graph) that is constructed using only </span><span class="s3">\&quot;</span><span class="s1">tight</span><span class="s3">\&quot;\n </span><span class="s1">* edges.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function feasibleTree(g) {</span><span class="s3">\n  </span><span class="s1">var t = new Graph({ directed: false });</span><span class="s3">\n\n  </span><span class="s1">// Choose arbitrary node from which to start our tree</span><span class="s3">\n  </span><span class="s1">var start = g.nodes()[0];</span><span class="s3">\n  </span><span class="s1">var size = g.nodeCount();</span><span class="s3">\n  </span><span class="s1">t.setNode(start, {});</span><span class="s3">\n\n  </span><span class="s1">var edge, delta;</span><span class="s3">\n  </span><span class="s1">while (tightTree(t, g) &lt; size) {</span><span class="s3">\n    </span><span class="s1">edge = findMinSlackEdge(t, g);</span><span class="s3">\n    </span><span class="s1">delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);</span><span class="s3">\n    </span><span class="s1">shiftRanks(t, g, delta);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return t;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Finds a maximal tree of tight edges and returns the number of nodes in the</span><span class="s3">\n </span><span class="s1">* tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function tightTree(t, g) {</span><span class="s3">\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">_.forEach(g.nodeEdges(v), function (e) {</span><span class="s3">\n      </span><span class="s1">var edgeV = e.v,</span><span class="s3">\n        </span><span class="s1">w = v === edgeV ? e.w : edgeV;</span><span class="s3">\n      </span><span class="s1">if (!t.hasNode(w) &amp;&amp; !slack(g, e)) {</span><span class="s3">\n        </span><span class="s1">t.setNode(w, {});</span><span class="s3">\n        </span><span class="s1">t.setEdge(v, w, {});</span><span class="s3">\n        </span><span class="s1">dfs(w);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.forEach(t.nodes(), dfs);</span><span class="s3">\n  </span><span class="s1">return t.nodeCount();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Finds the edge with the smallest slack that is incident on tree and returns</span><span class="s3">\n </span><span class="s1">* it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findMinSlackEdge(t, g) {</span><span class="s3">\n  </span><span class="s1">return _.minBy(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">if (t.hasNode(e.v) !== t.hasNode(e.w)) {</span><span class="s3">\n      </span><span class="s1">return slack(g, e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shiftRanks(t, g, delta) {</span><span class="s3">\n  </span><span class="s1">_.forEach(t.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">g.node(v).rank += delta;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { PriorityQueue } from '../data/priority-queue.js';</span><span class="s3">\n\n</span><span class="s1">export { dijkstra };</span><span class="s3">\n\n</span><span class="s1">var DEFAULT_WEIGHT_FUNC = _.constant(1);</span><span class="s3">\n\n</span><span class="s1">function dijkstra(g, source, weightFn, edgeFn) {</span><span class="s3">\n  </span><span class="s1">return runDijkstra(</span><span class="s3">\n    </span><span class="s1">g,</span><span class="s3">\n    </span><span class="s1">String(source),</span><span class="s3">\n    </span><span class="s1">weightFn || DEFAULT_WEIGHT_FUNC,</span><span class="s3">\n    </span><span class="s1">edgeFn ||</span><span class="s3">\n      </span><span class="s1">function (v) {</span><span class="s3">\n        </span><span class="s1">return g.outEdges(v);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function runDijkstra(g, source, weightFn, edgeFn) {</span><span class="s3">\n  </span><span class="s1">var results = {};</span><span class="s3">\n  </span><span class="s1">var pq = new PriorityQueue();</span><span class="s3">\n  </span><span class="s1">var v, vEntry;</span><span class="s3">\n\n  </span><span class="s1">var updateNeighbors = function (edge) {</span><span class="s3">\n    </span><span class="s1">var w = edge.v !== v ? edge.v : edge.w;</span><span class="s3">\n    </span><span class="s1">var wEntry = results[w];</span><span class="s3">\n    </span><span class="s1">var weight = weightFn(edge);</span><span class="s3">\n    </span><span class="s1">var distance = vEntry.distance + weight;</span><span class="s3">\n\n    </span><span class="s1">if (weight &lt; 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'dijkstra does not allow negative edge weights. ' +</span><span class="s3">\n          </span><span class="s1">'Bad edge: ' +</span><span class="s3">\n          </span><span class="s1">edge +</span><span class="s3">\n          </span><span class="s1">' Weight: ' +</span><span class="s3">\n          </span><span class="s1">weight,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (distance &lt; wEntry.distance) {</span><span class="s3">\n      </span><span class="s1">wEntry.distance = distance;</span><span class="s3">\n      </span><span class="s1">wEntry.predecessor = v;</span><span class="s3">\n      </span><span class="s1">pq.decrease(w, distance);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">g.nodes().forEach(function (v) {</span><span class="s3">\n    </span><span class="s1">var distance = v === source ? 0 : Number.POSITIVE_INFINITY;</span><span class="s3">\n    </span><span class="s1">results[v] = { distance: distance };</span><span class="s3">\n    </span><span class="s1">pq.add(v, distance);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">while (pq.size() &gt; 0) {</span><span class="s3">\n    </span><span class="s1">v = pq.removeMin();</span><span class="s3">\n    </span><span class="s1">vEntry = results[v];</span><span class="s3">\n    </span><span class="s1">if (vEntry.distance === Number.POSITIVE_INFINITY) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edgeFn(v).forEach(updateNeighbors);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return results;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { dijkstra } from './dijkstra.js';</span><span class="s3">\n\n</span><span class="s1">export { dijkstraAll };</span><span class="s3">\n\n</span><span class="s1">function dijkstraAll(g, weightFunc, edgeFunc) {</span><span class="s3">\n  </span><span class="s1">return _.transform(</span><span class="s3">\n    </span><span class="s1">g.nodes(),</span><span class="s3">\n    </span><span class="s1">function (acc, v) {</span><span class="s3">\n      </span><span class="s1">acc[v] = dijkstra(g, v, weightFunc, edgeFunc);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{},</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { floydWarshall };</span><span class="s3">\n\n</span><span class="s1">var DEFAULT_WEIGHT_FUNC = _.constant(1);</span><span class="s3">\n\n</span><span class="s1">function floydWarshall(g, weightFn, edgeFn) {</span><span class="s3">\n  </span><span class="s1">return runFloydWarshall(</span><span class="s3">\n    </span><span class="s1">g,</span><span class="s3">\n    </span><span class="s1">weightFn || DEFAULT_WEIGHT_FUNC,</span><span class="s3">\n    </span><span class="s1">edgeFn ||</span><span class="s3">\n      </span><span class="s1">function (v) {</span><span class="s3">\n        </span><span class="s1">return g.outEdges(v);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function runFloydWarshall(g, weightFn, edgeFn) {</span><span class="s3">\n  </span><span class="s1">var results = {};</span><span class="s3">\n  </span><span class="s1">var nodes = g.nodes();</span><span class="s3">\n\n  </span><span class="s1">nodes.forEach(function (v) {</span><span class="s3">\n    </span><span class="s1">results[v] = {};</span><span class="s3">\n    </span><span class="s1">results[v][v] = { distance: 0 };</span><span class="s3">\n    </span><span class="s1">nodes.forEach(function (w) {</span><span class="s3">\n      </span><span class="s1">if (v !== w) {</span><span class="s3">\n        </span><span class="s1">results[v][w] = { distance: Number.POSITIVE_INFINITY };</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">edgeFn(v).forEach(function (edge) {</span><span class="s3">\n      </span><span class="s1">var w = edge.v === v ? edge.w : edge.v;</span><span class="s3">\n      </span><span class="s1">var d = weightFn(edge);</span><span class="s3">\n      </span><span class="s1">results[v][w] = { distance: d, predecessor: v };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">nodes.forEach(function (k) {</span><span class="s3">\n    </span><span class="s1">var rowK = results[k];</span><span class="s3">\n    </span><span class="s1">nodes.forEach(function (i) {</span><span class="s3">\n      </span><span class="s1">var rowI = results[i];</span><span class="s3">\n      </span><span class="s1">nodes.forEach(function (j) {</span><span class="s3">\n        </span><span class="s1">var ik = rowI[k];</span><span class="s3">\n        </span><span class="s1">var kj = rowK[j];</span><span class="s3">\n        </span><span class="s1">var ij = rowI[j];</span><span class="s3">\n        </span><span class="s1">var altDistance = ik.distance + kj.distance;</span><span class="s3">\n        </span><span class="s1">if (altDistance &lt; ij.distance) {</span><span class="s3">\n          </span><span class="s1">ij.distance = altDistance;</span><span class="s3">\n          </span><span class="s1">ij.predecessor = kj.predecessor;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return results;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseProperty from './_baseProperty.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the size of an ASCII `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the string size.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var asciiSize = baseProperty('length');</span><span class="s3">\n\n</span><span class="s1">export default asciiSize;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to compose unicode character classes. */</span><span class="s3">\n</span><span class="s1">var rsAstralRange = '</span><span class="s3">\\\\</span><span class="s1">ud800-</span><span class="s3">\\\\</span><span class="s1">udfff',</span><span class="s3">\n    </span><span class="s1">rsComboMarksRange = '</span><span class="s3">\\\\</span><span class="s1">u0300-</span><span class="s3">\\\\</span><span class="s1">u036f',</span><span class="s3">\n    </span><span class="s1">reComboHalfMarksRange = '</span><span class="s3">\\\\</span><span class="s1">ufe20-</span><span class="s3">\\\\</span><span class="s1">ufe2f',</span><span class="s3">\n    </span><span class="s1">rsComboSymbolsRange = '</span><span class="s3">\\\\</span><span class="s1">u20d0-</span><span class="s3">\\\\</span><span class="s1">u20ff',</span><span class="s3">\n    </span><span class="s1">rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,</span><span class="s3">\n    </span><span class="s1">rsVarRange = '</span><span class="s3">\\\\</span><span class="s1">ufe0e</span><span class="s3">\\\\</span><span class="s1">ufe0f';</span><span class="s3">\n\n</span><span class="s1">/** Used to compose unicode capture groups. */</span><span class="s3">\n</span><span class="s1">var rsZWJ = '</span><span class="s3">\\\\</span><span class="s1">u200d';</span><span class="s3">\n\n</span><span class="s1">/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */</span><span class="s3">\n</span><span class="s1">var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `string` contains Unicode symbols.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if a symbol is found, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasUnicode(string) {</span><span class="s3">\n  </span><span class="s1">return reHasUnicode.test(string);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default hasUnicode;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to compose unicode character classes. */</span><span class="s3">\n</span><span class="s1">var rsAstralRange = '</span><span class="s3">\\\\</span><span class="s1">ud800-</span><span class="s3">\\\\</span><span class="s1">udfff',</span><span class="s3">\n    </span><span class="s1">rsComboMarksRange = '</span><span class="s3">\\\\</span><span class="s1">u0300-</span><span class="s3">\\\\</span><span class="s1">u036f',</span><span class="s3">\n    </span><span class="s1">reComboHalfMarksRange = '</span><span class="s3">\\\\</span><span class="s1">ufe20-</span><span class="s3">\\\\</span><span class="s1">ufe2f',</span><span class="s3">\n    </span><span class="s1">rsComboSymbolsRange = '</span><span class="s3">\\\\</span><span class="s1">u20d0-</span><span class="s3">\\\\</span><span class="s1">u20ff',</span><span class="s3">\n    </span><span class="s1">rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,</span><span class="s3">\n    </span><span class="s1">rsVarRange = '</span><span class="s3">\\\\</span><span class="s1">ufe0e</span><span class="s3">\\\\</span><span class="s1">ufe0f';</span><span class="s3">\n\n</span><span class="s1">/** Used to compose unicode capture groups. */</span><span class="s3">\n</span><span class="s1">var rsAstral = '[' + rsAstralRange + ']',</span><span class="s3">\n    </span><span class="s1">rsCombo = '[' + rsComboRange + ']',</span><span class="s3">\n    </span><span class="s1">rsFitz = '</span><span class="s3">\\\\</span><span class="s1">ud83c[</span><span class="s3">\\\\</span><span class="s1">udffb-</span><span class="s3">\\\\</span><span class="s1">udfff]',</span><span class="s3">\n    </span><span class="s1">rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',</span><span class="s3">\n    </span><span class="s1">rsNonAstral = '[^' + rsAstralRange + ']',</span><span class="s3">\n    </span><span class="s1">rsRegional = '(?:</span><span class="s3">\\\\</span><span class="s1">ud83c[</span><span class="s3">\\\\</span><span class="s1">udde6-</span><span class="s3">\\\\</span><span class="s1">uddff]){2}',</span><span class="s3">\n    </span><span class="s1">rsSurrPair = '[</span><span class="s3">\\\\</span><span class="s1">ud800-</span><span class="s3">\\\\</span><span class="s1">udbff][</span><span class="s3">\\\\</span><span class="s1">udc00-</span><span class="s3">\\\\</span><span class="s1">udfff]',</span><span class="s3">\n    </span><span class="s1">rsZWJ = '</span><span class="s3">\\\\</span><span class="s1">u200d';</span><span class="s3">\n\n</span><span class="s1">/** Used to compose unicode regexes. */</span><span class="s3">\n</span><span class="s1">var reOptMod = rsModifier + '?',</span><span class="s3">\n    </span><span class="s1">rsOptVar = '[' + rsVarRange + ']?',</span><span class="s3">\n    </span><span class="s1">rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',</span><span class="s3">\n    </span><span class="s1">rsSeq = rsOptVar + reOptMod + rsOptJoin,</span><span class="s3">\n    </span><span class="s1">rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';</span><span class="s3">\n\n</span><span class="s1">/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */</span><span class="s3">\n</span><span class="s1">var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the size of a Unicode `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the string size.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function unicodeSize(string) {</span><span class="s3">\n  </span><span class="s1">var result = reUnicode.lastIndex = 0;</span><span class="s3">\n  </span><span class="s1">while (reUnicode.test(string)) {</span><span class="s3">\n    </span><span class="s1">++result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default unicodeSize;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import asciiSize from './_asciiSize.js';</span><span class="s3">\n</span><span class="s1">import hasUnicode from './_hasUnicode.js';</span><span class="s3">\n</span><span class="s1">import unicodeSize from './_unicodeSize.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the number of symbols in `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the string size.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stringSize(string) {</span><span class="s3">\n  </span><span class="s1">return hasUnicode(string)</span><span class="s3">\n    </span><span class="s1">? unicodeSize(string)</span><span class="s3">\n    </span><span class="s1">: asciiSize(string);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default stringSize;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseKeys from './_baseKeys.js';</span><span class="s3">\n</span><span class="s1">import getTag from './_getTag.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n</span><span class="s1">import isString from './isString.js';</span><span class="s3">\n</span><span class="s1">import stringSize from './_stringSize.js';</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var mapTag = '[object Map]',</span><span class="s3">\n    </span><span class="s1">setTag = '[object Set]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the size of `collection` by returning its length for array-like</span><span class="s3">\n </span><span class="s1">* values or the number of own enumerable string keyed properties for objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object|string} collection The collection to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the collection size.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.size([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.size({ 'a': 1, 'b': 2 });</span><span class="s3">\n </span><span class="s1">* // =&gt; 2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.size('pebbles');</span><span class="s3">\n </span><span class="s1">* // =&gt; 7</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function size(collection) {</span><span class="s3">\n  </span><span class="s1">if (collection == null) {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isArrayLike(collection)) {</span><span class="s3">\n    </span><span class="s1">return isString(collection) ? stringSize(collection) : collection.length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var tag = getTag(collection);</span><span class="s3">\n  </span><span class="s1">if (tag == mapTag || tag == setTag) {</span><span class="s3">\n    </span><span class="s1">return collection.size;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseKeys(collection).length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default size;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { topsort, CycleException };</span><span class="s3">\n\n</span><span class="s1">topsort.CycleException = CycleException;</span><span class="s3">\n\n</span><span class="s1">function topsort(g) {</span><span class="s3">\n  </span><span class="s1">var visited = {};</span><span class="s3">\n  </span><span class="s1">var stack = {};</span><span class="s3">\n  </span><span class="s1">var results = [];</span><span class="s3">\n\n  </span><span class="s1">function visit(node) {</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(stack, node)) {</span><span class="s3">\n      </span><span class="s1">throw new CycleException();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(visited, node)) {</span><span class="s3">\n      </span><span class="s1">stack[node] = true;</span><span class="s3">\n      </span><span class="s1">visited[node] = true;</span><span class="s3">\n      </span><span class="s1">_.each(g.predecessors(node), visit);</span><span class="s3">\n      </span><span class="s1">delete stack[node];</span><span class="s3">\n      </span><span class="s1">results.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.each(g.sinks(), visit);</span><span class="s3">\n\n  </span><span class="s1">if (_.size(visited) !== g.nodeCount()) {</span><span class="s3">\n    </span><span class="s1">throw new CycleException();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return results;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function CycleException() {}</span><span class="s3">\n</span><span class="s1">CycleException.prototype = new Error(); // must be an instance of Error to pass testing</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { topsort, CycleException } from './topsort.js';</span><span class="s3">\n\n</span><span class="s1">export { isAcyclic };</span><span class="s3">\n\n</span><span class="s1">function isAcyclic(g) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">topsort(g);</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">if (e instanceof CycleException) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw e;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { dfs };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* A helper that preforms a pre- or post-order traversal on the input graph</span><span class="s3">\n </span><span class="s1">* and returns the nodes in the order they were visited. If the graph is</span><span class="s3">\n </span><span class="s1">* undirected then this algorithm will navigate using neighbors. If the graph</span><span class="s3">\n </span><span class="s1">* is directed then this algorithm will navigate using successors.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Order must be one of </span><span class="s3">\&quot;</span><span class="s1">pre</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">post</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function dfs(g, vs, order) {</span><span class="s3">\n  </span><span class="s1">if (!_.isArray(vs)) {</span><span class="s3">\n    </span><span class="s1">vs = [vs];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);</span><span class="s3">\n\n  </span><span class="s1">var acc = [];</span><span class="s3">\n  </span><span class="s1">var visited = {};</span><span class="s3">\n  </span><span class="s1">_.each(vs, function (v) {</span><span class="s3">\n    </span><span class="s1">if (!g.hasNode(v)) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Graph does not have node: ' + v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">doDfs(g, v, order === 'post', visited, navigation, acc);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return acc;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function doDfs(g, v, postorder, visited, navigation, acc) {</span><span class="s3">\n  </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(visited, v)) {</span><span class="s3">\n    </span><span class="s1">visited[v] = true;</span><span class="s3">\n\n    </span><span class="s1">if (!postorder) {</span><span class="s3">\n      </span><span class="s1">acc.push(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_.each(navigation(v), function (w) {</span><span class="s3">\n      </span><span class="s1">doDfs(g, w, postorder, visited, navigation, acc);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (postorder) {</span><span class="s3">\n      </span><span class="s1">acc.push(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { dfs } from './dfs.js';</span><span class="s3">\n\n</span><span class="s1">export { postorder };</span><span class="s3">\n\n</span><span class="s1">function postorder(g, vs) {</span><span class="s3">\n  </span><span class="s1">return dfs(g, vs, 'post');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { dfs } from './dfs.js';</span><span class="s3">\n\n</span><span class="s1">export { preorder };</span><span class="s3">\n\n</span><span class="s1">function preorder(g, vs) {</span><span class="s3">\n  </span><span class="s1">return dfs(g, vs, 'pre');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { PriorityQueue } from '../data/priority-queue.js';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../graph.js';</span><span class="s3">\n\n</span><span class="s1">export { prim };</span><span class="s3">\n\n</span><span class="s1">function prim(g, weightFunc) {</span><span class="s3">\n  </span><span class="s1">var result = new Graph();</span><span class="s3">\n  </span><span class="s1">var parents = {};</span><span class="s3">\n  </span><span class="s1">var pq = new PriorityQueue();</span><span class="s3">\n  </span><span class="s1">var v;</span><span class="s3">\n\n  </span><span class="s1">function updateNeighbors(edge) {</span><span class="s3">\n    </span><span class="s1">var w = edge.v === v ? edge.w : edge.v;</span><span class="s3">\n    </span><span class="s1">var pri = pq.priority(w);</span><span class="s3">\n    </span><span class="s1">if (pri !== undefined) {</span><span class="s3">\n      </span><span class="s1">var edgeWeight = weightFunc(edge);</span><span class="s3">\n      </span><span class="s1">if (edgeWeight &lt; pri) {</span><span class="s3">\n        </span><span class="s1">parents[w] = v;</span><span class="s3">\n        </span><span class="s1">pq.decrease(w, edgeWeight);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (g.nodeCount() === 0) {</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.each(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">pq.add(v, Number.POSITIVE_INFINITY);</span><span class="s3">\n    </span><span class="s1">result.setNode(v);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Start from an arbitrary node</span><span class="s3">\n  </span><span class="s1">pq.decrease(g.nodes()[0], 0);</span><span class="s3">\n\n  </span><span class="s1">var init = false;</span><span class="s3">\n  </span><span class="s1">while (pq.size() &gt; 0) {</span><span class="s3">\n    </span><span class="s1">v = pq.removeMin();</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(parents, v)) {</span><span class="s3">\n      </span><span class="s1">result.setEdge(v, parents[v]);</span><span class="s3">\n    </span><span class="s1">} else if (init) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Input graph is not connected: ' + g);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">init = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">g.nodeEdges(v).forEach(updateNeighbors);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { components } from './components.js';</span><span class="s3">\n</span><span class="s1">import { dijkstra } from './dijkstra.js';</span><span class="s3">\n</span><span class="s1">import { dijkstraAll } from './dijkstra-all.js';</span><span class="s3">\n</span><span class="s1">import { findCycles } from './find-cycles.js';</span><span class="s3">\n</span><span class="s1">import { floydWarshall } from './floyd-warshall.js';</span><span class="s3">\n</span><span class="s1">import { isAcyclic } from './is-acyclic.js';</span><span class="s3">\n</span><span class="s1">import { postorder } from './postorder.js';</span><span class="s3">\n</span><span class="s1">import { preorder } from './preorder.js';</span><span class="s3">\n</span><span class="s1">import { prim } from './prim.js';</span><span class="s3">\n</span><span class="s1">import { tarjan } from './tarjan.js';</span><span class="s3">\n</span><span class="s1">import { topsort } from './topsort.js';</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">components,</span><span class="s3">\n  </span><span class="s1">dijkstra,</span><span class="s3">\n  </span><span class="s1">dijkstraAll,</span><span class="s3">\n  </span><span class="s1">findCycles,</span><span class="s3">\n  </span><span class="s1">floydWarshall,</span><span class="s3">\n  </span><span class="s1">isAcyclic,</span><span class="s3">\n  </span><span class="s1">postorder,</span><span class="s3">\n  </span><span class="s1">preorder,</span><span class="s3">\n  </span><span class="s1">prim,</span><span class="s3">\n  </span><span class="s1">tarjan,</span><span class="s3">\n  </span><span class="s1">topsort,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import * as alg from '../../graphlib/alg/index.js';</span><span class="s3">\n</span><span class="s1">import { simplify } from '../util.js';</span><span class="s3">\n</span><span class="s1">import { feasibleTree } from './feasible-tree.js';</span><span class="s3">\n</span><span class="s1">import { longestPath, slack } from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { networkSimplex };</span><span class="s3">\n\n</span><span class="s1">// Expose some internals for testing purposes</span><span class="s3">\n</span><span class="s1">networkSimplex.initLowLimValues = initLowLimValues;</span><span class="s3">\n</span><span class="s1">networkSimplex.initCutValues = initCutValues;</span><span class="s3">\n</span><span class="s1">networkSimplex.calcCutValue = calcCutValue;</span><span class="s3">\n</span><span class="s1">networkSimplex.leaveEdge = leaveEdge;</span><span class="s3">\n</span><span class="s1">networkSimplex.enterEdge = enterEdge;</span><span class="s3">\n</span><span class="s1">networkSimplex.exchangeEdges = exchangeEdges;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* The network simplex algorithm assigns ranks to each node in the input graph</span><span class="s3">\n </span><span class="s1">* and iteratively improves the ranking to reduce the length of edges.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Preconditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. The input graph must be a DAG.</span><span class="s3">\n </span><span class="s1">*    2. All nodes in the graph must have an object value.</span><span class="s3">\n </span><span class="s1">*    3. All edges in the graph must have </span><span class="s3">\&quot;</span><span class="s1">minlen</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">weight</span><span class="s3">\&quot; </span><span class="s1">attributes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Postconditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. All nodes in the graph will have an assigned </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">attribute that has</span><span class="s3">\n </span><span class="s1">*       been optimized by the network simplex algorithm. Ranks start at 0.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* A rough sketch of the algorithm is as follows:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Assign initial ranks to each node. We use the longest path algorithm,</span><span class="s3">\n </span><span class="s1">*       which assigns ranks to the lowest position possible. In general this</span><span class="s3">\n </span><span class="s1">*       leads to very wide bottom ranks and unnecessarily long edges.</span><span class="s3">\n </span><span class="s1">*    2. Construct a feasible tight tree. A tight tree is one such that all</span><span class="s3">\n </span><span class="s1">*       edges in the tree have no slack (difference between length of edge</span><span class="s3">\n </span><span class="s1">*       and minlen for the edge). This by itself greatly improves the assigned</span><span class="s3">\n </span><span class="s1">*       rankings by shorting edges.</span><span class="s3">\n </span><span class="s1">*    3. Iteratively find edges that have negative cut values. Generally a</span><span class="s3">\n </span><span class="s1">*       negative cut value indicates that the edge could be removed and a new</span><span class="s3">\n </span><span class="s1">*       tree edge could be added to produce a more compact graph.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Much of the algorithms here are derived from Gansner, et al., </span><span class="s3">\&quot;</span><span class="s1">A Technique</span><span class="s3">\n </span><span class="s1">* for Drawing Directed Graphs.</span><span class="s3">\&quot; </span><span class="s1">The structure of the file roughly follows the</span><span class="s3">\n </span><span class="s1">* structure of the overall algorithm.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function networkSimplex(g) {</span><span class="s3">\n  </span><span class="s1">g = simplify(g);</span><span class="s3">\n  </span><span class="s1">longestPath(g);</span><span class="s3">\n  </span><span class="s1">var t = feasibleTree(g);</span><span class="s3">\n  </span><span class="s1">initLowLimValues(t);</span><span class="s3">\n  </span><span class="s1">initCutValues(t, g);</span><span class="s3">\n\n  </span><span class="s1">var e, f;</span><span class="s3">\n  </span><span class="s1">while ((e = leaveEdge(t))) {</span><span class="s3">\n    </span><span class="s1">f = enterEdge(t, g, e);</span><span class="s3">\n    </span><span class="s1">exchangeEdges(t, g, e, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Initializes cut values for all edges in the tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function initCutValues(t, g) {</span><span class="s3">\n  </span><span class="s1">var vs = alg.postorder(t, t.nodes());</span><span class="s3">\n  </span><span class="s1">vs = vs.slice(0, vs.length - 1);</span><span class="s3">\n  </span><span class="s1">_.forEach(vs, function (v) {</span><span class="s3">\n    </span><span class="s1">assignCutValue(t, g, v);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assignCutValue(t, g, child) {</span><span class="s3">\n  </span><span class="s1">var childLab = t.node(child);</span><span class="s3">\n  </span><span class="s1">var parent = childLab.parent;</span><span class="s3">\n  </span><span class="s1">t.edge(child, parent).cutvalue = calcCutValue(t, g, child);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Given the tight tree, its graph, and a child in the graph calculate and</span><span class="s3">\n </span><span class="s1">* return the cut value for the edge between the child and its parent.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function calcCutValue(t, g, child) {</span><span class="s3">\n  </span><span class="s1">var childLab = t.node(child);</span><span class="s3">\n  </span><span class="s1">var parent = childLab.parent;</span><span class="s3">\n  </span><span class="s1">// True if the child is on the tail end of the edge in the directed graph</span><span class="s3">\n  </span><span class="s1">var childIsTail = true;</span><span class="s3">\n  </span><span class="s1">// The graph's view of the tree edge we're inspecting</span><span class="s3">\n  </span><span class="s1">var graphEdge = g.edge(child, parent);</span><span class="s3">\n  </span><span class="s1">// The accumulated cut value for the edge between this node and its parent</span><span class="s3">\n  </span><span class="s1">var cutValue = 0;</span><span class="s3">\n\n  </span><span class="s1">if (!graphEdge) {</span><span class="s3">\n    </span><span class="s1">childIsTail = false;</span><span class="s3">\n    </span><span class="s1">graphEdge = g.edge(parent, child);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cutValue = graphEdge.weight;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodeEdges(child), function (e) {</span><span class="s3">\n    </span><span class="s1">var isOutEdge = e.v === child,</span><span class="s3">\n      </span><span class="s1">other = isOutEdge ? e.w : e.v;</span><span class="s3">\n\n    </span><span class="s1">if (other !== parent) {</span><span class="s3">\n      </span><span class="s1">var pointsToHead = isOutEdge === childIsTail,</span><span class="s3">\n        </span><span class="s1">otherWeight = g.edge(e).weight;</span><span class="s3">\n\n      </span><span class="s1">cutValue += pointsToHead ? otherWeight : -otherWeight;</span><span class="s3">\n      </span><span class="s1">if (isTreeEdge(t, child, other)) {</span><span class="s3">\n        </span><span class="s1">var otherCutValue = t.edge(child, other).cutvalue;</span><span class="s3">\n        </span><span class="s1">cutValue += pointsToHead ? -otherCutValue : otherCutValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return cutValue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function initLowLimValues(tree, root) {</span><span class="s3">\n  </span><span class="s1">if (arguments.length &lt; 2) {</span><span class="s3">\n    </span><span class="s1">root = tree.nodes()[0];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dfsAssignLowLim(tree, {}, 1, root);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function dfsAssignLowLim(tree, visited, nextLim, v, parent) {</span><span class="s3">\n  </span><span class="s1">var low = nextLim;</span><span class="s3">\n  </span><span class="s1">var label = tree.node(v);</span><span class="s3">\n\n  </span><span class="s1">visited[v] = true;</span><span class="s3">\n  </span><span class="s1">_.forEach(tree.neighbors(v), function (w) {</span><span class="s3">\n    </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(visited, w)) {</span><span class="s3">\n      </span><span class="s1">nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">label.low = low;</span><span class="s3">\n  </span><span class="s1">label.lim = nextLim++;</span><span class="s3">\n  </span><span class="s1">if (parent) {</span><span class="s3">\n    </span><span class="s1">label.parent = parent;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// TODO should be able to remove this when we incrementally update low lim</span><span class="s3">\n    </span><span class="s1">delete label.parent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nextLim;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function leaveEdge(tree) {</span><span class="s3">\n  </span><span class="s1">return _.find(tree.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">return tree.edge(e).cutvalue &lt; 0;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function enterEdge(t, g, edge) {</span><span class="s3">\n  </span><span class="s1">var v = edge.v;</span><span class="s3">\n  </span><span class="s1">var w = edge.w;</span><span class="s3">\n\n  </span><span class="s1">// For the rest of this function we assume that v is the tail and w is the</span><span class="s3">\n  </span><span class="s1">// head, so if we don't have this edge in the graph we should flip it to</span><span class="s3">\n  </span><span class="s1">// match the correct orientation.</span><span class="s3">\n  </span><span class="s1">if (!g.hasEdge(v, w)) {</span><span class="s3">\n    </span><span class="s1">v = edge.w;</span><span class="s3">\n    </span><span class="s1">w = edge.v;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var vLabel = t.node(v);</span><span class="s3">\n  </span><span class="s1">var wLabel = t.node(w);</span><span class="s3">\n  </span><span class="s1">var tailLabel = vLabel;</span><span class="s3">\n  </span><span class="s1">var flip = false;</span><span class="s3">\n\n  </span><span class="s1">// If the root is in the tail of the edge then we need to flip the logic that</span><span class="s3">\n  </span><span class="s1">// checks for the head and tail nodes in the candidates function below.</span><span class="s3">\n  </span><span class="s1">if (vLabel.lim &gt; wLabel.lim) {</span><span class="s3">\n    </span><span class="s1">tailLabel = wLabel;</span><span class="s3">\n    </span><span class="s1">flip = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var candidates = _.filter(g.edges(), function (edge) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">flip === isDescendant(t, t.node(edge.v), tailLabel) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">flip !== isDescendant(t, t.node(edge.w), tailLabel)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return _.minBy(candidates, function (edge) {</span><span class="s3">\n    </span><span class="s1">return slack(g, edge);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function exchangeEdges(t, g, e, f) {</span><span class="s3">\n  </span><span class="s1">var v = e.v;</span><span class="s3">\n  </span><span class="s1">var w = e.w;</span><span class="s3">\n  </span><span class="s1">t.removeEdge(v, w);</span><span class="s3">\n  </span><span class="s1">t.setEdge(f.v, f.w, {});</span><span class="s3">\n  </span><span class="s1">initLowLimValues(t);</span><span class="s3">\n  </span><span class="s1">initCutValues(t, g);</span><span class="s3">\n  </span><span class="s1">updateRanks(t, g);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function updateRanks(t, g) {</span><span class="s3">\n  </span><span class="s1">var root = _.find(t.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">return !g.node(v).parent;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var vs = alg.preorder(t, root);</span><span class="s3">\n  </span><span class="s1">vs = vs.slice(1);</span><span class="s3">\n  </span><span class="s1">_.forEach(vs, function (v) {</span><span class="s3">\n    </span><span class="s1">var parent = t.node(v).parent,</span><span class="s3">\n      </span><span class="s1">edge = g.edge(v, parent),</span><span class="s3">\n      </span><span class="s1">flipped = false;</span><span class="s3">\n\n    </span><span class="s1">if (!edge) {</span><span class="s3">\n      </span><span class="s1">edge = g.edge(parent, v);</span><span class="s3">\n      </span><span class="s1">flipped = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Returns true if the edge is in the tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isTreeEdge(tree, u, v) {</span><span class="s3">\n  </span><span class="s1">return tree.hasEdge(u, v);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Returns true if the specified node is descendant of the root node per the</span><span class="s3">\n </span><span class="s1">* assigned low and lim attributes in the tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isDescendant(tree, vLabel, rootLabel) {</span><span class="s3">\n  </span><span class="s1">return rootLabel.low &lt;= vLabel.lim &amp;&amp; vLabel.lim &lt;= rootLabel.lim;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { feasibleTree } from './feasible-tree.js';</span><span class="s3">\n</span><span class="s1">import { networkSimplex } from './network-simplex.js';</span><span class="s3">\n</span><span class="s1">import { longestPath } from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { rank };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Assigns a rank to each node in the input graph that respects the </span><span class="s3">\&quot;</span><span class="s1">minlen</span><span class="s3">\&quot;\n </span><span class="s1">* constraint specified on edges between nodes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This basic structure is derived from Gansner, et al., </span><span class="s3">\&quot;</span><span class="s1">A Technique for</span><span class="s3">\n </span><span class="s1">* Drawing Directed Graphs.</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Graph must be a connected DAG</span><span class="s3">\n </span><span class="s1">*    2. Graph nodes must be objects</span><span class="s3">\n </span><span class="s1">*    3. Graph edges must have </span><span class="s3">\&quot;</span><span class="s1">weight</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">minlen</span><span class="s3">\&quot; </span><span class="s1">attributes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Graph nodes will have a </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">attribute based on the results of the</span><span class="s3">\n </span><span class="s1">*       algorithm. Ranks can start at any index (including negative), we'll</span><span class="s3">\n </span><span class="s1">*       fix them up later.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function rank(g) {</span><span class="s3">\n  </span><span class="s1">switch (g.graph().ranker) {</span><span class="s3">\n    </span><span class="s1">case 'network-simplex':</span><span class="s3">\n      </span><span class="s1">networkSimplexRanker(g);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'tight-tree':</span><span class="s3">\n      </span><span class="s1">tightTreeRanker(g);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'longest-path':</span><span class="s3">\n      </span><span class="s1">longestPathRanker(g);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">networkSimplexRanker(g);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// A fast and simple ranker, but results are far from optimal.</span><span class="s3">\n</span><span class="s1">var longestPathRanker = longestPath;</span><span class="s3">\n\n</span><span class="s1">function tightTreeRanker(g) {</span><span class="s3">\n  </span><span class="s1">longestPath(g);</span><span class="s3">\n  </span><span class="s1">feasibleTree(g);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function networkSimplexRanker(g) {</span><span class="s3">\n  </span><span class="s1">networkSimplex(g);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import * as util from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { run, cleanup };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,</span><span class="s3">\n </span><span class="s1">* adds appropriate edges to ensure that all cluster nodes are placed between</span><span class="s3">\n </span><span class="s1">* these boundries, and ensures that the graph is connected.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In addition we ensure, through the use of the minlen property, that nodes</span><span class="s3">\n </span><span class="s1">* and subgraph border nodes to not end up on the same rank.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Preconditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Input graph is a DAG</span><span class="s3">\n </span><span class="s1">*    2. Nodes in the input graph has a minlen attribute</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Postconditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Input graph is connected.</span><span class="s3">\n </span><span class="s1">*    2. Dummy nodes are added for the tops and bottoms of subgraphs.</span><span class="s3">\n </span><span class="s1">*    3. The minlen attribute for nodes is adjusted to ensure nodes do not</span><span class="s3">\n </span><span class="s1">*       get placed on the same rank as subgraph border nodes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The nesting graph idea comes from Sander, </span><span class="s3">\&quot;</span><span class="s1">Layout of Compound Directed</span><span class="s3">\n </span><span class="s1">* Graphs.</span><span class="s3">\&quot;\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function run(g) {</span><span class="s3">\n  </span><span class="s1">var root = util.addDummyNode(g, 'root', {}, '_root');</span><span class="s3">\n  </span><span class="s1">var depths = treeDepths(g);</span><span class="s3">\n  </span><span class="s1">var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array</span><span class="s3">\n  </span><span class="s1">var nodeSep = 2 * height + 1;</span><span class="s3">\n\n  </span><span class="s1">g.graph().nestingRoot = root;</span><span class="s3">\n\n  </span><span class="s1">// Multiply minlen by nodeSep to align nodes on non-border ranks.</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">g.edge(e).minlen *= nodeSep;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Calculate a weight that is sufficient to keep subgraphs vertically compact</span><span class="s3">\n  </span><span class="s1">var weight = sumWeights(g) + 1;</span><span class="s3">\n\n  </span><span class="s1">// Create border nodes and link them up</span><span class="s3">\n  </span><span class="s1">_.forEach(g.children(), function (child) {</span><span class="s3">\n    </span><span class="s1">dfs(g, root, nodeSep, weight, height, depths, child);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Save the multiplier for node layers for later removal of empty border</span><span class="s3">\n  </span><span class="s1">// layers.</span><span class="s3">\n  </span><span class="s1">g.graph().nodeRankFactor = nodeSep;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function dfs(g, root, nodeSep, weight, height, depths, v) {</span><span class="s3">\n  </span><span class="s1">var children = g.children(v);</span><span class="s3">\n  </span><span class="s1">if (!children.length) {</span><span class="s3">\n    </span><span class="s1">if (v !== root) {</span><span class="s3">\n      </span><span class="s1">g.setEdge(root, v, { weight: 0, minlen: nodeSep });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var top = util.addBorderNode(g, '_bt');</span><span class="s3">\n  </span><span class="s1">var bottom = util.addBorderNode(g, '_bb');</span><span class="s3">\n  </span><span class="s1">var label = g.node(v);</span><span class="s3">\n\n  </span><span class="s1">g.setParent(top, v);</span><span class="s3">\n  </span><span class="s1">label.borderTop = top;</span><span class="s3">\n  </span><span class="s1">g.setParent(bottom, v);</span><span class="s3">\n  </span><span class="s1">label.borderBottom = bottom;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(children, function (child) {</span><span class="s3">\n    </span><span class="s1">dfs(g, root, nodeSep, weight, height, depths, child);</span><span class="s3">\n\n    </span><span class="s1">var childNode = g.node(child);</span><span class="s3">\n    </span><span class="s1">var childTop = childNode.borderTop ? childNode.borderTop : child;</span><span class="s3">\n    </span><span class="s1">var childBottom = childNode.borderBottom ? childNode.borderBottom : child;</span><span class="s3">\n    </span><span class="s1">var thisWeight = childNode.borderTop ? weight : 2 * weight;</span><span class="s3">\n    </span><span class="s1">var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;</span><span class="s3">\n\n    </span><span class="s1">g.setEdge(top, childTop, {</span><span class="s3">\n      </span><span class="s1">weight: thisWeight,</span><span class="s3">\n      </span><span class="s1">minlen: minlen,</span><span class="s3">\n      </span><span class="s1">nestingEdge: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">g.setEdge(childBottom, bottom, {</span><span class="s3">\n      </span><span class="s1">weight: thisWeight,</span><span class="s3">\n      </span><span class="s1">minlen: minlen,</span><span class="s3">\n      </span><span class="s1">nestingEdge: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">if (!g.parent(v)) {</span><span class="s3">\n    </span><span class="s1">g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function treeDepths(g) {</span><span class="s3">\n  </span><span class="s1">var depths = {};</span><span class="s3">\n  </span><span class="s1">function dfs(v, depth) {</span><span class="s3">\n    </span><span class="s1">var children = g.children(v);</span><span class="s3">\n    </span><span class="s1">if (children &amp;&amp; children.length) {</span><span class="s3">\n      </span><span class="s1">_.forEach(children, function (child) {</span><span class="s3">\n        </span><span class="s1">dfs(child, depth + 1);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">depths[v] = depth;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">_.forEach(g.children(), function (v) {</span><span class="s3">\n    </span><span class="s1">dfs(v, 1);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return depths;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sumWeights(g) {</span><span class="s3">\n  </span><span class="s1">return _.reduce(</span><span class="s3">\n    </span><span class="s1">g.edges(),</span><span class="s3">\n    </span><span class="s1">function (acc, e) {</span><span class="s3">\n      </span><span class="s1">return acc + g.edge(e).weight;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">0,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function cleanup(g) {</span><span class="s3">\n  </span><span class="s1">var graphLabel = g.graph();</span><span class="s3">\n  </span><span class="s1">g.removeNode(graphLabel.nestingRoot);</span><span class="s3">\n  </span><span class="s1">delete graphLabel.nestingRoot;</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">if (edge.nestingEdge) {</span><span class="s3">\n      </span><span class="s1">g.removeEdge(e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseClone from './_baseClone.js';</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for cloning. */</span><span class="s3">\n</span><span class="s1">var CLONE_DEEP_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">CLONE_SYMBOLS_FLAG = 4;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.clone` except that it recursively clones `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 1.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to recursively clone.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the deep cloned value.</span><span class="s3">\n </span><span class="s1">* @see _.clone</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [{ 'a': 1 }, { 'b': 2 }];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var deep = _.cloneDeep(objects);</span><span class="s3">\n </span><span class="s1">* console.log(deep[0] === objects[0]);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function cloneDeep(value) {</span><span class="s3">\n  </span><span class="s1">return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default cloneDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { addSubgraphConstraints };</span><span class="s3">\n\n</span><span class="s1">function addSubgraphConstraints(g, cg, vs) {</span><span class="s3">\n  </span><span class="s1">var prev = {},</span><span class="s3">\n    </span><span class="s1">rootPrev;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(vs, function (v) {</span><span class="s3">\n    </span><span class="s1">var child = g.parent(v),</span><span class="s3">\n      </span><span class="s1">parent,</span><span class="s3">\n      </span><span class="s1">prevChild;</span><span class="s3">\n    </span><span class="s1">while (child) {</span><span class="s3">\n      </span><span class="s1">parent = g.parent(child);</span><span class="s3">\n      </span><span class="s1">if (parent) {</span><span class="s3">\n        </span><span class="s1">prevChild = prev[parent];</span><span class="s3">\n        </span><span class="s1">prev[parent] = child;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">prevChild = rootPrev;</span><span class="s3">\n        </span><span class="s1">rootPrev = child;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (prevChild &amp;&amp; prevChild !== child) {</span><span class="s3">\n        </span><span class="s1">cg.setEdge(prevChild, child);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">child = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">var children = v ? g.children(v) : g.children();</span><span class="s3">\n    </span><span class="s1">if (children.length) {</span><span class="s3">\n      </span><span class="s1">var min = Number.POSITIVE_INFINITY,</span><span class="s3">\n          </span><span class="s1">subgraphs = [];</span><span class="s3">\n      </span><span class="s1">_.each(children, function(child) {</span><span class="s3">\n        </span><span class="s1">var childMin = dfs(child);</span><span class="s3">\n        </span><span class="s1">if (g.children(child).length) {</span><span class="s3">\n          </span><span class="s1">subgraphs.push({ v: child, order: childMin });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">min = Math.min(min, childMin);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">_.reduce(_.sortBy(subgraphs, </span><span class="s3">\&quot;</span><span class="s1">order</span><span class="s3">\&quot;</span><span class="s1">), function(prev, curr) {</span><span class="s3">\n        </span><span class="s1">cg.setEdge(prev.v, curr.v);</span><span class="s3">\n        </span><span class="s1">return curr;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">return min;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return g.node(v).order;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dfs(undefined);</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../../graphlib/index.js';</span><span class="s3">\n\n</span><span class="s1">export { buildLayerGraph };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Constructs a graph that can be used to sort a layer of nodes. The graph will</span><span class="s3">\n </span><span class="s1">* contain all base and subgraph nodes from the request layer in their original</span><span class="s3">\n </span><span class="s1">* hierarchy and any edges that are incident on these nodes and are of the type</span><span class="s3">\n </span><span class="s1">* requested by the </span><span class="s3">\&quot;</span><span class="s1">relationship</span><span class="s3">\&quot; </span><span class="s1">parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Nodes from the requested rank that do not have parents are assigned a root</span><span class="s3">\n </span><span class="s1">* node in the output graph, which is set in the root graph attribute. This</span><span class="s3">\n </span><span class="s1">* makes it easy to walk the hierarchy of movable nodes during ordering.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Input graph is a DAG</span><span class="s3">\n </span><span class="s1">*    2. Base nodes in the input graph have a rank attribute</span><span class="s3">\n </span><span class="s1">*    3. Subgraph nodes in the input graph has minRank and maxRank attributes</span><span class="s3">\n </span><span class="s1">*    4. Edges have an assigned weight</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Output graph has all nodes in the movable rank with preserved</span><span class="s3">\n </span><span class="s1">*       hierarchy.</span><span class="s3">\n </span><span class="s1">*    2. Root nodes in the movable layer are made children of the node</span><span class="s3">\n </span><span class="s1">*       indicated by the root attribute of the graph.</span><span class="s3">\n </span><span class="s1">*    3. Non-movable nodes incident on movable nodes, selected by the</span><span class="s3">\n </span><span class="s1">*       relationship parameter, are included in the graph (without hierarchy).</span><span class="s3">\n </span><span class="s1">*    4. Edges incident on movable nodes, selected by the relationship</span><span class="s3">\n </span><span class="s1">*       parameter, are added to the output graph.</span><span class="s3">\n </span><span class="s1">*    5. The weights for copied edges are aggregated as need, since the output</span><span class="s3">\n </span><span class="s1">*       graph is not a multi-graph.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildLayerGraph(g, rank, relationship) {</span><span class="s3">\n  </span><span class="s1">var root = createRootNode(g),</span><span class="s3">\n    </span><span class="s1">result = new Graph({ compound: true })</span><span class="s3">\n      </span><span class="s1">.setGraph({ root: root })</span><span class="s3">\n      </span><span class="s1">.setDefaultNodeLabel(function (v) {</span><span class="s3">\n        </span><span class="s1">return g.node(v);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v),</span><span class="s3">\n      </span><span class="s1">parent = g.parent(v);</span><span class="s3">\n\n    </span><span class="s1">if (node.rank === rank || (node.minRank &lt;= rank &amp;&amp; rank &lt;= node.maxRank)) {</span><span class="s3">\n      </span><span class="s1">result.setNode(v);</span><span class="s3">\n      </span><span class="s1">result.setParent(v, parent || root);</span><span class="s3">\n\n      </span><span class="s1">// This assumes we have only short edges!</span><span class="s3">\n      </span><span class="s1">_.forEach(g[relationship](v), function (e) {</span><span class="s3">\n        </span><span class="s1">var u = e.v === v ? e.w : e.v,</span><span class="s3">\n          </span><span class="s1">edge = result.edge(u, v),</span><span class="s3">\n          </span><span class="s1">weight = !_.isUndefined(edge) ? edge.weight : 0;</span><span class="s3">\n        </span><span class="s1">result.setEdge(u, v, { weight: g.edge(e).weight + weight });</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">if (Object.prototype.hasOwnProperty.call(node, 'minRank')) {</span><span class="s3">\n        </span><span class="s1">result.setNode(v, {</span><span class="s3">\n          </span><span class="s1">borderLeft: node.borderLeft[rank],</span><span class="s3">\n          </span><span class="s1">borderRight: node.borderRight[rank],</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRootNode(g) {</span><span class="s3">\n  </span><span class="s1">var v;</span><span class="s3">\n  </span><span class="s1">while (g.hasNode((v = _.uniqueId('_root'))));</span><span class="s3">\n  </span><span class="s1">return v;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This base implementation of `_.zipObject` which assigns values using `assignFunc`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} props The property identifiers.</span><span class="s3">\n </span><span class="s1">* @param {Array} values The property values.</span><span class="s3">\n </span><span class="s1">* @param {Function} assignFunc The function to assign values.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseZipObject(props, values, assignFunc) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = props.length,</span><span class="s3">\n      </span><span class="s1">valsLength = values.length,</span><span class="s3">\n      </span><span class="s1">result = {};</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = index &lt; valsLength ? values[index] : undefined;</span><span class="s3">\n    </span><span class="s1">assignFunc(result, props[index], value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseZipObject;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import assignValue from './_assignValue.js';</span><span class="s3">\n</span><span class="s1">import baseZipObject from './_baseZipObject.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.fromPairs` except that it accepts two arrays,</span><span class="s3">\n </span><span class="s1">* one of property identifiers and one of corresponding values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.4.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} [props=[]] The property identifiers.</span><span class="s3">\n </span><span class="s1">* @param {Array} [values=[]] The property values.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.zipObject(['a', 'b'], [1, 2]);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function zipObject(props, values) {</span><span class="s3">\n  </span><span class="s1">return baseZipObject(props || [], values || [], assignValue);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default zipObject;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.sortBy` which uses `comparer` to define the</span><span class="s3">\n </span><span class="s1">* sort order of `array` and replaces criteria objects with their corresponding</span><span class="s3">\n </span><span class="s1">* values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to sort.</span><span class="s3">\n </span><span class="s1">* @param {Function} comparer The function to define sort order.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns `array`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseSortBy(array, comparer) {</span><span class="s3">\n  </span><span class="s1">var length = array.length;</span><span class="s3">\n\n  </span><span class="s1">array.sort(comparer);</span><span class="s3">\n  </span><span class="s1">while (length--) {</span><span class="s3">\n    </span><span class="s1">array[length] = array[length].value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseSortBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import isSymbol from './isSymbol.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares values to sort them in ascending order.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the sort order indicator for `value`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareAscending(value, other) {</span><span class="s3">\n  </span><span class="s1">if (value !== other) {</span><span class="s3">\n    </span><span class="s1">var valIsDefined = value !== undefined,</span><span class="s3">\n        </span><span class="s1">valIsNull = value === null,</span><span class="s3">\n        </span><span class="s1">valIsReflexive = value === value,</span><span class="s3">\n        </span><span class="s1">valIsSymbol = isSymbol(value);</span><span class="s3">\n\n    </span><span class="s1">var othIsDefined = other !== undefined,</span><span class="s3">\n        </span><span class="s1">othIsNull = other === null,</span><span class="s3">\n        </span><span class="s1">othIsReflexive = other === other,</span><span class="s3">\n        </span><span class="s1">othIsSymbol = isSymbol(other);</span><span class="s3">\n\n    </span><span class="s1">if ((!othIsNull &amp;&amp; !othIsSymbol &amp;&amp; !valIsSymbol &amp;&amp; value &gt; other) ||</span><span class="s3">\n        </span><span class="s1">(valIsSymbol &amp;&amp; othIsDefined &amp;&amp; othIsReflexive &amp;&amp; !othIsNull &amp;&amp; !othIsSymbol) ||</span><span class="s3">\n        </span><span class="s1">(valIsNull &amp;&amp; othIsDefined &amp;&amp; othIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">(!valIsDefined &amp;&amp; othIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">!valIsReflexive) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if ((!valIsNull &amp;&amp; !valIsSymbol &amp;&amp; !othIsSymbol &amp;&amp; value &lt; other) ||</span><span class="s3">\n        </span><span class="s1">(othIsSymbol &amp;&amp; valIsDefined &amp;&amp; valIsReflexive &amp;&amp; !valIsNull &amp;&amp; !valIsSymbol) ||</span><span class="s3">\n        </span><span class="s1">(othIsNull &amp;&amp; valIsDefined &amp;&amp; valIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">(!othIsDefined &amp;&amp; valIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">!othIsReflexive) {</span><span class="s3">\n      </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default compareAscending;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import compareAscending from './_compareAscending.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used by `_.orderBy` to compare multiple properties of a value to another</span><span class="s3">\n </span><span class="s1">* and stable sort them.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If `orders` is unspecified, all values are sorted in ascending order. Otherwise,</span><span class="s3">\n </span><span class="s1">* specify an order of </span><span class="s3">\&quot;</span><span class="s1">desc</span><span class="s3">\&quot; </span><span class="s1">for descending or </span><span class="s3">\&quot;</span><span class="s1">asc</span><span class="s3">\&quot; </span><span class="s1">for ascending sort order</span><span class="s3">\n </span><span class="s1">* of corresponding values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {boolean[]|string[]} orders The order to sort by for each property.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the sort order indicator for `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareMultiple(object, other, orders) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">objCriteria = object.criteria,</span><span class="s3">\n      </span><span class="s1">othCriteria = other.criteria,</span><span class="s3">\n      </span><span class="s1">length = objCriteria.length,</span><span class="s3">\n      </span><span class="s1">ordersLength = orders.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var result = compareAscending(objCriteria[index], othCriteria[index]);</span><span class="s3">\n    </span><span class="s1">if (result) {</span><span class="s3">\n      </span><span class="s1">if (index &gt;= ordersLength) {</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var order = orders[index];</span><span class="s3">\n      </span><span class="s1">return result * (order == 'desc' ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications</span><span class="s3">\n  </span><span class="s1">// that causes it, under certain circumstances, to provide the same value for</span><span class="s3">\n  </span><span class="s1">// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247</span><span class="s3">\n  </span><span class="s1">// for more details.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This also ensures a stable sort in V8 and other engines.</span><span class="s3">\n  </span><span class="s1">// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.</span><span class="s3">\n  </span><span class="s1">return object.index - other.index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default compareMultiple;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayMap from './_arrayMap.js';</span><span class="s3">\n</span><span class="s1">import baseGet from './_baseGet.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import baseMap from './_baseMap.js';</span><span class="s3">\n</span><span class="s1">import baseSortBy from './_baseSortBy.js';</span><span class="s3">\n</span><span class="s1">import baseUnary from './_baseUnary.js';</span><span class="s3">\n</span><span class="s1">import compareMultiple from './_compareMultiple.js';</span><span class="s3">\n</span><span class="s1">import identity from './identity.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.orderBy` without param guards.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.</span><span class="s3">\n </span><span class="s1">* @param {string[]} orders The sort orders of `iteratees`.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new sorted array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseOrderBy(collection, iteratees, orders) {</span><span class="s3">\n  </span><span class="s1">if (iteratees.length) {</span><span class="s3">\n    </span><span class="s1">iteratees = arrayMap(iteratees, function(iteratee) {</span><span class="s3">\n      </span><span class="s1">if (isArray(iteratee)) {</span><span class="s3">\n        </span><span class="s1">return function(value) {</span><span class="s3">\n          </span><span class="s1">return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return iteratee;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">iteratees = [identity];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var index = -1;</span><span class="s3">\n  </span><span class="s1">iteratees = arrayMap(iteratees, baseUnary(baseIteratee));</span><span class="s3">\n\n  </span><span class="s1">var result = baseMap(collection, function(value, key, collection) {</span><span class="s3">\n    </span><span class="s1">var criteria = arrayMap(iteratees, function(iteratee) {</span><span class="s3">\n      </span><span class="s1">return iteratee(value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return { 'criteria': criteria, 'index': ++index, 'value': value };</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return baseSortBy(result, function(object, other) {</span><span class="s3">\n    </span><span class="s1">return compareMultiple(object, other, orders);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseOrderBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFlatten from './_baseFlatten.js';</span><span class="s3">\n</span><span class="s1">import baseOrderBy from './_baseOrderBy.js';</span><span class="s3">\n</span><span class="s1">import baseRest from './_baseRest.js';</span><span class="s3">\n</span><span class="s1">import isIterateeCall from './_isIterateeCall.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of elements, sorted in ascending order by the results of</span><span class="s3">\n </span><span class="s1">* running each element in a collection thru each iteratee. This method</span><span class="s3">\n </span><span class="s1">* performs a stable sort, that is, it preserves the original sort order of</span><span class="s3">\n </span><span class="s1">* equal elements. The iteratees are invoked with one argument: (value).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {...(Function|Function[])} [iteratees=[_.identity]]</span><span class="s3">\n </span><span class="s1">*  The iteratees to sort by.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new sorted array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'age': 48 },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'age': 36 },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'age': 30 },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'age': 34 }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.sortBy(users, [function(o) { return o.user; }]);</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.sortBy(users, ['user', 'age']);</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var sortBy = baseRest(function(collection, iteratees) {</span><span class="s3">\n  </span><span class="s1">if (collection == null) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var length = iteratees.length;</span><span class="s3">\n  </span><span class="s1">if (length &gt; 1 &amp;&amp; isIterateeCall(collection, iteratees[0], iteratees[1])) {</span><span class="s3">\n    </span><span class="s1">iteratees = [];</span><span class="s3">\n  </span><span class="s1">} else if (length &gt; 2 &amp;&amp; isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {</span><span class="s3">\n    </span><span class="s1">iteratees = [iteratees[0]];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseOrderBy(collection, baseFlatten(iteratees, 1), []);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default sortBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { crossCount };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* A function that takes a layering (an array of layers, each with an array of</span><span class="s3">\n </span><span class="s1">* ordererd nodes) and a graph and returns a weighted crossing count.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Input graph must be simple (not a multigraph), directed, and include</span><span class="s3">\n </span><span class="s1">*       only simple edges.</span><span class="s3">\n </span><span class="s1">*    2. Edges in the input graph must have assigned weights.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. The graph and layering matrix are left unchanged.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This algorithm is derived from Barth, et al., </span><span class="s3">\&quot;</span><span class="s1">Bilayer Cross Counting.</span><span class="s3">\&quot;\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function crossCount(g, layering) {</span><span class="s3">\n  </span><span class="s1">var cc = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 1; i &lt; layering.length; ++i) {</span><span class="s3">\n    </span><span class="s1">cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cc;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function twoLayerCrossCount(g, northLayer, southLayer) {</span><span class="s3">\n  </span><span class="s1">// Sort all of the edges between the north and south layers by their position</span><span class="s3">\n  </span><span class="s1">// in the north layer and then the south. Map these edges to the position of</span><span class="s3">\n  </span><span class="s1">// their head in the south layer.</span><span class="s3">\n  </span><span class="s1">var southPos = _.zipObject(</span><span class="s3">\n    </span><span class="s1">southLayer,</span><span class="s3">\n    </span><span class="s1">_.map(southLayer, function (v, i) {</span><span class="s3">\n      </span><span class="s1">return i;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">var southEntries = _.flatten(</span><span class="s3">\n    </span><span class="s1">_.map(northLayer, function (v) {</span><span class="s3">\n      </span><span class="s1">return _.sortBy(</span><span class="s3">\n        </span><span class="s1">_.map(g.outEdges(v), function (e) {</span><span class="s3">\n          </span><span class="s1">return { pos: southPos[e.w], weight: g.edge(e).weight };</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">'pos',</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// Build the accumulator tree</span><span class="s3">\n  </span><span class="s1">var firstIndex = 1;</span><span class="s3">\n  </span><span class="s1">while (firstIndex &lt; southLayer.length) firstIndex &lt;&lt;= 1;</span><span class="s3">\n  </span><span class="s1">var treeSize = 2 * firstIndex - 1;</span><span class="s3">\n  </span><span class="s1">firstIndex -= 1;</span><span class="s3">\n  </span><span class="s1">var tree = _.map(new Array(treeSize), function () {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Calculate the weighted crossings</span><span class="s3">\n  </span><span class="s1">var cc = 0;</span><span class="s3">\n  </span><span class="s1">_.forEach(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">southEntries.forEach(function (entry) {</span><span class="s3">\n      </span><span class="s1">var index = entry.pos + firstIndex;</span><span class="s3">\n      </span><span class="s1">tree[index] += entry.weight;</span><span class="s3">\n      </span><span class="s1">var weightSum = 0;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error</span><span class="s3">\n      </span><span class="s1">while (index &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error</span><span class="s3">\n        </span><span class="s1">if (index % 2) {</span><span class="s3">\n          </span><span class="s1">weightSum += tree[index + 1];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error</span><span class="s3">\n        </span><span class="s1">index = (index - 1) &gt;&gt; 1;</span><span class="s3">\n        </span><span class="s1">tree[index] += entry.weight;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cc += entry.weight * weightSum;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return cc;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Assigns an initial order value for each node by performing a DFS search</span><span class="s3">\n </span><span class="s1">* starting from nodes in the first rank. Nodes are assigned an order in their</span><span class="s3">\n </span><span class="s1">* rank as they are first visited.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This approach comes from Gansner, et al., </span><span class="s3">\&quot;</span><span class="s1">A Technique for Drawing Directed</span><span class="s3">\n </span><span class="s1">* Graphs.</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returns a layering matrix with an array per layer and each layer sorted by</span><span class="s3">\n </span><span class="s1">* the order of its nodes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function initOrder(g) {</span><span class="s3">\n  </span><span class="s1">var visited = {};</span><span class="s3">\n  </span><span class="s1">var simpleNodes = _.filter(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">return !g.children(v).length;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var maxRank = _.max(</span><span class="s3">\n    </span><span class="s1">_.map(simpleNodes, function (v) {</span><span class="s3">\n      </span><span class="s1">return g.node(v).rank;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">var layers = _.map(_.range(maxRank + 1), function () {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">if (_.has(visited, v)) return;</span><span class="s3">\n    </span><span class="s1">visited[v] = true;</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">layers[node.rank].push(v);</span><span class="s3">\n    </span><span class="s1">_.forEach(g.successors(v), dfs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var orderedVs = _.sortBy(simpleNodes, function (v) {</span><span class="s3">\n    </span><span class="s1">return g.node(v).rank;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.forEach(orderedVs, dfs);</span><span class="s3">\n\n  </span><span class="s1">return layers;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { barycenter };</span><span class="s3">\n\n</span><span class="s1">function barycenter(g, movable) {</span><span class="s3">\n  </span><span class="s1">return _.map(movable, function (v) {</span><span class="s3">\n    </span><span class="s1">var inV = g.inEdges(v);</span><span class="s3">\n    </span><span class="s1">if (!inV.length) {</span><span class="s3">\n      </span><span class="s1">return { v: v };</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var result = _.reduce(</span><span class="s3">\n        </span><span class="s1">inV,</span><span class="s3">\n        </span><span class="s1">function (acc, e) {</span><span class="s3">\n          </span><span class="s1">var edge = g.edge(e),</span><span class="s3">\n            </span><span class="s1">nodeU = g.node(e.v);</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">sum: acc.sum + edge.weight * nodeU.order,</span><span class="s3">\n            </span><span class="s1">weight: acc.weight + edge.weight,</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{ sum: 0, weight: 0 },</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">v: v,</span><span class="s3">\n        </span><span class="s1">barycenter: result.sum / result.weight,</span><span class="s3">\n        </span><span class="s1">weight: result.weight,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { resolveConflicts };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Given a list of entries of the form {v, barycenter, weight} and a</span><span class="s3">\n </span><span class="s1">* constraint graph this function will resolve any conflicts between the</span><span class="s3">\n </span><span class="s1">* constraint graph and the barycenters for the entries. If the barycenters for</span><span class="s3">\n </span><span class="s1">* an entry would violate a constraint in the constraint graph then we coalesce</span><span class="s3">\n </span><span class="s1">* the nodes in the conflict into a new node that respects the contraint and</span><span class="s3">\n </span><span class="s1">* aggregates barycenter and weight information.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This implementation is based on the description in Forster, </span><span class="s3">\&quot;</span><span class="s1">A Fast and</span><span class="s3">\n </span><span class="s1">* Simple Hueristic for Constrained Two-Level Crossing Reduction,</span><span class="s3">\&quot; </span><span class="s1">thought it</span><span class="s3">\n </span><span class="s1">* differs in some specific details.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Each entry has the form {v, barycenter, weight}, or if the node has</span><span class="s3">\n </span><span class="s1">*       no barycenter, then {v}.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returns:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    A new list of entries of the form {vs, i, barycenter, weight}. The list</span><span class="s3">\n </span><span class="s1">*    `vs` may either be a singleton or it may be an aggregation of nodes</span><span class="s3">\n </span><span class="s1">*    ordered such that they do not violate constraints from the constraint</span><span class="s3">\n </span><span class="s1">*    graph. The property `i` is the lowest original index of any of the</span><span class="s3">\n </span><span class="s1">*    elements in `vs`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveConflicts(entries, cg) {</span><span class="s3">\n  </span><span class="s1">var mappedEntries = {};</span><span class="s3">\n  </span><span class="s1">_.forEach(entries, function (entry, i) {</span><span class="s3">\n    </span><span class="s1">var tmp = (mappedEntries[entry.v] = {</span><span class="s3">\n      </span><span class="s1">indegree: 0,</span><span class="s3">\n      </span><span class="s1">in: [],</span><span class="s3">\n      </span><span class="s1">out: [],</span><span class="s3">\n      </span><span class="s1">vs: [entry.v],</span><span class="s3">\n      </span><span class="s1">i: i,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(entry.barycenter)) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error</span><span class="s3">\n      </span><span class="s1">tmp.barycenter = entry.barycenter;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error</span><span class="s3">\n      </span><span class="s1">tmp.weight = entry.weight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(cg.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var entryV = mappedEntries[e.v];</span><span class="s3">\n    </span><span class="s1">var entryW = mappedEntries[e.w];</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(entryV) &amp;&amp; !_.isUndefined(entryW)) {</span><span class="s3">\n      </span><span class="s1">entryW.indegree++;</span><span class="s3">\n      </span><span class="s1">entryV.out.push(mappedEntries[e.w]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var sourceSet = _.filter(mappedEntries, function (entry) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">return !entry.indegree;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return doResolveConflicts(sourceSet);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function doResolveConflicts(sourceSet) {</span><span class="s3">\n  </span><span class="s1">var entries = [];</span><span class="s3">\n\n  </span><span class="s1">function handleIn(vEntry) {</span><span class="s3">\n    </span><span class="s1">return function (uEntry) {</span><span class="s3">\n      </span><span class="s1">if (uEntry.merged) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">_.isUndefined(uEntry.barycenter) ||</span><span class="s3">\n        </span><span class="s1">_.isUndefined(vEntry.barycenter) ||</span><span class="s3">\n        </span><span class="s1">uEntry.barycenter &gt;= vEntry.barycenter</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">mergeEntries(vEntry, uEntry);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleOut(vEntry) {</span><span class="s3">\n    </span><span class="s1">return function (wEntry) {</span><span class="s3">\n      </span><span class="s1">wEntry['in'].push(vEntry);</span><span class="s3">\n      </span><span class="s1">if (--wEntry.indegree === 0) {</span><span class="s3">\n        </span><span class="s1">sourceSet.push(wEntry);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (sourceSet.length) {</span><span class="s3">\n    </span><span class="s1">var entry = sourceSet.pop();</span><span class="s3">\n    </span><span class="s1">entries.push(entry);</span><span class="s3">\n    </span><span class="s1">_.forEach(entry['in'].reverse(), handleIn(entry));</span><span class="s3">\n    </span><span class="s1">_.forEach(entry.out, handleOut(entry));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return _.map(</span><span class="s3">\n    </span><span class="s1">_.filter(entries, function (entry) {</span><span class="s3">\n      </span><span class="s1">return !entry.merged;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">function (entry) {</span><span class="s3">\n      </span><span class="s1">return _.pick(entry, ['vs', 'i', 'barycenter', 'weight']);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeEntries(target, source) {</span><span class="s3">\n  </span><span class="s1">var sum = 0;</span><span class="s3">\n  </span><span class="s1">var weight = 0;</span><span class="s3">\n\n  </span><span class="s1">if (target.weight) {</span><span class="s3">\n    </span><span class="s1">sum += target.barycenter * target.weight;</span><span class="s3">\n    </span><span class="s1">weight += target.weight;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (source.weight) {</span><span class="s3">\n    </span><span class="s1">sum += source.barycenter * source.weight;</span><span class="s3">\n    </span><span class="s1">weight += source.weight;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">target.vs = source.vs.concat(target.vs);</span><span class="s3">\n  </span><span class="s1">target.barycenter = sum / weight;</span><span class="s3">\n  </span><span class="s1">target.weight = weight;</span><span class="s3">\n  </span><span class="s1">target.i = Math.min(source.i, target.i);</span><span class="s3">\n  </span><span class="s1">source.merged = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import * as util from '../util.js';</span><span class="s3">\n\n</span><span class="s1">export { sort };</span><span class="s3">\n\n</span><span class="s1">function sort(entries, biasRight) {</span><span class="s3">\n  </span><span class="s1">var parts = util.partition(entries, function (entry) {</span><span class="s3">\n    </span><span class="s1">return Object.prototype.hasOwnProperty.call(entry, 'barycenter');</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var sortable = parts.lhs,</span><span class="s3">\n    </span><span class="s1">unsortable = _.sortBy(parts.rhs, function (entry) {</span><span class="s3">\n      </span><span class="s1">return -entry.i;</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">vs = [],</span><span class="s3">\n    </span><span class="s1">sum = 0,</span><span class="s3">\n    </span><span class="s1">weight = 0,</span><span class="s3">\n    </span><span class="s1">vsIndex = 0;</span><span class="s3">\n\n  </span><span class="s1">sortable.sort(compareWithBias(!!biasRight));</span><span class="s3">\n\n  </span><span class="s1">vsIndex = consumeUnsortable(vs, unsortable, vsIndex);</span><span class="s3">\n\n  </span><span class="s1">_.forEach(sortable, function (entry) {</span><span class="s3">\n    </span><span class="s1">vsIndex += entry.vs.length;</span><span class="s3">\n    </span><span class="s1">vs.push(entry.vs);</span><span class="s3">\n    </span><span class="s1">sum += entry.barycenter * entry.weight;</span><span class="s3">\n    </span><span class="s1">weight += entry.weight;</span><span class="s3">\n    </span><span class="s1">vsIndex = consumeUnsortable(vs, unsortable, vsIndex);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var result = { vs: _.flatten(vs) };</span><span class="s3">\n  </span><span class="s1">if (weight) {</span><span class="s3">\n    </span><span class="s1">result.barycenter = sum / weight;</span><span class="s3">\n    </span><span class="s1">result.weight = weight;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function consumeUnsortable(vs, unsortable, index) {</span><span class="s3">\n  </span><span class="s1">var last;</span><span class="s3">\n  </span><span class="s1">while (unsortable.length &amp;&amp; (last = _.last(unsortable)).i &lt;= index) {</span><span class="s3">\n    </span><span class="s1">unsortable.pop();</span><span class="s3">\n    </span><span class="s1">vs.push(last.vs);</span><span class="s3">\n    </span><span class="s1">index++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function compareWithBias(bias) {</span><span class="s3">\n  </span><span class="s1">return function (entryV, entryW) {</span><span class="s3">\n    </span><span class="s1">if (entryV.barycenter &lt; entryW.barycenter) {</span><span class="s3">\n      </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">} else if (entryV.barycenter &gt; entryW.barycenter) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { barycenter } from './barycenter.js';</span><span class="s3">\n</span><span class="s1">import { resolveConflicts } from './resolve-conflicts.js';</span><span class="s3">\n</span><span class="s1">import { sort } from './sort.js';</span><span class="s3">\n\n</span><span class="s1">export { sortSubgraph };</span><span class="s3">\n\n</span><span class="s1">function sortSubgraph(g, v, cg, biasRight) {</span><span class="s3">\n  </span><span class="s1">var movable = g.children(v);</span><span class="s3">\n  </span><span class="s1">var node = g.node(v);</span><span class="s3">\n  </span><span class="s1">var bl = node ? node.borderLeft : undefined;</span><span class="s3">\n  </span><span class="s1">var br = node ? node.borderRight : undefined;</span><span class="s3">\n  </span><span class="s1">var subgraphs = {};</span><span class="s3">\n\n  </span><span class="s1">if (bl) {</span><span class="s3">\n    </span><span class="s1">movable = _.filter(movable, function (w) {</span><span class="s3">\n      </span><span class="s1">return w !== bl &amp;&amp; w !== br;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var barycenters = barycenter(g, movable);</span><span class="s3">\n  </span><span class="s1">_.forEach(barycenters, function (entry) {</span><span class="s3">\n    </span><span class="s1">if (g.children(entry.v).length) {</span><span class="s3">\n      </span><span class="s1">var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);</span><span class="s3">\n      </span><span class="s1">subgraphs[entry.v] = subgraphResult;</span><span class="s3">\n      </span><span class="s1">if (Object.prototype.hasOwnProperty.call(subgraphResult, 'barycenter')) {</span><span class="s3">\n        </span><span class="s1">mergeBarycenters(entry, subgraphResult);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var entries = resolveConflicts(barycenters, cg);</span><span class="s3">\n  </span><span class="s1">expandSubgraphs(entries, subgraphs);</span><span class="s3">\n\n  </span><span class="s1">var result = sort(entries, biasRight);</span><span class="s3">\n\n  </span><span class="s1">if (bl) {</span><span class="s3">\n    </span><span class="s1">result.vs = _.flatten([bl, result.vs, br]);</span><span class="s3">\n    </span><span class="s1">if (g.predecessors(bl).length) {</span><span class="s3">\n      </span><span class="s1">var blPred = g.node(g.predecessors(bl)[0]),</span><span class="s3">\n        </span><span class="s1">brPred = g.node(g.predecessors(br)[0]);</span><span class="s3">\n      </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(result, 'barycenter')) {</span><span class="s3">\n        </span><span class="s1">result.barycenter = 0;</span><span class="s3">\n        </span><span class="s1">result.weight = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result.barycenter =</span><span class="s3">\n        </span><span class="s1">(result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);</span><span class="s3">\n      </span><span class="s1">result.weight += 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function expandSubgraphs(entries, subgraphs) {</span><span class="s3">\n  </span><span class="s1">_.forEach(entries, function (entry) {</span><span class="s3">\n    </span><span class="s1">entry.vs = _.flatten(</span><span class="s3">\n      </span><span class="s1">entry.vs.map(function (v) {</span><span class="s3">\n        </span><span class="s1">if (subgraphs[v]) {</span><span class="s3">\n          </span><span class="s1">return subgraphs[v].vs;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return v;</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeBarycenters(target, other) {</span><span class="s3">\n  </span><span class="s1">if (!_.isUndefined(target.barycenter)) {</span><span class="s3">\n    </span><span class="s1">target.barycenter =</span><span class="s3">\n      </span><span class="s1">(target.barycenter * target.weight + other.barycenter * other.weight) /</span><span class="s3">\n      </span><span class="s1">(target.weight + other.weight);</span><span class="s3">\n    </span><span class="s1">target.weight += other.weight;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">target.barycenter = other.barycenter;</span><span class="s3">\n    </span><span class="s1">target.weight = other.weight;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../../graphlib/index.js';</span><span class="s3">\n</span><span class="s1">import * as util from '../util.js';</span><span class="s3">\n</span><span class="s1">import { addSubgraphConstraints } from './add-subgraph-constraints.js';</span><span class="s3">\n</span><span class="s1">import { buildLayerGraph } from './build-layer-graph.js';</span><span class="s3">\n</span><span class="s1">import { crossCount } from './cross-count.js';</span><span class="s3">\n</span><span class="s1">import { initOrder } from './init-order.js';</span><span class="s3">\n</span><span class="s1">import { sortSubgraph } from './sort-subgraph.js';</span><span class="s3">\n\n</span><span class="s1">export { order };</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Applies heuristics to minimize edge crossings in the graph and sets the best</span><span class="s3">\n </span><span class="s1">* order solution as an order attribute on each node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pre-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Graph must be DAG</span><span class="s3">\n </span><span class="s1">*    2. Graph nodes must be objects with a </span><span class="s3">\&quot;</span><span class="s1">rank</span><span class="s3">\&quot; </span><span class="s1">attribute</span><span class="s3">\n </span><span class="s1">*    3. Graph edges must have the </span><span class="s3">\&quot;</span><span class="s1">weight</span><span class="s3">\&quot; </span><span class="s1">attribute</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Post-conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Graph nodes will have an </span><span class="s3">\&quot;</span><span class="s1">order</span><span class="s3">\&quot; </span><span class="s1">attribute based on the results of the</span><span class="s3">\n </span><span class="s1">*       algorithm.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function order(g) {</span><span class="s3">\n  </span><span class="s1">var maxRank = util.maxRank(g),</span><span class="s3">\n    </span><span class="s1">downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges'),</span><span class="s3">\n    </span><span class="s1">upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges');</span><span class="s3">\n\n  </span><span class="s1">var layering = initOrder(g);</span><span class="s3">\n  </span><span class="s1">assignOrder(g, layering);</span><span class="s3">\n\n  </span><span class="s1">var bestCC = Number.POSITIVE_INFINITY,</span><span class="s3">\n    </span><span class="s1">best;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0, lastBest = 0; lastBest &lt; 4; ++i, ++lastBest) {</span><span class="s3">\n    </span><span class="s1">sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 &gt;= 2);</span><span class="s3">\n\n    </span><span class="s1">layering = util.buildLayerMatrix(g);</span><span class="s3">\n    </span><span class="s1">var cc = crossCount(g, layering);</span><span class="s3">\n    </span><span class="s1">if (cc &lt; bestCC) {</span><span class="s3">\n      </span><span class="s1">lastBest = 0;</span><span class="s3">\n      </span><span class="s1">best = _.cloneDeep(layering);</span><span class="s3">\n      </span><span class="s1">bestCC = cc;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">assignOrder(g, best);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildLayerGraphs(g, ranks, relationship) {</span><span class="s3">\n  </span><span class="s1">return _.map(ranks, function (rank) {</span><span class="s3">\n    </span><span class="s1">return buildLayerGraph(g, rank, relationship);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sweepLayerGraphs(layerGraphs, biasRight) {</span><span class="s3">\n  </span><span class="s1">var cg = new Graph();</span><span class="s3">\n  </span><span class="s1">_.forEach(layerGraphs, function (lg) {</span><span class="s3">\n    </span><span class="s1">var root = lg.graph().root;</span><span class="s3">\n    </span><span class="s1">var sorted = sortSubgraph(lg, root, cg, biasRight);</span><span class="s3">\n    </span><span class="s1">_.forEach(sorted.vs, function (v, i) {</span><span class="s3">\n      </span><span class="s1">lg.node(v).order = i;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">addSubgraphConstraints(lg, cg, sorted.vs);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assignOrder(g, layering) {</span><span class="s3">\n  </span><span class="s1">_.forEach(layering, function (layer) {</span><span class="s3">\n    </span><span class="s1">_.forEach(layer, function (v, i) {</span><span class="s3">\n      </span><span class="s1">g.node(v).order = i;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">export { parentDummyChains };</span><span class="s3">\n\n</span><span class="s1">function parentDummyChains(g) {</span><span class="s3">\n  </span><span class="s1">var postorderNums = postorder(g);</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.graph().dummyChains, function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">var edgeObj = node.edgeObj;</span><span class="s3">\n    </span><span class="s1">var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);</span><span class="s3">\n    </span><span class="s1">var path = pathData.path;</span><span class="s3">\n    </span><span class="s1">var lca = pathData.lca;</span><span class="s3">\n    </span><span class="s1">var pathIdx = 0;</span><span class="s3">\n    </span><span class="s1">var pathV = path[pathIdx];</span><span class="s3">\n    </span><span class="s1">var ascending = true;</span><span class="s3">\n\n    </span><span class="s1">while (v !== edgeObj.w) {</span><span class="s3">\n      </span><span class="s1">node = g.node(v);</span><span class="s3">\n\n      </span><span class="s1">if (ascending) {</span><span class="s3">\n        </span><span class="s1">while ((pathV = path[pathIdx]) !== lca &amp;&amp; g.node(pathV).maxRank &lt; node.rank) {</span><span class="s3">\n          </span><span class="s1">pathIdx++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (pathV === lca) {</span><span class="s3">\n          </span><span class="s1">ascending = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!ascending) {</span><span class="s3">\n        </span><span class="s1">while (</span><span class="s3">\n          </span><span class="s1">pathIdx &lt; path.length - 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">g.node((pathV = path[pathIdx + 1])).minRank &lt;= node.rank</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">pathIdx++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pathV = path[pathIdx];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">g.setParent(v, pathV);</span><span class="s3">\n      </span><span class="s1">v = g.successors(v)[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Find a path from v to w through the lowest common ancestor (LCA). Return the</span><span class="s3">\n</span><span class="s1">// full path and the LCA.</span><span class="s3">\n</span><span class="s1">function findPath(g, postorderNums, v, w) {</span><span class="s3">\n  </span><span class="s1">var vPath = [];</span><span class="s3">\n  </span><span class="s1">var wPath = [];</span><span class="s3">\n  </span><span class="s1">var low = Math.min(postorderNums[v].low, postorderNums[w].low);</span><span class="s3">\n  </span><span class="s1">var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);</span><span class="s3">\n  </span><span class="s1">var parent;</span><span class="s3">\n  </span><span class="s1">var lca;</span><span class="s3">\n\n  </span><span class="s1">// Traverse up from v to find the LCA</span><span class="s3">\n  </span><span class="s1">parent = v;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">parent = g.parent(parent);</span><span class="s3">\n    </span><span class="s1">vPath.push(parent);</span><span class="s3">\n  </span><span class="s1">} while (parent &amp;&amp; (postorderNums[parent].low &gt; low || lim &gt; postorderNums[parent].lim));</span><span class="s3">\n  </span><span class="s1">lca = parent;</span><span class="s3">\n\n  </span><span class="s1">// Traverse from w to LCA</span><span class="s3">\n  </span><span class="s1">parent = w;</span><span class="s3">\n  </span><span class="s1">while ((parent = g.parent(parent)) !== lca) {</span><span class="s3">\n    </span><span class="s1">wPath.push(parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { path: vPath.concat(wPath.reverse()), lca: lca };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function postorder(g) {</span><span class="s3">\n  </span><span class="s1">var result = {};</span><span class="s3">\n  </span><span class="s1">var lim = 0;</span><span class="s3">\n\n  </span><span class="s1">function dfs(v) {</span><span class="s3">\n    </span><span class="s1">var low = lim;</span><span class="s3">\n    </span><span class="s1">_.forEach(g.children(v), dfs);</span><span class="s3">\n    </span><span class="s1">result[v] = { low: low, lim: lim++ };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">_.forEach(g.children(), dfs);</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseForOwn from './_baseForOwn.js';</span><span class="s3">\n</span><span class="s1">import castFunction from './_castFunction.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates over own enumerable string keyed properties of an object and</span><span class="s3">\n </span><span class="s1">* invokes `iteratee` for each property. The iteratee is invoked with three</span><span class="s3">\n </span><span class="s1">* arguments: (value, key, object). Iteratee functions may exit iteration</span><span class="s3">\n </span><span class="s1">* early by explicitly returning `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.3.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.forOwnRight</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.a = 1;</span><span class="s3">\n </span><span class="s1">*   this.b = 2;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Foo.prototype.c = 3;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.forOwn(new Foo, function(value, key) {</span><span class="s3">\n </span><span class="s1">*   console.log(key);</span><span class="s3">\n </span><span class="s1">* });</span><span class="s3">\n </span><span class="s1">* // =&gt; Logs 'a' then 'b' (iteration order is not guaranteed).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function forOwn(object, iteratee) {</span><span class="s3">\n  </span><span class="s1">return object &amp;&amp; baseForOwn(object, castFunction(iteratee));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default forOwn;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFor from './_baseFor.js';</span><span class="s3">\n</span><span class="s1">import castFunction from './_castFunction.js';</span><span class="s3">\n</span><span class="s1">import keysIn from './keysIn.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates over own and inherited enumerable string keyed properties of an</span><span class="s3">\n </span><span class="s1">* object and invokes `iteratee` for each property. The iteratee is invoked</span><span class="s3">\n </span><span class="s1">* with three arguments: (value, key, object). Iteratee functions may exit</span><span class="s3">\n </span><span class="s1">* iteration early by explicitly returning `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.3.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.forInRight</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.a = 1;</span><span class="s3">\n </span><span class="s1">*   this.b = 2;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Foo.prototype.c = 3;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.forIn(new Foo, function(value, key) {</span><span class="s3">\n </span><span class="s1">*   console.log(key);</span><span class="s3">\n </span><span class="s1">* });</span><span class="s3">\n </span><span class="s1">* // =&gt; Logs 'a', 'b', then 'c' (iteration order is not guaranteed).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function forIn(object, iteratee) {</span><span class="s3">\n  </span><span class="s1">return object == null</span><span class="s3">\n    </span><span class="s1">? object</span><span class="s3">\n    </span><span class="s1">: baseFor(object, castFunction(iteratee), keysIn);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default forIn;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../../graphlib/index.js';</span><span class="s3">\n</span><span class="s1">import * as util from '../util.js';</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* This module provides coordinate assignment based on Brandes and Köpf, </span><span class="s3">\&quot;</span><span class="s1">Fast</span><span class="s3">\n </span><span class="s1">* and Simple Horizontal Coordinate Assignment.</span><span class="s3">\&quot;\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">positionX,</span><span class="s3">\n  </span><span class="s1">findType1Conflicts,</span><span class="s3">\n  </span><span class="s1">findType2Conflicts,</span><span class="s3">\n  </span><span class="s1">addConflict,</span><span class="s3">\n  </span><span class="s1">hasConflict,</span><span class="s3">\n  </span><span class="s1">verticalAlignment,</span><span class="s3">\n  </span><span class="s1">horizontalCompaction,</span><span class="s3">\n  </span><span class="s1">alignCoordinates,</span><span class="s3">\n  </span><span class="s1">findSmallestWidthAlignment,</span><span class="s3">\n  </span><span class="s1">balance,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Marks all edges in the graph with a type-1 conflict with the </span><span class="s3">\&quot;</span><span class="s1">type1Conflict</span><span class="s3">\&quot;\n </span><span class="s1">* property. A type-1 conflict is one where a non-inner segment crosses an</span><span class="s3">\n </span><span class="s1">* inner segment. An inner segment is an edge with both incident nodes marked</span><span class="s3">\n </span><span class="s1">* with the </span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">property.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This algorithm scans layer by layer, starting with the second, for type-1</span><span class="s3">\n </span><span class="s1">* conflicts between the current layer and the previous layer. For each layer</span><span class="s3">\n </span><span class="s1">* it scans the nodes from left to right until it reaches one that is incident</span><span class="s3">\n </span><span class="s1">* on an inner segment. It then scans predecessors to determine if they have</span><span class="s3">\n </span><span class="s1">* edges that cross that inner segment. At the end a final scan is done for all</span><span class="s3">\n </span><span class="s1">* nodes on the current rank to see if they cross the last visited inner</span><span class="s3">\n </span><span class="s1">* segment.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This algorithm (safely) assumes that a dummy node will only be incident on a</span><span class="s3">\n </span><span class="s1">* single node in the layers being scanned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findType1Conflicts(g, layering) {</span><span class="s3">\n  </span><span class="s1">var conflicts = {};</span><span class="s3">\n\n  </span><span class="s1">function visitLayer(prevLayer, layer) {</span><span class="s3">\n    </span><span class="s1">var // last visited node in the previous layer that is incident on an inner</span><span class="s3">\n      </span><span class="s1">// segment.</span><span class="s3">\n      </span><span class="s1">k0 = 0,</span><span class="s3">\n      </span><span class="s1">// Tracks the last node in this layer scanned for crossings with a type-1</span><span class="s3">\n      </span><span class="s1">// segment.</span><span class="s3">\n      </span><span class="s1">scanPos = 0,</span><span class="s3">\n      </span><span class="s1">prevLayerLength = prevLayer.length,</span><span class="s3">\n      </span><span class="s1">lastNode = _.last(layer);</span><span class="s3">\n\n    </span><span class="s1">_.forEach(layer, function (v, i) {</span><span class="s3">\n      </span><span class="s1">var w = findOtherInnerSegmentNode(g, v),</span><span class="s3">\n        </span><span class="s1">k1 = w ? g.node(w).order : prevLayerLength;</span><span class="s3">\n\n      </span><span class="s1">if (w || v === lastNode) {</span><span class="s3">\n        </span><span class="s1">_.forEach(layer.slice(scanPos, i + 1), function (scanNode) {</span><span class="s3">\n          </span><span class="s1">_.forEach(g.predecessors(scanNode), function (u) {</span><span class="s3">\n            </span><span class="s1">var uLabel = g.node(u),</span><span class="s3">\n              </span><span class="s1">uPos = uLabel.order;</span><span class="s3">\n            </span><span class="s1">if ((uPos &lt; k0 || k1 &lt; uPos) &amp;&amp; !(uLabel.dummy &amp;&amp; g.node(scanNode).dummy)) {</span><span class="s3">\n              </span><span class="s1">addConflict(conflicts, u, scanNode);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error</span><span class="s3">\n        </span><span class="s1">scanPos = i + 1;</span><span class="s3">\n        </span><span class="s1">k0 = k1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return layer;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.reduce(layering, visitLayer);</span><span class="s3">\n  </span><span class="s1">return conflicts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function findType2Conflicts(g, layering) {</span><span class="s3">\n  </span><span class="s1">var conflicts = {};</span><span class="s3">\n\n  </span><span class="s1">function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {</span><span class="s3">\n    </span><span class="s1">var v;</span><span class="s3">\n    </span><span class="s1">_.forEach(_.range(southPos, southEnd), function (i) {</span><span class="s3">\n      </span><span class="s1">v = south[i];</span><span class="s3">\n      </span><span class="s1">if (g.node(v).dummy) {</span><span class="s3">\n        </span><span class="s1">_.forEach(g.predecessors(v), function (u) {</span><span class="s3">\n          </span><span class="s1">var uNode = g.node(u);</span><span class="s3">\n          </span><span class="s1">if (uNode.dummy &amp;&amp; (uNode.order &lt; prevNorthBorder || uNode.order &gt; nextNorthBorder)) {</span><span class="s3">\n            </span><span class="s1">addConflict(conflicts, u, v);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function visitLayer(north, south) {</span><span class="s3">\n    </span><span class="s1">var prevNorthPos = -1,</span><span class="s3">\n      </span><span class="s1">nextNorthPos,</span><span class="s3">\n      </span><span class="s1">southPos = 0;</span><span class="s3">\n\n    </span><span class="s1">_.forEach(south, function (v, southLookahead) {</span><span class="s3">\n      </span><span class="s1">if (g.node(v).dummy === 'border') {</span><span class="s3">\n        </span><span class="s1">var predecessors = g.predecessors(v);</span><span class="s3">\n        </span><span class="s1">if (predecessors.length) {</span><span class="s3">\n          </span><span class="s1">nextNorthPos = g.node(predecessors[0]).order;</span><span class="s3">\n          </span><span class="s1">scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error</span><span class="s3">\n          </span><span class="s1">southPos = southLookahead;</span><span class="s3">\n          </span><span class="s1">prevNorthPos = nextNorthPos;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">scan(south, southPos, south.length, nextNorthPos, north.length);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return south;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.reduce(layering, visitLayer);</span><span class="s3">\n  </span><span class="s1">return conflicts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function findOtherInnerSegmentNode(g, v) {</span><span class="s3">\n  </span><span class="s1">if (g.node(v).dummy) {</span><span class="s3">\n    </span><span class="s1">return _.find(g.predecessors(v), function (u) {</span><span class="s3">\n      </span><span class="s1">return g.node(u).dummy;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addConflict(conflicts, v, w) {</span><span class="s3">\n  </span><span class="s1">if (v &gt; w) {</span><span class="s3">\n    </span><span class="s1">var tmp = v;</span><span class="s3">\n    </span><span class="s1">v = w;</span><span class="s3">\n    </span><span class="s1">w = tmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var conflictsV = conflicts[v];</span><span class="s3">\n  </span><span class="s1">if (!conflictsV) {</span><span class="s3">\n    </span><span class="s1">conflicts[v] = conflictsV = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">conflictsV[w] = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasConflict(conflicts, v, w) {</span><span class="s3">\n  </span><span class="s1">if (v &gt; w) {</span><span class="s3">\n    </span><span class="s1">var tmp = v;</span><span class="s3">\n    </span><span class="s1">v = w;</span><span class="s3">\n    </span><span class="s1">w = tmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return !!conflicts[v] &amp;&amp; Object.prototype.hasOwnProperty.call(conflicts[v], w);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Try to align nodes into vertical </span><span class="s3">\&quot;</span><span class="s1">blocks</span><span class="s3">\&quot; </span><span class="s1">where possible. This algorithm</span><span class="s3">\n </span><span class="s1">* attempts to align a node with one of its median neighbors. If the edge</span><span class="s3">\n </span><span class="s1">* connecting a neighbor is a type-1 conflict then we ignore that possibility.</span><span class="s3">\n </span><span class="s1">* If a previous node has already formed a block with a node after the node</span><span class="s3">\n </span><span class="s1">* we're trying to form a block with, we also ignore that possibility - our</span><span class="s3">\n </span><span class="s1">* blocks would be split in that scenario.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function verticalAlignment(g, layering, conflicts, neighborFn) {</span><span class="s3">\n  </span><span class="s1">var root = {},</span><span class="s3">\n    </span><span class="s1">align = {},</span><span class="s3">\n    </span><span class="s1">pos = {};</span><span class="s3">\n\n  </span><span class="s1">// We cache the position here based on the layering because the graph and</span><span class="s3">\n  </span><span class="s1">// layering may be out of sync. The layering matrix is manipulated to</span><span class="s3">\n  </span><span class="s1">// generate different extreme alignments.</span><span class="s3">\n  </span><span class="s1">_.forEach(layering, function (layer) {</span><span class="s3">\n    </span><span class="s1">_.forEach(layer, function (v, order) {</span><span class="s3">\n      </span><span class="s1">root[v] = v;</span><span class="s3">\n      </span><span class="s1">align[v] = v;</span><span class="s3">\n      </span><span class="s1">pos[v] = order;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(layering, function (layer) {</span><span class="s3">\n    </span><span class="s1">var prevIdx = -1;</span><span class="s3">\n    </span><span class="s1">_.forEach(layer, function (v) {</span><span class="s3">\n      </span><span class="s1">var ws = neighborFn(v);</span><span class="s3">\n      </span><span class="s1">if (ws.length) {</span><span class="s3">\n        </span><span class="s1">ws = _.sortBy(ws, function (w) {</span><span class="s3">\n          </span><span class="s1">return pos[w];</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">var mp = (ws.length - 1) / 2;</span><span class="s3">\n        </span><span class="s1">for (var i = Math.floor(mp), il = Math.ceil(mp); i &lt;= il; ++i) {</span><span class="s3">\n          </span><span class="s1">var w = ws[i];</span><span class="s3">\n          </span><span class="s1">if (align[v] === v &amp;&amp; prevIdx &lt; pos[w] &amp;&amp; !hasConflict(conflicts, v, w)) {</span><span class="s3">\n            </span><span class="s1">align[w] = v;</span><span class="s3">\n            </span><span class="s1">align[v] = root[v] = root[w];</span><span class="s3">\n            </span><span class="s1">prevIdx = pos[w];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return { root: root, align: align };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function horizontalCompaction(g, layering, root, align, reverseSep) {</span><span class="s3">\n  </span><span class="s1">// This portion of the algorithm differs from BK due to a number of problems.</span><span class="s3">\n  </span><span class="s1">// Instead of their algorithm we construct a new block graph and do two</span><span class="s3">\n  </span><span class="s1">// sweeps. The first sweep places blocks with the smallest possible</span><span class="s3">\n  </span><span class="s1">// coordinates. The second sweep removes unused space by moving blocks to the</span><span class="s3">\n  </span><span class="s1">// greatest coordinates without violating separation.</span><span class="s3">\n  </span><span class="s1">var xs = {},</span><span class="s3">\n    </span><span class="s1">blockG = buildBlockGraph(g, layering, root, reverseSep),</span><span class="s3">\n    </span><span class="s1">borderType = reverseSep ? 'borderLeft' : 'borderRight';</span><span class="s3">\n\n  </span><span class="s1">function iterate(setXsFunc, nextNodesFunc) {</span><span class="s3">\n    </span><span class="s1">var stack = blockG.nodes();</span><span class="s3">\n    </span><span class="s1">var elem = stack.pop();</span><span class="s3">\n    </span><span class="s1">var visited = {};</span><span class="s3">\n    </span><span class="s1">while (elem) {</span><span class="s3">\n      </span><span class="s1">if (visited[elem]) {</span><span class="s3">\n        </span><span class="s1">setXsFunc(elem);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">visited[elem] = true;</span><span class="s3">\n        </span><span class="s1">stack.push(elem);</span><span class="s3">\n        </span><span class="s1">stack = stack.concat(nextNodesFunc(elem));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">elem = stack.pop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// First pass, assign smallest coordinates</span><span class="s3">\n  </span><span class="s1">function pass1(elem) {</span><span class="s3">\n    </span><span class="s1">xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {</span><span class="s3">\n      </span><span class="s1">return Math.max(acc, xs[e.v] + blockG.edge(e));</span><span class="s3">\n    </span><span class="s1">}, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Second pass, assign greatest coordinates</span><span class="s3">\n  </span><span class="s1">function pass2(elem) {</span><span class="s3">\n    </span><span class="s1">var min = blockG.outEdges(elem).reduce(function (acc, e) {</span><span class="s3">\n      </span><span class="s1">return Math.min(acc, xs[e.w] - blockG.edge(e));</span><span class="s3">\n    </span><span class="s1">}, Number.POSITIVE_INFINITY);</span><span class="s3">\n\n    </span><span class="s1">var node = g.node(elem);</span><span class="s3">\n    </span><span class="s1">if (min !== Number.POSITIVE_INFINITY &amp;&amp; node.borderType !== borderType) {</span><span class="s3">\n      </span><span class="s1">xs[elem] = Math.max(xs[elem], min);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">iterate(pass1, blockG.predecessors.bind(blockG));</span><span class="s3">\n  </span><span class="s1">iterate(pass2, blockG.successors.bind(blockG));</span><span class="s3">\n\n  </span><span class="s1">// Assign x coordinates to all nodes</span><span class="s3">\n  </span><span class="s1">_.forEach(align, function (v) {</span><span class="s3">\n    </span><span class="s1">xs[v] = xs[root[v]];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return xs;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildBlockGraph(g, layering, root, reverseSep) {</span><span class="s3">\n  </span><span class="s1">var blockGraph = new Graph(),</span><span class="s3">\n    </span><span class="s1">graphLabel = g.graph(),</span><span class="s3">\n    </span><span class="s1">sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);</span><span class="s3">\n\n  </span><span class="s1">_.forEach(layering, function (layer) {</span><span class="s3">\n    </span><span class="s1">var u;</span><span class="s3">\n    </span><span class="s1">_.forEach(layer, function (v) {</span><span class="s3">\n      </span><span class="s1">var vRoot = root[v];</span><span class="s3">\n      </span><span class="s1">blockGraph.setNode(vRoot);</span><span class="s3">\n      </span><span class="s1">if (u) {</span><span class="s3">\n        </span><span class="s1">var uRoot = root[u],</span><span class="s3">\n          </span><span class="s1">prevMax = blockGraph.edge(uRoot, vRoot);</span><span class="s3">\n        </span><span class="s1">blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">u = v;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return blockGraph;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Returns the alignment that has the smallest width of the given alignments.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findSmallestWidthAlignment(g, xss) {</span><span class="s3">\n  </span><span class="s1">return _.minBy(_.values(xss), function (xs) {</span><span class="s3">\n    </span><span class="s1">var max = Number.NEGATIVE_INFINITY;</span><span class="s3">\n    </span><span class="s1">var min = Number.POSITIVE_INFINITY;</span><span class="s3">\n\n    </span><span class="s1">_.forIn(xs, function (x, v) {</span><span class="s3">\n      </span><span class="s1">var halfWidth = width(g, v) / 2;</span><span class="s3">\n\n      </span><span class="s1">max = Math.max(x + halfWidth, max);</span><span class="s3">\n      </span><span class="s1">min = Math.min(x - halfWidth, min);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return max - min;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Align the coordinates of each of the layout alignments such that</span><span class="s3">\n </span><span class="s1">* left-biased alignments have their minimum coordinate at the same point as</span><span class="s3">\n </span><span class="s1">* the minimum coordinate of the smallest width alignment and right-biased</span><span class="s3">\n </span><span class="s1">* alignments have their maximum coordinate at the same point as the maximum</span><span class="s3">\n </span><span class="s1">* coordinate of the smallest width alignment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function alignCoordinates(xss, alignTo) {</span><span class="s3">\n  </span><span class="s1">var alignToVals = _.values(alignTo),</span><span class="s3">\n    </span><span class="s1">alignToMin = _.min(alignToVals),</span><span class="s3">\n    </span><span class="s1">alignToMax = _.max(alignToVals);</span><span class="s3">\n\n  </span><span class="s1">_.forEach(['u', 'd'], function (vert) {</span><span class="s3">\n    </span><span class="s1">_.forEach(['l', 'r'], function (horiz) {</span><span class="s3">\n      </span><span class="s1">var alignment = vert + horiz,</span><span class="s3">\n        </span><span class="s1">xs = xss[alignment],</span><span class="s3">\n        </span><span class="s1">delta;</span><span class="s3">\n      </span><span class="s1">if (xs === alignTo) return;</span><span class="s3">\n\n      </span><span class="s1">var xsVals = _.values(xs);</span><span class="s3">\n      </span><span class="s1">delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);</span><span class="s3">\n\n      </span><span class="s1">if (delta) {</span><span class="s3">\n        </span><span class="s1">xss[alignment] = _.mapValues(xs, function (x) {</span><span class="s3">\n          </span><span class="s1">return x + delta;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function balance(xss, align) {</span><span class="s3">\n  </span><span class="s1">return _.mapValues(xss.ul, function (ignore, v) {</span><span class="s3">\n    </span><span class="s1">if (align) {</span><span class="s3">\n      </span><span class="s1">return xss[align.toLowerCase()][v];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var xs = _.sortBy(_.map(xss, v));</span><span class="s3">\n      </span><span class="s1">return (xs[1] + xs[2]) / 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function positionX(g) {</span><span class="s3">\n  </span><span class="s1">var layering = util.buildLayerMatrix(g);</span><span class="s3">\n  </span><span class="s1">var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));</span><span class="s3">\n\n  </span><span class="s1">var xss = {};</span><span class="s3">\n  </span><span class="s1">var adjustedLayering;</span><span class="s3">\n  </span><span class="s1">_.forEach(['u', 'd'], function (vert) {</span><span class="s3">\n    </span><span class="s1">adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse();</span><span class="s3">\n    </span><span class="s1">_.forEach(['l', 'r'], function (horiz) {</span><span class="s3">\n      </span><span class="s1">if (horiz === 'r') {</span><span class="s3">\n        </span><span class="s1">adjustedLayering = _.map(adjustedLayering, function (inner) {</span><span class="s3">\n          </span><span class="s1">return _.values(inner).reverse();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var neighborFn = (vert === 'u' ? g.predecessors : g.successors).bind(g);</span><span class="s3">\n      </span><span class="s1">var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);</span><span class="s3">\n      </span><span class="s1">var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === 'r');</span><span class="s3">\n      </span><span class="s1">if (horiz === 'r') {</span><span class="s3">\n        </span><span class="s1">xs = _.mapValues(xs, function (x) {</span><span class="s3">\n          </span><span class="s1">return -x;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">xss[vert + horiz] = xs;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var smallestWidth = findSmallestWidthAlignment(g, xss);</span><span class="s3">\n  </span><span class="s1">alignCoordinates(xss, smallestWidth);</span><span class="s3">\n  </span><span class="s1">return balance(xss, g.graph().align);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sep(nodeSep, edgeSep, reverseSep) {</span><span class="s3">\n  </span><span class="s1">return function (g, v, w) {</span><span class="s3">\n    </span><span class="s1">var vLabel = g.node(v);</span><span class="s3">\n    </span><span class="s1">var wLabel = g.node(w);</span><span class="s3">\n    </span><span class="s1">var sum = 0;</span><span class="s3">\n    </span><span class="s1">var delta;</span><span class="s3">\n\n    </span><span class="s1">sum += vLabel.width / 2;</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(vLabel, 'labelpos')) {</span><span class="s3">\n      </span><span class="s1">switch (vLabel.labelpos.toLowerCase()) {</span><span class="s3">\n        </span><span class="s1">case 'l':</span><span class="s3">\n          </span><span class="s1">delta = -vLabel.width / 2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'r':</span><span class="s3">\n          </span><span class="s1">delta = vLabel.width / 2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (delta) {</span><span class="s3">\n      </span><span class="s1">sum += reverseSep ? delta : -delta;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delta = 0;</span><span class="s3">\n\n    </span><span class="s1">sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;</span><span class="s3">\n    </span><span class="s1">sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;</span><span class="s3">\n\n    </span><span class="s1">sum += wLabel.width / 2;</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(wLabel, 'labelpos')) {</span><span class="s3">\n      </span><span class="s1">switch (wLabel.labelpos.toLowerCase()) {</span><span class="s3">\n        </span><span class="s1">case 'l':</span><span class="s3">\n          </span><span class="s1">delta = wLabel.width / 2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'r':</span><span class="s3">\n          </span><span class="s1">delta = -wLabel.width / 2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (delta) {</span><span class="s3">\n      </span><span class="s1">sum += reverseSep ? delta : -delta;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delta = 0;</span><span class="s3">\n\n    </span><span class="s1">return sum;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function width(g, v) {</span><span class="s3">\n  </span><span class="s1">return g.node(v).width;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import * as util from '../util.js';</span><span class="s3">\n</span><span class="s1">import { positionX } from './bk.js';</span><span class="s3">\n\n</span><span class="s1">export { position };</span><span class="s3">\n\n</span><span class="s1">function position(g) {</span><span class="s3">\n  </span><span class="s1">g = util.asNonCompoundGraph(g);</span><span class="s3">\n\n  </span><span class="s1">positionY(g);</span><span class="s3">\n  </span><span class="s1">_.forOwn(positionX(g), function (x, v) {</span><span class="s3">\n    </span><span class="s1">g.node(v).x = x;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function positionY(g) {</span><span class="s3">\n  </span><span class="s1">var layering = util.buildLayerMatrix(g);</span><span class="s3">\n  </span><span class="s1">var rankSep = g.graph().ranksep;</span><span class="s3">\n  </span><span class="s1">var prevY = 0;</span><span class="s3">\n  </span><span class="s1">_.forEach(layering, function (layer) {</span><span class="s3">\n    </span><span class="s1">var maxHeight = _.max(</span><span class="s3">\n      </span><span class="s1">_.map(layer, function (v) {</span><span class="s3">\n        </span><span class="s1">return g.node(v).height;</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">_.forEach(layer, function (v) {</span><span class="s3">\n      </span><span class="s1">g.node(v).y = prevY + maxHeight / 2;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">prevY += maxHeight + rankSep;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from '../graphlib/index.js';</span><span class="s3">\n</span><span class="s1">import { addBorderSegments } from './add-border-segments.js';</span><span class="s3">\n</span><span class="s1">import * as coordinateSystem from './coordinate-system.js';</span><span class="s3">\n</span><span class="s1">import * as acyclic from './acyclic.js';</span><span class="s3">\n</span><span class="s1">import * as normalize from './normalize.js';</span><span class="s3">\n</span><span class="s1">import { rank } from './rank/index.js';</span><span class="s3">\n</span><span class="s1">import * as nestingGraph from './nesting-graph.js';</span><span class="s3">\n</span><span class="s1">import { order } from './order/index.js';</span><span class="s3">\n</span><span class="s1">import { parentDummyChains } from './parent-dummy-chains.js';</span><span class="s3">\n</span><span class="s1">import { position } from './position/index.js';</span><span class="s3">\n</span><span class="s1">import * as util from './util.js';</span><span class="s3">\n\n</span><span class="s1">export { layout };</span><span class="s3">\n\n</span><span class="s1">function layout(g, opts) {</span><span class="s3">\n  </span><span class="s1">var time = opts &amp;&amp; opts.debugTiming ? util.time : util.notime;</span><span class="s3">\n  </span><span class="s1">time('layout', () =&gt; {</span><span class="s3">\n    </span><span class="s1">var layoutGraph = time('  buildLayoutGraph', () =&gt; buildLayoutGraph(g));</span><span class="s3">\n    </span><span class="s1">time('  runLayout', () =&gt; runLayout(layoutGraph, time));</span><span class="s3">\n    </span><span class="s1">time('  updateInputGraph', () =&gt; updateInputGraph(g, layoutGraph));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function runLayout(g, time) {</span><span class="s3">\n  </span><span class="s1">time('    makeSpaceForEdgeLabels', () =&gt; makeSpaceForEdgeLabels(g));</span><span class="s3">\n  </span><span class="s1">time('    removeSelfEdges', () =&gt; removeSelfEdges(g));</span><span class="s3">\n  </span><span class="s1">time('    acyclic', () =&gt; acyclic.run(g));</span><span class="s3">\n  </span><span class="s1">time('    nestingGraph.run', () =&gt; nestingGraph.run(g));</span><span class="s3">\n  </span><span class="s1">time('    rank', () =&gt; rank(util.asNonCompoundGraph(g)));</span><span class="s3">\n  </span><span class="s1">time('    injectEdgeLabelProxies', () =&gt; injectEdgeLabelProxies(g));</span><span class="s3">\n  </span><span class="s1">time('    removeEmptyRanks', () =&gt; util.removeEmptyRanks(g));</span><span class="s3">\n  </span><span class="s1">time('    nestingGraph.cleanup', () =&gt; nestingGraph.cleanup(g));</span><span class="s3">\n  </span><span class="s1">time('    normalizeRanks', () =&gt; util.normalizeRanks(g));</span><span class="s3">\n  </span><span class="s1">time('    assignRankMinMax', () =&gt; assignRankMinMax(g));</span><span class="s3">\n  </span><span class="s1">time('    removeEdgeLabelProxies', () =&gt; removeEdgeLabelProxies(g));</span><span class="s3">\n  </span><span class="s1">time('    normalize.run', () =&gt; normalize.run(g));</span><span class="s3">\n  </span><span class="s1">time('    parentDummyChains', () =&gt; parentDummyChains(g));</span><span class="s3">\n  </span><span class="s1">time('    addBorderSegments', () =&gt; addBorderSegments(g));</span><span class="s3">\n  </span><span class="s1">time('    order', () =&gt; order(g));</span><span class="s3">\n  </span><span class="s1">time('    insertSelfEdges', () =&gt; insertSelfEdges(g));</span><span class="s3">\n  </span><span class="s1">time('    adjustCoordinateSystem', () =&gt; coordinateSystem.adjust(g));</span><span class="s3">\n  </span><span class="s1">time('    position', () =&gt; position(g));</span><span class="s3">\n  </span><span class="s1">time('    positionSelfEdges', () =&gt; positionSelfEdges(g));</span><span class="s3">\n  </span><span class="s1">time('    removeBorderNodes', () =&gt; removeBorderNodes(g));</span><span class="s3">\n  </span><span class="s1">time('    normalize.undo', () =&gt; normalize.undo(g));</span><span class="s3">\n  </span><span class="s1">time('    fixupEdgeLabelCoords', () =&gt; fixupEdgeLabelCoords(g));</span><span class="s3">\n  </span><span class="s1">time('    undoCoordinateSystem', () =&gt; coordinateSystem.undo(g));</span><span class="s3">\n  </span><span class="s1">time('    translateGraph', () =&gt; translateGraph(g));</span><span class="s3">\n  </span><span class="s1">time('    assignNodeIntersects', () =&gt; assignNodeIntersects(g));</span><span class="s3">\n  </span><span class="s1">time('    reversePoints', () =&gt; reversePointsForReversedEdges(g));</span><span class="s3">\n  </span><span class="s1">time('    acyclic.undo', () =&gt; acyclic.undo(g));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copies final layout information from the layout graph back to the input</span><span class="s3">\n </span><span class="s1">* graph. This process only copies whitelisted attributes from the layout graph</span><span class="s3">\n </span><span class="s1">* to the input graph, so it serves as a good place to determine what</span><span class="s3">\n </span><span class="s1">* attributes can influence layout.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function updateInputGraph(inputGraph, layoutGraph) {</span><span class="s3">\n  </span><span class="s1">_.forEach(inputGraph.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var inputLabel = inputGraph.node(v);</span><span class="s3">\n    </span><span class="s1">var layoutLabel = layoutGraph.node(v);</span><span class="s3">\n\n    </span><span class="s1">if (inputLabel) {</span><span class="s3">\n      </span><span class="s1">inputLabel.x = layoutLabel.x;</span><span class="s3">\n      </span><span class="s1">inputLabel.y = layoutLabel.y;</span><span class="s3">\n\n      </span><span class="s1">if (layoutGraph.children(v).length) {</span><span class="s3">\n        </span><span class="s1">inputLabel.width = layoutLabel.width;</span><span class="s3">\n        </span><span class="s1">inputLabel.height = layoutLabel.height;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(inputGraph.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var inputLabel = inputGraph.edge(e);</span><span class="s3">\n    </span><span class="s1">var layoutLabel = layoutGraph.edge(e);</span><span class="s3">\n\n    </span><span class="s1">inputLabel.points = layoutLabel.points;</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(layoutLabel, 'x')) {</span><span class="s3">\n      </span><span class="s1">inputLabel.x = layoutLabel.x;</span><span class="s3">\n      </span><span class="s1">inputLabel.y = layoutLabel.y;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">inputGraph.graph().width = layoutGraph.graph().width;</span><span class="s3">\n  </span><span class="s1">inputGraph.graph().height = layoutGraph.graph().height;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy'];</span><span class="s3">\n</span><span class="s1">var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' };</span><span class="s3">\n</span><span class="s1">var graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align'];</span><span class="s3">\n</span><span class="s1">var nodeNumAttrs = ['width', 'height'];</span><span class="s3">\n</span><span class="s1">var nodeDefaults = { width: 0, height: 0 };</span><span class="s3">\n</span><span class="s1">var edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset'];</span><span class="s3">\n</span><span class="s1">var edgeDefaults = {</span><span class="s3">\n  </span><span class="s1">minlen: 1,</span><span class="s3">\n  </span><span class="s1">weight: 1,</span><span class="s3">\n  </span><span class="s1">width: 0,</span><span class="s3">\n  </span><span class="s1">height: 0,</span><span class="s3">\n  </span><span class="s1">labeloffset: 10,</span><span class="s3">\n  </span><span class="s1">labelpos: 'r',</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var edgeAttrs = ['labelpos'];</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Constructs a new graph from the input graph, which can be used for layout.</span><span class="s3">\n </span><span class="s1">* This process copies only whitelisted attributes from the input graph to the</span><span class="s3">\n </span><span class="s1">* layout graph. Thus this function serves as a good place to determine what</span><span class="s3">\n </span><span class="s1">* attributes can influence layout.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildLayoutGraph(inputGraph) {</span><span class="s3">\n  </span><span class="s1">var g = new Graph({ multigraph: true, compound: true });</span><span class="s3">\n  </span><span class="s1">var graph = canonicalize(inputGraph.graph());</span><span class="s3">\n\n  </span><span class="s1">g.setGraph(</span><span class="s3">\n    </span><span class="s1">_.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _.pick(graph, graphAttrs)),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">_.forEach(inputGraph.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = canonicalize(inputGraph.node(v));</span><span class="s3">\n    </span><span class="s1">g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));</span><span class="s3">\n    </span><span class="s1">g.setParent(v, inputGraph.parent(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(inputGraph.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = canonicalize(inputGraph.edge(e));</span><span class="s3">\n    </span><span class="s1">g.setEdge(</span><span class="s3">\n      </span><span class="s1">e,</span><span class="s3">\n      </span><span class="s1">_.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _.pick(edge, edgeAttrs)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return g;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* This idea comes from the Gansner paper: to account for edge labels in our</span><span class="s3">\n </span><span class="s1">* layout we split each rank in half by doubling minlen and halving ranksep.</span><span class="s3">\n </span><span class="s1">* Then we can place labels at these mid-points between nodes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* We also add some minimal padding to the width to push the label for the edge</span><span class="s3">\n </span><span class="s1">* away from the edge itself a bit.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function makeSpaceForEdgeLabels(g) {</span><span class="s3">\n  </span><span class="s1">var graph = g.graph();</span><span class="s3">\n  </span><span class="s1">graph.ranksep /= 2;</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">edge.minlen *= 2;</span><span class="s3">\n    </span><span class="s1">if (edge.labelpos.toLowerCase() !== 'c') {</span><span class="s3">\n      </span><span class="s1">if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {</span><span class="s3">\n        </span><span class="s1">edge.width += edge.labeloffset;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">edge.height += edge.labeloffset;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Creates temporary dummy nodes that capture the rank in which each edge's</span><span class="s3">\n </span><span class="s1">* label is going to, if it has one of non-zero width and height. We do this</span><span class="s3">\n </span><span class="s1">* so that we can safely remove empty ranks while preserving balance for the</span><span class="s3">\n </span><span class="s1">* label's position.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function injectEdgeLabelProxies(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">if (edge.width &amp;&amp; edge.height) {</span><span class="s3">\n      </span><span class="s1">var v = g.node(e.v);</span><span class="s3">\n      </span><span class="s1">var w = g.node(e.w);</span><span class="s3">\n      </span><span class="s1">var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };</span><span class="s3">\n      </span><span class="s1">util.addDummyNode(g, 'edge-proxy', label, '_ep');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assignRankMinMax(g) {</span><span class="s3">\n  </span><span class="s1">var maxRank = 0;</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">if (node.borderTop) {</span><span class="s3">\n      </span><span class="s1">node.minRank = g.node(node.borderTop).rank;</span><span class="s3">\n      </span><span class="s1">node.maxRank = g.node(node.borderBottom).rank;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error</span><span class="s3">\n      </span><span class="s1">maxRank = _.max(maxRank, node.maxRank);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">g.graph().maxRank = maxRank;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeEdgeLabelProxies(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">if (node.dummy === 'edge-proxy') {</span><span class="s3">\n      </span><span class="s1">g.edge(node.e).labelRank = node.rank;</span><span class="s3">\n      </span><span class="s1">g.removeNode(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function translateGraph(g) {</span><span class="s3">\n  </span><span class="s1">var minX = Number.POSITIVE_INFINITY;</span><span class="s3">\n  </span><span class="s1">var maxX = 0;</span><span class="s3">\n  </span><span class="s1">var minY = Number.POSITIVE_INFINITY;</span><span class="s3">\n  </span><span class="s1">var maxY = 0;</span><span class="s3">\n  </span><span class="s1">var graphLabel = g.graph();</span><span class="s3">\n  </span><span class="s1">var marginX = graphLabel.marginx || 0;</span><span class="s3">\n  </span><span class="s1">var marginY = graphLabel.marginy || 0;</span><span class="s3">\n\n  </span><span class="s1">function getExtremes(attrs) {</span><span class="s3">\n    </span><span class="s1">var x = attrs.x;</span><span class="s3">\n    </span><span class="s1">var y = attrs.y;</span><span class="s3">\n    </span><span class="s1">var w = attrs.width;</span><span class="s3">\n    </span><span class="s1">var h = attrs.height;</span><span class="s3">\n    </span><span class="s1">minX = Math.min(minX, x - w / 2);</span><span class="s3">\n    </span><span class="s1">maxX = Math.max(maxX, x + w / 2);</span><span class="s3">\n    </span><span class="s1">minY = Math.min(minY, y - h / 2);</span><span class="s3">\n    </span><span class="s1">maxY = Math.max(maxY, y + h / 2);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">getExtremes(g.node(v));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(edge, 'x')) {</span><span class="s3">\n      </span><span class="s1">getExtremes(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">minX -= marginX;</span><span class="s3">\n  </span><span class="s1">minY -= marginY;</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">node.x -= minX;</span><span class="s3">\n    </span><span class="s1">node.y -= minY;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">_.forEach(edge.points, function (p) {</span><span class="s3">\n      </span><span class="s1">p.x -= minX;</span><span class="s3">\n      </span><span class="s1">p.y -= minY;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(edge, 'x')) {</span><span class="s3">\n      </span><span class="s1">edge.x -= minX;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(edge, 'y')) {</span><span class="s3">\n      </span><span class="s1">edge.y -= minY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">graphLabel.width = maxX - minX + marginX;</span><span class="s3">\n  </span><span class="s1">graphLabel.height = maxY - minY + marginY;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assignNodeIntersects(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">var nodeV = g.node(e.v);</span><span class="s3">\n    </span><span class="s1">var nodeW = g.node(e.w);</span><span class="s3">\n    </span><span class="s1">var p1, p2;</span><span class="s3">\n    </span><span class="s1">if (!edge.points) {</span><span class="s3">\n      </span><span class="s1">edge.points = [];</span><span class="s3">\n      </span><span class="s1">p1 = nodeW;</span><span class="s3">\n      </span><span class="s1">p2 = nodeV;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">p1 = edge.points[0];</span><span class="s3">\n      </span><span class="s1">p2 = edge.points[edge.points.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">edge.points.unshift(util.intersectRect(nodeV, p1));</span><span class="s3">\n    </span><span class="s1">edge.points.push(util.intersectRect(nodeW, p2));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fixupEdgeLabelCoords(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(edge, 'x')) {</span><span class="s3">\n      </span><span class="s1">if (edge.labelpos === 'l' || edge.labelpos === 'r') {</span><span class="s3">\n        </span><span class="s1">edge.width -= edge.labeloffset;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">switch (edge.labelpos) {</span><span class="s3">\n        </span><span class="s1">case 'l':</span><span class="s3">\n          </span><span class="s1">edge.x -= edge.width / 2 + edge.labeloffset;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'r':</span><span class="s3">\n          </span><span class="s1">edge.x += edge.width / 2 + edge.labeloffset;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function reversePointsForReversedEdges(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edge = g.edge(e);</span><span class="s3">\n    </span><span class="s1">if (edge.reversed) {</span><span class="s3">\n      </span><span class="s1">edge.points.reverse();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeBorderNodes(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">if (g.children(v).length) {</span><span class="s3">\n      </span><span class="s1">var node = g.node(v);</span><span class="s3">\n      </span><span class="s1">var t = g.node(node.borderTop);</span><span class="s3">\n      </span><span class="s1">var b = g.node(node.borderBottom);</span><span class="s3">\n      </span><span class="s1">var l = g.node(_.last(node.borderLeft));</span><span class="s3">\n      </span><span class="s1">var r = g.node(_.last(node.borderRight));</span><span class="s3">\n\n      </span><span class="s1">node.width = Math.abs(r.x - l.x);</span><span class="s3">\n      </span><span class="s1">node.height = Math.abs(b.y - t.y);</span><span class="s3">\n      </span><span class="s1">node.x = l.x + node.width / 2;</span><span class="s3">\n      </span><span class="s1">node.y = t.y + node.height / 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">if (g.node(v).dummy === 'border') {</span><span class="s3">\n      </span><span class="s1">g.removeNode(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeSelfEdges(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">if (e.v === e.w) {</span><span class="s3">\n      </span><span class="s1">var node = g.node(e.v);</span><span class="s3">\n      </span><span class="s1">if (!node.selfEdges) {</span><span class="s3">\n        </span><span class="s1">node.selfEdges = [];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">node.selfEdges.push({ e: e, label: g.edge(e) });</span><span class="s3">\n      </span><span class="s1">g.removeEdge(e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function insertSelfEdges(g) {</span><span class="s3">\n  </span><span class="s1">var layers = util.buildLayerMatrix(g);</span><span class="s3">\n  </span><span class="s1">_.forEach(layers, function (layer) {</span><span class="s3">\n    </span><span class="s1">var orderShift = 0;</span><span class="s3">\n    </span><span class="s1">_.forEach(layer, function (v, i) {</span><span class="s3">\n      </span><span class="s1">var node = g.node(v);</span><span class="s3">\n      </span><span class="s1">node.order = i + orderShift;</span><span class="s3">\n      </span><span class="s1">_.forEach(node.selfEdges, function (selfEdge) {</span><span class="s3">\n        </span><span class="s1">util.addDummyNode(</span><span class="s3">\n          </span><span class="s1">g,</span><span class="s3">\n          </span><span class="s1">'selfedge',</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">width: selfEdge.label.width,</span><span class="s3">\n            </span><span class="s1">height: selfEdge.label.height,</span><span class="s3">\n            </span><span class="s1">rank: node.rank,</span><span class="s3">\n            </span><span class="s1">order: i + ++orderShift,</span><span class="s3">\n            </span><span class="s1">e: selfEdge.e,</span><span class="s3">\n            </span><span class="s1">label: selfEdge.label,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">'_se',</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">delete node.selfEdges;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function positionSelfEdges(g) {</span><span class="s3">\n  </span><span class="s1">_.forEach(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var node = g.node(v);</span><span class="s3">\n    </span><span class="s1">if (node.dummy === 'selfedge') {</span><span class="s3">\n      </span><span class="s1">var selfNode = g.node(node.e.v);</span><span class="s3">\n      </span><span class="s1">var x = selfNode.x + selfNode.width / 2;</span><span class="s3">\n      </span><span class="s1">var y = selfNode.y;</span><span class="s3">\n      </span><span class="s1">var dx = node.x - x;</span><span class="s3">\n      </span><span class="s1">var dy = selfNode.height / 2;</span><span class="s3">\n      </span><span class="s1">g.setEdge(node.e, node.label);</span><span class="s3">\n      </span><span class="s1">g.removeNode(v);</span><span class="s3">\n      </span><span class="s1">node.label.points = [</span><span class="s3">\n        </span><span class="s1">{ x: x + (2 * dx) / 3, y: y - dy },</span><span class="s3">\n        </span><span class="s1">{ x: x + (5 * dx) / 6, y: y - dy },</span><span class="s3">\n        </span><span class="s1">{ x: x + dx, y: y },</span><span class="s3">\n        </span><span class="s1">{ x: x + (5 * dx) / 6, y: y + dy },</span><span class="s3">\n        </span><span class="s1">{ x: x + (2 * dx) / 3, y: y + dy },</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n      </span><span class="s1">node.label.x = node.x;</span><span class="s3">\n      </span><span class="s1">node.label.y = node.y;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function selectNumberAttrs(obj, attrs) {</span><span class="s3">\n  </span><span class="s1">return _.mapValues(_.pick(obj, attrs), Number);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function canonicalize(attrs) {</span><span class="s3">\n  </span><span class="s1">var newAttrs = {};</span><span class="s3">\n  </span><span class="s1">_.forEach(attrs, function (v, k) {</span><span class="s3">\n    </span><span class="s1">newAttrs[k.toLowerCase()] = v;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return newAttrs;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as acyclic from './acyclic.js';</span><span class="s3">\n</span><span class="s1">import { layout } from './layout.js';</span><span class="s3">\n</span><span class="s1">import * as normalize from './normalize.js';</span><span class="s3">\n</span><span class="s1">import { rank } from './rank/index.js';</span><span class="s3">\n\n</span><span class="s1">export { acyclic, normalize, rank, layout };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFlatten from './_baseFlatten.js';</span><span class="s3">\n</span><span class="s1">import baseRest from './_baseRest.js';</span><span class="s3">\n</span><span class="s1">import baseUniq from './_baseUniq.js';</span><span class="s3">\n</span><span class="s1">import isArrayLikeObject from './isArrayLikeObject.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of unique values, in order, from all given arrays using</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {...Array} [arrays] The arrays to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of combined values.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.union([2], [1, 2]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2, 1]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var union = baseRest(function(arrays) {</span><span class="s3">\n  </span><span class="s1">return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default union;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n\n</span><span class="s1">var DEFAULT_EDGE_NAME = '</span><span class="s3">\\</span><span class="s1">x00';</span><span class="s3">\n</span><span class="s1">var GRAPH_NODE = '</span><span class="s3">\\</span><span class="s1">x00';</span><span class="s3">\n</span><span class="s1">var EDGE_KEY_DELIM = '</span><span class="s3">\\</span><span class="s1">x01';</span><span class="s3">\n\n</span><span class="s1">// Implementation notes:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  * Node id query functions should return string ids for the nodes</span><span class="s3">\n</span><span class="s1">//  * Edge id query functions should return an </span><span class="s3">\&quot;</span><span class="s1">edgeObj</span><span class="s3">\&quot;</span><span class="s1">, edge object, that is</span><span class="s3">\n</span><span class="s1">//    composed of enough information to uniquely identify an edge: {v, w, name}.</span><span class="s3">\n</span><span class="s1">//  * Internally we use an </span><span class="s3">\&quot;</span><span class="s1">edgeId</span><span class="s3">\&quot;</span><span class="s1">, a stringified form of the edgeObj, to</span><span class="s3">\n</span><span class="s1">//    reference edges. This is because we need a performant way to look these</span><span class="s3">\n</span><span class="s1">//    edges up and, object properties, which have string keys, are the closest</span><span class="s3">\n</span><span class="s1">//    we're going to get to a performant hashtable in JavaScript.</span><span class="s3">\n\n</span><span class="s1">// Implementation notes:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  * Node id query functions should return string ids for the nodes</span><span class="s3">\n</span><span class="s1">//  * Edge id query functions should return an </span><span class="s3">\&quot;</span><span class="s1">edgeObj</span><span class="s3">\&quot;</span><span class="s1">, edge object, that is</span><span class="s3">\n</span><span class="s1">//    composed of enough information to uniquely identify an edge: {v, w, name}.</span><span class="s3">\n</span><span class="s1">//  * Internally we use an </span><span class="s3">\&quot;</span><span class="s1">edgeId</span><span class="s3">\&quot;</span><span class="s1">, a stringified form of the edgeObj, to</span><span class="s3">\n</span><span class="s1">//    reference edges. This is because we need a performant way to look these</span><span class="s3">\n</span><span class="s1">//    edges up and, object properties, which have string keys, are the closest</span><span class="s3">\n</span><span class="s1">//    we're going to get to a performant hashtable in JavaScript.</span><span class="s3">\n</span><span class="s1">export class Graph {</span><span class="s3">\n  </span><span class="s1">constructor(opts = {}) {</span><span class="s3">\n    </span><span class="s1">this._isDirected = Object.prototype.hasOwnProperty.call(opts, 'directed')</span><span class="s3">\n      </span><span class="s1">? opts.directed</span><span class="s3">\n      </span><span class="s1">: true;</span><span class="s3">\n    </span><span class="s1">this._isMultigraph = Object.prototype.hasOwnProperty.call(opts, 'multigraph')</span><span class="s3">\n      </span><span class="s1">? opts.multigraph</span><span class="s3">\n      </span><span class="s1">: false;</span><span class="s3">\n    </span><span class="s1">this._isCompound = Object.prototype.hasOwnProperty.call(opts, 'compound')</span><span class="s3">\n      </span><span class="s1">? opts.compound</span><span class="s3">\n      </span><span class="s1">: false;</span><span class="s3">\n\n    </span><span class="s1">// Label for the graph itself</span><span class="s3">\n    </span><span class="s1">this._label = undefined;</span><span class="s3">\n\n    </span><span class="s1">// Defaults to be set when creating a new node</span><span class="s3">\n    </span><span class="s1">this._defaultNodeLabelFn = _.constant(undefined);</span><span class="s3">\n\n    </span><span class="s1">// Defaults to be set when creating a new edge</span><span class="s3">\n    </span><span class="s1">this._defaultEdgeLabelFn = _.constant(undefined);</span><span class="s3">\n\n    </span><span class="s1">// v -&gt; label</span><span class="s3">\n    </span><span class="s1">this._nodes = {};</span><span class="s3">\n\n    </span><span class="s1">if (this._isCompound) {</span><span class="s3">\n      </span><span class="s1">// v -&gt; parent</span><span class="s3">\n      </span><span class="s1">this._parent = {};</span><span class="s3">\n\n      </span><span class="s1">// v -&gt; children</span><span class="s3">\n      </span><span class="s1">this._children = {};</span><span class="s3">\n      </span><span class="s1">this._children[GRAPH_NODE] = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// v -&gt; edgeObj</span><span class="s3">\n    </span><span class="s1">this._in = {};</span><span class="s3">\n\n    </span><span class="s1">// u -&gt; v -&gt; Number</span><span class="s3">\n    </span><span class="s1">this._preds = {};</span><span class="s3">\n\n    </span><span class="s1">// v -&gt; edgeObj</span><span class="s3">\n    </span><span class="s1">this._out = {};</span><span class="s3">\n\n    </span><span class="s1">// v -&gt; w -&gt; Number</span><span class="s3">\n    </span><span class="s1">this._sucs = {};</span><span class="s3">\n\n    </span><span class="s1">// e -&gt; edgeObj</span><span class="s3">\n    </span><span class="s1">this._edgeObjs = {};</span><span class="s3">\n\n    </span><span class="s1">// e -&gt; label</span><span class="s3">\n    </span><span class="s1">this._edgeLabels = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/* === Graph functions ========= */</span><span class="s3">\n  </span><span class="s1">isDirected() {</span><span class="s3">\n    </span><span class="s1">return this._isDirected;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isMultigraph() {</span><span class="s3">\n    </span><span class="s1">return this._isMultigraph;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isCompound() {</span><span class="s3">\n    </span><span class="s1">return this._isCompound;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">setGraph(label) {</span><span class="s3">\n    </span><span class="s1">this._label = label;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">graph() {</span><span class="s3">\n    </span><span class="s1">return this._label;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/* === Node functions ========== */</span><span class="s3">\n  </span><span class="s1">setDefaultNodeLabel(newDefault) {</span><span class="s3">\n    </span><span class="s1">if (!_.isFunction(newDefault)) {</span><span class="s3">\n      </span><span class="s1">newDefault = _.constant(newDefault);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._defaultNodeLabelFn = newDefault;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodeCount() {</span><span class="s3">\n    </span><span class="s1">return this._nodeCount;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodes() {</span><span class="s3">\n    </span><span class="s1">return _.keys(this._nodes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">sources() {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">return _.filter(this.nodes(), function (v) {</span><span class="s3">\n      </span><span class="s1">return _.isEmpty(self._in[v]);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">sinks() {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">return _.filter(this.nodes(), function (v) {</span><span class="s3">\n      </span><span class="s1">return _.isEmpty(self._out[v]);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">setNodes(vs, value) {</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">_.each(vs, function (v) {</span><span class="s3">\n      </span><span class="s1">if (args.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">self.setNode(v, value);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">self.setNode(v);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">setNode(v, value) {</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(this._nodes, v)) {</span><span class="s3">\n      </span><span class="s1">if (arguments.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">this._nodes[v] = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">this._nodes[v] = arguments.length &gt; 1 ? value : this._defaultNodeLabelFn(v);</span><span class="s3">\n    </span><span class="s1">if (this._isCompound) {</span><span class="s3">\n      </span><span class="s1">this._parent[v] = GRAPH_NODE;</span><span class="s3">\n      </span><span class="s1">this._children[v] = {};</span><span class="s3">\n      </span><span class="s1">this._children[GRAPH_NODE][v] = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._in[v] = {};</span><span class="s3">\n    </span><span class="s1">this._preds[v] = {};</span><span class="s3">\n    </span><span class="s1">this._out[v] = {};</span><span class="s3">\n    </span><span class="s1">this._sucs[v] = {};</span><span class="s3">\n    </span><span class="s1">++this._nodeCount;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">node(v) {</span><span class="s3">\n    </span><span class="s1">return this._nodes[v];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">hasNode(v) {</span><span class="s3">\n    </span><span class="s1">return Object.prototype.hasOwnProperty.call(this._nodes, v);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">removeNode(v) {</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(this._nodes, v)) {</span><span class="s3">\n      </span><span class="s1">var removeEdge = (e) =&gt; this.removeEdge(this._edgeObjs[e]);</span><span class="s3">\n      </span><span class="s1">delete this._nodes[v];</span><span class="s3">\n      </span><span class="s1">if (this._isCompound) {</span><span class="s3">\n        </span><span class="s1">this._removeFromParentsChildList(v);</span><span class="s3">\n        </span><span class="s1">delete this._parent[v];</span><span class="s3">\n        </span><span class="s1">_.each(this.children(v), (child) =&gt; {</span><span class="s3">\n          </span><span class="s1">this.setParent(child);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">delete this._children[v];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_.each(_.keys(this._in[v]), removeEdge);</span><span class="s3">\n      </span><span class="s1">delete this._in[v];</span><span class="s3">\n      </span><span class="s1">delete this._preds[v];</span><span class="s3">\n      </span><span class="s1">_.each(_.keys(this._out[v]), removeEdge);</span><span class="s3">\n      </span><span class="s1">delete this._out[v];</span><span class="s3">\n      </span><span class="s1">delete this._sucs[v];</span><span class="s3">\n      </span><span class="s1">--this._nodeCount;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">setParent(v, parent) {</span><span class="s3">\n    </span><span class="s1">if (!this._isCompound) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Cannot set parent in a non-compound graph');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (_.isUndefined(parent)) {</span><span class="s3">\n      </span><span class="s1">parent = GRAPH_NODE;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Coerce parent to string</span><span class="s3">\n      </span><span class="s1">parent += '';</span><span class="s3">\n      </span><span class="s1">for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {</span><span class="s3">\n        </span><span class="s1">if (ancestor === v) {</span><span class="s3">\n          </span><span class="s1">throw new Error('Setting ' + parent + ' as parent of ' + v + ' would create a cycle');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.setNode(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.setNode(v);</span><span class="s3">\n    </span><span class="s1">this._removeFromParentsChildList(v);</span><span class="s3">\n    </span><span class="s1">this._parent[v] = parent;</span><span class="s3">\n    </span><span class="s1">this._children[parent][v] = true;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">_removeFromParentsChildList(v) {</span><span class="s3">\n    </span><span class="s1">delete this._children[this._parent[v]][v];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">parent(v) {</span><span class="s3">\n    </span><span class="s1">if (this._isCompound) {</span><span class="s3">\n      </span><span class="s1">var parent = this._parent[v];</span><span class="s3">\n      </span><span class="s1">if (parent !== GRAPH_NODE) {</span><span class="s3">\n        </span><span class="s1">return parent;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">children(v) {</span><span class="s3">\n    </span><span class="s1">if (_.isUndefined(v)) {</span><span class="s3">\n      </span><span class="s1">v = GRAPH_NODE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this._isCompound) {</span><span class="s3">\n      </span><span class="s1">var children = this._children[v];</span><span class="s3">\n      </span><span class="s1">if (children) {</span><span class="s3">\n        </span><span class="s1">return _.keys(children);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (v === GRAPH_NODE) {</span><span class="s3">\n      </span><span class="s1">return this.nodes();</span><span class="s3">\n    </span><span class="s1">} else if (this.hasNode(v)) {</span><span class="s3">\n      </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">predecessors(v) {</span><span class="s3">\n    </span><span class="s1">var predsV = this._preds[v];</span><span class="s3">\n    </span><span class="s1">if (predsV) {</span><span class="s3">\n      </span><span class="s1">return _.keys(predsV);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">successors(v) {</span><span class="s3">\n    </span><span class="s1">var sucsV = this._sucs[v];</span><span class="s3">\n    </span><span class="s1">if (sucsV) {</span><span class="s3">\n      </span><span class="s1">return _.keys(sucsV);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">neighbors(v) {</span><span class="s3">\n    </span><span class="s1">var preds = this.predecessors(v);</span><span class="s3">\n    </span><span class="s1">if (preds) {</span><span class="s3">\n      </span><span class="s1">return _.union(preds, this.successors(v));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isLeaf(v) {</span><span class="s3">\n    </span><span class="s1">var neighbors;</span><span class="s3">\n    </span><span class="s1">if (this.isDirected()) {</span><span class="s3">\n      </span><span class="s1">neighbors = this.successors(v);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">neighbors = this.neighbors(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return neighbors.length === 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">filterNodes(filter) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">var copy = new this.constructor({</span><span class="s3">\n      </span><span class="s1">directed: this._isDirected,</span><span class="s3">\n      </span><span class="s1">multigraph: this._isMultigraph,</span><span class="s3">\n      </span><span class="s1">compound: this._isCompound,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">copy.setGraph(this.graph());</span><span class="s3">\n\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">_.each(this._nodes, function (value, v) {</span><span class="s3">\n      </span><span class="s1">if (filter(v)) {</span><span class="s3">\n        </span><span class="s1">copy.setNode(v, value);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">_.each(this._edgeObjs, function (e) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error</span><span class="s3">\n      </span><span class="s1">if (copy.hasNode(e.v) &amp;&amp; copy.hasNode(e.w)) {</span><span class="s3">\n        </span><span class="s1">copy.setEdge(e, self.edge(e));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">var parents = {};</span><span class="s3">\n    </span><span class="s1">function findParent(v) {</span><span class="s3">\n      </span><span class="s1">var parent = self.parent(v);</span><span class="s3">\n      </span><span class="s1">if (parent === undefined || copy.hasNode(parent)) {</span><span class="s3">\n        </span><span class="s1">parents[v] = parent;</span><span class="s3">\n        </span><span class="s1">return parent;</span><span class="s3">\n      </span><span class="s1">} else if (parent in parents) {</span><span class="s3">\n        </span><span class="s1">return parents[parent];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return findParent(parent);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this._isCompound) {</span><span class="s3">\n      </span><span class="s1">_.each(copy.nodes(), function (v) {</span><span class="s3">\n        </span><span class="s1">copy.setParent(v, findParent(v));</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return copy;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/* === Edge functions ========== */</span><span class="s3">\n  </span><span class="s1">setDefaultEdgeLabel(newDefault) {</span><span class="s3">\n    </span><span class="s1">if (!_.isFunction(newDefault)) {</span><span class="s3">\n      </span><span class="s1">newDefault = _.constant(newDefault);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._defaultEdgeLabelFn = newDefault;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">edgeCount() {</span><span class="s3">\n    </span><span class="s1">return this._edgeCount;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">edges() {</span><span class="s3">\n    </span><span class="s1">return _.values(this._edgeObjs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">setPath(vs, value) {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">_.reduce(vs, function (v, w) {</span><span class="s3">\n      </span><span class="s1">if (args.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">self.setEdge(v, w, value);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">self.setEdge(v, w);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return w;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/*</span><span class="s3">\n   </span><span class="s1">* setEdge(v, w, [value, [name]])</span><span class="s3">\n   </span><span class="s1">* setEdge({ v, w, [name] }, [value])</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setEdge() {</span><span class="s3">\n    </span><span class="s1">var v, w, name, value;</span><span class="s3">\n    </span><span class="s1">var valueSpecified = false;</span><span class="s3">\n    </span><span class="s1">var arg0 = arguments[0];</span><span class="s3">\n\n    </span><span class="s1">if (typeof arg0 === 'object' &amp;&amp; arg0 !== null &amp;&amp; 'v' in arg0) {</span><span class="s3">\n      </span><span class="s1">v = arg0.v;</span><span class="s3">\n      </span><span class="s1">w = arg0.w;</span><span class="s3">\n      </span><span class="s1">name = arg0.name;</span><span class="s3">\n      </span><span class="s1">if (arguments.length === 2) {</span><span class="s3">\n        </span><span class="s1">value = arguments[1];</span><span class="s3">\n        </span><span class="s1">valueSpecified = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">v = arg0;</span><span class="s3">\n      </span><span class="s1">w = arguments[1];</span><span class="s3">\n      </span><span class="s1">name = arguments[3];</span><span class="s3">\n      </span><span class="s1">if (arguments.length &gt; 2) {</span><span class="s3">\n        </span><span class="s1">value = arguments[2];</span><span class="s3">\n        </span><span class="s1">valueSpecified = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">v = '' + v;</span><span class="s3">\n    </span><span class="s1">w = '' + w;</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(name)) {</span><span class="s3">\n      </span><span class="s1">name = '' + name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var e = edgeArgsToId(this._isDirected, v, w, name);</span><span class="s3">\n    </span><span class="s1">if (Object.prototype.hasOwnProperty.call(this._edgeLabels, e)) {</span><span class="s3">\n      </span><span class="s1">if (valueSpecified) {</span><span class="s3">\n        </span><span class="s1">this._edgeLabels[e] = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!_.isUndefined(name) &amp;&amp; !this._isMultigraph) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Cannot set a named edge when isMultigraph = false');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// It didn't exist, so we need to create it.</span><span class="s3">\n    </span><span class="s1">// First ensure the nodes exist.</span><span class="s3">\n    </span><span class="s1">this.setNode(v);</span><span class="s3">\n    </span><span class="s1">this.setNode(w);</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);</span><span class="s3">\n\n    </span><span class="s1">var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);</span><span class="s3">\n    </span><span class="s1">// Ensure we add undirected edges in a consistent way.</span><span class="s3">\n    </span><span class="s1">v = edgeObj.v;</span><span class="s3">\n    </span><span class="s1">w = edgeObj.w;</span><span class="s3">\n\n    </span><span class="s1">Object.freeze(edgeObj);</span><span class="s3">\n    </span><span class="s1">this._edgeObjs[e] = edgeObj;</span><span class="s3">\n    </span><span class="s1">incrementOrInitEntry(this._preds[w], v);</span><span class="s3">\n    </span><span class="s1">incrementOrInitEntry(this._sucs[v], w);</span><span class="s3">\n    </span><span class="s1">this._in[w][e] = edgeObj;</span><span class="s3">\n    </span><span class="s1">this._out[v][e] = edgeObj;</span><span class="s3">\n    </span><span class="s1">this._edgeCount++;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">edge(v, w, name) {</span><span class="s3">\n    </span><span class="s1">var e =</span><span class="s3">\n      </span><span class="s1">arguments.length === 1</span><span class="s3">\n        </span><span class="s1">? edgeObjToId(this._isDirected, arguments[0])</span><span class="s3">\n        </span><span class="s1">: edgeArgsToId(this._isDirected, v, w, name);</span><span class="s3">\n    </span><span class="s1">return this._edgeLabels[e];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">hasEdge(v, w, name) {</span><span class="s3">\n    </span><span class="s1">var e =</span><span class="s3">\n      </span><span class="s1">arguments.length === 1</span><span class="s3">\n        </span><span class="s1">? edgeObjToId(this._isDirected, arguments[0])</span><span class="s3">\n        </span><span class="s1">: edgeArgsToId(this._isDirected, v, w, name);</span><span class="s3">\n    </span><span class="s1">return Object.prototype.hasOwnProperty.call(this._edgeLabels, e);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">removeEdge(v, w, name) {</span><span class="s3">\n    </span><span class="s1">var e =</span><span class="s3">\n      </span><span class="s1">arguments.length === 1</span><span class="s3">\n        </span><span class="s1">? edgeObjToId(this._isDirected, arguments[0])</span><span class="s3">\n        </span><span class="s1">: edgeArgsToId(this._isDirected, v, w, name);</span><span class="s3">\n    </span><span class="s1">var edge = this._edgeObjs[e];</span><span class="s3">\n    </span><span class="s1">if (edge) {</span><span class="s3">\n      </span><span class="s1">v = edge.v;</span><span class="s3">\n      </span><span class="s1">w = edge.w;</span><span class="s3">\n      </span><span class="s1">delete this._edgeLabels[e];</span><span class="s3">\n      </span><span class="s1">delete this._edgeObjs[e];</span><span class="s3">\n      </span><span class="s1">decrementOrRemoveEntry(this._preds[w], v);</span><span class="s3">\n      </span><span class="s1">decrementOrRemoveEntry(this._sucs[v], w);</span><span class="s3">\n      </span><span class="s1">delete this._in[w][e];</span><span class="s3">\n      </span><span class="s1">delete this._out[v][e];</span><span class="s3">\n      </span><span class="s1">this._edgeCount--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">inEdges(v, u) {</span><span class="s3">\n    </span><span class="s1">var inV = this._in[v];</span><span class="s3">\n    </span><span class="s1">if (inV) {</span><span class="s3">\n      </span><span class="s1">var edges = _.values(inV);</span><span class="s3">\n      </span><span class="s1">if (!u) {</span><span class="s3">\n        </span><span class="s1">return edges;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return _.filter(edges, function (edge) {</span><span class="s3">\n        </span><span class="s1">return edge.v === u;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">outEdges(v, w) {</span><span class="s3">\n    </span><span class="s1">var outV = this._out[v];</span><span class="s3">\n    </span><span class="s1">if (outV) {</span><span class="s3">\n      </span><span class="s1">var edges = _.values(outV);</span><span class="s3">\n      </span><span class="s1">if (!w) {</span><span class="s3">\n        </span><span class="s1">return edges;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return _.filter(edges, function (edge) {</span><span class="s3">\n        </span><span class="s1">return edge.w === w;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodeEdges(v, w) {</span><span class="s3">\n    </span><span class="s1">var inEdges = this.inEdges(v, w);</span><span class="s3">\n    </span><span class="s1">if (inEdges) {</span><span class="s3">\n      </span><span class="s1">return inEdges.concat(this.outEdges(v, w));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* Number of nodes in the graph. Should only be changed by the implementation. */</span><span class="s3">\n</span><span class="s1">Graph.prototype._nodeCount = 0;</span><span class="s3">\n\n</span><span class="s1">/* Number of edges in the graph. Should only be changed by the implementation. */</span><span class="s3">\n</span><span class="s1">Graph.prototype._edgeCount = 0;</span><span class="s3">\n\n</span><span class="s1">function incrementOrInitEntry(map, k) {</span><span class="s3">\n  </span><span class="s1">if (map[k]) {</span><span class="s3">\n    </span><span class="s1">map[k]++;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">map[k] = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function decrementOrRemoveEntry(map, k) {</span><span class="s3">\n  </span><span class="s1">if (!--map[k]) {</span><span class="s3">\n    </span><span class="s1">delete map[k];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function edgeArgsToId(isDirected, v_, w_, name) {</span><span class="s3">\n  </span><span class="s1">var v = '' + v_;</span><span class="s3">\n  </span><span class="s1">var w = '' + w_;</span><span class="s3">\n  </span><span class="s1">if (!isDirected &amp;&amp; v &gt; w) {</span><span class="s3">\n    </span><span class="s1">var tmp = v;</span><span class="s3">\n    </span><span class="s1">v = w;</span><span class="s3">\n    </span><span class="s1">w = tmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function edgeArgsToObj(isDirected, v_, w_, name) {</span><span class="s3">\n  </span><span class="s1">var v = '' + v_;</span><span class="s3">\n  </span><span class="s1">var w = '' + w_;</span><span class="s3">\n  </span><span class="s1">if (!isDirected &amp;&amp; v &gt; w) {</span><span class="s3">\n    </span><span class="s1">var tmp = v;</span><span class="s3">\n    </span><span class="s1">v = w;</span><span class="s3">\n    </span><span class="s1">w = tmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var edgeObj = { v: v, w: w };</span><span class="s3">\n  </span><span class="s1">if (name) {</span><span class="s3">\n    </span><span class="s1">edgeObj.name = name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return edgeObj;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function edgeObjToId(isDirected, edgeObj) {</span><span class="s3">\n  </span><span class="s1">return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Includes only the </span><span class="s3">\&quot;</span><span class="s1">core</span><span class="s3">\&quot; </span><span class="s1">of graphlib</span><span class="s3">\n\n</span><span class="s1">import { Graph } from './graph.js';</span><span class="s3">\n\n</span><span class="s1">const version = '2.1.9-pre';</span><span class="s3">\n\n</span><span class="s1">export { Graph, version };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import isSymbol from './isSymbol.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of methods like `_.max` and `_.min` which accepts a</span><span class="s3">\n </span><span class="s1">* `comparator` to determine the extremum value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The iteratee invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {Function} comparator The comparator used to compare values.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the extremum value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseExtremum(array, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index],</span><span class="s3">\n        </span><span class="s1">current = iteratee(value);</span><span class="s3">\n\n    </span><span class="s1">if (current != null &amp;&amp; (computed === undefined</span><span class="s3">\n          </span><span class="s1">? (current === current &amp;&amp; !isSymbol(current))</span><span class="s3">\n          </span><span class="s1">: comparator(current, computed)</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">var computed = current,</span><span class="s3">\n          </span><span class="s1">result = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseExtremum;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.lt` which doesn't coerce arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is less than `other`,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseLt(value, other) {</span><span class="s3">\n  </span><span class="s1">return value &lt; other;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseLt;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseEach from './_baseEach.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.map` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new mapped array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMap(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = isArrayLike(collection) ? Array(collection.length) : [];</span><span class="s3">\n\n  </span><span class="s1">baseEach(collection, function(value, key, collection) {</span><span class="s3">\n    </span><span class="s1">result[++index] = iteratee(value, key, collection);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseMap;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import assignValue from './_assignValue.js';</span><span class="s3">\n</span><span class="s1">import castPath from './_castPath.js';</span><span class="s3">\n</span><span class="s1">import isIndex from './_isIndex.js';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject.js';</span><span class="s3">\n</span><span class="s1">import toKey from './_toKey.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.set`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path of the property to set.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize path creation.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseSet(object, path, value, customizer) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(object)) {</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">path = castPath(path, object);</span><span class="s3">\n\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = path.length,</span><span class="s3">\n      </span><span class="s1">lastIndex = length - 1,</span><span class="s3">\n      </span><span class="s1">nested = object;</span><span class="s3">\n\n  </span><span class="s1">while (nested != null &amp;&amp; ++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var key = toKey(path[index]),</span><span class="s3">\n        </span><span class="s1">newValue = value;</span><span class="s3">\n\n    </span><span class="s1">if (key === '__proto__' || key === 'constructor' || key === 'prototype') {</span><span class="s3">\n      </span><span class="s1">return object;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (index != lastIndex) {</span><span class="s3">\n      </span><span class="s1">var objValue = nested[key];</span><span class="s3">\n      </span><span class="s1">newValue = customizer ? customizer(objValue, key, nested) : undefined;</span><span class="s3">\n      </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n        </span><span class="s1">newValue = isObject(objValue)</span><span class="s3">\n          </span><span class="s1">? objValue</span><span class="s3">\n          </span><span class="s1">: (isIndex(path[index + 1]) ? [] : {});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assignValue(nested, key, newValue);</span><span class="s3">\n    </span><span class="s1">nested = nested[key];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseSet;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseGet from './_baseGet.js';</span><span class="s3">\n</span><span class="s1">import baseSet from './_baseSet.js';</span><span class="s3">\n</span><span class="s1">import castPath from './_castPath.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of  `_.pickBy` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {string[]} paths The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per property.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePickBy(object, paths, predicate) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = paths.length,</span><span class="s3">\n      </span><span class="s1">result = {};</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var path = paths[index],</span><span class="s3">\n        </span><span class="s1">value = baseGet(object, path);</span><span class="s3">\n\n    </span><span class="s1">if (predicate(value, path)) {</span><span class="s3">\n      </span><span class="s1">baseSet(result, castPath(path, object), value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default basePickBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseRest from './_baseRest.js';</span><span class="s3">\n</span><span class="s1">import eq from './eq.js';</span><span class="s3">\n</span><span class="s1">import isIterateeCall from './_isIterateeCall.js';</span><span class="s3">\n</span><span class="s1">import keysIn from './keysIn.js';</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns own and inherited enumerable string keyed properties of source</span><span class="s3">\n </span><span class="s1">* objects to the destination object for all destination properties that</span><span class="s3">\n </span><span class="s1">* resolve to `undefined`. Source objects are applied from left to right.</span><span class="s3">\n </span><span class="s1">* Once a property is set, additional values of the same property are ignored.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} [sources] The source objects.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.defaultsDeep</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var defaults = baseRest(function(object, sources) {</span><span class="s3">\n  </span><span class="s1">object = Object(object);</span><span class="s3">\n\n  </span><span class="s1">var index = -1;</span><span class="s3">\n  </span><span class="s1">var length = sources.length;</span><span class="s3">\n  </span><span class="s1">var guard = length &gt; 2 ? sources[2] : undefined;</span><span class="s3">\n\n  </span><span class="s1">if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) {</span><span class="s3">\n    </span><span class="s1">length = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var source = sources[index];</span><span class="s3">\n    </span><span class="s1">var props = keysIn(source);</span><span class="s3">\n    </span><span class="s1">var propsIndex = -1;</span><span class="s3">\n    </span><span class="s1">var propsLength = props.length;</span><span class="s3">\n\n    </span><span class="s1">while (++propsIndex &lt; propsLength) {</span><span class="s3">\n      </span><span class="s1">var key = props[propsIndex];</span><span class="s3">\n      </span><span class="s1">var value = object[key];</span><span class="s3">\n\n      </span><span class="s1">if (value === undefined ||</span><span class="s3">\n          </span><span class="s1">(eq(value, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) {</span><span class="s3">\n        </span><span class="s1">object[key] = source[key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default defaults;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n</span><span class="s1">import keys from './keys.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a `_.find` or `_.findLast` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} findIndexFunc The function to find the collection index.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new find function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createFind(findIndexFunc) {</span><span class="s3">\n  </span><span class="s1">return function(collection, predicate, fromIndex) {</span><span class="s3">\n    </span><span class="s1">var iterable = Object(collection);</span><span class="s3">\n    </span><span class="s1">if (!isArrayLike(collection)) {</span><span class="s3">\n      </span><span class="s1">var iteratee = baseIteratee(predicate, 3);</span><span class="s3">\n      </span><span class="s1">collection = keys(collection);</span><span class="s3">\n      </span><span class="s1">predicate = function(key) { return iteratee(iterable[key], key, iterable); };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var index = findIndexFunc(collection, predicate, fromIndex);</span><span class="s3">\n    </span><span class="s1">return index &gt; -1 ? iterable[iteratee ? collection[index] : index] : undefined;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default createFind;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFindIndex from './_baseFindIndex.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import toInteger from './toInteger.js';</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeMax = Math.max;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.find` except that it returns the index of the first</span><span class="s3">\n </span><span class="s1">* element `predicate` returns truthy for instead of the element itself.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 1.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {number} [fromIndex=0] The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the found element, else `-1`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney',  'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',    'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'pebbles', 'active': true }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, function(o) { return o.user == 'barney'; });</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, { 'user': 'fred', 'active': false });</span><span class="s3">\n </span><span class="s1">* // =&gt; 1</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; 2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findIndex(array, predicate, fromIndex) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = fromIndex == null ? 0 : toInteger(fromIndex);</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n    </span><span class="s1">index = nativeMax(length + index, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseFindIndex(array, baseIteratee(predicate, 3), index);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default findIndex;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import createFind from './_createFind.js';</span><span class="s3">\n</span><span class="s1">import findIndex from './findIndex.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates over elements of `collection`, returning the first element</span><span class="s3">\n </span><span class="s1">* `predicate` returns truthy for. The predicate is invoked with three</span><span class="s3">\n </span><span class="s1">* arguments: (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {number} [fromIndex=0] The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the matched element, else `undefined`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney',  'age': 36, 'active': true },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',    'age': 40, 'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'pebbles', 'age': 1,  'active': true }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.find(users, function(o) { return o.age &lt; 40; });</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'barney'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.find(users, { 'age': 1, 'active': true });</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'pebbles'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.find(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'fred'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.find(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'barney'</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var find = createFind(findIndex);</span><span class="s3">\n\n</span><span class="s1">export default find;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFlatten from './_baseFlatten.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Flattens `array` a single level deep.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to flatten.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new flattened array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.flatten([1, [2, [3, [4]], 5]]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, [3, [4]], 5]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function flatten(array) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">return length ? baseFlatten(array, 1) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default flatten;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.has` without support for deep paths.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} [object] The object to query.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} key The key to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseHas(object, key) {</span><span class="s3">\n  </span><span class="s1">return object != null &amp;&amp; hasOwnProperty.call(object, key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseHas;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseHas from './_baseHas.js';</span><span class="s3">\n</span><span class="s1">import hasPath from './_hasPath.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `path` is a direct property of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `path` exists, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': { 'b': 2 } };</span><span class="s3">\n </span><span class="s1">* var other = _.create({ 'a': _.create({ 'b': 2 }) });</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(object, 'a');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(object, 'a.b');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(object, ['a', 'b']);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(other, 'a');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function has(object, path) {</span><span class="s3">\n  </span><span class="s1">return object != null &amp;&amp; hasPath(object, path, baseHas);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default has;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseGetTag from './_baseGetTag.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n</span><span class="s1">import isObjectLike from './isObjectLike.js';</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var stringTag = '[object String]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a `String` primitive or object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a string, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isString('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isString(1);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isString(value) {</span><span class="s3">\n  </span><span class="s1">return typeof value == 'string' ||</span><span class="s3">\n    </span><span class="s1">(!isArray(value) &amp;&amp; isObjectLike(value) &amp;&amp; baseGetTag(value) == stringTag);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default isString;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Gets the last element of `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to query.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the last element of `array`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.last([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function last(array) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">return length ? array[length - 1] : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default last;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayMap from './_arrayMap.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import baseMap from './_baseMap.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of values by running each element in `collection` thru</span><span class="s3">\n </span><span class="s1">* `iteratee`. The iteratee is invoked with three arguments:</span><span class="s3">\n </span><span class="s1">* (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Many lodash methods are guarded to work as iteratees for methods like</span><span class="s3">\n </span><span class="s1">* `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The guarded methods are:</span><span class="s3">\n </span><span class="s1">* `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,</span><span class="s3">\n </span><span class="s1">* `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,</span><span class="s3">\n </span><span class="s1">* `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,</span><span class="s3">\n </span><span class="s1">* `template`, `trim`, `trimEnd`, `trimStart`, and `words`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new mapped array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function square(n) {</span><span class="s3">\n </span><span class="s1">*   return n * n;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.map([4, 8], square);</span><span class="s3">\n </span><span class="s1">* // =&gt; [16, 64]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.map({ 'a': 4, 'b': 8 }, square);</span><span class="s3">\n </span><span class="s1">* // =&gt; [16, 64] (iteration order is not guaranteed)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney' },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred' }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.map(users, 'user');</span><span class="s3">\n </span><span class="s1">* // =&gt; ['barney', 'fred']</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function map(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arrayMap : baseMap;</span><span class="s3">\n  </span><span class="s1">return func(collection, baseIteratee(iteratee, 3));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default map;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseExtremum from './_baseExtremum.js';</span><span class="s3">\n</span><span class="s1">import baseLt from './_baseLt.js';</span><span class="s3">\n</span><span class="s1">import identity from './identity.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Computes the minimum value of `array`. If `array` is empty or falsey,</span><span class="s3">\n </span><span class="s1">* `undefined` is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Math</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the minimum value.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.min([4, 2, 8, 6]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.min([]);</span><span class="s3">\n </span><span class="s1">* // =&gt; undefined</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function min(array) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length)</span><span class="s3">\n    </span><span class="s1">? baseExtremum(array, identity, baseLt)</span><span class="s3">\n    </span><span class="s1">: undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default min;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to match a single whitespace character. */</span><span class="s3">\n</span><span class="s1">var reWhitespace = /</span><span class="s3">\\</span><span class="s1">s/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace</span><span class="s3">\n </span><span class="s1">* character of `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the last non-whitespace character.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function trimmedEndIndex(string) {</span><span class="s3">\n  </span><span class="s1">var index = string.length;</span><span class="s3">\n\n  </span><span class="s1">while (index-- &amp;&amp; reWhitespace.test(string.charAt(index))) {}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default trimmedEndIndex;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import trimmedEndIndex from './_trimmedEndIndex.js';</span><span class="s3">\n\n</span><span class="s1">/** Used to match leading whitespace. */</span><span class="s3">\n</span><span class="s1">var reTrimStart = /^</span><span class="s3">\\</span><span class="s1">s+/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.trim`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to trim.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the trimmed string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseTrim(string) {</span><span class="s3">\n  </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')</span><span class="s3">\n    </span><span class="s1">: string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseTrim;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseTrim from './_baseTrim.js';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject.js';</span><span class="s3">\n</span><span class="s1">import isSymbol from './isSymbol.js';</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var NAN = 0 / 0;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect bad signed hexadecimal string values. */</span><span class="s3">\n</span><span class="s1">var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect binary string values. */</span><span class="s3">\n</span><span class="s1">var reIsBinary = /^0b[01]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect octal string values. */</span><span class="s3">\n</span><span class="s1">var reIsOctal = /^0o[0-7]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Built-in method references without a dependency on `root`. */</span><span class="s3">\n</span><span class="s1">var freeParseInt = parseInt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to process.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the number.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; Infinity</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toNumber(value) {</span><span class="s3">\n  </span><span class="s1">if (typeof value == 'number') {</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isSymbol(value)) {</span><span class="s3">\n    </span><span class="s1">return NAN;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isObject(value)) {</span><span class="s3">\n    </span><span class="s1">var other = typeof value.valueOf == 'function' ? value.valueOf() : value;</span><span class="s3">\n    </span><span class="s1">value = isObject(other) ? (other + '') : other;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof value != 'string') {</span><span class="s3">\n    </span><span class="s1">return value === 0 ? value : +value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = baseTrim(value);</span><span class="s3">\n  </span><span class="s1">var isBinary = reIsBinary.test(value);</span><span class="s3">\n  </span><span class="s1">return (isBinary || reIsOctal.test(value))</span><span class="s3">\n    </span><span class="s1">? freeParseInt(value.slice(2), isBinary ? 2 : 8)</span><span class="s3">\n    </span><span class="s1">: (reIsBadHex.test(value) ? NAN : +value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default toNumber;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import toNumber from './toNumber.js';</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var INFINITY = 1 / 0,</span><span class="s3">\n    </span><span class="s1">MAX_INTEGER = 1.7976931348623157e+308;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a finite number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.12.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the converted number.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1.7976931348623157e+308</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toFinite(value) {</span><span class="s3">\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">return value === 0 ? value : 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = toNumber(value);</span><span class="s3">\n  </span><span class="s1">if (value === INFINITY || value === -INFINITY) {</span><span class="s3">\n    </span><span class="s1">var sign = (value &lt; 0 ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">return sign * MAX_INTEGER;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value === value ? value : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default toFinite;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import toFinite from './toFinite.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to an integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method is loosely based on</span><span class="s3">\n </span><span class="s1">* [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the converted integer.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1.7976931348623157e+308</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toInteger(value) {</span><span class="s3">\n  </span><span class="s1">var result = toFinite(value),</span><span class="s3">\n      </span><span class="s1">remainder = result % 1;</span><span class="s3">\n\n  </span><span class="s1">return result === result ? (remainder ? result - remainder : result) : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default toInteger;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>