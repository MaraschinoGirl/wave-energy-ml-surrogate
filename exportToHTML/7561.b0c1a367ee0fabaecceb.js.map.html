<html>
<head>
<title>7561.b0c1a367ee0fabaecceb.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7561.b0c1a367ee0fabaecceb.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7561.b0c1a367ee0fabaecceb.js?v=b0c1a367ee0fabaecceb&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAwC;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kEAAS;AAClB;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCU;AACI;;AAEZ;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO,0BAAa;AACpB,iBAAiB,oBAAO;AACxB;AACA;AACA;;AAEA;AACA,SAAS,kBAAK;AACd;AACA;AACA,iBAAiB;AACjB,SAAS,0BAAa;AACtB;AACA;AACA,SAAS,0BAAa;AACtB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,SAAS,kBAAK;AACd;AACA,iBAAiB;AACjB,SAAS,0BAAa;AACtB;AACA;AACA,SAAS,0BAAa;AACtB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,gBAAgB,0CAA0C;AAC1D,GAAG;AACH;AACA;;;;;ACxD8B;AACA;AASA;AAGA;AACA;AACA;AACA;AAKA;;AAE9B;AACuE;AACL;AACH;;AAE/D;AAC8D;AACG;AACjE;AACA;AACA;AACA,6BAA6B,iCAAM;AACnC;AACA;AACA;AACA,CAAC;AACD,mCAAmC,iCAAM;AACzC;AACA,EAAE,0BAAG;AACL;AACA,CAAC;AACD,oCAAoC,iCAAM;AAC1C;AACA,EAAE,0BAAG;AACL,EAAE,0BAAG;AACL;AACA;AACA;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA,CAAC;AACD,2BAA2B,iCAAM;AACjC,EAAE,0BAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,0BAAG;AACL;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM,0BAAG;AACT;AACA;AACA,QAAQ,0BAAG;AACX;AACA;AACA;AACA,QAAQ,0BAAG;AACX;AACA,QAAQ;AACR,QAAQ,0BAAG;AACX,QAAQ,0BAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA,QAAQ,0BAAG;AACX;AACA,QAAQ,0BAAG;AACX;AACA;AACA,YAAY,0BAAG;AACf;AACA,YAAY,0BAAG;AACf,YAAY;AACZ,YAAY,0BAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU,0BAAG;AACb;AACA,OAAO;AACP;AACA,IAAI,0BAAG;AACP;AACA,GAAG;AACH,CAAC;AACD,yCAAyC,iCAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sCAAsC,iCAAM;AAC5C;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD,0CAA0C,iCAAM;AAChD;AACA,EAAE,0BAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kCAAkC,iCAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6CAA6C,iCAAM;AACnD;AACA,IAAI,0BAAG;AACP;AACA,IAAI;AACJ,IAAI,0BAAG;AACP;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAqE;AAC/F;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA,UAAU,0BAAG;AACb,UAAU,0BAAG;AACb;AACA;AACA,OAAO;AACP,MAAM;AACN,MAAM,0BAAG;AACT;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0BAAG;AACP,IAAI,0BAAG;AACP;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA;AACA,GAAG;AACH,EAAE,0BAAG,wBAAwB,KAAkB;AAC/C;AACA,EAAE,0BAAG;AACL,CAAC;AACD,gCAAgC,iCAAM;AACtC,EAAE,0BAAG,6BAA6B,KAAkB;AACpD;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA,EAAE,0BAAG;AACL;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT,MAAM;AACN,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAG;AACX;AACA,+BAA+B,qBAAc;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,MAAM,0BAAG,+BAA+B,KAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,0BAAG,iDAAiD,KAAkB;AAC5E,MAAM,0BAAG,+BAA+B,KAAkB;AAC1D,MAAM;AACN,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA;AACA;AACA,EAAE,0BAAG;AACL;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA;AACA,CAAC;AACD,6BAA6B,iCAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD,2CAA2C,iCAAM;;AAEjD;AACA,sCAAsC,iCAAM;AAC5C,EAAE,0BAAG,uCAAuC,KAAmB;AAC/D;AACA,EAAE,0BAAG;AACL;AACA;AACA,IAAI,0BAAG;AACP,IAAI;AACJ,IAAI,0BAAG;AACP;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0BAAG;AACb;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA,QAAQ,0BAAG;AACX,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAAgB;AACxB;AACA,QAAQ,0BAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sCAAW;AACnB,QAAQ;AACR;AACA,UAAU,0BAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0BAAG;AACb,mCAAmC,+CAA+C;AAClF,UAAU;AACV,UAAU,0BAAG;AACb,gBAAgB,qCAAU,yBAAyB,yBAAyB;AAC5E;AACA;AACA,KAAK;AACL;AACA,uCAAuC,iCAAM;AAC7C;AACA;AACA,MAAM,0BAAG;AACT,MAAM,0BAAG;AACT,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAAe;AAC3B,KAAK;AACL;AACA,GAAG;AACH;AACA,EAAE,0BAAG,6CAA6C,KAAmB;AACrE,EAAE,0BAAG;AACL,EAAE,0BAAG;AACL,EAAE,0BAAG;AACL,EAAE,wBAAW;AACb,EAAE,0BAAG,4CAA4C,KAAmB;AACpE;AACA,QAAQ,2BAA2B,EAAE,iDAAuB;AAC5D;AACA;AACA;AACA,MAAM,0BAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAY;AACpB,QAAQ;AACR;AACA,UAAU,0BAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0BAAG;AACb,gBAAgB,wCAAa;AAC7B;AACA,UAAU;AACV;AACA;AACA,UAAU,0BAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uCAAY;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA,kBAAkB,qCAAU;AAC5B,IAAI,4CAAiB;AACrB,GAAG;AACH;AACA;AACA,IAAI,0BAAG;AACP;AACA;AACA;AACA,GAAG;AACH,EAAE,0BAAG;AACL,WAAW;AACX,CAAC;AACD,6BAA6B,iCAAM;AACnC,oBAAoB,qBAAe;AACnC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,EAAE,0CAAe;AACjB,EAAE,iCAAM;AACR,EAAE,gCAAM;AACR,EAAE,gCAAK;AACP;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,GAAG;AACH,EAAE,0BAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4CAA4C,SAAS;AACrD;AACA,GAAG;AACH,EAAE,0BAAG,wCAAwC,KAAmB;AAChE;AACA,EAAE,0BAAG,yCAAyC,KAAmB;AACjE,qBAAqB,qCAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAGC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/clone.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/dagre-d3-es/src/graphlib/json.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/mermaid/dist/chunks/mermaid.core/dagre-OKDRZEBW.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import baseClone from './_baseClone.js';</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for cloning. */</span><span class="s3">\n</span><span class="s1">var CLONE_SYMBOLS_FLAG = 4;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a shallow clone of `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method is loosely based on the</span><span class="s3">\n </span><span class="s1">* [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)</span><span class="s3">\n </span><span class="s1">* and supports cloning arrays, array buffers, booleans, date objects, maps,</span><span class="s3">\n </span><span class="s1">* numbers, `Object` objects, regexes, sets, strings, symbols, and typed</span><span class="s3">\n </span><span class="s1">* arrays. The own enumerable properties of `arguments` objects are cloned</span><span class="s3">\n </span><span class="s1">* as plain objects. An empty object is returned for uncloneable values such</span><span class="s3">\n </span><span class="s1">* as error objects, functions, DOM nodes, and WeakMaps.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to clone.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the cloned value.</span><span class="s3">\n </span><span class="s1">* @see _.cloneDeep</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [{ 'a': 1 }, { 'b': 2 }];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var shallow = _.clone(objects);</span><span class="s3">\n </span><span class="s1">* console.log(shallow[0] === objects[0]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function clone(value) {</span><span class="s3">\n  </span><span class="s1">return baseClone(value, CLONE_SYMBOLS_FLAG);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default clone;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as _ from 'lodash-es';</span><span class="s3">\n</span><span class="s1">import { Graph } from './graph.js';</span><span class="s3">\n\n</span><span class="s1">export { write, read };</span><span class="s3">\n\n</span><span class="s1">function write(g) {</span><span class="s3">\n  </span><span class="s1">var json = {</span><span class="s3">\n    </span><span class="s1">options: {</span><span class="s3">\n      </span><span class="s1">directed: g.isDirected(),</span><span class="s3">\n      </span><span class="s1">multigraph: g.isMultigraph(),</span><span class="s3">\n      </span><span class="s1">compound: g.isCompound(),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nodes: writeNodes(g),</span><span class="s3">\n    </span><span class="s1">edges: writeEdges(g),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (!_.isUndefined(g.graph())) {</span><span class="s3">\n    </span><span class="s1">json.value = _.clone(g.graph());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return json;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeNodes(g) {</span><span class="s3">\n  </span><span class="s1">return _.map(g.nodes(), function (v) {</span><span class="s3">\n    </span><span class="s1">var nodeValue = g.node(v);</span><span class="s3">\n    </span><span class="s1">var parent = g.parent(v);</span><span class="s3">\n    </span><span class="s1">var node = { v: v };</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(nodeValue)) {</span><span class="s3">\n      </span><span class="s1">node.value = nodeValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(parent)) {</span><span class="s3">\n      </span><span class="s1">node.parent = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeEdges(g) {</span><span class="s3">\n  </span><span class="s1">return _.map(g.edges(), function (e) {</span><span class="s3">\n    </span><span class="s1">var edgeValue = g.edge(e);</span><span class="s3">\n    </span><span class="s1">var edge = { v: e.v, w: e.w };</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(e.name)) {</span><span class="s3">\n      </span><span class="s1">edge.name = e.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!_.isUndefined(edgeValue)) {</span><span class="s3">\n      </span><span class="s1">edge.value = edgeValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return edge;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function read(json) {</span><span class="s3">\n  </span><span class="s1">var g = new Graph(json.options).setGraph(json.value);</span><span class="s3">\n  </span><span class="s1">_.each(json.nodes, function (entry) {</span><span class="s3">\n    </span><span class="s1">g.setNode(entry.v, entry.value);</span><span class="s3">\n    </span><span class="s1">if (entry.parent) {</span><span class="s3">\n      </span><span class="s1">g.setParent(entry.v, entry.parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">_.each(json.edges, function (entry) {</span><span class="s3">\n    </span><span class="s1">g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return g;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">clear as clear2,</span><span class="s3">\n  </span><span class="s1">insertEdge,</span><span class="s3">\n  </span><span class="s1">insertEdgeLabel,</span><span class="s3">\n  </span><span class="s1">markers_default,</span><span class="s3">\n  </span><span class="s1">positionEdgeLabel</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-IIMUDSI4.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import </span><span class="s3">\&quot;</span><span class="s1">./chunk-VV3M67IP.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">clear,</span><span class="s3">\n  </span><span class="s1">clear2 as clear3,</span><span class="s3">\n  </span><span class="s1">insertCluster,</span><span class="s3">\n  </span><span class="s1">insertNode,</span><span class="s3">\n  </span><span class="s1">positionNode,</span><span class="s3">\n  </span><span class="s1">setNodeElem,</span><span class="s3">\n  </span><span class="s1">updateNodeBounds</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-HRU6DDCH.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getSubGraphTitleMargins</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-K557N5IZ.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import </span><span class="s3">\&quot;</span><span class="s1">./chunk-H2D2JQ3I.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import </span><span class="s3">\&quot;</span><span class="s1">./chunk-C3MQ5ANM.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import </span><span class="s3">\&quot;</span><span class="s1">./chunk-O4NI6UNU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">__name,</span><span class="s3">\n  </span><span class="s1">getConfig2 as getConfig,</span><span class="s3">\n  </span><span class="s1">log</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-YTJNT7DU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/rendering-util/layout-algorithms/dagre/index.js</span><span class="s3">\n</span><span class="s1">import { layout as dagreLayout } from </span><span class="s3">\&quot;</span><span class="s1">dagre-d3-es/src/dagre/index.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as graphlibJson2 from </span><span class="s3">\&quot;</span><span class="s1">dagre-d3-es/src/graphlib/json.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as graphlib2 from </span><span class="s3">\&quot;</span><span class="s1">dagre-d3-es/src/graphlib/index.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.js</span><span class="s3">\n</span><span class="s1">import * as graphlib from </span><span class="s3">\&quot;</span><span class="s1">dagre-d3-es/src/graphlib/index.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as graphlibJson from </span><span class="s3">\&quot;</span><span class="s1">dagre-d3-es/src/graphlib/json.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var clusterDb = /* @__PURE__ */ new Map();</span><span class="s3">\n</span><span class="s1">var descendants = /* @__PURE__ */ new Map();</span><span class="s3">\n</span><span class="s1">var parents = /* @__PURE__ */ new Map();</span><span class="s3">\n</span><span class="s1">var clear4 = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">descendants.clear();</span><span class="s3">\n  </span><span class="s1">parents.clear();</span><span class="s3">\n  </span><span class="s1">clusterDb.clear();</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">clear</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isDescendant = /* @__PURE__ */ __name((id, ancestorId) =&gt; {</span><span class="s3">\n  </span><span class="s1">const ancestorDescendants = descendants.get(ancestorId) || [];</span><span class="s3">\n  </span><span class="s1">log.trace(</span><span class="s3">\&quot;</span><span class="s1">In isDescendant</span><span class="s3">\&quot;</span><span class="s1">, ancestorId, </span><span class="s3">\&quot; \&quot;</span><span class="s1">, id, </span><span class="s3">\&quot; </span><span class="s1">= </span><span class="s3">\&quot;</span><span class="s1">, ancestorDescendants.includes(id));</span><span class="s3">\n  </span><span class="s1">return ancestorDescendants.includes(id);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isDescendant</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var edgeInCluster = /* @__PURE__ */ __name((edge, clusterId) =&gt; {</span><span class="s3">\n  </span><span class="s1">const clusterDescendants = descendants.get(clusterId) || [];</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Descendants of </span><span class="s3">\&quot;</span><span class="s1">, clusterId, </span><span class="s3">\&quot; </span><span class="s1">is </span><span class="s3">\&quot;</span><span class="s1">, clusterDescendants);</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Edge is </span><span class="s3">\&quot;</span><span class="s1">, edge);</span><span class="s3">\n  </span><span class="s1">if (edge.v === clusterId || edge.w === clusterId) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!clusterDescendants) {</span><span class="s3">\n    </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Tilt, </span><span class="s3">\&quot;</span><span class="s1">, clusterId, </span><span class="s3">\&quot;</span><span class="s1">,not in descendants</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusterDescendants.includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || clusterDescendants.includes(edge.w);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">edgeInCluster</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var copy = /* @__PURE__ */ __name((clusterId, graph, newGraph, rootId) =&gt; {</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\n    \&quot;</span><span class="s1">Copying children of </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">clusterId,</span><span class="s3">\n    \&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">rootId,</span><span class="s3">\n    \&quot;</span><span class="s1">data</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">graph.node(clusterId),</span><span class="s3">\n    </span><span class="s1">rootId</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const nodes = graph.children(clusterId) || [];</span><span class="s3">\n  </span><span class="s1">if (clusterId !== rootId) {</span><span class="s3">\n    </span><span class="s1">nodes.push(clusterId);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Copying (nodes) clusterId</span><span class="s3">\&quot;</span><span class="s1">, clusterId, </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">, nodes);</span><span class="s3">\n  </span><span class="s1">nodes.forEach((node) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (graph.children(node).length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">copy(node, graph, newGraph, rootId);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const data = graph.node(node);</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">cp </span><span class="s3">\&quot;</span><span class="s1">, node, </span><span class="s3">\&quot; </span><span class="s1">to </span><span class="s3">\&quot;</span><span class="s1">, rootId, </span><span class="s3">\&quot; </span><span class="s1">with parent </span><span class="s3">\&quot;</span><span class="s1">, clusterId);</span><span class="s3">\n      </span><span class="s1">newGraph.setNode(node, data);</span><span class="s3">\n      </span><span class="s1">if (rootId !== graph.parent(node)) {</span><span class="s3">\n        </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Setting parent</span><span class="s3">\&quot;</span><span class="s1">, node, graph.parent(node));</span><span class="s3">\n        </span><span class="s1">newGraph.setParent(node, graph.parent(node));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (clusterId !== rootId &amp;&amp; node !== clusterId) {</span><span class="s3">\n        </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Setting parent</span><span class="s3">\&quot;</span><span class="s1">, node, clusterId);</span><span class="s3">\n        </span><span class="s1">newGraph.setParent(node, clusterId);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">In copy </span><span class="s3">\&quot;</span><span class="s1">, clusterId, </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">, rootId, </span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot;</span><span class="s1">, graph.node(clusterId), rootId);</span><span class="s3">\n        </span><span class="s1">log.debug(</span><span class="s3">\n          \&quot;</span><span class="s1">Not Setting parent for node=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">node,</span><span class="s3">\n          \&quot;</span><span class="s1">cluster!==rootId</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">clusterId !== rootId,</span><span class="s3">\n          \&quot;</span><span class="s1">node!==clusterId</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">node !== clusterId</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const edges = graph.edges(node);</span><span class="s3">\n      </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Copying Edges</span><span class="s3">\&quot;</span><span class="s1">, edges);</span><span class="s3">\n      </span><span class="s1">edges.forEach((edge) =&gt; {</span><span class="s3">\n        </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Edge</span><span class="s3">\&quot;</span><span class="s1">, edge);</span><span class="s3">\n        </span><span class="s1">const data2 = graph.edge(edge.v, edge.w, edge.name);</span><span class="s3">\n        </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Edge data</span><span class="s3">\&quot;</span><span class="s1">, data2, rootId);</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">if (edgeInCluster(edge, rootId)) {</span><span class="s3">\n            </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Copying as </span><span class="s3">\&quot;</span><span class="s1">, edge.v, edge.w, data2, edge.name);</span><span class="s3">\n            </span><span class="s1">newGraph.setEdge(edge.v, edge.w, data2, edge.name);</span><span class="s3">\n            </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">newGraph edges </span><span class="s3">\&quot;</span><span class="s1">, newGraph.edges(), newGraph.edge(newGraph.edges()[0]));</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">log.info(</span><span class="s3">\n              \&quot;</span><span class="s1">Skipping copy of edge </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">edge.v,</span><span class="s3">\n              \&quot;</span><span class="s1">--&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">edge.w,</span><span class="s3">\n              \&quot; </span><span class="s1">rootId: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">rootId,</span><span class="s3">\n              \&quot; </span><span class="s1">clusterId:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">clusterId</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (e) {</span><span class="s3">\n          </span><span class="s1">log.error(e);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Removing node</span><span class="s3">\&quot;</span><span class="s1">, node);</span><span class="s3">\n    </span><span class="s1">graph.removeNode(node);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">copy</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var extractDescendants = /* @__PURE__ */ __name((id, graph) =&gt; {</span><span class="s3">\n  </span><span class="s1">const children = graph.children(id);</span><span class="s3">\n  </span><span class="s1">let res = [...children];</span><span class="s3">\n  </span><span class="s1">for (const child of children) {</span><span class="s3">\n    </span><span class="s1">parents.set(child, id);</span><span class="s3">\n    </span><span class="s1">res = [...res, ...extractDescendants(child, graph)];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">extractDescendants</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var findCommonEdges = /* @__PURE__ */ __name((graph, id1, id2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const edges1 = graph.edges().filter((edge) =&gt; edge.v === id1 || edge.w === id1);</span><span class="s3">\n  </span><span class="s1">const edges2 = graph.edges().filter((edge) =&gt; edge.v === id2 || edge.w === id2);</span><span class="s3">\n  </span><span class="s1">const edges1Prim = edges1.map((edge) =&gt; {</span><span class="s3">\n    </span><span class="s1">return { v: edge.v === id1 ? id2 : edge.v, w: edge.w === id1 ? id1 : edge.w };</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">const edges2Prim = edges2.map((edge) =&gt; {</span><span class="s3">\n    </span><span class="s1">return { v: edge.v, w: edge.w };</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">const result = edges1Prim.filter((edgeIn1) =&gt; {</span><span class="s3">\n    </span><span class="s1">return edges2Prim.some((edge) =&gt; edgeIn1.v === edge.v &amp;&amp; edgeIn1.w === edge.w);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">findCommonEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var findNonClusterChild = /* @__PURE__ */ __name((id, graph, clusterId) =&gt; {</span><span class="s3">\n  </span><span class="s1">const children = graph.children(id);</span><span class="s3">\n  </span><span class="s1">log.trace(</span><span class="s3">\&quot;</span><span class="s1">Searching children of id </span><span class="s3">\&quot;</span><span class="s1">, id, children);</span><span class="s3">\n  </span><span class="s1">if (children.length &lt; 1) {</span><span class="s3">\n    </span><span class="s1">return id;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let reserve;</span><span class="s3">\n  </span><span class="s1">for (const child of children) {</span><span class="s3">\n    </span><span class="s1">const _id = findNonClusterChild(child, graph, clusterId);</span><span class="s3">\n    </span><span class="s1">const commonEdges = findCommonEdges(graph, clusterId, _id);</span><span class="s3">\n    </span><span class="s1">if (_id) {</span><span class="s3">\n      </span><span class="s1">if (commonEdges.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">reserve = _id;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return _id;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return reserve;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">findNonClusterChild</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getAnchorId = /* @__PURE__ */ __name((id) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!clusterDb.has(id)) {</span><span class="s3">\n    </span><span class="s1">return id;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!clusterDb.get(id).externalConnections) {</span><span class="s3">\n    </span><span class="s1">return id;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (clusterDb.has(id)) {</span><span class="s3">\n    </span><span class="s1">return clusterDb.get(id).id;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return id;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getAnchorId</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var adjustClustersAndEdges = /* @__PURE__ */ __name((graph, depth) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!graph || depth &gt; 10) {</span><span class="s3">\n    </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Opting out, no graph </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Opting in, graph </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">graph.nodes().forEach(function(id) {</span><span class="s3">\n    </span><span class="s1">const children = graph.children(id);</span><span class="s3">\n    </span><span class="s1">if (children.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\n        \&quot;</span><span class="s1">Cluster identified</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        \&quot; </span><span class="s1">Replacement id in edges: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">findNonClusterChild(id, graph, id)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">descendants.set(id, extractDescendants(id, graph));</span><span class="s3">\n      </span><span class="s1">clusterDb.set(id, { id: findNonClusterChild(id, graph, id), clusterData: graph.node(id) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">graph.nodes().forEach(function(id) {</span><span class="s3">\n    </span><span class="s1">const children = graph.children(id);</span><span class="s3">\n    </span><span class="s1">const edges = graph.edges();</span><span class="s3">\n    </span><span class="s1">if (children.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Cluster identified</span><span class="s3">\&quot;</span><span class="s1">, id, descendants);</span><span class="s3">\n      </span><span class="s1">edges.forEach((edge) =&gt; {</span><span class="s3">\n        </span><span class="s1">const d1 = isDescendant(edge.v, id);</span><span class="s3">\n        </span><span class="s1">const d2 = isDescendant(edge.w, id);</span><span class="s3">\n        </span><span class="s1">if (d1 ^ d2) {</span><span class="s3">\n          </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Edge: </span><span class="s3">\&quot;</span><span class="s1">, edge, </span><span class="s3">\&quot; </span><span class="s1">leaves cluster </span><span class="s3">\&quot;</span><span class="s1">, id);</span><span class="s3">\n          </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Descendants of XXX </span><span class="s3">\&quot;</span><span class="s1">, id, </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">, descendants.get(id));</span><span class="s3">\n          </span><span class="s1">clusterDb.get(id).externalConnections = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Not a cluster </span><span class="s3">\&quot;</span><span class="s1">, id, descendants);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">for (let id of clusterDb.keys()) {</span><span class="s3">\n    </span><span class="s1">const nonClusterChild = clusterDb.get(id).id;</span><span class="s3">\n    </span><span class="s1">const parent = graph.parent(nonClusterChild);</span><span class="s3">\n    </span><span class="s1">if (parent !== id &amp;&amp; clusterDb.has(parent) &amp;&amp; !clusterDb.get(parent).externalConnections) {</span><span class="s3">\n      </span><span class="s1">clusterDb.get(id).id = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">graph.edges().forEach(function(e) {</span><span class="s3">\n    </span><span class="s1">const edge = graph.edge(e);</span><span class="s3">\n    </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Edge </span><span class="s3">\&quot; </span><span class="s1">+ e.v + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ e.w + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(e));</span><span class="s3">\n    </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Edge </span><span class="s3">\&quot; </span><span class="s1">+ e.v + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ e.w + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(graph.edge(e)));</span><span class="s3">\n    </span><span class="s1">let v = e.v;</span><span class="s3">\n    </span><span class="s1">let w = e.w;</span><span class="s3">\n    </span><span class="s1">log.warn(</span><span class="s3">\n      \&quot;</span><span class="s1">Fix XXX</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">clusterDb,</span><span class="s3">\n      \&quot;</span><span class="s1">ids:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">e.v,</span><span class="s3">\n      </span><span class="s1">e.w,</span><span class="s3">\n      \&quot;</span><span class="s1">Translating: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">clusterDb.get(e.v),</span><span class="s3">\n      \&quot; </span><span class="s1">--- </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">clusterDb.get(e.w)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (clusterDb.get(e.v) || clusterDb.get(e.w)) {</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Fixing and trying - removing XXX</span><span class="s3">\&quot;</span><span class="s1">, e.v, e.w, e.name);</span><span class="s3">\n      </span><span class="s1">v = getAnchorId(e.v);</span><span class="s3">\n      </span><span class="s1">w = getAnchorId(e.w);</span><span class="s3">\n      </span><span class="s1">graph.removeEdge(e.v, e.w, e.name);</span><span class="s3">\n      </span><span class="s1">if (v !== e.v) {</span><span class="s3">\n        </span><span class="s1">const parent = graph.parent(v);</span><span class="s3">\n        </span><span class="s1">clusterDb.get(parent).externalConnections = true;</span><span class="s3">\n        </span><span class="s1">edge.fromCluster = e.v;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (w !== e.w) {</span><span class="s3">\n        </span><span class="s1">const parent = graph.parent(w);</span><span class="s3">\n        </span><span class="s1">clusterDb.get(parent).externalConnections = true;</span><span class="s3">\n        </span><span class="s1">edge.toCluster = e.w;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Fix Replacing with XXX</span><span class="s3">\&quot;</span><span class="s1">, v, w, e.name);</span><span class="s3">\n      </span><span class="s1">graph.setEdge(v, w, edge, e.name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Adjusted Graph</span><span class="s3">\&quot;</span><span class="s1">, graphlibJson.write(graph));</span><span class="s3">\n  </span><span class="s1">extractor(graph, 0);</span><span class="s3">\n  </span><span class="s1">log.trace(clusterDb);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">adjustClustersAndEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var extractor = /* @__PURE__ */ __name((graph, depth) =&gt; {</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">extractor - </span><span class="s3">\&quot;</span><span class="s1">, depth, graphlibJson.write(graph), graph.children(</span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">if (depth &gt; 10) {</span><span class="s3">\n    </span><span class="s1">log.error(</span><span class="s3">\&quot;</span><span class="s1">Bailing out</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let nodes = graph.nodes();</span><span class="s3">\n  </span><span class="s1">let hasChildren = false;</span><span class="s3">\n  </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n    </span><span class="s1">const children = graph.children(node);</span><span class="s3">\n    </span><span class="s1">hasChildren = hasChildren || children.length &gt; 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!hasChildren) {</span><span class="s3">\n    </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Done, no node has children</span><span class="s3">\&quot;</span><span class="s1">, graph.nodes());</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Nodes = </span><span class="s3">\&quot;</span><span class="s1">, nodes, depth);</span><span class="s3">\n  </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n    </span><span class="s1">log.debug(</span><span class="s3">\n      \&quot;</span><span class="s1">Extracting node</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">node,</span><span class="s3">\n      </span><span class="s1">clusterDb,</span><span class="s3">\n      </span><span class="s1">clusterDb.has(node) &amp;&amp; !clusterDb.get(node).externalConnections,</span><span class="s3">\n      </span><span class="s1">!graph.parent(node),</span><span class="s3">\n      </span><span class="s1">graph.node(node),</span><span class="s3">\n      </span><span class="s1">graph.children(</span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      \&quot; </span><span class="s1">Depth </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">depth</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (!clusterDb.has(node)) {</span><span class="s3">\n      </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Not a cluster</span><span class="s3">\&quot;</span><span class="s1">, node, depth);</span><span class="s3">\n    </span><span class="s1">} else if (!clusterDb.get(node).externalConnections &amp;&amp; graph.children(node) &amp;&amp; graph.children(node).length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\n        \&quot;</span><span class="s1">Cluster without external connections, without a parent and with children</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">depth</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const graphSettings = graph.graph();</span><span class="s3">\n      </span><span class="s1">let dir = graphSettings.rankdir === </span><span class="s3">\&quot;</span><span class="s1">TB</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">LR</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">TB</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (clusterDb.get(node)?.clusterData?.dir) {</span><span class="s3">\n        </span><span class="s1">dir = clusterDb.get(node).clusterData.dir;</span><span class="s3">\n        </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Fixing dir</span><span class="s3">\&quot;</span><span class="s1">, clusterDb.get(node).clusterData.dir, dir);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const clusterGraph = new graphlib.Graph({</span><span class="s3">\n        </span><span class="s1">multigraph: true,</span><span class="s3">\n        </span><span class="s1">compound: true</span><span class="s3">\n      </span><span class="s1">}).setGraph({</span><span class="s3">\n        </span><span class="s1">rankdir: dir,</span><span class="s3">\n        </span><span class="s1">nodesep: 50,</span><span class="s3">\n        </span><span class="s1">ranksep: 50,</span><span class="s3">\n        </span><span class="s1">marginx: 8,</span><span class="s3">\n        </span><span class="s1">marginy: 8</span><span class="s3">\n      </span><span class="s1">}).setDefaultEdgeLabel(function() {</span><span class="s3">\n        </span><span class="s1">return {};</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Old graph before copy</span><span class="s3">\&quot;</span><span class="s1">, graphlibJson.write(graph));</span><span class="s3">\n      </span><span class="s1">copy(node, graph, clusterGraph, node);</span><span class="s3">\n      </span><span class="s1">graph.setNode(node, {</span><span class="s3">\n        </span><span class="s1">clusterNode: true,</span><span class="s3">\n        </span><span class="s1">id: node,</span><span class="s3">\n        </span><span class="s1">clusterData: clusterDb.get(node).clusterData,</span><span class="s3">\n        </span><span class="s1">label: clusterDb.get(node).label,</span><span class="s3">\n        </span><span class="s1">graph: clusterGraph</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">New graph after copy node: (</span><span class="s3">\&quot;</span><span class="s1">, node, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">, graphlibJson.write(clusterGraph));</span><span class="s3">\n      </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Old graph after copy</span><span class="s3">\&quot;</span><span class="s1">, graphlibJson.write(graph));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">log.warn(</span><span class="s3">\n        \&quot;</span><span class="s1">Cluster ** </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        \&quot; </span><span class="s1">**not meeting the criteria !externalConnections:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">!clusterDb.get(node).externalConnections,</span><span class="s3">\n        \&quot; </span><span class="s1">no parent: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">!graph.parent(node),</span><span class="s3">\n        \&quot; </span><span class="s1">children </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">graph.children(node) &amp;&amp; graph.children(node).length &gt; 0,</span><span class="s3">\n        </span><span class="s1">graph.children(</span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">depth</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">log.debug(clusterDb);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodes = graph.nodes();</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">New list of nodes</span><span class="s3">\&quot;</span><span class="s1">, nodes);</span><span class="s3">\n  </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n    </span><span class="s1">const data = graph.node(node);</span><span class="s3">\n    </span><span class="s1">log.warn(</span><span class="s3">\&quot; </span><span class="s1">Now next level</span><span class="s3">\&quot;</span><span class="s1">, node, data);</span><span class="s3">\n    </span><span class="s1">if (data?.clusterNode) {</span><span class="s3">\n      </span><span class="s1">extractor(data.graph, depth + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">extractor</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var sorter = /* @__PURE__ */ __name((graph, nodes) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (nodes.length === 0) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let result = Object.assign([], nodes);</span><span class="s3">\n  </span><span class="s1">nodes.forEach((node) =&gt; {</span><span class="s3">\n    </span><span class="s1">const children = graph.children(node);</span><span class="s3">\n    </span><span class="s1">const sorted = sorter(graph, children);</span><span class="s3">\n    </span><span class="s1">result = [...result, ...sorted];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">sorter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var sortNodesByHierarchy = /* @__PURE__ */ __name((graph) =&gt; sorter(graph, graph.children()), </span><span class="s3">\&quot;</span><span class="s1">sortNodesByHierarchy</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/rendering-util/layout-algorithms/dagre/index.js</span><span class="s3">\n</span><span class="s1">var recursiveRender = /* @__PURE__ */ __name(async (_elem, graph, diagramType, id, parentCluster, siteConfig) =&gt; {</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Graph in recursive render:XAX</span><span class="s3">\&quot;</span><span class="s1">, graphlibJson2.write(graph), parentCluster);</span><span class="s3">\n  </span><span class="s1">const dir = graph.graph().rankdir;</span><span class="s3">\n  </span><span class="s1">log.trace(</span><span class="s3">\&quot;</span><span class="s1">Dir in recursive render - dir:</span><span class="s3">\&quot;</span><span class="s1">, dir);</span><span class="s3">\n  </span><span class="s1">const elem = _elem.insert(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (!graph.nodes()) {</span><span class="s3">\n    </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">No nodes found for</span><span class="s3">\&quot;</span><span class="s1">, graph);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Recursive render XXX</span><span class="s3">\&quot;</span><span class="s1">, graph.nodes());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (graph.edges().length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Recursive edges</span><span class="s3">\&quot;</span><span class="s1">, graph.edge(graph.edges()[0]));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const clusters = elem.insert(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">clusters</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const edgePaths = elem.insert(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">edgePaths</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const edgeLabels = elem.insert(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">edgeLabels</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const nodes = elem.insert(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">await Promise.all(</span><span class="s3">\n    </span><span class="s1">graph.nodes().map(async function(v) {</span><span class="s3">\n      </span><span class="s1">const node = graph.node(v);</span><span class="s3">\n      </span><span class="s1">if (parentCluster !== void 0) {</span><span class="s3">\n        </span><span class="s1">const data = JSON.parse(JSON.stringify(parentCluster.clusterData));</span><span class="s3">\n        </span><span class="s1">log.trace(</span><span class="s3">\n          \&quot;</span><span class="s1">Setting data for parent cluster XXX</span><span class="s3">\\</span><span class="s1">n Node.id = </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">v,</span><span class="s3">\n          \&quot;\\</span><span class="s1">n data=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">data.height,</span><span class="s3">\n          \&quot;\\</span><span class="s1">nParent cluster</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">parentCluster.height</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">graph.setNode(parentCluster.id, data);</span><span class="s3">\n        </span><span class="s1">if (!graph.parent(v)) {</span><span class="s3">\n          </span><span class="s1">log.trace(</span><span class="s3">\&quot;</span><span class="s1">Setting parent</span><span class="s3">\&quot;</span><span class="s1">, v, parentCluster.id);</span><span class="s3">\n          </span><span class="s1">graph.setParent(v, parentCluster.id, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">(Insert) Node XXX</span><span class="s3">\&quot; </span><span class="s1">+ v + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(graph.node(v)));</span><span class="s3">\n      </span><span class="s1">if (node?.clusterNode) {</span><span class="s3">\n        </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Cluster identified XBX</span><span class="s3">\&quot;</span><span class="s1">, v, node.width, graph.node(v));</span><span class="s3">\n        </span><span class="s1">const { ranksep, nodesep } = graph.graph();</span><span class="s3">\n        </span><span class="s1">node.graph.setGraph({</span><span class="s3">\n          </span><span class="s1">...node.graph.graph(),</span><span class="s3">\n          </span><span class="s1">ranksep: ranksep + 25,</span><span class="s3">\n          </span><span class="s1">nodesep</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const o = await recursiveRender(</span><span class="s3">\n          </span><span class="s1">nodes,</span><span class="s3">\n          </span><span class="s1">node.graph,</span><span class="s3">\n          </span><span class="s1">diagramType,</span><span class="s3">\n          </span><span class="s1">id,</span><span class="s3">\n          </span><span class="s1">graph.node(v),</span><span class="s3">\n          </span><span class="s1">siteConfig</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const newEl = o.elem;</span><span class="s3">\n        </span><span class="s1">updateNodeBounds(node, newEl);</span><span class="s3">\n        </span><span class="s1">node.diff = o.diff || 0;</span><span class="s3">\n        </span><span class="s1">log.info(</span><span class="s3">\n          \&quot;</span><span class="s1">New compound node after recursive render XAX</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">v,</span><span class="s3">\n          \&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">// node,</span><span class="s3">\n          </span><span class="s1">node.width,</span><span class="s3">\n          \&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">node.height</span><span class="s3">\n          </span><span class="s1">// node.x,</span><span class="s3">\n          </span><span class="s1">// node.y</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">setNodeElem(newEl, node);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (graph.children(v).length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">log.trace(</span><span class="s3">\n            \&quot;</span><span class="s1">Cluster - the non recursive path XBX</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">v,</span><span class="s3">\n            </span><span class="s1">node.id,</span><span class="s3">\n            </span><span class="s1">node,</span><span class="s3">\n            </span><span class="s1">node.width,</span><span class="s3">\n            \&quot;</span><span class="s1">Graph:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">graph</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">log.trace(findNonClusterChild(node.id, graph));</span><span class="s3">\n          </span><span class="s1">clusterDb.set(node.id, { id: findNonClusterChild(node.id, graph), node });</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">log.trace(</span><span class="s3">\&quot;</span><span class="s1">Node - the non recursive path XAX</span><span class="s3">\&quot;</span><span class="s1">, v, nodes, graph.node(v), dir);</span><span class="s3">\n          </span><span class="s1">await insertNode(nodes, graph.node(v), { config: siteConfig, dir });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const processEdges = /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const edgePromises = graph.edges().map(async function(e) {</span><span class="s3">\n      </span><span class="s1">const edge = graph.edge(e.v, e.w, e.name);</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Edge </span><span class="s3">\&quot; </span><span class="s1">+ e.v + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ e.w + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(e));</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Edge </span><span class="s3">\&quot; </span><span class="s1">+ e.v + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ e.w + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">, e, </span><span class="s3">\&quot; \&quot;</span><span class="s1">, JSON.stringify(graph.edge(e)));</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\n        \&quot;</span><span class="s1">Fix</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">clusterDb,</span><span class="s3">\n        \&quot;</span><span class="s1">ids:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">e.v,</span><span class="s3">\n        </span><span class="s1">e.w,</span><span class="s3">\n        \&quot;</span><span class="s1">Translating: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">clusterDb.get(e.v),</span><span class="s3">\n        </span><span class="s1">clusterDb.get(e.w)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">await insertEdgeLabel(edgeLabels, edge);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">await Promise.all(edgePromises);</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">processEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">await processEdges();</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Graph before layout:</span><span class="s3">\&quot;</span><span class="s1">, JSON.stringify(graphlibJson2.write(graph)));</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">############################################# XXX</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">###                Layout                 ### XXX</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">############################################# XXX</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">dagreLayout(graph);</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Graph after layout:</span><span class="s3">\&quot;</span><span class="s1">, JSON.stringify(graphlibJson2.write(graph)));</span><span class="s3">\n  </span><span class="s1">let diff = 0;</span><span class="s3">\n  </span><span class="s1">let { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);</span><span class="s3">\n  </span><span class="s1">await Promise.all(</span><span class="s3">\n    </span><span class="s1">sortNodesByHierarchy(graph).map(async function(v) {</span><span class="s3">\n      </span><span class="s1">const node = graph.node(v);</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\n        \&quot;</span><span class="s1">Position XBX =&gt; </span><span class="s3">\&quot; </span><span class="s1">+ v + </span><span class="s3">\&quot;</span><span class="s1">: (</span><span class="s3">\&quot; </span><span class="s1">+ node.x,</span><span class="s3">\n        \&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ node.y,</span><span class="s3">\n        \&quot;</span><span class="s1">) width: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">node.width,</span><span class="s3">\n        \&quot; </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">node.height</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (node?.clusterNode) {</span><span class="s3">\n        </span><span class="s1">node.y += subGraphTitleTotalMargin;</span><span class="s3">\n        </span><span class="s1">log.info(</span><span class="s3">\n          \&quot;</span><span class="s1">A tainted cluster node XBX1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">v,</span><span class="s3">\n          </span><span class="s1">node.id,</span><span class="s3">\n          </span><span class="s1">node.width,</span><span class="s3">\n          </span><span class="s1">node.height,</span><span class="s3">\n          </span><span class="s1">node.x,</span><span class="s3">\n          </span><span class="s1">node.y,</span><span class="s3">\n          </span><span class="s1">graph.parent(v)</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">clusterDb.get(node.id).node = node;</span><span class="s3">\n        </span><span class="s1">positionNode(node);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (graph.children(v).length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">log.info(</span><span class="s3">\n            \&quot;</span><span class="s1">A pure cluster node XBX1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">v,</span><span class="s3">\n            </span><span class="s1">node.id,</span><span class="s3">\n            </span><span class="s1">node.x,</span><span class="s3">\n            </span><span class="s1">node.y,</span><span class="s3">\n            </span><span class="s1">node.width,</span><span class="s3">\n            </span><span class="s1">node.height,</span><span class="s3">\n            </span><span class="s1">graph.parent(v)</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">node.height += subGraphTitleTotalMargin;</span><span class="s3">\n          </span><span class="s1">graph.node(node.parentId);</span><span class="s3">\n          </span><span class="s1">const halfPadding = node?.padding / 2 || 0;</span><span class="s3">\n          </span><span class="s1">const labelHeight = node?.labelBBox?.height || 0;</span><span class="s3">\n          </span><span class="s1">const offsetY = labelHeight - halfPadding || 0;</span><span class="s3">\n          </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">OffsetY</span><span class="s3">\&quot;</span><span class="s1">, offsetY, </span><span class="s3">\&quot;</span><span class="s1">labelHeight</span><span class="s3">\&quot;</span><span class="s1">, labelHeight, </span><span class="s3">\&quot;</span><span class="s1">halfPadding</span><span class="s3">\&quot;</span><span class="s1">, halfPadding);</span><span class="s3">\n          </span><span class="s1">await insertCluster(clusters, node);</span><span class="s3">\n          </span><span class="s1">clusterDb.get(node.id).node = node;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const parent = graph.node(node.parentId);</span><span class="s3">\n          </span><span class="s1">node.y += subGraphTitleTotalMargin / 2;</span><span class="s3">\n          </span><span class="s1">log.info(</span><span class="s3">\n            \&quot;</span><span class="s1">A regular node XBX1 - using the padding</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">node.id,</span><span class="s3">\n            \&quot;</span><span class="s1">parent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">node.parentId,</span><span class="s3">\n            </span><span class="s1">node.width,</span><span class="s3">\n            </span><span class="s1">node.height,</span><span class="s3">\n            </span><span class="s1">node.x,</span><span class="s3">\n            </span><span class="s1">node.y,</span><span class="s3">\n            \&quot;</span><span class="s1">offsetY</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">node.offsetY,</span><span class="s3">\n            \&quot;</span><span class="s1">parent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parent,</span><span class="s3">\n            </span><span class="s1">parent?.offsetY,</span><span class="s3">\n            </span><span class="s1">node</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">positionNode(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">graph.edges().forEach(function(e) {</span><span class="s3">\n    </span><span class="s1">const edge = graph.edge(e);</span><span class="s3">\n    </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Edge </span><span class="s3">\&quot; </span><span class="s1">+ e.v + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ e.w + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(edge), edge);</span><span class="s3">\n    </span><span class="s1">edge.points.forEach((point) =&gt; point.y += subGraphTitleTotalMargin / 2);</span><span class="s3">\n    </span><span class="s1">const startNode = graph.node(e.v);</span><span class="s3">\n    </span><span class="s1">var endNode = graph.node(e.w);</span><span class="s3">\n    </span><span class="s1">const paths = insertEdge(edgePaths, edge, clusterDb, diagramType, startNode, endNode, id);</span><span class="s3">\n    </span><span class="s1">positionEdgeLabel(edge, paths);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">graph.nodes().forEach(function(v) {</span><span class="s3">\n    </span><span class="s1">const n = graph.node(v);</span><span class="s3">\n    </span><span class="s1">log.info(v, n.type, n.diff);</span><span class="s3">\n    </span><span class="s1">if (n.isGroup) {</span><span class="s3">\n      </span><span class="s1">diff = n.diff;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Returning from recursive render XAX</span><span class="s3">\&quot;</span><span class="s1">, elem, diff);</span><span class="s3">\n  </span><span class="s1">return { elem, diff };</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">recursiveRender</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var render = /* @__PURE__ */ __name(async (data4Layout, svg) =&gt; {</span><span class="s3">\n  </span><span class="s1">const graph = new graphlib2.Graph({</span><span class="s3">\n    </span><span class="s1">multigraph: true,</span><span class="s3">\n    </span><span class="s1">compound: true</span><span class="s3">\n  </span><span class="s1">}).setGraph({</span><span class="s3">\n    </span><span class="s1">rankdir: data4Layout.direction,</span><span class="s3">\n    </span><span class="s1">nodesep: data4Layout.config?.nodeSpacing || data4Layout.config?.flowchart?.nodeSpacing || data4Layout.nodeSpacing,</span><span class="s3">\n    </span><span class="s1">ranksep: data4Layout.config?.rankSpacing || data4Layout.config?.flowchart?.rankSpacing || data4Layout.rankSpacing,</span><span class="s3">\n    </span><span class="s1">marginx: 8,</span><span class="s3">\n    </span><span class="s1">marginy: 8</span><span class="s3">\n  </span><span class="s1">}).setDefaultEdgeLabel(function() {</span><span class="s3">\n    </span><span class="s1">return {};</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">const element = svg.select(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">markers_default(element, data4Layout.markers, data4Layout.type, data4Layout.diagramId);</span><span class="s3">\n  </span><span class="s1">clear3();</span><span class="s3">\n  </span><span class="s1">clear2();</span><span class="s3">\n  </span><span class="s1">clear();</span><span class="s3">\n  </span><span class="s1">clear4();</span><span class="s3">\n  </span><span class="s1">data4Layout.nodes.forEach((node) =&gt; {</span><span class="s3">\n    </span><span class="s1">graph.setNode(node.id, { ...node });</span><span class="s3">\n    </span><span class="s1">if (node.parentId) {</span><span class="s3">\n      </span><span class="s1">graph.setParent(node.id, node.parentId);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Edges:</span><span class="s3">\&quot;</span><span class="s1">, data4Layout.edges);</span><span class="s3">\n  </span><span class="s1">data4Layout.edges.forEach((edge) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (edge.start === edge.end) {</span><span class="s3">\n      </span><span class="s1">const nodeId = edge.start;</span><span class="s3">\n      </span><span class="s1">const specialId1 = nodeId + </span><span class="s3">\&quot;</span><span class="s1">---</span><span class="s3">\&quot; </span><span class="s1">+ nodeId + </span><span class="s3">\&quot;</span><span class="s1">---1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">const specialId2 = nodeId + </span><span class="s3">\&quot;</span><span class="s1">---</span><span class="s3">\&quot; </span><span class="s1">+ nodeId + </span><span class="s3">\&quot;</span><span class="s1">---2</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">const node = graph.node(nodeId);</span><span class="s3">\n      </span><span class="s1">graph.setNode(specialId1, {</span><span class="s3">\n        </span><span class="s1">domId: specialId1,</span><span class="s3">\n        </span><span class="s1">id: specialId1,</span><span class="s3">\n        </span><span class="s1">parentId: node.parentId,</span><span class="s3">\n        </span><span class="s1">labelStyle: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">label: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: 0,</span><span class="s3">\n        </span><span class="s1">shape: </span><span class="s3">\&quot;</span><span class="s1">labelRect</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">// shape: 'rect',</span><span class="s3">\n        </span><span class="s1">style: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">width: 10,</span><span class="s3">\n        </span><span class="s1">height: 10</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">graph.setParent(specialId1, node.parentId);</span><span class="s3">\n      </span><span class="s1">graph.setNode(specialId2, {</span><span class="s3">\n        </span><span class="s1">domId: specialId2,</span><span class="s3">\n        </span><span class="s1">id: specialId2,</span><span class="s3">\n        </span><span class="s1">parentId: node.parentId,</span><span class="s3">\n        </span><span class="s1">labelStyle: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: 0,</span><span class="s3">\n        </span><span class="s1">// shape: 'rect',</span><span class="s3">\n        </span><span class="s1">shape: </span><span class="s3">\&quot;</span><span class="s1">labelRect</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">label: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">style: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">width: 10,</span><span class="s3">\n        </span><span class="s1">height: 10</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">graph.setParent(specialId2, node.parentId);</span><span class="s3">\n      </span><span class="s1">const edge1 = structuredClone(edge);</span><span class="s3">\n      </span><span class="s1">const edgeMid = structuredClone(edge);</span><span class="s3">\n      </span><span class="s1">const edge2 = structuredClone(edge);</span><span class="s3">\n      </span><span class="s1">edge1.label = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edge1.arrowTypeEnd = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edge1.id = nodeId + </span><span class="s3">\&quot;</span><span class="s1">-cyclic-special-1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edgeMid.arrowTypeStart = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edgeMid.arrowTypeEnd = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edgeMid.id = nodeId + </span><span class="s3">\&quot;</span><span class="s1">-cyclic-special-mid</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edge2.label = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (node.isGroup) {</span><span class="s3">\n        </span><span class="s1">edge1.fromCluster = nodeId;</span><span class="s3">\n        </span><span class="s1">edge2.toCluster = nodeId;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">edge2.id = nodeId + </span><span class="s3">\&quot;</span><span class="s1">-cyclic-special-2</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">edge2.arrowTypeStart = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">graph.setEdge(nodeId, specialId1, edge1, nodeId + </span><span class="s3">\&quot;</span><span class="s1">-cyclic-special-0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">graph.setEdge(specialId1, specialId2, edgeMid, nodeId + </span><span class="s3">\&quot;</span><span class="s1">-cyclic-special-1</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">graph.setEdge(specialId2, nodeId, edge2, nodeId + </span><span class="s3">\&quot;</span><span class="s1">-cyc&lt;lic-special-2</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">graph.setEdge(edge.start, edge.end, { ...edge }, edge.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Graph at first:</span><span class="s3">\&quot;</span><span class="s1">, JSON.stringify(graphlibJson2.write(graph)));</span><span class="s3">\n  </span><span class="s1">adjustClustersAndEdges(graph);</span><span class="s3">\n  </span><span class="s1">log.warn(</span><span class="s3">\&quot;</span><span class="s1">Graph after XAX:</span><span class="s3">\&quot;</span><span class="s1">, JSON.stringify(graphlibJson2.write(graph)));</span><span class="s3">\n  </span><span class="s1">const siteConfig = getConfig();</span><span class="s3">\n  </span><span class="s1">await recursiveRender(</span><span class="s3">\n    </span><span class="s1">element,</span><span class="s3">\n    </span><span class="s1">graph,</span><span class="s3">\n    </span><span class="s1">data4Layout.type,</span><span class="s3">\n    </span><span class="s1">data4Layout.diagramId,</span><span class="s3">\n    </span><span class="s1">void 0,</span><span class="s3">\n    </span><span class="s1">siteConfig</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">render</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">render</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>