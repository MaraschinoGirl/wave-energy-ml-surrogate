<html>
<head>
<title>4039.dcbb5e4f3949b6eff7e9.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
4039.dcbb5e4f3949b6eff7e9.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;4039.dcbb5e4f3949b6eff7e9.js?v=dcbb5e4f3949b6eff7e9&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;AAAA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA,uCAAuC,4BAA4B,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,iBAAiB,MAAM;AAC3B;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,GAAG;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,oCAAoC,GAAG;AACvC;AACA,0BAA0B;AAC1B;AACA;;AAEA,UAAU;AACV;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,IAAI;AACJ;AACA,wBAAwB;AACxB;AACA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE;AACA;AACA,gBAAgB,yBAAyB;AACzC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,2EAA2E,uBAAuB;AAClG;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB,wBAAwB;AACjE;AACA;AACA;AACA,oBAAoB,EAAE;AACtB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D,uBAAuB;AACnF;AACA;;AAEA;AACA;AACA,4DAA4D,uBAAuB;AACnF,8DAA8D;AAC9D;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,IAAI;AAC5F;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,2BAA2B;AAC3B,oBAAoB,oBAAoB;AACxC;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,oBAAoB;AACpB;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/haxe.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Tokenizer</span><span class="s3">\n\n</span><span class="s1">function kw(type) {return {type: type, style: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">};}</span><span class="s3">\n</span><span class="s1">var A = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword a</span><span class="s3">\&quot;</span><span class="s1">), B = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword b</span><span class="s3">\&quot;</span><span class="s1">), C = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword c</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var operator = kw(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">), atom = {type: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">}, attribute = {type:</span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var type = kw(</span><span class="s3">\&quot;</span><span class="s1">typedef</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var keywords = {</span><span class="s3">\n  \&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">: A, </span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">: A, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">: B, </span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">: B, </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">: B,</span><span class="s3">\n  \&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">: C,</span><span class="s3">\n  \&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">inline</span><span class="s3">\&quot;</span><span class="s1">:attribute, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">: attribute, </span><span class="s3">\&quot;</span><span class="s1">using</span><span class="s3">\&quot;</span><span class="s1">:kw(</span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  \&quot;</span><span class="s1">public</span><span class="s3">\&quot;</span><span class="s1">: attribute, </span><span class="s3">\&quot;</span><span class="s1">private</span><span class="s3">\&quot;</span><span class="s1">: attribute, </span><span class="s3">\&quot;</span><span class="s1">cast</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">cast</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">macro</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">macro</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  \&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">untyped</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">untyped</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">callback</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">cb</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  \&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  \&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">: operator, </span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">property_access</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">trace</span><span class="s3">\&quot;</span><span class="s1">:kw(</span><span class="s3">\&quot;</span><span class="s1">trace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  \&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">: type, </span><span class="s3">\&quot;</span><span class="s1">abstract</span><span class="s3">\&quot;</span><span class="s1">:type, </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">:type, </span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">:type, </span><span class="s3">\&quot;</span><span class="s1">typedef</span><span class="s3">\&quot;</span><span class="s1">:type, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">:type, </span><span class="s3">\&quot;</span><span class="s1">implements</span><span class="s3">\&quot;</span><span class="s1">:type, </span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">:type,</span><span class="s3">\n  \&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">: atom</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var isOperatorChar = /[+</span><span class="s3">\\</span><span class="s1">-*&amp;%=&lt;&gt;!?|]/;</span><span class="s3">\n\n</span><span class="s1">function chain(stream, state, f) {</span><span class="s3">\n  </span><span class="s1">state.tokenize = f;</span><span class="s3">\n  </span><span class="s1">return f(stream, state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function toUnescaped(stream, end) {</span><span class="s3">\n  </span><span class="s1">var escaped = false, next;</span><span class="s3">\n  </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n    </span><span class="s1">if (next == end &amp;&amp; !escaped)</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Used as scratch variables to communicate multiple values without</span><span class="s3">\n</span><span class="s1">// consing up tons of objects.</span><span class="s3">\n</span><span class="s1">var type, content;</span><span class="s3">\n</span><span class="s1">function ret(tp, style, cont) {</span><span class="s3">\n  </span><span class="s1">type = tp; content = cont;</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function haxeTokenBase(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch = stream.next();</span><span class="s3">\n  </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">' || ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return chain(stream, state, haxeTokenString(ch));</span><span class="s3">\n  </span><span class="s1">} else if (/[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{}</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">),;</span><span class="s3">\\</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">.]/.test(ch)) {</span><span class="s3">\n    </span><span class="s1">return ret(ch);</span><span class="s3">\n  </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(/x/i)) {</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">da-f]/i);</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (/</span><span class="s3">\\</span><span class="s1">d/.test(ch) || ch == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(/</span><span class="s3">\\</span><span class="s1">d/)) {</span><span class="s3">\n    </span><span class="s1">stream.match(/^</span><span class="s3">\\</span><span class="s1">d*(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*(?!</span><span class="s3">\\</span><span class="s1">.))?(?:[eE][+</span><span class="s3">\\</span><span class="s1">-]?</span><span class="s3">\\</span><span class="s1">d+)?/);</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (state.reAllowed &amp;&amp; (ch == </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(/</span><span class="s3">\\</span><span class="s1">//))) {</span><span class="s3">\n    </span><span class="s1">toUnescaped(stream, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(/[gimsu]/);</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return chain(stream, state, haxeTokenComment);</span><span class="s3">\n    </span><span class="s1">} else if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(isOperatorChar);</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, null, stream.current());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">conditional</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.eat(/:/);</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w_]/);</span><span class="s3">\n    </span><span class="s1">return ret (</span><span class="s3">\&quot;</span><span class="s1">metadata</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (isOperatorChar.test(ch)) {</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(isOperatorChar);</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, null, stream.current());</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var word;</span><span class="s3">\n    </span><span class="s1">if(/[A-Z]/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w_&lt;&gt;]/);</span><span class="s3">\n      </span><span class="s1">word = stream.current();</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, word);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w_]/);</span><span class="s3">\n      </span><span class="s1">var word = stream.current(), known = keywords.propertyIsEnumerable(word) &amp;&amp; keywords[word];</span><span class="s3">\n      </span><span class="s1">return (known &amp;&amp; state.kwAllowed) ? ret(known.type, known.style, word) :</span><span class="s3">\n        </span><span class="s1">ret(</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">, word);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function haxeTokenString(quote) {</span><span class="s3">\n  </span><span class="s1">return function(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (toUnescaped(stream, quote))</span><span class="s3">\n      </span><span class="s1">state.tokenize = haxeTokenBase;</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function haxeTokenComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">var maybeEnd = false, ch;</span><span class="s3">\n  </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = haxeTokenBase;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Parser</span><span class="s3">\n\n</span><span class="s1">var atomicTypes = {</span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">: true};</span><span class="s3">\n\n</span><span class="s1">function HaxeLexical(indented, column, type, align, prev, info) {</span><span class="s3">\n  </span><span class="s1">this.indented = indented;</span><span class="s3">\n  </span><span class="s1">this.column = column;</span><span class="s3">\n  </span><span class="s1">this.type = type;</span><span class="s3">\n  </span><span class="s1">this.prev = prev;</span><span class="s3">\n  </span><span class="s1">this.info = info;</span><span class="s3">\n  </span><span class="s1">if (align != null) this.align = align;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function inScope(state, varname) {</span><span class="s3">\n  </span><span class="s1">for (var v = state.localVars; v; v = v.next)</span><span class="s3">\n    </span><span class="s1">if (v.name == varname) return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseHaxe(state, style, type, content, stream) {</span><span class="s3">\n  </span><span class="s1">var cc = state.cc;</span><span class="s3">\n  </span><span class="s1">// Communicate our context to the combinators.</span><span class="s3">\n  </span><span class="s1">// (Less wasteful than consing up a hundred closures on every call.)</span><span class="s3">\n  </span><span class="s1">cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;</span><span class="s3">\n\n  </span><span class="s1">if (!state.lexical.hasOwnProperty(</span><span class="s3">\&quot;</span><span class="s1">align</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n    </span><span class="s1">state.lexical.align = true;</span><span class="s3">\n\n  </span><span class="s1">while(true) {</span><span class="s3">\n    </span><span class="s1">var combinator = cc.length ? cc.pop() : statement;</span><span class="s3">\n    </span><span class="s1">if (combinator(type, content)) {</span><span class="s3">\n      </span><span class="s1">while(cc.length &amp;&amp; cc[cc.length - 1].lex)</span><span class="s3">\n        </span><span class="s1">cc.pop()();</span><span class="s3">\n      </span><span class="s1">if (cx.marked) return cx.marked;</span><span class="s3">\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; inScope(state, content)) return </span><span class="s3">\&quot;</span><span class="s1">variableName.local</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; imported(state, content)) return </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return style;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function imported(state, typename) {</span><span class="s3">\n  </span><span class="s1">if (/[a-z]/.test(typename.charAt(0)))</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">var len = state.importedtypes.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i&lt;len; i++)</span><span class="s3">\n    </span><span class="s1">if(state.importedtypes[i]==typename) return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function registerimport(importname) {</span><span class="s3">\n  </span><span class="s1">var state = cx.state;</span><span class="s3">\n  </span><span class="s1">for (var t = state.importedtypes; t; t = t.next)</span><span class="s3">\n    </span><span class="s1">if(t.name == importname) return;</span><span class="s3">\n  </span><span class="s1">state.importedtypes = { name: importname, next: state.importedtypes };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Combinator utils</span><span class="s3">\n\n</span><span class="s1">var cx = {state: null, column: null, marked: null, cc: null};</span><span class="s3">\n</span><span class="s1">function pass() {</span><span class="s3">\n  </span><span class="s1">for (var i = arguments.length - 1; i &gt;= 0; i--) cx.cc.push(arguments[i]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cont() {</span><span class="s3">\n  </span><span class="s1">pass.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function inList(name, list) {</span><span class="s3">\n  </span><span class="s1">for (var v = list; v; v = v.next)</span><span class="s3">\n    </span><span class="s1">if (v.name == name) return true;</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function register(varname) {</span><span class="s3">\n  </span><span class="s1">var state = cx.state;</span><span class="s3">\n  </span><span class="s1">if (state.context) {</span><span class="s3">\n    </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (inList(varname, state.localVars)) return;</span><span class="s3">\n    </span><span class="s1">state.localVars = {name: varname, next: state.localVars};</span><span class="s3">\n  </span><span class="s1">} else if (state.globalVars) {</span><span class="s3">\n    </span><span class="s1">if (inList(varname, state.globalVars)) return;</span><span class="s3">\n    </span><span class="s1">state.globalVars = {name: varname, next: state.globalVars};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Combinators</span><span class="s3">\n\n</span><span class="s1">var defaultVars = {name: </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, next: null};</span><span class="s3">\n</span><span class="s1">function pushcontext() {</span><span class="s3">\n  </span><span class="s1">if (!cx.state.context) cx.state.localVars = defaultVars;</span><span class="s3">\n  </span><span class="s1">cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function popcontext() {</span><span class="s3">\n  </span><span class="s1">cx.state.localVars = cx.state.context.vars;</span><span class="s3">\n  </span><span class="s1">cx.state.context = cx.state.context.prev;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">popcontext.lex = true;</span><span class="s3">\n</span><span class="s1">function pushlex(type, info) {</span><span class="s3">\n  </span><span class="s1">var result = function() {</span><span class="s3">\n    </span><span class="s1">var state = cx.state;</span><span class="s3">\n    </span><span class="s1">state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">result.lex = true;</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function poplex() {</span><span class="s3">\n  </span><span class="s1">var state = cx.state;</span><span class="s3">\n  </span><span class="s1">if (state.lexical.prev) {</span><span class="s3">\n    </span><span class="s1">if (state.lexical.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">state.indented = state.lexical.indented;</span><span class="s3">\n    </span><span class="s1">state.lexical = state.lexical.prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">poplex.lex = true;</span><span class="s3">\n\n</span><span class="s1">function expect(wanted) {</span><span class="s3">\n  </span><span class="s1">function f(type) {</span><span class="s3">\n    </span><span class="s1">if (type == wanted) return cont();</span><span class="s3">\n    </span><span class="s1">else if (wanted == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return pass();</span><span class="s3">\n    </span><span class="s1">else return cont(f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return f;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function statement(type) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) return cont(metadef);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">vardef</span><span class="s3">\&quot;</span><span class="s1">), vardef1, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword a</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), expression, statement, poplex);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword b</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), statement, poplex);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), pushcontext, block, poplex, popcontext);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybeattribute);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) return cont(functiondef);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), expect(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">), pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), forspec1, expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                                 </span><span class="s1">poplex, statement, poplex);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), maybelabel);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), expression, pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">), expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                                    </span><span class="s1">block, poplex, poplex);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), pushcontext, expect(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">), funarg, expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                                   </span><span class="s1">statement, poplex, popcontext);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">) return cont(importdef, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">typedef</span><span class="s3">\&quot;</span><span class="s1">) return cont(typedef);</span><span class="s3">\n  </span><span class="s1">return pass(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), expression, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function expression(type) {</span><span class="s3">\n  </span><span class="s1">if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">) return cont(maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) return cont(functiondef);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword c</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybeexpression);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), maybeexpression, expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), commasep(maybeexpression, </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), poplex, maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), commasep(objprop, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), poplex, maybeoperator);</span><span class="s3">\n  </span><span class="s1">return cont();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function maybeexpression(type) {</span><span class="s3">\n  </span><span class="s1">if (type.match(/[;</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">],]/)) return pass();</span><span class="s3">\n  </span><span class="s1">return pass(expression);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function maybeoperator(type, value) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">+|--/.test(value)) return cont(maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), commasep(expression, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) return cont(property, maybeoperator);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), expression, expect(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), poplex, maybeoperator);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function maybeattribute(type) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybeattribute);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) return cont(functiondef);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) return cont(vardef1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function metadef(type) {</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(metadef);</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return cont(metadef);</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), commasep(metaargs, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, statement);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function metaargs(type) {</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function importdef (type, value) {</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }</span><span class="s3">\n  </span><span class="s1">else if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) return cont(importdef);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function typedef (type, value)</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }</span><span class="s3">\n  </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /[A-Z]/.test(value.charAt(0))) { return cont(); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function maybelabel(type) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(poplex, statement);</span><span class="s3">\n  </span><span class="s1">return pass(maybeoperator, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function property(type) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">; return cont();}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function objprop(type) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (atomicTypes.hasOwnProperty(type)) return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">), expression);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function commasep(what, end) {</span><span class="s3">\n  </span><span class="s1">function proceed(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) return cont(what, proceed);</span><span class="s3">\n    </span><span class="s1">if (type == end) return cont();</span><span class="s3">\n    </span><span class="s1">return cont(expect(end));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function(type) {</span><span class="s3">\n    </span><span class="s1">if (type == end) return cont();</span><span class="s3">\n    </span><span class="s1">else return pass(what, proceed);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function block(type) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n  </span><span class="s1">return pass(statement, block);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function vardef1(type, value) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">){register(value); return cont(typeuse, vardef2);}</span><span class="s3">\n  </span><span class="s1">return cont();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function vardef2(type, value) {</span><span class="s3">\n  </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, vardef2);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) return cont(vardef1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function forspec1(type, value) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">register(value);</span><span class="s3">\n    </span><span class="s1">return cont(forin, expression)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return pass()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function forin(_type, value) {</span><span class="s3">\n  </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function functiondef(type, value) {</span><span class="s3">\n  </span><span class="s1">//function names starting with upper-case letters are recognised as types, so cludging them together here.</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) {register(value); return cont(functiondef);}</span><span class="s3">\n  </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">) return cont(functiondef);</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), pushcontext, commasep(funarg, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, typeuse, statement, popcontext);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function typeuse(type) {</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(typestring);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function typestring(type) {</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeprop, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function typeprop(type) {</span><span class="s3">\n  </span><span class="s1">if(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeuse);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function funarg(type, value) {</span><span class="s3">\n  </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {register(value); return cont(typeuse);}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Interface</span><span class="s3">\n</span><span class="s1">export const haxe = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">haxe</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">startState: function(indentUnit) {</span><span class="s3">\n    </span><span class="s1">var defaulttypes = [</span><span class="s3">\&quot;</span><span class="s1">Int</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Float</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">String</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Void</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Std</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Bool</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Dynamic</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Array</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">var state = {</span><span class="s3">\n      </span><span class="s1">tokenize: haxeTokenBase,</span><span class="s3">\n      </span><span class="s1">reAllowed: true,</span><span class="s3">\n      </span><span class="s1">kwAllowed: true,</span><span class="s3">\n      </span><span class="s1">cc: [],</span><span class="s3">\n      </span><span class="s1">lexical: new HaxeLexical(-indentUnit, 0, </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">, false),</span><span class="s3">\n      </span><span class="s1">importedtypes: defaulttypes,</span><span class="s3">\n      </span><span class="s1">context: null,</span><span class="s3">\n      </span><span class="s1">indented: 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return state;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (stream.sol()) {</span><span class="s3">\n      </span><span class="s1">if (!state.lexical.hasOwnProperty(</span><span class="s3">\&quot;</span><span class="s1">align</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">state.lexical.align = false;</span><span class="s3">\n      </span><span class="s1">state.indented = stream.indentation();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n    </span><span class="s1">var style = state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">) return style;</span><span class="s3">\n    </span><span class="s1">state.reAllowed = !!(type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">keyword c</span><span class="s3">\&quot; </span><span class="s1">|| type.match(/^[</span><span class="s3">\\</span><span class="s1">[{}</span><span class="s3">\\</span><span class="s1">(,;:]$/));</span><span class="s3">\n    </span><span class="s1">state.kwAllowed = type != '.';</span><span class="s3">\n    </span><span class="s1">return parseHaxe(state, style, type, content, stream);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">indent: function(state, textAfter, cx) {</span><span class="s3">\n    </span><span class="s1">if (state.tokenize != haxeTokenBase) return 0;</span><span class="s3">\n    </span><span class="s1">var firstChar = textAfter &amp;&amp; textAfter.charAt(0), lexical = state.lexical;</span><span class="s3">\n    </span><span class="s1">if (lexical.type == </span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) lexical = lexical.prev;</span><span class="s3">\n    </span><span class="s1">var type = lexical.type, closing = firstChar == type;</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">vardef</span><span class="s3">\&quot;</span><span class="s1">) return lexical.indented + 4;</span><span class="s3">\n    </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return lexical.indented;</span><span class="s3">\n    </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">) return lexical.indented + cx.unit;</span><span class="s3">\n    </span><span class="s1">else if (lexical.info == </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !closing)</span><span class="s3">\n      </span><span class="s1">return lexical.indented + (/^(?:case|default)</span><span class="s3">\\</span><span class="s1">b/.test(textAfter) ? cx.unit : 2 * cx.unit);</span><span class="s3">\n    </span><span class="s1">else if (lexical.align) return lexical.column + (closing ? 0 : 1);</span><span class="s3">\n    </span><span class="s1">else return lexical.indented + (closing ? 0 : cx.unit);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">indentOnInput: /^</span><span class="s3">\\</span><span class="s1">s*[{}]$/,</span><span class="s3">\n    </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">, block: {open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot;</span><span class="s1">}}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const hxml = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">hxml</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">startState: function () {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">define: false,</span><span class="s3">\n      </span><span class="s1">inString: false</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">token: function (stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch = stream.peek();</span><span class="s3">\n    </span><span class="s1">var sol = stream.sol();</span><span class="s3">\n\n    </span><span class="s1">///* comments */</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (sol &amp;&amp; ch == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">var style = </span><span class="s3">\&quot;</span><span class="s1">variable-2</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">stream.eat(/-/);</span><span class="s3">\n\n      </span><span class="s1">if (stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">stream.eat(/-/);</span><span class="s3">\n        </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">keyword a</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">stream.eat(/[D]/);</span><span class="s3">\n        </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">keyword c</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">state.define = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">stream.eatWhile(/[A-Z]/i);</span><span class="s3">\n      </span><span class="s1">return style;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var ch = stream.peek();</span><span class="s3">\n\n    </span><span class="s1">if (state.inString == false &amp;&amp; ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.inString = true;</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (state.inString == true) {</span><span class="s3">\n      </span><span class="s1">if (stream.skipTo(</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">stream.next();</span><span class="s3">\n        </span><span class="s1">state.inString = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>