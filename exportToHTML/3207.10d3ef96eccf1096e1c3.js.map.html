<html>
<head>
<title>3207.10d3ef96eccf1096e1c3.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
3207.10d3ef96eccf1096e1c3.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;3207.10d3ef96eccf1096e1c3.js?v=10d3ef96eccf1096e1c3&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY,kEAAkE;AACtF,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,6DAA6D;;AAE7D;AACA;AACA;AACA,0BAA0B;AAC1B,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iBAAiB;AACjB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;;AAE7B;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,MAAM;AACN,iBAAiB;;AAEjB;AACA;AACA;AACA,MAAM;AACN,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sHAAsH,qBAAM,mBAAmB,qBAAM;;AAErJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB,YAAY,QAAQ,WAAW;AAC/B,YAAY,SAAS;AACrB;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,SAAS;AACrB;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB;AAChB;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mCAAmC,0BAA0B;AACtH;AACA,OAAO;AACP;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sCAAsC;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL,GAAG;AACH,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,SAAS;AACjC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,oCAAoC;AACpC;AACA,MAAM;AACN;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA,4CAA4C;AAC5C,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;;AAE7C;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA,QAAQ;AACR;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA;AACA,wBAAwB,gBAAgB;AACxC,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,uCAAuC;AACvC,QAAQ;AACR,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;;AAEV;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA,qBAAqB,WAAW;AAChC,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,sBAAsB,UAAU;AAChC;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA,kDAAkD;AAClD;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C,sBAAsB,8BAA8B;AACpD;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,oBAAoB,kBAAkB;AACtC;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,0EAA0E;AAC1E;AACA,4DAA4D;AAC5D;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB,kBAAkB;;AAElB;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;;AAEA,SAAS;AACT,UAAU;AACV,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;;AAET;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,uBAAuB;AACvB;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,YAAY;AACZ,qCAAqC;AACrC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,yBAAyB;AACzB,wBAAwB;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,iCAAiC;AACjC,yBAAyB;AACzB,wBAAwB;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B,mEAAmE;AACnE,gEAAgE;AAChE;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,+FAA+F;AAC/F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA,oBAAoB,qBAAqB,yBAAyB;AAClE;;AAEA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,QAAQ;AACR,wBAAwB;AACxB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,mEAAmE;AACnE,OAAO;AACP;AACA;AACA,yBAAyB;AACzB;AACA,OAAO;AACP,MAAM;AACN;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,kCAAkC;AAClC;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,mBAAmB;AACnB;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,GAAG;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,GAAG;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,cAAc,UAAU;AACxB;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B,cAAc,GAAG;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B,YAAY,GAAG;AACf,cAAc,GAAG;AACjB;AACA;AACA,mBAAmB,QAAQ,OAAO,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,KAAK;AACL,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B,YAAY,GAAG;AACf,YAAY,UAAU;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B,YAAY,GAAG;AACf,cAAc,QAAQ;AACtB;AACA;AACA,mBAAmB,QAAQ,OAAO,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,4CAA4C;AAC5C,iDAAiD;AACjD,oCAAoC;AACpC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,KAAK;AAClC,QAAQ;AACR;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,8BAA8B,MAAM;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,kEAAkE;AAClE,oDAAoD;AACpD,6BAA6B;;AAE7B;AACA;;AAEA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;;AAEA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,uBAAuB;AACvB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,qCAAqC;AACrC;AACA;AACA,OAAO,GAAG;;AAEV;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,sCAAsC;AACtC,gCAAgC;;AAEhC;AACA,sBAAsB;AACtB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,qCAAqC;AACrC;AACA;AACA,OAAO,GAAG;;AAEV;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,wCAAwC;AACxC,gCAAgC;;AAEhC;AACA,2BAA2B;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,QAAQ;AACnB,mEAAmE,8BAA8B;AACjG;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C,SAAS;AACT;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,QAAQ;AACR,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB;AACxB;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB;AACxB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;;AAEL,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C,+BAA+B;;AAE/B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,oBAAoB,4BAA4B;AAChD;AACA,MAAM;;AAEN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mCAAmC;AACnC;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,kCAAkC;AAClC;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C,MAAM;AACN,iCAAiC;AACjC;AACA;AACA;AACA,KAAK;AACL,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,qCAAqC;AACrC;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,MAAM;AACN;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ;;AAER;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA,MAAM;AACN,kCAAkC;AAClC,MAAM;AACN;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;;AAEJ;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA,MAAM;AACN,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oEAAoE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,qCAAqC;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,QAAQ;AACR,gCAAgC;AAChC,QAAQ;AACR,sCAAsC;AACtC;AACA,sBAAsB,kBAAkB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA,oFAAoF;;AAEpF;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,iCAAiC;AACjC;AACA,oBAAoB;AACpB,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oBAAoB;AACpB;AACA;AACA;AACA,4LAA4L;AAC5L;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,sEAAsE;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,MAAM;AACN;AACA;AACA;AACA,6BAA6B;AAC7B,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA,QAAQ;AACR,8CAA8C;AAC9C;;AAEA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC,8CAA8C;AAC9C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,oBAAoB,kBAAkB;AACtC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,+BAA+B;AAC/B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,4BAA4B;AAC5B;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,GAAG;AACH,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA,mBAAmB,mBAAmB;AACtC;AACA,6BAA6B;AAC7B;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iBAAiB,GAAG;AACpB;AACA,GAAG;AACH,iBAAiB,GAAG;AACpB;AACA,GAAG;AACH,iBAAiB,GAAG;AACpB;AACA,GAAG;AACH,oBAAoB,6BAA6B;AACjD,sCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG,IAAI;AACP;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,MAAM;;AAEN,iDAAiD;AACjD;AACA;AACA,MAAM;;AAEN;AACA;AACA,kGAAkG;AAClG,kDAAkD;AAClD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,0DAA0D;AAC1D,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,gDAAgD;AAChD,MAAM;AACN,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,KAAK;AACL,GAAG;AACH;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,4CAA4C;AAC5C,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,yBAAyB;AACzB;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uGAAuG;AACvG,8JAA8J,2CAA2C;AACzM;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,sFAAsF,+CAA+C;;AAErI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6EAA6E;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,gBAAgB;;AAEhB;;AAEA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;;AAEhB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,eAAe,WAAW;AAC1B;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mCAAmC;AACnC,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2EAA2E;AAC3E;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,kBAAkB,oBAAoB;AACtC;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;;AAEV,YAAY;AACZ,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,4BAA4B;AAC5B,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,4BAA4B;AAC5B,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA,wEAAwE;;AAExE,sBAAsB,gBAAgB;AACtC;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gBAAgB;AAC1C;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,0DAA0D;;AAE1D;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,sDAAsD;;AAEtD;AACA;AACA,KAAK;AACL;;AAEA;AACA,0DAA0D;;AAE1D;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,yBAAyB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yBAAyB,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qBAAqB;AAC1E,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,kBAAkB;AAClB,mBAAmB;AACnB,mBAAmB;AACnB,kBAAkB;AAClB,sBAAsB;AACtB,uBAAuB;AACvB,wBAAwB;AACxB,oBAAoB;AACpB,oBAAoB;AACpB,sBAAsB;AACtB,uBAAuB;AACvB,4BAA4B;AAC5B,sBAAsB;AACtB,wBAAwB;AACxB,2BAA2B;AAC3B,yBAAyB;AACzB,gCAAgC;AAChC,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ,oBAAoB;AACpB;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf,uBAAuB;AACvB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,iBAAiB;AACrC;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED,sBAAsB;AACtB,iBAAiB;AACjB,gBAAgB;AAChB,oBAAoB;AACpB,6BAA6B;AAC7B,gCAAgC;AAChC,oBAAoB;AACpB,sBAAsB;AACtB,yBAAyB;AACzB,uBAAuB;AACvB,oBAAoB;AACpB,4BAA4B;AAC5B,gCAAgC;AAChC,yBAAyB;AACzB,qCAAqC;;AAErC,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,iBAAiB;;AAEjD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC,yCAAyC;AACzC,kFAAkF;AAClF;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC,yBAAyB;AACzB,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,wDAAwD;AACxD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;;AAElC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA,GAAG;AACH;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,6EAA6E,sCAAsC,gCAAgC,uDAAuD,6BAA6B,4DAA4D,+CAA+C,wDAAwD,uDAAuD,kFAAkF,8BAA8B,4BAA4B,uBAAuB,6BAA6B,wBAAwB,8BAA8B,6BAA6B,+BAA+B,2BAA2B,gCAAgC,oCAAoC,kDAAkD,gCAAgC,gCAAgC,gCAAgC,gCAAgC,oCAAoC,oDAAoD,2BAA2B,aAAa,kDAAkD,2BAA2B,aAAa,0CAA0C,kDAAkD,8HAA8H,WAAW,wDAAwD,uFAAuF,4BAA4B,WAAW,4DAA4D,2CAA2C,2CAA2C,uHAAuH,4CAA4C,+DAA+D,yFAAyF,yEAAyE,4BAA4B,YAAY,iEAAiE,2CAA2C,2CAA2C,2CAA2C,2CAA2C,uHAAuH,+BAA+B,6BAA6B,6BAA6B,gCAAgC,mCAAmC,0BAA0B,0BAA0B,0BAA0B,2CAA2C,aAAa,iCAAiC,+BAA+B,+BAA+B,8GAA8G,sDAAsD,qHAAqH,qGAAqG,qCAAqC,yCAAyC,gLAAgL,8EAA8E,cAAc,MAAM,8JAA8J,8EAA8E,aAAa,8BAA8B,YAAY,oEAAoE,+HAA+H,mEAAmE,mEAAmE,yFAAyF,4BAA4B,WAAW,gBAAgB,oDAAoD,mEAAmE,gCAAgC,0BAA0B,gCAAgC,SAAS;AAChlJ;AACA,+EAA+E;AAC/E,wDAAwD;AACxD,OAAO,iDAAiD,4BAA4B,uBAAuB,6BAA6B,4BAA4B,8BAA8B,4BAA4B,2BAA2B,iDAAiD;AAC1S,oGAAoG;AACpG,OAAO,kCAAkC,+CAA+C,uJAAuJ,8BAA8B,sDAAsD,MAAM,8BAA8B,WAAW,4EAA4E,sCAAsC,kBAAkB;AACtf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAA+C;AACrE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oCAAoC;AACpC;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,2BAA2B;AAC3B,oDAAoD;AACpD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA,MAAM;AACN,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB;AAClB,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAiE,KAAK;AACtE;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,8BAA8B;;AAE9B,oBAAoB,kBAAkB;AACtC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;;AAEvD,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEgC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/cytoscape/dist/cytoscape.esm.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Copyright (c) 2016-2025, The Cytoscape Consortium.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Permission is hereby granted, free of charge, to any person obtaining a copy of</span><span class="s3">\n </span><span class="s1">* this software and associated documentation files (the Software), to deal in</span><span class="s3">\n </span><span class="s1">* the Software without restriction, including without limitation the rights to</span><span class="s3">\n </span><span class="s1">* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</span><span class="s3">\n </span><span class="s1">* of the Software, and to permit persons to whom the Software is furnished to do</span><span class="s3">\n </span><span class="s1">* so, subject to the following conditions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The above copyright notice and this permission notice shall be included in all</span><span class="s3">\n </span><span class="s1">* copies or substantial portions of the Software.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><span class="s3">\n </span><span class="s1">* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><span class="s3">\n </span><span class="s1">* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><span class="s3">\n </span><span class="s1">* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><span class="s3">\n </span><span class="s1">* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><span class="s3">\n </span><span class="s1">* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><span class="s3">\n </span><span class="s1">* SOFTWARE.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function _arrayLikeToArray(r, a) {</span><span class="s3">\n  </span><span class="s1">(null == a || a &gt; r.length) &amp;&amp; (a = r.length);</span><span class="s3">\n  </span><span class="s1">for (var e = 0, n = Array(a); e &lt; a; e++) n[e] = r[e];</span><span class="s3">\n  </span><span class="s1">return n;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _arrayWithHoles(r) {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(r)) return r;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _arrayWithoutHoles(r) {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(r)) return _arrayLikeToArray(r);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _classCallCheck(a, n) {</span><span class="s3">\n  </span><span class="s1">if (!(a instanceof n)) throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _defineProperties(e, r) {</span><span class="s3">\n  </span><span class="s1">for (var t = 0; t &lt; r.length; t++) {</span><span class="s3">\n    </span><span class="s1">var o = r[t];</span><span class="s3">\n    </span><span class="s1">o.enumerable = o.enumerable || false, o.configurable = true, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in o &amp;&amp; (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _createClass(e, r, t) {</span><span class="s3">\n  </span><span class="s1">return r &amp;&amp; _defineProperties(e.prototype, r), Object.defineProperty(e, </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n    </span><span class="s1">writable: false</span><span class="s3">\n  </span><span class="s1">}), e;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _createForOfIteratorHelper(r, e) {</span><span class="s3">\n  </span><span class="s1">var t = </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">!= typeof Symbol &amp;&amp; r[Symbol.iterator] || r[</span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">if (!t) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {</span><span class="s3">\n      </span><span class="s1">t &amp;&amp; (r = t);</span><span class="s3">\n      </span><span class="s1">var n = 0,</span><span class="s3">\n        </span><span class="s1">F = function () {};</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">s: F,</span><span class="s3">\n        </span><span class="s1">n: function () {</span><span class="s3">\n          </span><span class="s1">return n &gt;= r.length ? {</span><span class="s3">\n            </span><span class="s1">done: true</span><span class="s3">\n          </span><span class="s1">} : {</span><span class="s3">\n            </span><span class="s1">done: false,</span><span class="s3">\n            </span><span class="s1">value: r[n++]</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">e: function (r) {</span><span class="s3">\n          </span><span class="s1">throw r;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">f: F</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid attempt to iterate non-iterable instance.</span><span class="s3">\\</span><span class="s1">nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var o,</span><span class="s3">\n    </span><span class="s1">a = true,</span><span class="s3">\n    </span><span class="s1">u = false;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">s: function () {</span><span class="s3">\n      </span><span class="s1">t = t.call(r);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">n: function () {</span><span class="s3">\n      </span><span class="s1">var r = t.next();</span><span class="s3">\n      </span><span class="s1">return a = r.done, r;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">e: function (r) {</span><span class="s3">\n      </span><span class="s1">u = true, o = r;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">f: function () {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">a || null == t.return || t.return();</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">if (u) throw o;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _defineProperty$1(e, r, t) {</span><span class="s3">\n  </span><span class="s1">return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {</span><span class="s3">\n    </span><span class="s1">value: t,</span><span class="s3">\n    </span><span class="s1">enumerable: true,</span><span class="s3">\n    </span><span class="s1">configurable: true,</span><span class="s3">\n    </span><span class="s1">writable: true</span><span class="s3">\n  </span><span class="s1">}) : e[r] = t, e;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _iterableToArray(r) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">!= typeof Symbol &amp;&amp; null != r[Symbol.iterator] || null != r[</span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">]) return Array.from(r);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _iterableToArrayLimit(r, l) {</span><span class="s3">\n  </span><span class="s1">var t = null == r ? null : </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">!= typeof Symbol &amp;&amp; r[Symbol.iterator] || r[</span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">if (null != t) {</span><span class="s3">\n    </span><span class="s1">var e,</span><span class="s3">\n      </span><span class="s1">n,</span><span class="s3">\n      </span><span class="s1">i,</span><span class="s3">\n      </span><span class="s1">u,</span><span class="s3">\n      </span><span class="s1">a = [],</span><span class="s3">\n      </span><span class="s1">f = true,</span><span class="s3">\n      </span><span class="s1">o = false;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (i = (t = t.call(r)).next, 0 === l) {</span><span class="s3">\n        </span><span class="s1">if (Object(t) !== t) return;</span><span class="s3">\n        </span><span class="s1">f = !1;</span><span class="s3">\n      </span><span class="s1">} else for (; !(f = (e = i.call(t)).done) &amp;&amp; (a.push(e.value), a.length !== l); f = !0);</span><span class="s3">\n    </span><span class="s1">} catch (r) {</span><span class="s3">\n      </span><span class="s1">o = true, n = r;</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (!f &amp;&amp; null != t.return &amp;&amp; (u = t.return(), Object(u) !== u)) return;</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">if (o) throw n;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return a;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _nonIterableRest() {</span><span class="s3">\n  </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid attempt to destructure non-iterable instance.</span><span class="s3">\\</span><span class="s1">nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _nonIterableSpread() {</span><span class="s3">\n  </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid attempt to spread non-iterable instance.</span><span class="s3">\\</span><span class="s1">nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _slicedToArray(r, e) {</span><span class="s3">\n  </span><span class="s1">return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _toConsumableArray(r) {</span><span class="s3">\n  </span><span class="s1">return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _toPrimitive(t, r) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">!= typeof t || !t) return t;</span><span class="s3">\n  </span><span class="s1">var e = t[Symbol.toPrimitive];</span><span class="s3">\n  </span><span class="s1">if (undefined !== e) {</span><span class="s3">\n    </span><span class="s1">var i = e.call(t, r);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">!= typeof i) return i;</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">@@toPrimitive must return a primitive value.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (String )(t);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _toPropertyKey(t) {</span><span class="s3">\n  </span><span class="s1">var i = _toPrimitive(t, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">== typeof i ? i : i + </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _typeof(o) {</span><span class="s3">\n  \&quot;</span><span class="s1">@babel/helpers - typeof</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">return _typeof = </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">== typeof Symbol &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">== typeof Symbol.iterator ? function (o) {</span><span class="s3">\n    </span><span class="s1">return typeof o;</span><span class="s3">\n  </span><span class="s1">} : function (o) {</span><span class="s3">\n    </span><span class="s1">return o &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">== typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">: typeof o;</span><span class="s3">\n  </span><span class="s1">}, _typeof(o);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _unsupportedIterableToArray(r, a) {</span><span class="s3">\n  </span><span class="s1">if (r) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">== typeof r) return _arrayLikeToArray(r, a);</span><span class="s3">\n    </span><span class="s1">var t = {}.toString.call(r).slice(8, -1);</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">Object</span><span class="s3">\&quot; </span><span class="s1">=== t &amp;&amp; r.constructor &amp;&amp; (t = r.constructor.name), </span><span class="s3">\&quot;</span><span class="s1">Map</span><span class="s3">\&quot; </span><span class="s1">=== t || </span><span class="s3">\&quot;</span><span class="s1">Set</span><span class="s3">\&quot; </span><span class="s1">=== t ? Array.from(r) : </span><span class="s3">\&quot;</span><span class="s1">Arguments</span><span class="s3">\&quot; </span><span class="s1">=== t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _window = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef</span><span class="s3">\n\n</span><span class="s1">var navigator = _window ? _window.navigator : null;</span><span class="s3">\n</span><span class="s1">_window ? _window.document : null;</span><span class="s3">\n</span><span class="s1">var typeofstr = _typeof('');</span><span class="s3">\n</span><span class="s1">var typeofobj = _typeof({});</span><span class="s3">\n</span><span class="s1">var typeoffn = _typeof(function () {});</span><span class="s3">\n</span><span class="s1">var typeofhtmlele = typeof HTMLElement === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: _typeof(HTMLElement);</span><span class="s3">\n</span><span class="s1">var instanceStr = function instanceStr(obj) {</span><span class="s3">\n  </span><span class="s1">return obj &amp;&amp; obj.instanceString &amp;&amp; fn$6(obj.instanceString) ? obj.instanceString() : null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var string = function string(obj) {</span><span class="s3">\n  </span><span class="s1">return obj != null &amp;&amp; _typeof(obj) == typeofstr;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var fn$6 = function fn(obj) {</span><span class="s3">\n  </span><span class="s1">return obj != null &amp;&amp; _typeof(obj) === typeoffn;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var array = function array(obj) {</span><span class="s3">\n  </span><span class="s1">return !elementOrCollection(obj) &amp;&amp; (Array.isArray ? Array.isArray(obj) : obj != null &amp;&amp; obj instanceof Array);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var plainObject = function plainObject(obj) {</span><span class="s3">\n  </span><span class="s1">return obj != null &amp;&amp; _typeof(obj) === typeofobj &amp;&amp; !array(obj) &amp;&amp; obj.constructor === Object;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var object = function object(obj) {</span><span class="s3">\n  </span><span class="s1">return obj != null &amp;&amp; _typeof(obj) === typeofobj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var number$1 = function number(obj) {</span><span class="s3">\n  </span><span class="s1">return obj != null &amp;&amp; _typeof(obj) === _typeof(1) &amp;&amp; !isNaN(obj);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var integer = function integer(obj) {</span><span class="s3">\n  </span><span class="s1">return number$1(obj) &amp;&amp; Math.floor(obj) === obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var htmlElement = function htmlElement(obj) {</span><span class="s3">\n  </span><span class="s1">if ('undefined' === typeofhtmlele) {</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return null != obj &amp;&amp; obj instanceof HTMLElement;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var elementOrCollection = function elementOrCollection(obj) {</span><span class="s3">\n  </span><span class="s1">return element(obj) || collection(obj);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var element = function element(obj) {</span><span class="s3">\n  </span><span class="s1">return instanceStr(obj) === 'collection' &amp;&amp; obj._private.single;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var collection = function collection(obj) {</span><span class="s3">\n  </span><span class="s1">return instanceStr(obj) === 'collection' &amp;&amp; !obj._private.single;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var core = function core(obj) {</span><span class="s3">\n  </span><span class="s1">return instanceStr(obj) === 'core';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var stylesheet = function stylesheet(obj) {</span><span class="s3">\n  </span><span class="s1">return instanceStr(obj) === 'stylesheet';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var event = function event(obj) {</span><span class="s3">\n  </span><span class="s1">return instanceStr(obj) === 'event';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var emptyString = function emptyString(obj) {</span><span class="s3">\n  </span><span class="s1">if (obj === undefined || obj === null) {</span><span class="s3">\n    </span><span class="s1">// null is empty</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} else if (obj === '' || obj.match(/^</span><span class="s3">\\</span><span class="s1">s+$/)) {</span><span class="s3">\n    </span><span class="s1">return true; // empty string is empty</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false; // otherwise, we don't know what we've got</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var domElement = function domElement(obj) {</span><span class="s3">\n  </span><span class="s1">if (typeof HTMLElement === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return false; // we're not in a browser so it doesn't matter</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return obj instanceof HTMLElement;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var boundingBox = function boundingBox(obj) {</span><span class="s3">\n  </span><span class="s1">return plainObject(obj) &amp;&amp; number$1(obj.x1) &amp;&amp; number$1(obj.x2) &amp;&amp; number$1(obj.y1) &amp;&amp; number$1(obj.y2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var promise = function promise(obj) {</span><span class="s3">\n  </span><span class="s1">return object(obj) &amp;&amp; fn$6(obj.then);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ms = function ms() {</span><span class="s3">\n  </span><span class="s1">return navigator &amp;&amp; navigator.userAgent.match(/msie|trident|edge/i);</span><span class="s3">\n</span><span class="s1">}; // probably a better way to detect this...</span><span class="s3">\n\n</span><span class="s1">var memoize = function memoize(fn, keyFn) {</span><span class="s3">\n  </span><span class="s1">if (!keyFn) {</span><span class="s3">\n    </span><span class="s1">keyFn = function keyFn() {</span><span class="s3">\n      </span><span class="s1">if (arguments.length === 1) {</span><span class="s3">\n        </span><span class="s1">return arguments[0];</span><span class="s3">\n      </span><span class="s1">} else if (arguments.length === 0) {</span><span class="s3">\n        </span><span class="s1">return 'undefined';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var args = [];</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; arguments.length; i++) {</span><span class="s3">\n        </span><span class="s1">args.push(arguments[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return args.join('$');</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var _memoizedFn = function memoizedFn() {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">var ret;</span><span class="s3">\n    </span><span class="s1">var k = keyFn.apply(self, args);</span><span class="s3">\n    </span><span class="s1">var cache = _memoizedFn.cache;</span><span class="s3">\n    </span><span class="s1">if (!(ret = cache[k])) {</span><span class="s3">\n      </span><span class="s1">ret = cache[k] = fn.apply(self, args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">_memoizedFn.cache = {};</span><span class="s3">\n  </span><span class="s1">return _memoizedFn;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var camel2dash = memoize(function (str) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/([A-Z])/g, function (v) {</span><span class="s3">\n    </span><span class="s1">return '-' + v.toLowerCase();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var dash2camel = memoize(function (str) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/(-</span><span class="s3">\\</span><span class="s1">w)/g, function (v) {</span><span class="s3">\n    </span><span class="s1">return v[1].toUpperCase();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var prependCamel = memoize(function (prefix, str) {</span><span class="s3">\n  </span><span class="s1">return prefix + str[0].toUpperCase() + str.substring(1);</span><span class="s3">\n</span><span class="s1">}, function (prefix, str) {</span><span class="s3">\n  </span><span class="s1">return prefix + '$' + str;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var capitalize = function capitalize(str) {</span><span class="s3">\n  </span><span class="s1">if (emptyString(str)) {</span><span class="s3">\n    </span><span class="s1">return str;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return str.charAt(0).toUpperCase() + str.substring(1);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var number = '(?:[-+]?(?:(?:</span><span class="s3">\\\\</span><span class="s1">d+|</span><span class="s3">\\\\</span><span class="s1">d*</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">d+)(?:[Ee][+-]?</span><span class="s3">\\\\</span><span class="s1">d+)?))';</span><span class="s3">\n</span><span class="s1">var rgba = 'rgb[a]?</span><span class="s3">\\\\</span><span class="s1">((' + number + '[%]?)</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number + '[%]?)</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number + '[%]?)(?:</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number + '))?</span><span class="s3">\\\\</span><span class="s1">)';</span><span class="s3">\n</span><span class="s1">var rgbaNoBackRefs = 'rgb[a]?</span><span class="s3">\\\\</span><span class="s1">((?:' + number + '[%]?)</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(?:' + number + '[%]?)</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(?:' + number + '[%]?)(?:</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(?:' + number + '))?</span><span class="s3">\\\\</span><span class="s1">)';</span><span class="s3">\n</span><span class="s1">var hsla = 'hsl[a]?</span><span class="s3">\\\\</span><span class="s1">((' + number + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number + '[%])</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number + '[%])(?:</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number + '))?</span><span class="s3">\\\\</span><span class="s1">)';</span><span class="s3">\n</span><span class="s1">var hslaNoBackRefs = 'hsl[a]?</span><span class="s3">\\\\</span><span class="s1">((?:' + number + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(?:' + number + '[%])</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(?:' + number + '[%])(?:</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(?:' + number + '))?</span><span class="s3">\\\\</span><span class="s1">)';</span><span class="s3">\n</span><span class="s1">var hex3 = '</span><span class="s3">\\\\</span><span class="s1">#[0-9a-fA-F]{3}';</span><span class="s3">\n</span><span class="s1">var hex6 = '</span><span class="s3">\\\\</span><span class="s1">#[0-9a-fA-F]{6}';</span><span class="s3">\n\n</span><span class="s1">var ascending = function ascending(a, b) {</span><span class="s3">\n  </span><span class="s1">if (a &lt; b) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">} else if (a &gt; b) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var descending = function descending(a, b) {</span><span class="s3">\n  </span><span class="s1">return -1 * ascending(a, b);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {</span><span class="s3">\n  </span><span class="s1">var args = arguments;</span><span class="s3">\n  </span><span class="s1">for (var i = 1; i &lt; args.length; i++) {</span><span class="s3">\n    </span><span class="s1">var obj = args[i];</span><span class="s3">\n    </span><span class="s1">if (obj == null) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var keys = Object.keys(obj);</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; keys.length; j++) {</span><span class="s3">\n      </span><span class="s1">var k = keys[j];</span><span class="s3">\n      </span><span class="s1">tgt[k] = obj[k];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return tgt;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get [r, g, b] from #abc or #aabbcc</span><span class="s3">\n</span><span class="s1">var hex2tuple = function hex2tuple(hex) {</span><span class="s3">\n  </span><span class="s1">if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var shortHex = hex.length === 4;</span><span class="s3">\n  </span><span class="s1">var r, g, b;</span><span class="s3">\n  </span><span class="s1">var base = 16;</span><span class="s3">\n  </span><span class="s1">if (shortHex) {</span><span class="s3">\n    </span><span class="s1">r = parseInt(hex[1] + hex[1], base);</span><span class="s3">\n    </span><span class="s1">g = parseInt(hex[2] + hex[2], base);</span><span class="s3">\n    </span><span class="s1">b = parseInt(hex[3] + hex[3], base);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r = parseInt(hex[1] + hex[2], base);</span><span class="s3">\n    </span><span class="s1">g = parseInt(hex[3] + hex[4], base);</span><span class="s3">\n    </span><span class="s1">b = parseInt(hex[5] + hex[6], base);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [r, g, b];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)</span><span class="s3">\n</span><span class="s1">var hsl2tuple = function hsl2tuple(hsl) {</span><span class="s3">\n  </span><span class="s1">var ret;</span><span class="s3">\n  </span><span class="s1">var h, s, l, a, r, g, b;</span><span class="s3">\n  </span><span class="s1">function hue2rgb(p, q, t) {</span><span class="s3">\n    </span><span class="s1">if (t &lt; 0) t += 1;</span><span class="s3">\n    </span><span class="s1">if (t &gt; 1) t -= 1;</span><span class="s3">\n    </span><span class="s1">if (t &lt; 1 / 6) return p + (q - p) * 6 * t;</span><span class="s3">\n    </span><span class="s1">if (t &lt; 1 / 2) return q;</span><span class="s3">\n    </span><span class="s1">if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;</span><span class="s3">\n    </span><span class="s1">return p;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var m = new RegExp('^' + hsla + '$').exec(hsl);</span><span class="s3">\n  </span><span class="s1">if (m) {</span><span class="s3">\n    </span><span class="s1">// get hue</span><span class="s3">\n    </span><span class="s1">h = parseInt(m[1]);</span><span class="s3">\n    </span><span class="s1">if (h &lt; 0) {</span><span class="s3">\n      </span><span class="s1">h = (360 - -1 * h % 360) % 360;</span><span class="s3">\n    </span><span class="s1">} else if (h &gt; 360) {</span><span class="s3">\n      </span><span class="s1">h = h % 360;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">h /= 360; // normalise on [0, 1]</span><span class="s3">\n\n    </span><span class="s1">s = parseFloat(m[2]);</span><span class="s3">\n    </span><span class="s1">if (s &lt; 0 || s &gt; 100) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // saturation is [0, 100]</span><span class="s3">\n    </span><span class="s1">s = s / 100; // normalise on [0, 1]</span><span class="s3">\n\n    </span><span class="s1">l = parseFloat(m[3]);</span><span class="s3">\n    </span><span class="s1">if (l &lt; 0 || l &gt; 100) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // lightness is [0, 100]</span><span class="s3">\n    </span><span class="s1">l = l / 100; // normalise on [0, 1]</span><span class="s3">\n\n    </span><span class="s1">a = m[4];</span><span class="s3">\n    </span><span class="s1">if (a !== undefined) {</span><span class="s3">\n      </span><span class="s1">a = parseFloat(a);</span><span class="s3">\n      </span><span class="s1">if (a &lt; 0 || a &gt; 1) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // alpha is [0, 1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now, convert to rgb</span><span class="s3">\n    </span><span class="s1">// code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript</span><span class="s3">\n    </span><span class="s1">if (s === 0) {</span><span class="s3">\n      </span><span class="s1">r = g = b = Math.round(l * 255); // achromatic</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;</span><span class="s3">\n      </span><span class="s1">var p = 2 * l - q;</span><span class="s3">\n      </span><span class="s1">r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));</span><span class="s3">\n      </span><span class="s1">g = Math.round(255 * hue2rgb(p, q, h));</span><span class="s3">\n      </span><span class="s1">b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ret = [r, g, b, a];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ret;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)</span><span class="s3">\n</span><span class="s1">var rgb2tuple = function rgb2tuple(rgb) {</span><span class="s3">\n  </span><span class="s1">var ret;</span><span class="s3">\n  </span><span class="s1">var m = new RegExp('^' + rgba + '$').exec(rgb);</span><span class="s3">\n  </span><span class="s1">if (m) {</span><span class="s3">\n    </span><span class="s1">ret = [];</span><span class="s3">\n    </span><span class="s1">var isPct = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 1; i &lt;= 3; i++) {</span><span class="s3">\n      </span><span class="s1">var channel = m[i];</span><span class="s3">\n      </span><span class="s1">if (channel[channel.length - 1] === '%') {</span><span class="s3">\n        </span><span class="s1">isPct[i] = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">channel = parseFloat(channel);</span><span class="s3">\n      </span><span class="s1">if (isPct[i]) {</span><span class="s3">\n        </span><span class="s1">channel = channel / 100 * 255; // normalise to [0, 255]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (channel &lt; 0 || channel &gt; 255) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // invalid channel value</span><span class="s3">\n\n      </span><span class="s1">ret.push(Math.floor(channel));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];</span><span class="s3">\n    </span><span class="s1">var allArePct = isPct[1] &amp;&amp; isPct[2] &amp;&amp; isPct[3];</span><span class="s3">\n    </span><span class="s1">if (atLeastOneIsPct &amp;&amp; !allArePct) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // must all be percent values if one is</span><span class="s3">\n\n    </span><span class="s1">var alpha = m[4];</span><span class="s3">\n    </span><span class="s1">if (alpha !== undefined) {</span><span class="s3">\n      </span><span class="s1">alpha = parseFloat(alpha);</span><span class="s3">\n      </span><span class="s1">if (alpha &lt; 0 || alpha &gt; 1) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // invalid alpha value</span><span class="s3">\n\n      </span><span class="s1">ret.push(alpha);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ret;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var colorname2tuple = function colorname2tuple(color) {</span><span class="s3">\n  </span><span class="s1">return colors[color.toLowerCase()];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var color2tuple = function color2tuple(color) {</span><span class="s3">\n  </span><span class="s1">return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var colors = {</span><span class="s3">\n  </span><span class="s1">// special colour names</span><span class="s3">\n  </span><span class="s1">transparent: [0, 0, 0, 0],</span><span class="s3">\n  </span><span class="s1">// NB alpha === 0</span><span class="s3">\n\n  </span><span class="s1">// regular colours</span><span class="s3">\n  </span><span class="s1">aliceblue: [240, 248, 255],</span><span class="s3">\n  </span><span class="s1">antiquewhite: [250, 235, 215],</span><span class="s3">\n  </span><span class="s1">aqua: [0, 255, 255],</span><span class="s3">\n  </span><span class="s1">aquamarine: [127, 255, 212],</span><span class="s3">\n  </span><span class="s1">azure: [240, 255, 255],</span><span class="s3">\n  </span><span class="s1">beige: [245, 245, 220],</span><span class="s3">\n  </span><span class="s1">bisque: [255, 228, 196],</span><span class="s3">\n  </span><span class="s1">black: [0, 0, 0],</span><span class="s3">\n  </span><span class="s1">blanchedalmond: [255, 235, 205],</span><span class="s3">\n  </span><span class="s1">blue: [0, 0, 255],</span><span class="s3">\n  </span><span class="s1">blueviolet: [138, 43, 226],</span><span class="s3">\n  </span><span class="s1">brown: [165, 42, 42],</span><span class="s3">\n  </span><span class="s1">burlywood: [222, 184, 135],</span><span class="s3">\n  </span><span class="s1">cadetblue: [95, 158, 160],</span><span class="s3">\n  </span><span class="s1">chartreuse: [127, 255, 0],</span><span class="s3">\n  </span><span class="s1">chocolate: [210, 105, 30],</span><span class="s3">\n  </span><span class="s1">coral: [255, 127, 80],</span><span class="s3">\n  </span><span class="s1">cornflowerblue: [100, 149, 237],</span><span class="s3">\n  </span><span class="s1">cornsilk: [255, 248, 220],</span><span class="s3">\n  </span><span class="s1">crimson: [220, 20, 60],</span><span class="s3">\n  </span><span class="s1">cyan: [0, 255, 255],</span><span class="s3">\n  </span><span class="s1">darkblue: [0, 0, 139],</span><span class="s3">\n  </span><span class="s1">darkcyan: [0, 139, 139],</span><span class="s3">\n  </span><span class="s1">darkgoldenrod: [184, 134, 11],</span><span class="s3">\n  </span><span class="s1">darkgray: [169, 169, 169],</span><span class="s3">\n  </span><span class="s1">darkgreen: [0, 100, 0],</span><span class="s3">\n  </span><span class="s1">darkgrey: [169, 169, 169],</span><span class="s3">\n  </span><span class="s1">darkkhaki: [189, 183, 107],</span><span class="s3">\n  </span><span class="s1">darkmagenta: [139, 0, 139],</span><span class="s3">\n  </span><span class="s1">darkolivegreen: [85, 107, 47],</span><span class="s3">\n  </span><span class="s1">darkorange: [255, 140, 0],</span><span class="s3">\n  </span><span class="s1">darkorchid: [153, 50, 204],</span><span class="s3">\n  </span><span class="s1">darkred: [139, 0, 0],</span><span class="s3">\n  </span><span class="s1">darksalmon: [233, 150, 122],</span><span class="s3">\n  </span><span class="s1">darkseagreen: [143, 188, 143],</span><span class="s3">\n  </span><span class="s1">darkslateblue: [72, 61, 139],</span><span class="s3">\n  </span><span class="s1">darkslategray: [47, 79, 79],</span><span class="s3">\n  </span><span class="s1">darkslategrey: [47, 79, 79],</span><span class="s3">\n  </span><span class="s1">darkturquoise: [0, 206, 209],</span><span class="s3">\n  </span><span class="s1">darkviolet: [148, 0, 211],</span><span class="s3">\n  </span><span class="s1">deeppink: [255, 20, 147],</span><span class="s3">\n  </span><span class="s1">deepskyblue: [0, 191, 255],</span><span class="s3">\n  </span><span class="s1">dimgray: [105, 105, 105],</span><span class="s3">\n  </span><span class="s1">dimgrey: [105, 105, 105],</span><span class="s3">\n  </span><span class="s1">dodgerblue: [30, 144, 255],</span><span class="s3">\n  </span><span class="s1">firebrick: [178, 34, 34],</span><span class="s3">\n  </span><span class="s1">floralwhite: [255, 250, 240],</span><span class="s3">\n  </span><span class="s1">forestgreen: [34, 139, 34],</span><span class="s3">\n  </span><span class="s1">fuchsia: [255, 0, 255],</span><span class="s3">\n  </span><span class="s1">gainsboro: [220, 220, 220],</span><span class="s3">\n  </span><span class="s1">ghostwhite: [248, 248, 255],</span><span class="s3">\n  </span><span class="s1">gold: [255, 215, 0],</span><span class="s3">\n  </span><span class="s1">goldenrod: [218, 165, 32],</span><span class="s3">\n  </span><span class="s1">gray: [128, 128, 128],</span><span class="s3">\n  </span><span class="s1">grey: [128, 128, 128],</span><span class="s3">\n  </span><span class="s1">green: [0, 128, 0],</span><span class="s3">\n  </span><span class="s1">greenyellow: [173, 255, 47],</span><span class="s3">\n  </span><span class="s1">honeydew: [240, 255, 240],</span><span class="s3">\n  </span><span class="s1">hotpink: [255, 105, 180],</span><span class="s3">\n  </span><span class="s1">indianred: [205, 92, 92],</span><span class="s3">\n  </span><span class="s1">indigo: [75, 0, 130],</span><span class="s3">\n  </span><span class="s1">ivory: [255, 255, 240],</span><span class="s3">\n  </span><span class="s1">khaki: [240, 230, 140],</span><span class="s3">\n  </span><span class="s1">lavender: [230, 230, 250],</span><span class="s3">\n  </span><span class="s1">lavenderblush: [255, 240, 245],</span><span class="s3">\n  </span><span class="s1">lawngreen: [124, 252, 0],</span><span class="s3">\n  </span><span class="s1">lemonchiffon: [255, 250, 205],</span><span class="s3">\n  </span><span class="s1">lightblue: [173, 216, 230],</span><span class="s3">\n  </span><span class="s1">lightcoral: [240, 128, 128],</span><span class="s3">\n  </span><span class="s1">lightcyan: [224, 255, 255],</span><span class="s3">\n  </span><span class="s1">lightgoldenrodyellow: [250, 250, 210],</span><span class="s3">\n  </span><span class="s1">lightgray: [211, 211, 211],</span><span class="s3">\n  </span><span class="s1">lightgreen: [144, 238, 144],</span><span class="s3">\n  </span><span class="s1">lightgrey: [211, 211, 211],</span><span class="s3">\n  </span><span class="s1">lightpink: [255, 182, 193],</span><span class="s3">\n  </span><span class="s1">lightsalmon: [255, 160, 122],</span><span class="s3">\n  </span><span class="s1">lightseagreen: [32, 178, 170],</span><span class="s3">\n  </span><span class="s1">lightskyblue: [135, 206, 250],</span><span class="s3">\n  </span><span class="s1">lightslategray: [119, 136, 153],</span><span class="s3">\n  </span><span class="s1">lightslategrey: [119, 136, 153],</span><span class="s3">\n  </span><span class="s1">lightsteelblue: [176, 196, 222],</span><span class="s3">\n  </span><span class="s1">lightyellow: [255, 255, 224],</span><span class="s3">\n  </span><span class="s1">lime: [0, 255, 0],</span><span class="s3">\n  </span><span class="s1">limegreen: [50, 205, 50],</span><span class="s3">\n  </span><span class="s1">linen: [250, 240, 230],</span><span class="s3">\n  </span><span class="s1">magenta: [255, 0, 255],</span><span class="s3">\n  </span><span class="s1">maroon: [128, 0, 0],</span><span class="s3">\n  </span><span class="s1">mediumaquamarine: [102, 205, 170],</span><span class="s3">\n  </span><span class="s1">mediumblue: [0, 0, 205],</span><span class="s3">\n  </span><span class="s1">mediumorchid: [186, 85, 211],</span><span class="s3">\n  </span><span class="s1">mediumpurple: [147, 112, 219],</span><span class="s3">\n  </span><span class="s1">mediumseagreen: [60, 179, 113],</span><span class="s3">\n  </span><span class="s1">mediumslateblue: [123, 104, 238],</span><span class="s3">\n  </span><span class="s1">mediumspringgreen: [0, 250, 154],</span><span class="s3">\n  </span><span class="s1">mediumturquoise: [72, 209, 204],</span><span class="s3">\n  </span><span class="s1">mediumvioletred: [199, 21, 133],</span><span class="s3">\n  </span><span class="s1">midnightblue: [25, 25, 112],</span><span class="s3">\n  </span><span class="s1">mintcream: [245, 255, 250],</span><span class="s3">\n  </span><span class="s1">mistyrose: [255, 228, 225],</span><span class="s3">\n  </span><span class="s1">moccasin: [255, 228, 181],</span><span class="s3">\n  </span><span class="s1">navajowhite: [255, 222, 173],</span><span class="s3">\n  </span><span class="s1">navy: [0, 0, 128],</span><span class="s3">\n  </span><span class="s1">oldlace: [253, 245, 230],</span><span class="s3">\n  </span><span class="s1">olive: [128, 128, 0],</span><span class="s3">\n  </span><span class="s1">olivedrab: [107, 142, 35],</span><span class="s3">\n  </span><span class="s1">orange: [255, 165, 0],</span><span class="s3">\n  </span><span class="s1">orangered: [255, 69, 0],</span><span class="s3">\n  </span><span class="s1">orchid: [218, 112, 214],</span><span class="s3">\n  </span><span class="s1">palegoldenrod: [238, 232, 170],</span><span class="s3">\n  </span><span class="s1">palegreen: [152, 251, 152],</span><span class="s3">\n  </span><span class="s1">paleturquoise: [175, 238, 238],</span><span class="s3">\n  </span><span class="s1">palevioletred: [219, 112, 147],</span><span class="s3">\n  </span><span class="s1">papayawhip: [255, 239, 213],</span><span class="s3">\n  </span><span class="s1">peachpuff: [255, 218, 185],</span><span class="s3">\n  </span><span class="s1">peru: [205, 133, 63],</span><span class="s3">\n  </span><span class="s1">pink: [255, 192, 203],</span><span class="s3">\n  </span><span class="s1">plum: [221, 160, 221],</span><span class="s3">\n  </span><span class="s1">powderblue: [176, 224, 230],</span><span class="s3">\n  </span><span class="s1">purple: [128, 0, 128],</span><span class="s3">\n  </span><span class="s1">red: [255, 0, 0],</span><span class="s3">\n  </span><span class="s1">rosybrown: [188, 143, 143],</span><span class="s3">\n  </span><span class="s1">royalblue: [65, 105, 225],</span><span class="s3">\n  </span><span class="s1">saddlebrown: [139, 69, 19],</span><span class="s3">\n  </span><span class="s1">salmon: [250, 128, 114],</span><span class="s3">\n  </span><span class="s1">sandybrown: [244, 164, 96],</span><span class="s3">\n  </span><span class="s1">seagreen: [46, 139, 87],</span><span class="s3">\n  </span><span class="s1">seashell: [255, 245, 238],</span><span class="s3">\n  </span><span class="s1">sienna: [160, 82, 45],</span><span class="s3">\n  </span><span class="s1">silver: [192, 192, 192],</span><span class="s3">\n  </span><span class="s1">skyblue: [135, 206, 235],</span><span class="s3">\n  </span><span class="s1">slateblue: [106, 90, 205],</span><span class="s3">\n  </span><span class="s1">slategray: [112, 128, 144],</span><span class="s3">\n  </span><span class="s1">slategrey: [112, 128, 144],</span><span class="s3">\n  </span><span class="s1">snow: [255, 250, 250],</span><span class="s3">\n  </span><span class="s1">springgreen: [0, 255, 127],</span><span class="s3">\n  </span><span class="s1">steelblue: [70, 130, 180],</span><span class="s3">\n  </span><span class="s1">tan: [210, 180, 140],</span><span class="s3">\n  </span><span class="s1">teal: [0, 128, 128],</span><span class="s3">\n  </span><span class="s1">thistle: [216, 191, 216],</span><span class="s3">\n  </span><span class="s1">tomato: [255, 99, 71],</span><span class="s3">\n  </span><span class="s1">turquoise: [64, 224, 208],</span><span class="s3">\n  </span><span class="s1">violet: [238, 130, 238],</span><span class="s3">\n  </span><span class="s1">wheat: [245, 222, 179],</span><span class="s3">\n  </span><span class="s1">white: [255, 255, 255],</span><span class="s3">\n  </span><span class="s1">whitesmoke: [245, 245, 245],</span><span class="s3">\n  </span><span class="s1">yellow: [255, 255, 0],</span><span class="s3">\n  </span><span class="s1">yellowgreen: [154, 205, 50]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// sets the value in a map (map may not be built)</span><span class="s3">\n</span><span class="s1">var setMap = function setMap(options) {</span><span class="s3">\n  </span><span class="s1">var obj = options.map;</span><span class="s3">\n  </span><span class="s1">var keys = options.keys;</span><span class="s3">\n  </span><span class="s1">var l = keys.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; l; i++) {</span><span class="s3">\n    </span><span class="s1">var key = keys[i];</span><span class="s3">\n    </span><span class="s1">if (plainObject(key)) {</span><span class="s3">\n      </span><span class="s1">throw Error('Tried to set map with object key');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (i &lt; keys.length - 1) {</span><span class="s3">\n      </span><span class="s1">// extend the map if necessary</span><span class="s3">\n      </span><span class="s1">if (obj[key] == null) {</span><span class="s3">\n        </span><span class="s1">obj[key] = {};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">obj = obj[key];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// set the value</span><span class="s3">\n      </span><span class="s1">obj[key] = options.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// gets the value in a map even if it's not built in places</span><span class="s3">\n</span><span class="s1">var getMap = function getMap(options) {</span><span class="s3">\n  </span><span class="s1">var obj = options.map;</span><span class="s3">\n  </span><span class="s1">var keys = options.keys;</span><span class="s3">\n  </span><span class="s1">var l = keys.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; l; i++) {</span><span class="s3">\n    </span><span class="s1">var key = keys[i];</span><span class="s3">\n    </span><span class="s1">if (plainObject(key)) {</span><span class="s3">\n      </span><span class="s1">throw Error('Tried to get map with object key');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">obj = obj[key];</span><span class="s3">\n    </span><span class="s1">if (obj == null) {</span><span class="s3">\n      </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};</span><span class="s3">\n\n</span><span class="s1">function getDefaultExportFromCjs (x) {</span><span class="s3">\n\t</span><span class="s1">return x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is the</span><span class="s3">\n </span><span class="s1">* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)</span><span class="s3">\n </span><span class="s1">* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an object, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject({});</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject(null);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var isObject_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredIsObject;</span><span class="s3">\n\n</span><span class="s1">function requireIsObject () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredIsObject) return isObject_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredIsObject = 1;</span><span class="s3">\n\t</span><span class="s1">function isObject(value) {</span><span class="s3">\n\t  </span><span class="s1">var type = typeof value;</span><span class="s3">\n\t  </span><span class="s1">return value != null &amp;&amp; (type == 'object' || type == 'function');</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isObject_1 = isObject;</span><span class="s3">\n\t</span><span class="s1">return isObject_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Detect free variable `global` from Node.js. */</span><span class="s3">\n\n</span><span class="s1">var _freeGlobal;</span><span class="s3">\n</span><span class="s1">var hasRequired_freeGlobal;</span><span class="s3">\n\n</span><span class="s1">function require_freeGlobal () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_freeGlobal) return _freeGlobal;</span><span class="s3">\n\t</span><span class="s1">hasRequired_freeGlobal = 1;</span><span class="s3">\n\t</span><span class="s1">var freeGlobal = typeof commonjsGlobal == 'object' &amp;&amp; commonjsGlobal &amp;&amp; commonjsGlobal.Object === Object &amp;&amp; commonjsGlobal;</span><span class="s3">\n\n\t</span><span class="s1">_freeGlobal = freeGlobal;</span><span class="s3">\n\t</span><span class="s1">return _freeGlobal;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _root;</span><span class="s3">\n</span><span class="s1">var hasRequired_root;</span><span class="s3">\n\n</span><span class="s1">function require_root () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_root) return _root;</span><span class="s3">\n\t</span><span class="s1">hasRequired_root = 1;</span><span class="s3">\n\t</span><span class="s1">var freeGlobal = require_freeGlobal();</span><span class="s3">\n\n\t</span><span class="s1">/** Detect free variable `self`. */</span><span class="s3">\n\t</span><span class="s1">var freeSelf = typeof self == 'object' &amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self;</span><span class="s3">\n\n\t</span><span class="s1">/** Used as a reference to the global object. */</span><span class="s3">\n\t</span><span class="s1">var root = freeGlobal || freeSelf || Function('return this')();</span><span class="s3">\n\n\t</span><span class="s1">_root = root;</span><span class="s3">\n\t</span><span class="s1">return _root;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var now_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredNow;</span><span class="s3">\n\n</span><span class="s1">function requireNow () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredNow) return now_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredNow = 1;</span><span class="s3">\n\t</span><span class="s1">var root = require_root();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the timestamp of the number of milliseconds that have elapsed since</span><span class="s3">\n\t </span><span class="s1">* the Unix epoch (1 January 1970 00:00:00 UTC).</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 2.4.0</span><span class="s3">\n\t </span><span class="s1">* @category Date</span><span class="s3">\n\t </span><span class="s1">* @returns {number} Returns the timestamp.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.defer(function(stamp) {</span><span class="s3">\n\t </span><span class="s1">*   console.log(_.now() - stamp);</span><span class="s3">\n\t </span><span class="s1">* }, _.now());</span><span class="s3">\n\t </span><span class="s1">* // =&gt; Logs the number of milliseconds it took for the deferred invocation.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">var now = function() {</span><span class="s3">\n\t  </span><span class="s1">return root.Date.now();</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\n\t</span><span class="s1">now_1 = now;</span><span class="s3">\n\t</span><span class="s1">return now_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Used to match a single whitespace character. */</span><span class="s3">\n\n</span><span class="s1">var _trimmedEndIndex;</span><span class="s3">\n</span><span class="s1">var hasRequired_trimmedEndIndex;</span><span class="s3">\n\n</span><span class="s1">function require_trimmedEndIndex () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;</span><span class="s3">\n\t</span><span class="s1">hasRequired_trimmedEndIndex = 1;</span><span class="s3">\n\t</span><span class="s1">var reWhitespace = /</span><span class="s3">\\</span><span class="s1">s/;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace</span><span class="s3">\n\t </span><span class="s1">* character of `string`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {string} string The string to inspect.</span><span class="s3">\n\t </span><span class="s1">* @returns {number} Returns the index of the last non-whitespace character.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function trimmedEndIndex(string) {</span><span class="s3">\n\t  </span><span class="s1">var index = string.length;</span><span class="s3">\n\n\t  </span><span class="s1">while (index-- &amp;&amp; reWhitespace.test(string.charAt(index))) {}</span><span class="s3">\n\t  </span><span class="s1">return index;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_trimmedEndIndex = trimmedEndIndex;</span><span class="s3">\n\t</span><span class="s1">return _trimmedEndIndex;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseTrim;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseTrim;</span><span class="s3">\n\n</span><span class="s1">function require_baseTrim () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseTrim) return _baseTrim;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseTrim = 1;</span><span class="s3">\n\t</span><span class="s1">var trimmedEndIndex = require_trimmedEndIndex();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to match leading whitespace. */</span><span class="s3">\n\t</span><span class="s1">var reTrimStart = /^</span><span class="s3">\\</span><span class="s1">s+/;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `_.trim`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {string} string The string to trim.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the trimmed string.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseTrim(string) {</span><span class="s3">\n\t  </span><span class="s1">return string</span><span class="s3">\n\t    </span><span class="s1">? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')</span><span class="s3">\n\t    </span><span class="s1">: string;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseTrim = baseTrim;</span><span class="s3">\n\t</span><span class="s1">return _baseTrim;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _Symbol;</span><span class="s3">\n</span><span class="s1">var hasRequired_Symbol;</span><span class="s3">\n\n</span><span class="s1">function require_Symbol () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_Symbol) return _Symbol;</span><span class="s3">\n\t</span><span class="s1">hasRequired_Symbol = 1;</span><span class="s3">\n\t</span><span class="s1">var root = require_root();</span><span class="s3">\n\n\t</span><span class="s1">/** Built-in value references. */</span><span class="s3">\n\t</span><span class="s1">var Symbol = root.Symbol;</span><span class="s3">\n\n\t</span><span class="s1">_Symbol = Symbol;</span><span class="s3">\n\t</span><span class="s1">return _Symbol;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _getRawTag;</span><span class="s3">\n</span><span class="s1">var hasRequired_getRawTag;</span><span class="s3">\n\n</span><span class="s1">function require_getRawTag () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_getRawTag) return _getRawTag;</span><span class="s3">\n\t</span><span class="s1">hasRequired_getRawTag = 1;</span><span class="s3">\n\t</span><span class="s1">var Symbol = require_Symbol();</span><span class="s3">\n\n\t</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\t</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n\t</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Used to resolve the</span><span class="s3">\n\t </span><span class="s1">* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)</span><span class="s3">\n\t </span><span class="s1">* of values.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">var nativeObjectToString = objectProto.toString;</span><span class="s3">\n\n\t</span><span class="s1">/** Built-in value references. */</span><span class="s3">\n\t</span><span class="s1">var symToStringTag = Symbol ? Symbol.toStringTag : undefined;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to query.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the raw `toStringTag`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function getRawTag(value) {</span><span class="s3">\n\t  </span><span class="s1">var isOwn = hasOwnProperty.call(value, symToStringTag),</span><span class="s3">\n\t      </span><span class="s1">tag = value[symToStringTag];</span><span class="s3">\n\n\t  </span><span class="s1">try {</span><span class="s3">\n\t    </span><span class="s1">value[symToStringTag] = undefined;</span><span class="s3">\n\t    </span><span class="s1">var unmasked = true;</span><span class="s3">\n\t  </span><span class="s1">} catch (e) {}</span><span class="s3">\n\n\t  </span><span class="s1">var result = nativeObjectToString.call(value);</span><span class="s3">\n\t  </span><span class="s1">if (unmasked) {</span><span class="s3">\n\t    </span><span class="s1">if (isOwn) {</span><span class="s3">\n\t      </span><span class="s1">value[symToStringTag] = tag;</span><span class="s3">\n\t    </span><span class="s1">} else {</span><span class="s3">\n\t      </span><span class="s1">delete value[symToStringTag];</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_getRawTag = getRawTag;</span><span class="s3">\n\t</span><span class="s1">return _getRawTag;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\n</span><span class="s1">var _objectToString;</span><span class="s3">\n</span><span class="s1">var hasRequired_objectToString;</span><span class="s3">\n\n</span><span class="s1">function require_objectToString () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_objectToString) return _objectToString;</span><span class="s3">\n\t</span><span class="s1">hasRequired_objectToString = 1;</span><span class="s3">\n\t</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Used to resolve the</span><span class="s3">\n\t </span><span class="s1">* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)</span><span class="s3">\n\t </span><span class="s1">* of values.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">var nativeObjectToString = objectProto.toString;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `value` to a string using `Object.prototype.toString`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the converted string.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function objectToString(value) {</span><span class="s3">\n\t  </span><span class="s1">return nativeObjectToString.call(value);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_objectToString = objectToString;</span><span class="s3">\n\t</span><span class="s1">return _objectToString;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseGetTag;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseGetTag;</span><span class="s3">\n\n</span><span class="s1">function require_baseGetTag () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseGetTag) return _baseGetTag;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseGetTag = 1;</span><span class="s3">\n\t</span><span class="s1">var Symbol = require_Symbol(),</span><span class="s3">\n\t    </span><span class="s1">getRawTag = require_getRawTag(),</span><span class="s3">\n\t    </span><span class="s1">objectToString = require_objectToString();</span><span class="s3">\n\n\t</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n\t</span><span class="s1">var nullTag = '[object Null]',</span><span class="s3">\n\t    </span><span class="s1">undefinedTag = '[object Undefined]';</span><span class="s3">\n\n\t</span><span class="s1">/** Built-in value references. */</span><span class="s3">\n\t</span><span class="s1">var symToStringTag = Symbol ? Symbol.toStringTag : undefined;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `getTag` without fallbacks for buggy environments.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to query.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the `toStringTag`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseGetTag(value) {</span><span class="s3">\n\t  </span><span class="s1">if (value == null) {</span><span class="s3">\n\t    </span><span class="s1">return value === undefined ? undefinedTag : nullTag;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return (symToStringTag &amp;&amp; symToStringTag in Object(value))</span><span class="s3">\n\t    </span><span class="s1">? getRawTag(value)</span><span class="s3">\n\t    </span><span class="s1">: objectToString(value);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseGetTag = baseGetTag;</span><span class="s3">\n\t</span><span class="s1">return _baseGetTag;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is object-like. A value is object-like if it's not `null`</span><span class="s3">\n </span><span class="s1">* and has a `typeof` result of </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is object-like, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike({});</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike(null);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var isObjectLike_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredIsObjectLike;</span><span class="s3">\n\n</span><span class="s1">function requireIsObjectLike () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredIsObjectLike) return isObjectLike_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredIsObjectLike = 1;</span><span class="s3">\n\t</span><span class="s1">function isObjectLike(value) {</span><span class="s3">\n\t  </span><span class="s1">return value != null &amp;&amp; typeof value == 'object';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isObjectLike_1 = isObjectLike;</span><span class="s3">\n\t</span><span class="s1">return isObjectLike_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var isSymbol_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredIsSymbol;</span><span class="s3">\n\n</span><span class="s1">function requireIsSymbol () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredIsSymbol) return isSymbol_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredIsSymbol = 1;</span><span class="s3">\n\t</span><span class="s1">var baseGetTag = require_baseGetTag(),</span><span class="s3">\n\t    </span><span class="s1">isObjectLike = requireIsObjectLike();</span><span class="s3">\n\n\t</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n\t</span><span class="s1">var symbolTag = '[object Symbol]';</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if `value` is classified as a `Symbol` primitive or object.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 4.0.0</span><span class="s3">\n\t </span><span class="s1">* @category Lang</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.isSymbol(Symbol.iterator);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; true</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.isSymbol('abc');</span><span class="s3">\n\t </span><span class="s1">* // =&gt; false</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function isSymbol(value) {</span><span class="s3">\n\t  </span><span class="s1">return typeof value == 'symbol' ||</span><span class="s3">\n\t    </span><span class="s1">(isObjectLike(value) &amp;&amp; baseGetTag(value) == symbolTag);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isSymbol_1 = isSymbol;</span><span class="s3">\n\t</span><span class="s1">return isSymbol_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var toNumber_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredToNumber;</span><span class="s3">\n\n</span><span class="s1">function requireToNumber () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredToNumber) return toNumber_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredToNumber = 1;</span><span class="s3">\n\t</span><span class="s1">var baseTrim = require_baseTrim(),</span><span class="s3">\n\t    </span><span class="s1">isObject = requireIsObject(),</span><span class="s3">\n\t    </span><span class="s1">isSymbol = requireIsSymbol();</span><span class="s3">\n\n\t</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n\t</span><span class="s1">var NAN = 0 / 0;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect bad signed hexadecimal string values. */</span><span class="s3">\n\t</span><span class="s1">var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect binary string values. */</span><span class="s3">\n\t</span><span class="s1">var reIsBinary = /^0b[01]+$/i;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect octal string values. */</span><span class="s3">\n\t</span><span class="s1">var reIsOctal = /^0o[0-7]+$/i;</span><span class="s3">\n\n\t</span><span class="s1">/** Built-in method references without a dependency on `root`. */</span><span class="s3">\n\t</span><span class="s1">var freeParseInt = parseInt;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `value` to a number.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 4.0.0</span><span class="s3">\n\t </span><span class="s1">* @category Lang</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to process.</span><span class="s3">\n\t </span><span class="s1">* @returns {number} Returns the number.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toNumber(3.2);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toNumber(Number.MIN_VALUE);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toNumber(Infinity);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; Infinity</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toNumber('3.2');</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toNumber(value) {</span><span class="s3">\n\t  </span><span class="s1">if (typeof value == 'number') {</span><span class="s3">\n\t    </span><span class="s1">return value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (isSymbol(value)) {</span><span class="s3">\n\t    </span><span class="s1">return NAN;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (isObject(value)) {</span><span class="s3">\n\t    </span><span class="s1">var other = typeof value.valueOf == 'function' ? value.valueOf() : value;</span><span class="s3">\n\t    </span><span class="s1">value = isObject(other) ? (other + '') : other;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (typeof value != 'string') {</span><span class="s3">\n\t    </span><span class="s1">return value === 0 ? value : +value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">value = baseTrim(value);</span><span class="s3">\n\t  </span><span class="s1">var isBinary = reIsBinary.test(value);</span><span class="s3">\n\t  </span><span class="s1">return (isBinary || reIsOctal.test(value))</span><span class="s3">\n\t    </span><span class="s1">? freeParseInt(value.slice(2), isBinary ? 2 : 8)</span><span class="s3">\n\t    </span><span class="s1">: (reIsBadHex.test(value) ? NAN : +value);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toNumber_1 = toNumber;</span><span class="s3">\n\t</span><span class="s1">return toNumber_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var debounce_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredDebounce;</span><span class="s3">\n\n</span><span class="s1">function requireDebounce () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredDebounce) return debounce_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredDebounce = 1;</span><span class="s3">\n\t</span><span class="s1">var isObject = requireIsObject(),</span><span class="s3">\n\t    </span><span class="s1">now = requireNow(),</span><span class="s3">\n\t    </span><span class="s1">toNumber = requireToNumber();</span><span class="s3">\n\n\t</span><span class="s1">/** Error message constants. */</span><span class="s3">\n\t</span><span class="s1">var FUNC_ERROR_TEXT = 'Expected a function';</span><span class="s3">\n\n\t</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n\t</span><span class="s1">var nativeMax = Math.max,</span><span class="s3">\n\t    </span><span class="s1">nativeMin = Math.min;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates a debounced function that delays invoking `func` until after `wait`</span><span class="s3">\n\t </span><span class="s1">* milliseconds have elapsed since the last time the debounced function was</span><span class="s3">\n\t </span><span class="s1">* invoked. The debounced function comes with a `cancel` method to cancel</span><span class="s3">\n\t </span><span class="s1">* delayed `func` invocations and a `flush` method to immediately invoke them.</span><span class="s3">\n\t </span><span class="s1">* Provide `options` to indicate whether `func` should be invoked on the</span><span class="s3">\n\t </span><span class="s1">* leading and/or trailing edge of the `wait` timeout. The `func` is invoked</span><span class="s3">\n\t </span><span class="s1">* with the last arguments provided to the debounced function. Subsequent</span><span class="s3">\n\t </span><span class="s1">* calls to the debounced function return the result of the last `func`</span><span class="s3">\n\t </span><span class="s1">* invocation.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* **Note:** If `leading` and `trailing` options are `true`, `func` is</span><span class="s3">\n\t </span><span class="s1">* invoked on the trailing edge of the timeout only if the debounced function</span><span class="s3">\n\t </span><span class="s1">* is invoked more than once during the `wait` timeout.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span><span class="s3">\n\t </span><span class="s1">* until to the next tick, similar to `setTimeout` with a timeout of `0`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span><span class="s3">\n\t </span><span class="s1">* for details over the differences between `_.debounce` and `_.throttle`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 0.1.0</span><span class="s3">\n\t </span><span class="s1">* @category Function</span><span class="s3">\n\t </span><span class="s1">* @param {Function} func The function to debounce.</span><span class="s3">\n\t </span><span class="s1">* @param {number} [wait=0] The number of milliseconds to delay.</span><span class="s3">\n\t </span><span class="s1">* @param {Object} [options={}] The options object.</span><span class="s3">\n\t </span><span class="s1">* @param {boolean} [options.leading=false]</span><span class="s3">\n\t </span><span class="s1">*  Specify invoking on the leading edge of the timeout.</span><span class="s3">\n\t </span><span class="s1">* @param {number} [options.maxWait]</span><span class="s3">\n\t </span><span class="s1">*  The maximum time `func` is allowed to be delayed before it's invoked.</span><span class="s3">\n\t </span><span class="s1">* @param {boolean} [options.trailing=true]</span><span class="s3">\n\t </span><span class="s1">*  Specify invoking on the trailing edge of the timeout.</span><span class="s3">\n\t </span><span class="s1">* @returns {Function} Returns the new debounced function.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* // Avoid costly calculations while the window size is in flux.</span><span class="s3">\n\t </span><span class="s1">* jQuery(window).on('resize', _.debounce(calculateLayout, 150));</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* // Invoke `sendMail` when clicked, debouncing subsequent calls.</span><span class="s3">\n\t </span><span class="s1">* jQuery(element).on('click', _.debounce(sendMail, 300, {</span><span class="s3">\n\t </span><span class="s1">*   'leading': true,</span><span class="s3">\n\t </span><span class="s1">*   'trailing': false</span><span class="s3">\n\t </span><span class="s1">* }));</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span><span class="s3">\n\t </span><span class="s1">* var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });</span><span class="s3">\n\t </span><span class="s1">* var source = new EventSource('/stream');</span><span class="s3">\n\t </span><span class="s1">* jQuery(source).on('message', debounced);</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* // Cancel the trailing debounced invocation.</span><span class="s3">\n\t </span><span class="s1">* jQuery(window).on('popstate', debounced.cancel);</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function debounce(func, wait, options) {</span><span class="s3">\n\t  </span><span class="s1">var lastArgs,</span><span class="s3">\n\t      </span><span class="s1">lastThis,</span><span class="s3">\n\t      </span><span class="s1">maxWait,</span><span class="s3">\n\t      </span><span class="s1">result,</span><span class="s3">\n\t      </span><span class="s1">timerId,</span><span class="s3">\n\t      </span><span class="s1">lastCallTime,</span><span class="s3">\n\t      </span><span class="s1">lastInvokeTime = 0,</span><span class="s3">\n\t      </span><span class="s1">leading = false,</span><span class="s3">\n\t      </span><span class="s1">maxing = false,</span><span class="s3">\n\t      </span><span class="s1">trailing = true;</span><span class="s3">\n\n\t  </span><span class="s1">if (typeof func != 'function') {</span><span class="s3">\n\t    </span><span class="s1">throw new TypeError(FUNC_ERROR_TEXT);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">wait = toNumber(wait) || 0;</span><span class="s3">\n\t  </span><span class="s1">if (isObject(options)) {</span><span class="s3">\n\t    </span><span class="s1">leading = !!options.leading;</span><span class="s3">\n\t    </span><span class="s1">maxing = 'maxWait' in options;</span><span class="s3">\n\t    </span><span class="s1">maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;</span><span class="s3">\n\t    </span><span class="s1">trailing = 'trailing' in options ? !!options.trailing : trailing;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function invokeFunc(time) {</span><span class="s3">\n\t    </span><span class="s1">var args = lastArgs,</span><span class="s3">\n\t        </span><span class="s1">thisArg = lastThis;</span><span class="s3">\n\n\t    </span><span class="s1">lastArgs = lastThis = undefined;</span><span class="s3">\n\t    </span><span class="s1">lastInvokeTime = time;</span><span class="s3">\n\t    </span><span class="s1">result = func.apply(thisArg, args);</span><span class="s3">\n\t    </span><span class="s1">return result;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function leadingEdge(time) {</span><span class="s3">\n\t    </span><span class="s1">// Reset any `maxWait` timer.</span><span class="s3">\n\t    </span><span class="s1">lastInvokeTime = time;</span><span class="s3">\n\t    </span><span class="s1">// Start the timer for the trailing edge.</span><span class="s3">\n\t    </span><span class="s1">timerId = setTimeout(timerExpired, wait);</span><span class="s3">\n\t    </span><span class="s1">// Invoke the leading edge.</span><span class="s3">\n\t    </span><span class="s1">return leading ? invokeFunc(time) : result;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function remainingWait(time) {</span><span class="s3">\n\t    </span><span class="s1">var timeSinceLastCall = time - lastCallTime,</span><span class="s3">\n\t        </span><span class="s1">timeSinceLastInvoke = time - lastInvokeTime,</span><span class="s3">\n\t        </span><span class="s1">timeWaiting = wait - timeSinceLastCall;</span><span class="s3">\n\n\t    </span><span class="s1">return maxing</span><span class="s3">\n\t      </span><span class="s1">? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)</span><span class="s3">\n\t      </span><span class="s1">: timeWaiting;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function shouldInvoke(time) {</span><span class="s3">\n\t    </span><span class="s1">var timeSinceLastCall = time - lastCallTime,</span><span class="s3">\n\t        </span><span class="s1">timeSinceLastInvoke = time - lastInvokeTime;</span><span class="s3">\n\n\t    </span><span class="s1">// Either this is the first call, activity has stopped and we're at the</span><span class="s3">\n\t    </span><span class="s1">// trailing edge, the system time has gone backwards and we're treating</span><span class="s3">\n\t    </span><span class="s1">// it as the trailing edge, or we've hit the `maxWait` limit.</span><span class="s3">\n\t    </span><span class="s1">return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) ||</span><span class="s3">\n\t      </span><span class="s1">(timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function timerExpired() {</span><span class="s3">\n\t    </span><span class="s1">var time = now();</span><span class="s3">\n\t    </span><span class="s1">if (shouldInvoke(time)) {</span><span class="s3">\n\t      </span><span class="s1">return trailingEdge(time);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">// Restart the timer.</span><span class="s3">\n\t    </span><span class="s1">timerId = setTimeout(timerExpired, remainingWait(time));</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function trailingEdge(time) {</span><span class="s3">\n\t    </span><span class="s1">timerId = undefined;</span><span class="s3">\n\n\t    </span><span class="s1">// Only invoke if we have `lastArgs` which means `func` has been</span><span class="s3">\n\t    </span><span class="s1">// debounced at least once.</span><span class="s3">\n\t    </span><span class="s1">if (trailing &amp;&amp; lastArgs) {</span><span class="s3">\n\t      </span><span class="s1">return invokeFunc(time);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">lastArgs = lastThis = undefined;</span><span class="s3">\n\t    </span><span class="s1">return result;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function cancel() {</span><span class="s3">\n\t    </span><span class="s1">if (timerId !== undefined) {</span><span class="s3">\n\t      </span><span class="s1">clearTimeout(timerId);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">lastInvokeTime = 0;</span><span class="s3">\n\t    </span><span class="s1">lastArgs = lastCallTime = lastThis = timerId = undefined;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function flush() {</span><span class="s3">\n\t    </span><span class="s1">return timerId === undefined ? result : trailingEdge(now());</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\n\t  </span><span class="s1">function debounced() {</span><span class="s3">\n\t    </span><span class="s1">var time = now(),</span><span class="s3">\n\t        </span><span class="s1">isInvoking = shouldInvoke(time);</span><span class="s3">\n\n\t    </span><span class="s1">lastArgs = arguments;</span><span class="s3">\n\t    </span><span class="s1">lastThis = this;</span><span class="s3">\n\t    </span><span class="s1">lastCallTime = time;</span><span class="s3">\n\n\t    </span><span class="s1">if (isInvoking) {</span><span class="s3">\n\t      </span><span class="s1">if (timerId === undefined) {</span><span class="s3">\n\t        </span><span class="s1">return leadingEdge(lastCallTime);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">if (maxing) {</span><span class="s3">\n\t        </span><span class="s1">// Handle invocations in a tight loop.</span><span class="s3">\n\t        </span><span class="s1">clearTimeout(timerId);</span><span class="s3">\n\t        </span><span class="s1">timerId = setTimeout(timerExpired, wait);</span><span class="s3">\n\t        </span><span class="s1">return invokeFunc(lastCallTime);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">if (timerId === undefined) {</span><span class="s3">\n\t      </span><span class="s1">timerId = setTimeout(timerExpired, wait);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">return result;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">debounced.cancel = cancel;</span><span class="s3">\n\t  </span><span class="s1">debounced.flush = flush;</span><span class="s3">\n\t  </span><span class="s1">return debounced;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">debounce_1 = debounce;</span><span class="s3">\n\t</span><span class="s1">return debounce_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var debounceExports = requireDebounce();</span><span class="s3">\n</span><span class="s1">var debounce = /*@__PURE__*/getDefaultExportFromCjs(debounceExports);</span><span class="s3">\n\n</span><span class="s1">var performance$1 = _window ? _window.performance : null;</span><span class="s3">\n</span><span class="s1">var pnow = performance$1 &amp;&amp; performance$1.now ? function () {</span><span class="s3">\n  </span><span class="s1">return performance$1.now();</span><span class="s3">\n</span><span class="s1">} : function () {</span><span class="s3">\n  </span><span class="s1">return Date.now();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var raf = function () {</span><span class="s3">\n  </span><span class="s1">if (_window) {</span><span class="s3">\n    </span><span class="s1">if (_window.requestAnimationFrame) {</span><span class="s3">\n      </span><span class="s1">return function (fn) {</span><span class="s3">\n        </span><span class="s1">_window.requestAnimationFrame(fn);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else if (_window.mozRequestAnimationFrame) {</span><span class="s3">\n      </span><span class="s1">return function (fn) {</span><span class="s3">\n        </span><span class="s1">_window.mozRequestAnimationFrame(fn);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else if (_window.webkitRequestAnimationFrame) {</span><span class="s3">\n      </span><span class="s1">return function (fn) {</span><span class="s3">\n        </span><span class="s1">_window.webkitRequestAnimationFrame(fn);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else if (_window.msRequestAnimationFrame) {</span><span class="s3">\n      </span><span class="s1">return function (fn) {</span><span class="s3">\n        </span><span class="s1">_window.msRequestAnimationFrame(fn);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function (fn) {</span><span class="s3">\n    </span><span class="s1">if (fn) {</span><span class="s3">\n      </span><span class="s1">setTimeout(function () {</span><span class="s3">\n        </span><span class="s1">fn(pnow());</span><span class="s3">\n      </span><span class="s1">}, 1000 / 60);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">var requestAnimationFrame = function requestAnimationFrame(fn) {</span><span class="s3">\n  </span><span class="s1">return raf(fn);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var performanceNow = pnow;</span><span class="s3">\n\n</span><span class="s1">var DEFAULT_HASH_SEED = 9261;</span><span class="s3">\n</span><span class="s1">var K = 65599; // 37 also works pretty well</span><span class="s3">\n</span><span class="s1">var DEFAULT_HASH_SEED_ALT = 5381;</span><span class="s3">\n</span><span class="s1">var hashIterableInts = function hashIterableInts(iterator) {</span><span class="s3">\n  </span><span class="s1">var seed = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;</span><span class="s3">\n  </span><span class="s1">// sdbm/string-hash</span><span class="s3">\n  </span><span class="s1">var hash = seed;</span><span class="s3">\n  </span><span class="s1">var entry;</span><span class="s3">\n  </span><span class="s1">for (;;) {</span><span class="s3">\n    </span><span class="s1">entry = iterator.next();</span><span class="s3">\n    </span><span class="s1">if (entry.done) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hash = hash * K + entry.value | 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return hash;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashInt = function hashInt(num) {</span><span class="s3">\n  </span><span class="s1">var seed = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;</span><span class="s3">\n  </span><span class="s1">// sdbm/string-hash</span><span class="s3">\n  </span><span class="s1">return seed * K + num | 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashIntAlt = function hashIntAlt(num) {</span><span class="s3">\n  </span><span class="s1">var seed = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;</span><span class="s3">\n  </span><span class="s1">// djb2/string-hash</span><span class="s3">\n  </span><span class="s1">return (seed &lt;&lt; 5) + seed + num | 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var combineHashes = function combineHashes(hash1, hash2) {</span><span class="s3">\n  </span><span class="s1">return hash1 * 0x200000 + hash2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var combineHashesArray = function combineHashesArray(hashes) {</span><span class="s3">\n  </span><span class="s1">return hashes[0] * 0x200000 + hashes[1];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashArrays = function hashArrays(hashes1, hashes2) {</span><span class="s3">\n  </span><span class="s1">return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashIntsArray = function hashIntsArray(ints, seed) {</span><span class="s3">\n  </span><span class="s1">var entry = {</span><span class="s3">\n    </span><span class="s1">value: 0,</span><span class="s3">\n    </span><span class="s1">done: false</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var i = 0;</span><span class="s3">\n  </span><span class="s1">var length = ints.length;</span><span class="s3">\n  </span><span class="s1">var iterator = {</span><span class="s3">\n    </span><span class="s1">next: function next() {</span><span class="s3">\n      </span><span class="s1">if (i &lt; length) {</span><span class="s3">\n        </span><span class="s1">entry.value = ints[i++];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">entry.done = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return entry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return hashIterableInts(iterator, seed);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashString = function hashString(str, seed) {</span><span class="s3">\n  </span><span class="s1">var entry = {</span><span class="s3">\n    </span><span class="s1">value: 0,</span><span class="s3">\n    </span><span class="s1">done: false</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var i = 0;</span><span class="s3">\n  </span><span class="s1">var length = str.length;</span><span class="s3">\n  </span><span class="s1">var iterator = {</span><span class="s3">\n    </span><span class="s1">next: function next() {</span><span class="s3">\n      </span><span class="s1">if (i &lt; length) {</span><span class="s3">\n        </span><span class="s1">entry.value = str.charCodeAt(i++);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">entry.done = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return entry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return hashIterableInts(iterator, seed);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashStrings = function hashStrings() {</span><span class="s3">\n  </span><span class="s1">return hashStringsArray(arguments);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hashStringsArray = function hashStringsArray(strs) {</span><span class="s3">\n  </span><span class="s1">var hash;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; strs.length; i++) {</span><span class="s3">\n    </span><span class="s1">var str = strs[i];</span><span class="s3">\n    </span><span class="s1">if (i === 0) {</span><span class="s3">\n      </span><span class="s1">hash = hashString(str);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">hash = hashString(str, hash);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return hash;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var warningsEnabled = true;</span><span class="s3">\n</span><span class="s1">var warnSupported = console.warn != null;</span><span class="s3">\n</span><span class="s1">var traceSupported = console.trace != null;</span><span class="s3">\n</span><span class="s1">var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;</span><span class="s3">\n</span><span class="s1">var trueify = function trueify() {</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var falsify = function falsify() {</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var zeroify = function zeroify() {</span><span class="s3">\n  </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var noop$1 = function noop() {};</span><span class="s3">\n</span><span class="s1">var error = function error(msg) {</span><span class="s3">\n  </span><span class="s1">throw new Error(msg);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var warnings = function warnings(enabled) {</span><span class="s3">\n  </span><span class="s1">if (enabled !== undefined) {</span><span class="s3">\n    </span><span class="s1">warningsEnabled = !!enabled;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return warningsEnabled;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var warn = function warn(msg) {</span><span class="s3">\n  </span><span class="s1">if (!warnings()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (warnSupported) {</span><span class="s3">\n    </span><span class="s1">console.warn(msg);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">console.log(msg);</span><span class="s3">\n    </span><span class="s1">if (traceSupported) {</span><span class="s3">\n      </span><span class="s1">console.trace();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var clone = function clone(obj) {</span><span class="s3">\n  </span><span class="s1">return extend({}, obj);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// gets a shallow copy of the argument</span><span class="s3">\n</span><span class="s1">var copy = function copy(obj) {</span><span class="s3">\n  </span><span class="s1">if (obj == null) {</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (array(obj)) {</span><span class="s3">\n    </span><span class="s1">return obj.slice();</span><span class="s3">\n  </span><span class="s1">} else if (plainObject(obj)) {</span><span class="s3">\n    </span><span class="s1">return clone(obj);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var copyArray = function copyArray(arr) {</span><span class="s3">\n  </span><span class="s1">return arr.slice();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var uuid = function uuid(a, b /* placeholders */) {</span><span class="s3">\n  </span><span class="s1">for (</span><span class="s3">\n  </span><span class="s1">// loop :)</span><span class="s3">\n  </span><span class="s1">b = a = '';</span><span class="s3">\n  </span><span class="s1">// b - result , a - numeric letiable</span><span class="s3">\n  </span><span class="s1">a++ &lt; 36;</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">b += a * 51 &amp; 52 // if </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot; </span><span class="s1">is not 9 or 14 or 19 or 24</span><span class="s3">\n  </span><span class="s1">?</span><span class="s3">\n  </span><span class="s1">//  return a random number or 4</span><span class="s3">\n  </span><span class="s1">(a ^ 15 // if </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot; </span><span class="s1">is not 15</span><span class="s3">\n  </span><span class="s1">?</span><span class="s3">\n  </span><span class="s1">// generate a random number from 0 to 15</span><span class="s3">\n  </span><span class="s1">8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot; </span><span class="s1">is 20, in which case a random number from 8 to 11</span><span class="s3">\n  </span><span class="s1">: 4 //  otherwise 4</span><span class="s3">\n  </span><span class="s1">).toString(16) : '-' //  in other cases (if </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot; </span><span class="s1">is 9,14,19,24) insert </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return b;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var _staticEmptyObject = {};</span><span class="s3">\n</span><span class="s1">var staticEmptyObject = function staticEmptyObject() {</span><span class="s3">\n  </span><span class="s1">return _staticEmptyObject;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var defaults$g = function defaults(_defaults) {</span><span class="s3">\n  </span><span class="s1">var keys = Object.keys(_defaults);</span><span class="s3">\n  </span><span class="s1">return function (opts) {</span><span class="s3">\n    </span><span class="s1">var filledOpts = {};</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s3">\n      </span><span class="s1">var key = keys[i];</span><span class="s3">\n      </span><span class="s1">var optVal = opts == null ? undefined : opts[key];</span><span class="s3">\n      </span><span class="s1">filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return filledOpts;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var removeFromArray = function removeFromArray(arr, ele, oneCopy) {</span><span class="s3">\n  </span><span class="s1">for (var i = arr.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">if (arr[i] === ele) {</span><span class="s3">\n      </span><span class="s1">arr.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var clearArray = function clearArray(arr) {</span><span class="s3">\n  </span><span class="s1">arr.splice(0, arr.length);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var push = function push(arr, otherArr) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; otherArr.length; i++) {</span><span class="s3">\n    </span><span class="s1">var el = otherArr[i];</span><span class="s3">\n    </span><span class="s1">arr.push(el);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {</span><span class="s3">\n  </span><span class="s1">if (prefix) {</span><span class="s3">\n    </span><span class="s1">propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) =&gt; sourceLabelWidth</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return obj[propName];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {</span><span class="s3">\n  </span><span class="s1">if (prefix) {</span><span class="s3">\n    </span><span class="s1">propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) =&gt; sourceLabelWidth</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">obj[propName] = value;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* global Map */</span><span class="s3">\n</span><span class="s1">var ObjectMap = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function ObjectMap() {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, ObjectMap);</span><span class="s3">\n    </span><span class="s1">this._obj = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(ObjectMap, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function set(key, val) {</span><span class="s3">\n      </span><span class="s1">this._obj[key] = val;</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _delete(key) {</span><span class="s3">\n      </span><span class="s1">this._obj[key] = undefined;</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">clear</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function clear() {</span><span class="s3">\n      </span><span class="s1">this._obj = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">has</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function has(key) {</span><span class="s3">\n      </span><span class="s1">return this._obj[key] !== undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function get(key) {</span><span class="s3">\n      </span><span class="s1">return this._obj[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">var Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;</span><span class="s3">\n\n</span><span class="s1">/* global Set */</span><span class="s3">\n\n</span><span class="s1">var undef = </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var ObjectSet = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function ObjectSet(arrayOrObjectSet) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, ObjectSet);</span><span class="s3">\n    </span><span class="s1">this._obj = Object.create(null);</span><span class="s3">\n    </span><span class="s1">this.size = 0;</span><span class="s3">\n    </span><span class="s1">if (arrayOrObjectSet != null) {</span><span class="s3">\n      </span><span class="s1">var arr;</span><span class="s3">\n      </span><span class="s1">if (arrayOrObjectSet.instanceString != null &amp;&amp; arrayOrObjectSet.instanceString() === this.instanceString()) {</span><span class="s3">\n        </span><span class="s1">arr = arrayOrObjectSet.toArray();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">arr = arrayOrObjectSet;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n        </span><span class="s1">this.add(arr[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(ObjectSet, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">instanceString</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function instanceString() {</span><span class="s3">\n      </span><span class="s1">return 'set';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">add</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function add(val) {</span><span class="s3">\n      </span><span class="s1">var o = this._obj;</span><span class="s3">\n      </span><span class="s1">if (o[val] !== 1) {</span><span class="s3">\n        </span><span class="s1">o[val] = 1;</span><span class="s3">\n        </span><span class="s1">this.size++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _delete(val) {</span><span class="s3">\n      </span><span class="s1">var o = this._obj;</span><span class="s3">\n      </span><span class="s1">if (o[val] === 1) {</span><span class="s3">\n        </span><span class="s1">o[val] = 0;</span><span class="s3">\n        </span><span class="s1">this.size--;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">clear</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function clear() {</span><span class="s3">\n      </span><span class="s1">this._obj = Object.create(null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">has</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function has(val) {</span><span class="s3">\n      </span><span class="s1">return this._obj[val] === 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">toArray</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function toArray() {</span><span class="s3">\n      </span><span class="s1">var _this = this;</span><span class="s3">\n      </span><span class="s1">return Object.keys(this._obj).filter(function (key) {</span><span class="s3">\n        </span><span class="s1">return _this.has(key);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">forEach</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function forEach(callback, thisArg) {</span><span class="s3">\n      </span><span class="s1">return this.toArray().forEach(callback, thisArg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">var Set$1 = (typeof Set === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: _typeof(Set)) !== undef ? Set : ObjectSet;</span><span class="s3">\n\n</span><span class="s1">// represents a node or an edge</span><span class="s3">\n</span><span class="s1">var Element = function Element(cy, params) {</span><span class="s3">\n  </span><span class="s1">var restore = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : true;</span><span class="s3">\n  </span><span class="s1">if (cy === undefined || params === undefined || !core(cy)) {</span><span class="s3">\n    </span><span class="s1">error('An element must have a core reference and parameters set');</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var group = params.group;</span><span class="s3">\n\n  </span><span class="s1">// try to automatically infer the group if unspecified</span><span class="s3">\n  </span><span class="s1">if (group == null) {</span><span class="s3">\n    </span><span class="s1">if (params.data &amp;&amp; params.data.source != null &amp;&amp; params.data.target != null) {</span><span class="s3">\n      </span><span class="s1">group = 'edges';</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">group = 'nodes';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// validate group</span><span class="s3">\n  </span><span class="s1">if (group !== 'nodes' &amp;&amp; group !== 'edges') {</span><span class="s3">\n    </span><span class="s1">error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// make the element array-like, just like a collection</span><span class="s3">\n  </span><span class="s1">this.length = 1;</span><span class="s3">\n  </span><span class="s1">this[0] = this;</span><span class="s3">\n\n  </span><span class="s1">// NOTE: when something is added here, add also to ele.json()</span><span class="s3">\n  </span><span class="s1">var _p = this._private = {</span><span class="s3">\n    </span><span class="s1">cy: cy,</span><span class="s3">\n    </span><span class="s1">single: true,</span><span class="s3">\n    </span><span class="s1">// indicates this is an element</span><span class="s3">\n    </span><span class="s1">data: params.data || {},</span><span class="s3">\n    </span><span class="s1">// data object</span><span class="s3">\n    </span><span class="s1">position: params.position || {</span><span class="s3">\n      </span><span class="s1">x: 0,</span><span class="s3">\n      </span><span class="s1">y: 0</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// (x, y) position pair</span><span class="s3">\n    </span><span class="s1">autoWidth: undefined,</span><span class="s3">\n    </span><span class="s1">// width and height of nodes calculated by the renderer when set to special 'auto' value</span><span class="s3">\n    </span><span class="s1">autoHeight: undefined,</span><span class="s3">\n    </span><span class="s1">autoPadding: undefined,</span><span class="s3">\n    </span><span class="s1">compoundBoundsClean: false,</span><span class="s3">\n    </span><span class="s1">// whether the compound dimensions need to be recalculated the next time dimensions are read</span><span class="s3">\n    </span><span class="s1">listeners: [],</span><span class="s3">\n    </span><span class="s1">// array of bound listeners</span><span class="s3">\n    </span><span class="s1">group: group,</span><span class="s3">\n    </span><span class="s1">// string; 'nodes' or 'edges'</span><span class="s3">\n    </span><span class="s1">style: {},</span><span class="s3">\n    </span><span class="s1">// properties as set by the style</span><span class="s3">\n    </span><span class="s1">rstyle: {},</span><span class="s3">\n    </span><span class="s1">// properties for style sent from the renderer to the core</span><span class="s3">\n    </span><span class="s1">styleCxts: [],</span><span class="s3">\n    </span><span class="s1">// applied style contexts from the styler</span><span class="s3">\n    </span><span class="s1">styleKeys: {},</span><span class="s3">\n    </span><span class="s1">// per-group keys of style property values</span><span class="s3">\n    </span><span class="s1">removed: true,</span><span class="s3">\n    </span><span class="s1">// whether it's inside the vis; true if removed (set true here since we call restore)</span><span class="s3">\n    </span><span class="s1">selected: params.selected ? true : false,</span><span class="s3">\n    </span><span class="s1">// whether it's selected</span><span class="s3">\n    </span><span class="s1">selectable: params.selectable === undefined ? true : params.selectable ? true : false,</span><span class="s3">\n    </span><span class="s1">// whether it's selectable</span><span class="s3">\n    </span><span class="s1">locked: params.locked ? true : false,</span><span class="s3">\n    </span><span class="s1">// whether the element is locked (cannot be moved)</span><span class="s3">\n    </span><span class="s1">grabbed: false,</span><span class="s3">\n    </span><span class="s1">// whether the element is grabbed by the mouse; renderer sets this privately</span><span class="s3">\n    </span><span class="s1">grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,</span><span class="s3">\n    </span><span class="s1">// whether the element can be grabbed</span><span class="s3">\n    </span><span class="s1">pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,</span><span class="s3">\n    </span><span class="s1">// whether the element has passthrough panning enabled</span><span class="s3">\n    </span><span class="s1">active: false,</span><span class="s3">\n    </span><span class="s1">// whether the element is active from user interaction</span><span class="s3">\n    </span><span class="s1">classes: new Set$1(),</span><span class="s3">\n    </span><span class="s1">// map ( className =&gt; true )</span><span class="s3">\n    </span><span class="s1">animation: {</span><span class="s3">\n      </span><span class="s1">// object for currently-running animations</span><span class="s3">\n      </span><span class="s1">current: [],</span><span class="s3">\n      </span><span class="s1">queue: []</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">rscratch: {},</span><span class="s3">\n    </span><span class="s1">// object in which the renderer can store information</span><span class="s3">\n    </span><span class="s1">scratch: params.scratch || {},</span><span class="s3">\n    </span><span class="s1">// scratch objects</span><span class="s3">\n    </span><span class="s1">edges: [],</span><span class="s3">\n    </span><span class="s1">// array of connected edges</span><span class="s3">\n    </span><span class="s1">children: [],</span><span class="s3">\n    </span><span class="s1">// array of children</span><span class="s3">\n    </span><span class="s1">parent: params.parent &amp;&amp; params.parent.isNode() ? params.parent : null,</span><span class="s3">\n    </span><span class="s1">// parent ref</span><span class="s3">\n    </span><span class="s1">traversalCache: {},</span><span class="s3">\n    </span><span class="s1">// cache of output of traversal functions</span><span class="s3">\n    </span><span class="s1">backgrounding: false,</span><span class="s3">\n    </span><span class="s1">// whether background images are loading</span><span class="s3">\n    </span><span class="s1">bbCache: null,</span><span class="s3">\n    </span><span class="s1">// cache of the current bounding box</span><span class="s3">\n    </span><span class="s1">bbCacheShift: {</span><span class="s3">\n      </span><span class="s1">x: 0,</span><span class="s3">\n      </span><span class="s1">y: 0</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// shift applied to cached bb to be applied on next get</span><span class="s3">\n    </span><span class="s1">bodyBounds: null,</span><span class="s3">\n    </span><span class="s1">// bounds cache of element body, w/o overlay</span><span class="s3">\n    </span><span class="s1">overlayBounds: null,</span><span class="s3">\n    </span><span class="s1">// bounds cache of element body, including overlay</span><span class="s3">\n    </span><span class="s1">labelBounds: {</span><span class="s3">\n      </span><span class="s1">// bounds cache of labels</span><span class="s3">\n      </span><span class="s1">all: null,</span><span class="s3">\n      </span><span class="s1">source: null,</span><span class="s3">\n      </span><span class="s1">target: null,</span><span class="s3">\n      </span><span class="s1">main: null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">arrowBounds: {</span><span class="s3">\n      </span><span class="s1">// bounds cache of edge arrows</span><span class="s3">\n      </span><span class="s1">source: null,</span><span class="s3">\n      </span><span class="s1">target: null,</span><span class="s3">\n      </span><span class="s1">'mid-source': null,</span><span class="s3">\n      </span><span class="s1">'mid-target': null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (_p.position.x == null) {</span><span class="s3">\n    </span><span class="s1">_p.position.x = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (_p.position.y == null) {</span><span class="s3">\n    </span><span class="s1">_p.position.y = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// renderedPosition overrides if specified</span><span class="s3">\n  </span><span class="s1">if (params.renderedPosition) {</span><span class="s3">\n    </span><span class="s1">var rpos = params.renderedPosition;</span><span class="s3">\n    </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">_p.position = {</span><span class="s3">\n      </span><span class="s1">x: (rpos.x - pan.x) / zoom,</span><span class="s3">\n      </span><span class="s1">y: (rpos.y - pan.y) / zoom</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var classes = [];</span><span class="s3">\n  </span><span class="s1">if (array(params.classes)) {</span><span class="s3">\n    </span><span class="s1">classes = params.classes;</span><span class="s3">\n  </span><span class="s1">} else if (string(params.classes)) {</span><span class="s3">\n    </span><span class="s1">classes = params.classes.split(/</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0, l = classes.length; i &lt; l; i++) {</span><span class="s3">\n    </span><span class="s1">var cls = classes[i];</span><span class="s3">\n    </span><span class="s1">if (!cls || cls === '') {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.classes.add(cls);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.createEmitter();</span><span class="s3">\n  </span><span class="s1">if (restore === undefined || restore) {</span><span class="s3">\n    </span><span class="s1">this.restore();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var bypass = params.style || params.css;</span><span class="s3">\n  </span><span class="s1">if (bypass) {</span><span class="s3">\n    </span><span class="s1">warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');</span><span class="s3">\n    </span><span class="s1">this.style(bypass);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defineSearch = function defineSearch(params) {</span><span class="s3">\n  </span><span class="s1">params = {</span><span class="s3">\n    </span><span class="s1">bfs: params.bfs || !params.dfs,</span><span class="s3">\n    </span><span class="s1">dfs: params.dfs || !params.bfs</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// from pseudocode on wikipedia</span><span class="s3">\n  </span><span class="s1">return function searchFn(roots, fn, directed) {</span><span class="s3">\n    </span><span class="s1">var options;</span><span class="s3">\n    </span><span class="s1">if (plainObject(roots) &amp;&amp; !elementOrCollection(roots)) {</span><span class="s3">\n      </span><span class="s1">options = roots;</span><span class="s3">\n      </span><span class="s1">roots = options.roots || options.root;</span><span class="s3">\n      </span><span class="s1">fn = options.visit;</span><span class="s3">\n      </span><span class="s1">directed = options.directed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">directed = arguments.length === 2 &amp;&amp; !fn$6(fn) ? fn : directed;</span><span class="s3">\n    </span><span class="s1">fn = fn$6(fn) ? fn : function () {};</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">var v = roots = string(roots) ? this.filter(roots) : roots;</span><span class="s3">\n    </span><span class="s1">var Q = [];</span><span class="s3">\n    </span><span class="s1">var connectedNodes = [];</span><span class="s3">\n    </span><span class="s1">var connectedBy = {};</span><span class="s3">\n    </span><span class="s1">var id2depth = {};</span><span class="s3">\n    </span><span class="s1">var V = {};</span><span class="s3">\n    </span><span class="s1">var j = 0;</span><span class="s3">\n    </span><span class="s1">var found;</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes,</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges;</span><span class="s3">\n\n    </span><span class="s1">// enqueue v</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; v.length; i++) {</span><span class="s3">\n      </span><span class="s1">var vi = v[i];</span><span class="s3">\n      </span><span class="s1">var viId = vi.id();</span><span class="s3">\n      </span><span class="s1">if (vi.isNode()) {</span><span class="s3">\n        </span><span class="s1">Q.unshift(vi);</span><span class="s3">\n        </span><span class="s1">if (params.bfs) {</span><span class="s3">\n          </span><span class="s1">V[viId] = true;</span><span class="s3">\n          </span><span class="s1">connectedNodes.push(vi);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">id2depth[viId] = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n        </span><span class="s1">var v = params.bfs ? Q.shift() : Q.pop();</span><span class="s3">\n        </span><span class="s1">var vId = v.id();</span><span class="s3">\n        </span><span class="s1">if (params.dfs) {</span><span class="s3">\n          </span><span class="s1">if (V[vId]) {</span><span class="s3">\n            </span><span class="s1">return 0; // continue</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">V[vId] = true;</span><span class="s3">\n          </span><span class="s1">connectedNodes.push(v);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var depth = id2depth[vId];</span><span class="s3">\n        </span><span class="s1">var prevEdge = connectedBy[vId];</span><span class="s3">\n        </span><span class="s1">var src = prevEdge != null ? prevEdge.source() : null;</span><span class="s3">\n        </span><span class="s1">var tgt = prevEdge != null ? prevEdge.target() : null;</span><span class="s3">\n        </span><span class="s1">var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];</span><span class="s3">\n        </span><span class="s1">var ret;</span><span class="s3">\n        </span><span class="s1">ret = fn(v, prevEdge, prevNode, j++, depth);</span><span class="s3">\n        </span><span class="s1">if (ret === true) {</span><span class="s3">\n          </span><span class="s1">found = v;</span><span class="s3">\n          </span><span class="s1">return 1; // break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ret === false) {</span><span class="s3">\n          </span><span class="s1">return 1; // break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var vwEdges = v.connectedEdges().filter(function (e) {</span><span class="s3">\n          </span><span class="s1">return (!directed || e.source().same(v)) &amp;&amp; edges.has(e);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">for (var _i2 = 0; _i2 &lt; vwEdges.length; _i2++) {</span><span class="s3">\n          </span><span class="s1">var e = vwEdges[_i2];</span><span class="s3">\n          </span><span class="s1">var w = e.connectedNodes().filter(function (n) {</span><span class="s3">\n            </span><span class="s1">return !n.same(v) &amp;&amp; nodes.has(n);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">var wId = w.id();</span><span class="s3">\n          </span><span class="s1">if (w.length !== 0 &amp;&amp; !V[wId]) {</span><span class="s3">\n            </span><span class="s1">w = w[0];</span><span class="s3">\n            </span><span class="s1">Q.push(w);</span><span class="s3">\n            </span><span class="s1">if (params.bfs) {</span><span class="s3">\n              </span><span class="s1">V[wId] = true;</span><span class="s3">\n              </span><span class="s1">connectedNodes.push(w);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">connectedBy[wId] = e;</span><span class="s3">\n            </span><span class="s1">id2depth[wId] = id2depth[vId] + 1;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">_ret;</span><span class="s3">\n    </span><span class="s1">while (Q.length !== 0) {</span><span class="s3">\n      </span><span class="s1">_ret = _loop();</span><span class="s3">\n      </span><span class="s1">if (_ret === 0) continue;</span><span class="s3">\n      </span><span class="s1">if (_ret === 1) break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var connectedEles = cy.collection();</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; connectedNodes.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var node = connectedNodes[_i];</span><span class="s3">\n      </span><span class="s1">var edge = connectedBy[node.id()];</span><span class="s3">\n      </span><span class="s1">if (edge != null) {</span><span class="s3">\n        </span><span class="s1">connectedEles.push(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">connectedEles.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">path: cy.collection(connectedEles),</span><span class="s3">\n      </span><span class="s1">found: cy.collection(found)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// search, spanning trees, etc</span><span class="s3">\n</span><span class="s1">var elesfn$v = {</span><span class="s3">\n  </span><span class="s1">breadthFirstSearch: defineSearch({</span><span class="s3">\n    </span><span class="s1">bfs: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">depthFirstSearch: defineSearch({</span><span class="s3">\n    </span><span class="s1">dfs: true</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// nice, short mathematical alias</span><span class="s3">\n</span><span class="s1">elesfn$v.bfs = elesfn$v.breadthFirstSearch;</span><span class="s3">\n</span><span class="s1">elesfn$v.dfs = elesfn$v.depthFirstSearch;</span><span class="s3">\n\n</span><span class="s1">var heap$2 = {exports: {}};</span><span class="s3">\n\n</span><span class="s1">var heap$1 = heap$2.exports;</span><span class="s3">\n\n</span><span class="s1">var hasRequiredHeap$1;</span><span class="s3">\n\n</span><span class="s1">function requireHeap$1 () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredHeap$1) return heap$2.exports;</span><span class="s3">\n\t</span><span class="s1">hasRequiredHeap$1 = 1;</span><span class="s3">\n\t</span><span class="s1">(function (module, exports) {</span><span class="s3">\n\t\t</span><span class="s1">// Generated by CoffeeScript 1.8.0</span><span class="s3">\n\t\t</span><span class="s1">(function() {</span><span class="s3">\n\t\t  </span><span class="s1">var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;</span><span class="s3">\n\n\t\t  </span><span class="s1">floor = Math.floor, min = Math.min;</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Default comparison function to be used</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">defaultCmp = function(x, y) {</span><span class="s3">\n\t\t    </span><span class="s1">if (x &lt; y) {</span><span class="s3">\n\t\t      </span><span class="s1">return -1;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">if (x &gt; y) {</span><span class="s3">\n\t\t      </span><span class="s1">return 1;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return 0;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Insert item x in list a, and keep it sorted assuming a is sorted.</span><span class="s3">\n\t\t  \n\t\t  </span><span class="s1">If x is already in a, insert it to the right of the rightmost x.</span><span class="s3">\n\t\t  \n\t\t  </span><span class="s1">Optional args lo (default 0) and hi (default a.length) bound the slice</span><span class="s3">\n\t\t  </span><span class="s1">of a to be searched.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">insort = function(a, x, lo, hi, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var mid;</span><span class="s3">\n\t\t    </span><span class="s1">if (lo == null) {</span><span class="s3">\n\t\t      </span><span class="s1">lo = 0;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">if (lo &lt; 0) {</span><span class="s3">\n\t\t      </span><span class="s1">throw new Error('lo must be non-negative');</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">if (hi == null) {</span><span class="s3">\n\t\t      </span><span class="s1">hi = a.length;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">while (lo &lt; hi) {</span><span class="s3">\n\t\t      </span><span class="s1">mid = floor((lo + hi) / 2);</span><span class="s3">\n\t\t      </span><span class="s1">if (cmp(x, a[mid]) &lt; 0) {</span><span class="s3">\n\t\t        </span><span class="s1">hi = mid;</span><span class="s3">\n\t\t      </span><span class="s1">} else {</span><span class="s3">\n\t\t        </span><span class="s1">lo = mid + 1;</span><span class="s3">\n\t\t      </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Push item onto heap, maintaining the heap invariant.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">heappush = function(array, item, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">array.push(item);</span><span class="s3">\n\t\t    </span><span class="s1">return _siftdown(array, 0, array.length - 1, cmp);</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Pop the smallest item off the heap, maintaining the heap invariant.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">heappop = function(array, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var lastelt, returnitem;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">lastelt = array.pop();</span><span class="s3">\n\t\t    </span><span class="s1">if (array.length) {</span><span class="s3">\n\t\t      </span><span class="s1">returnitem = array[0];</span><span class="s3">\n\t\t      </span><span class="s1">array[0] = lastelt;</span><span class="s3">\n\t\t      </span><span class="s1">_siftup(array, 0, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">} else {</span><span class="s3">\n\t\t      </span><span class="s1">returnitem = lastelt;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return returnitem;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Pop and return the current smallest value, and add the new item.</span><span class="s3">\n\t\t  \n\t\t  </span><span class="s1">This is more efficient than heappop() followed by heappush(), and can be</span><span class="s3">\n\t\t  </span><span class="s1">more appropriate when using a fixed size heap. Note that the value</span><span class="s3">\n\t\t  </span><span class="s1">returned may be larger than item! That constrains reasonable use of</span><span class="s3">\n\t\t  </span><span class="s1">this routine unless written as part of a conditional replacement:</span><span class="s3">\n\t\t      </span><span class="s1">if item &gt; array[0]</span><span class="s3">\n\t\t        </span><span class="s1">item = heapreplace(array, item)</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">heapreplace = function(array, item, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var returnitem;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">returnitem = array[0];</span><span class="s3">\n\t\t    </span><span class="s1">array[0] = item;</span><span class="s3">\n\t\t    </span><span class="s1">_siftup(array, 0, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">return returnitem;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Fast version of a heappush followed by a heappop.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">heappushpop = function(array, item, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var _ref;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">if (array.length &amp;&amp; cmp(array[0], item) &lt; 0) {</span><span class="s3">\n\t\t      </span><span class="s1">_ref = [array[0], item], item = _ref[0], array[0] = _ref[1];</span><span class="s3">\n\t\t      </span><span class="s1">_siftup(array, 0, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return item;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Transform list into a heap, in-place, in O(array.length) time.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">heapify = function(array, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var i, _i, _len, _ref1, _results, _results1;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">_ref1 = (function() {</span><span class="s3">\n\t\t      </span><span class="s1">_results1 = [];</span><span class="s3">\n\t\t      </span><span class="s1">for (var _j = 0, _ref = floor(array.length / 2); 0 &lt;= _ref ? _j &lt; _ref : _j &gt; _ref; 0 &lt;= _ref ? _j++ : _j--){ _results1.push(_j); }</span><span class="s3">\n\t\t      </span><span class="s1">return _results1;</span><span class="s3">\n\t\t    </span><span class="s1">}).apply(this).reverse();</span><span class="s3">\n\t\t    </span><span class="s1">_results = [];</span><span class="s3">\n\t\t    </span><span class="s1">for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {</span><span class="s3">\n\t\t      </span><span class="s1">i = _ref1[_i];</span><span class="s3">\n\t\t      </span><span class="s1">_results.push(_siftup(array, i, cmp));</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return _results;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Update the position of the given item in the heap.</span><span class="s3">\n\t\t  </span><span class="s1">This function should be called every time the item is being modified.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">updateItem = function(array, item, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var pos;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">pos = array.indexOf(item);</span><span class="s3">\n\t\t    </span><span class="s1">if (pos === -1) {</span><span class="s3">\n\t\t      </span><span class="s1">return;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">_siftdown(array, 0, pos, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">return _siftup(array, pos, cmp);</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Find the n largest elements in a dataset.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">nlargest = function(array, n, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var elem, result, _i, _len, _ref;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">result = array.slice(0, n);</span><span class="s3">\n\t\t    </span><span class="s1">if (!result.length) {</span><span class="s3">\n\t\t      </span><span class="s1">return result;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">heapify(result, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">_ref = array.slice(n);</span><span class="s3">\n\t\t    </span><span class="s1">for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {</span><span class="s3">\n\t\t      </span><span class="s1">elem = _ref[_i];</span><span class="s3">\n\t\t      </span><span class="s1">heappushpop(result, elem, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return result.sort(cmp).reverse();</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\n\t\t  </span><span class="s1">/*</span><span class="s3">\n\t\t  </span><span class="s1">Find the n smallest elements in a dataset.</span><span class="s3">\n\t\t   </span><span class="s1">*/</span><span class="s3">\n\n\t\t  </span><span class="s1">nsmallest = function(array, n, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var elem, los, result, _i, _j, _len, _ref, _ref1, _results;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">if (n * 10 &lt;= array.length) {</span><span class="s3">\n\t\t      </span><span class="s1">result = array.slice(0, n).sort(cmp);</span><span class="s3">\n\t\t      </span><span class="s1">if (!result.length) {</span><span class="s3">\n\t\t        </span><span class="s1">return result;</span><span class="s3">\n\t\t      </span><span class="s1">}</span><span class="s3">\n\t\t      </span><span class="s1">los = result[result.length - 1];</span><span class="s3">\n\t\t      </span><span class="s1">_ref = array.slice(n);</span><span class="s3">\n\t\t      </span><span class="s1">for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {</span><span class="s3">\n\t\t        </span><span class="s1">elem = _ref[_i];</span><span class="s3">\n\t\t        </span><span class="s1">if (cmp(elem, los) &lt; 0) {</span><span class="s3">\n\t\t          </span><span class="s1">insort(result, elem, 0, null, cmp);</span><span class="s3">\n\t\t          </span><span class="s1">result.pop();</span><span class="s3">\n\t\t          </span><span class="s1">los = result[result.length - 1];</span><span class="s3">\n\t\t        </span><span class="s1">}</span><span class="s3">\n\t\t      </span><span class="s1">}</span><span class="s3">\n\t\t      </span><span class="s1">return result;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">heapify(array, cmp);</span><span class="s3">\n\t\t    </span><span class="s1">_results = [];</span><span class="s3">\n\t\t    </span><span class="s1">for (_j = 0, _ref1 = min(n, array.length); 0 &lt;= _ref1 ? _j &lt; _ref1 : _j &gt; _ref1; 0 &lt;= _ref1 ? ++_j : --_j) {</span><span class="s3">\n\t\t      </span><span class="s1">_results.push(heappop(array, cmp));</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return _results;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\t\t  </span><span class="s1">_siftdown = function(array, startpos, pos, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var newitem, parent, parentpos;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">newitem = array[pos];</span><span class="s3">\n\t\t    </span><span class="s1">while (pos &gt; startpos) {</span><span class="s3">\n\t\t      </span><span class="s1">parentpos = (pos - 1) &gt;&gt; 1;</span><span class="s3">\n\t\t      </span><span class="s1">parent = array[parentpos];</span><span class="s3">\n\t\t      </span><span class="s1">if (cmp(newitem, parent) &lt; 0) {</span><span class="s3">\n\t\t        </span><span class="s1">array[pos] = parent;</span><span class="s3">\n\t\t        </span><span class="s1">pos = parentpos;</span><span class="s3">\n\t\t        </span><span class="s1">continue;</span><span class="s3">\n\t\t      </span><span class="s1">}</span><span class="s3">\n\t\t      </span><span class="s1">break;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">return array[pos] = newitem;</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\t\t  </span><span class="s1">_siftup = function(array, pos, cmp) {</span><span class="s3">\n\t\t    </span><span class="s1">var childpos, endpos, newitem, rightpos, startpos;</span><span class="s3">\n\t\t    </span><span class="s1">if (cmp == null) {</span><span class="s3">\n\t\t      </span><span class="s1">cmp = defaultCmp;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">endpos = array.length;</span><span class="s3">\n\t\t    </span><span class="s1">startpos = pos;</span><span class="s3">\n\t\t    </span><span class="s1">newitem = array[pos];</span><span class="s3">\n\t\t    </span><span class="s1">childpos = 2 * pos + 1;</span><span class="s3">\n\t\t    </span><span class="s1">while (childpos &lt; endpos) {</span><span class="s3">\n\t\t      </span><span class="s1">rightpos = childpos + 1;</span><span class="s3">\n\t\t      </span><span class="s1">if (rightpos &lt; endpos &amp;&amp; !(cmp(array[childpos], array[rightpos]) &lt; 0)) {</span><span class="s3">\n\t\t        </span><span class="s1">childpos = rightpos;</span><span class="s3">\n\t\t      </span><span class="s1">}</span><span class="s3">\n\t\t      </span><span class="s1">array[pos] = array[childpos];</span><span class="s3">\n\t\t      </span><span class="s1">pos = childpos;</span><span class="s3">\n\t\t      </span><span class="s1">childpos = 2 * pos + 1;</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t    </span><span class="s1">array[pos] = newitem;</span><span class="s3">\n\t\t    </span><span class="s1">return _siftdown(array, startpos, pos, cmp);</span><span class="s3">\n\t\t  </span><span class="s1">};</span><span class="s3">\n\n\t\t  </span><span class="s1">Heap = (function() {</span><span class="s3">\n\t\t    </span><span class="s1">Heap.push = heappush;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.pop = heappop;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.replace = heapreplace;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.pushpop = heappushpop;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.heapify = heapify;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.updateItem = updateItem;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.nlargest = nlargest;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.nsmallest = nsmallest;</span><span class="s3">\n\n\t\t    </span><span class="s1">function Heap(cmp) {</span><span class="s3">\n\t\t      </span><span class="s1">this.cmp = cmp != null ? cmp : defaultCmp;</span><span class="s3">\n\t\t      </span><span class="s1">this.nodes = [];</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.push = function(x) {</span><span class="s3">\n\t\t      </span><span class="s1">return heappush(this.nodes, x, this.cmp);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.pop = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return heappop(this.nodes, this.cmp);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.peek = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return this.nodes[0];</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.contains = function(x) {</span><span class="s3">\n\t\t      </span><span class="s1">return this.nodes.indexOf(x) !== -1;</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.replace = function(x) {</span><span class="s3">\n\t\t      </span><span class="s1">return heapreplace(this.nodes, x, this.cmp);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.pushpop = function(x) {</span><span class="s3">\n\t\t      </span><span class="s1">return heappushpop(this.nodes, x, this.cmp);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.heapify = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return heapify(this.nodes, this.cmp);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.updateItem = function(x) {</span><span class="s3">\n\t\t      </span><span class="s1">return updateItem(this.nodes, x, this.cmp);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.clear = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return this.nodes = [];</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.empty = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return this.nodes.length === 0;</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.size = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return this.nodes.length;</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.clone = function() {</span><span class="s3">\n\t\t      </span><span class="s1">var heap;</span><span class="s3">\n\t\t      </span><span class="s1">heap = new Heap();</span><span class="s3">\n\t\t      </span><span class="s1">heap.nodes = this.nodes.slice(0);</span><span class="s3">\n\t\t      </span><span class="s1">return heap;</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.toArray = function() {</span><span class="s3">\n\t\t      </span><span class="s1">return this.nodes.slice(0);</span><span class="s3">\n\t\t    </span><span class="s1">};</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.insert = Heap.prototype.push;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.top = Heap.prototype.peek;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.front = Heap.prototype.peek;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.has = Heap.prototype.contains;</span><span class="s3">\n\n\t\t    </span><span class="s1">Heap.prototype.copy = Heap.prototype.clone;</span><span class="s3">\n\n\t\t    </span><span class="s1">return Heap;</span><span class="s3">\n\n\t\t  </span><span class="s1">})();</span><span class="s3">\n\n\t\t  </span><span class="s1">(function(root, factory) {</span><span class="s3">\n\t\t    </span><span class="s1">{</span><span class="s3">\n\t\t      </span><span class="s1">return module.exports = factory();</span><span class="s3">\n\t\t    </span><span class="s1">}</span><span class="s3">\n\t\t  </span><span class="s1">})(this, function() {</span><span class="s3">\n\t\t    </span><span class="s1">return Heap;</span><span class="s3">\n\t\t  </span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">}).call(heap$1); </span><span class="s3">\n\t</span><span class="s1">} (heap$2));</span><span class="s3">\n\t</span><span class="s1">return heap$2.exports;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var heap;</span><span class="s3">\n</span><span class="s1">var hasRequiredHeap;</span><span class="s3">\n\n</span><span class="s1">function requireHeap () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredHeap) return heap;</span><span class="s3">\n\t</span><span class="s1">hasRequiredHeap = 1;</span><span class="s3">\n\t</span><span class="s1">heap = requireHeap$1();</span><span class="s3">\n\t</span><span class="s1">return heap;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var heapExports = requireHeap();</span><span class="s3">\n</span><span class="s1">var Heap = /*@__PURE__*/getDefaultExportFromCjs(heapExports);</span><span class="s3">\n\n</span><span class="s1">var dijkstraDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">root: null,</span><span class="s3">\n  </span><span class="s1">weight: function weight(edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">directed: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$u = {</span><span class="s3">\n  </span><span class="s1">dijkstra: function dijkstra(options) {</span><span class="s3">\n    </span><span class="s1">if (!plainObject(options)) {</span><span class="s3">\n      </span><span class="s1">var args = arguments;</span><span class="s3">\n      </span><span class="s1">options = {</span><span class="s3">\n        </span><span class="s1">root: args[0],</span><span class="s3">\n        </span><span class="s1">weight: args[1],</span><span class="s3">\n        </span><span class="s1">directed: args[2]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _dijkstraDefaults = dijkstraDefaults(options),</span><span class="s3">\n      </span><span class="s1">root = _dijkstraDefaults.root,</span><span class="s3">\n      </span><span class="s1">weight = _dijkstraDefaults.weight,</span><span class="s3">\n      </span><span class="s1">directed = _dijkstraDefaults.directed;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var weightFn = weight;</span><span class="s3">\n    </span><span class="s1">var source = string(root) ? this.filter(root)[0] : root[0];</span><span class="s3">\n    </span><span class="s1">var dist = {};</span><span class="s3">\n    </span><span class="s1">var prev = {};</span><span class="s3">\n    </span><span class="s1">var knownDist = {};</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes,</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges;</span><span class="s3">\n    </span><span class="s1">edges.unmergeBy(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isLoop();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var getDist = function getDist(node) {</span><span class="s3">\n      </span><span class="s1">return dist[node.id()];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var setDist = function setDist(node, d) {</span><span class="s3">\n      </span><span class="s1">dist[node.id()] = d;</span><span class="s3">\n      </span><span class="s1">Q.updateItem(node);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var Q = new Heap(function (a, b) {</span><span class="s3">\n      </span><span class="s1">return getDist(a) - getDist(b);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">var node = nodes[i];</span><span class="s3">\n      </span><span class="s1">dist[node.id()] = node.same(source) ? 0 : Infinity;</span><span class="s3">\n      </span><span class="s1">Q.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var distBetween = function distBetween(u, v) {</span><span class="s3">\n      </span><span class="s1">var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);</span><span class="s3">\n      </span><span class="s1">var smallestDistance = Infinity;</span><span class="s3">\n      </span><span class="s1">var smallestEdge;</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; uvs.length; _i++) {</span><span class="s3">\n        </span><span class="s1">var edge = uvs[_i];</span><span class="s3">\n        </span><span class="s1">var _weight = weightFn(edge);</span><span class="s3">\n        </span><span class="s1">if (_weight &lt; smallestDistance || !smallestEdge) {</span><span class="s3">\n          </span><span class="s1">smallestDistance = _weight;</span><span class="s3">\n          </span><span class="s1">smallestEdge = edge;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">edge: smallestEdge,</span><span class="s3">\n        </span><span class="s1">dist: smallestDistance</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">while (Q.size() &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var u = Q.pop();</span><span class="s3">\n      </span><span class="s1">var smalletsDist = getDist(u);</span><span class="s3">\n      </span><span class="s1">var uid = u.id();</span><span class="s3">\n      </span><span class="s1">knownDist[uid] = smalletsDist;</span><span class="s3">\n      </span><span class="s1">if (smalletsDist === Infinity) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var neighbors = u.neighborhood().intersect(nodes);</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; neighbors.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">var v = neighbors[_i2];</span><span class="s3">\n        </span><span class="s1">var vid = v.id();</span><span class="s3">\n        </span><span class="s1">var vDist = distBetween(u, v);</span><span class="s3">\n        </span><span class="s1">var alt = smalletsDist + vDist.dist;</span><span class="s3">\n        </span><span class="s1">if (alt &lt; getDist(v)) {</span><span class="s3">\n          </span><span class="s1">setDist(v, alt);</span><span class="s3">\n          </span><span class="s1">prev[vid] = {</span><span class="s3">\n            </span><span class="s1">node: u,</span><span class="s3">\n            </span><span class="s1">edge: vDist.edge</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // for</span><span class="s3">\n    </span><span class="s1">} // while</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">distanceTo: function distanceTo(node) {</span><span class="s3">\n        </span><span class="s1">var target = string(node) ? nodes.filter(node)[0] : node[0];</span><span class="s3">\n        </span><span class="s1">return knownDist[target.id()];</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">pathTo: function pathTo(node) {</span><span class="s3">\n        </span><span class="s1">var target = string(node) ? nodes.filter(node)[0] : node[0];</span><span class="s3">\n        </span><span class="s1">var S = [];</span><span class="s3">\n        </span><span class="s1">var u = target;</span><span class="s3">\n        </span><span class="s1">var uid = u.id();</span><span class="s3">\n        </span><span class="s1">if (target.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">S.unshift(target);</span><span class="s3">\n          </span><span class="s1">while (prev[uid]) {</span><span class="s3">\n            </span><span class="s1">var p = prev[uid];</span><span class="s3">\n            </span><span class="s1">S.unshift(p.edge);</span><span class="s3">\n            </span><span class="s1">S.unshift(p.node);</span><span class="s3">\n            </span><span class="s1">u = p.node;</span><span class="s3">\n            </span><span class="s1">uid = u.id();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return eles.spawn(S);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var elesfn$t = {</span><span class="s3">\n  </span><span class="s1">// kruskal's algorithm (finds min spanning tree, assuming undirected graph)</span><span class="s3">\n  </span><span class="s1">// implemented from pseudocode from wikipedia</span><span class="s3">\n  </span><span class="s1">kruskal: function kruskal(weightFn) {</span><span class="s3">\n    </span><span class="s1">weightFn = weightFn || function (edge) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes,</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges;</span><span class="s3">\n    </span><span class="s1">var numNodes = nodes.length;</span><span class="s3">\n    </span><span class="s1">var forest = new Array(numNodes);</span><span class="s3">\n    </span><span class="s1">var A = nodes; // assumes byGroup() creates new collections that can be safely mutated</span><span class="s3">\n\n    </span><span class="s1">var findSetIndex = function findSetIndex(ele) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; forest.length; i++) {</span><span class="s3">\n        </span><span class="s1">var eles = forest[i];</span><span class="s3">\n        </span><span class="s1">if (eles.has(ele)) {</span><span class="s3">\n          </span><span class="s1">return i;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// start with one forest per node</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; numNodes; i++) {</span><span class="s3">\n      </span><span class="s1">forest[i] = this.spawn(nodes[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var S = edges.sort(function (a, b) {</span><span class="s3">\n      </span><span class="s1">return weightFn(a) - weightFn(b);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; S.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var edge = S[_i];</span><span class="s3">\n      </span><span class="s1">var u = edge.source()[0];</span><span class="s3">\n      </span><span class="s1">var v = edge.target()[0];</span><span class="s3">\n      </span><span class="s1">var setUIndex = findSetIndex(u);</span><span class="s3">\n      </span><span class="s1">var setVIndex = findSetIndex(v);</span><span class="s3">\n      </span><span class="s1">var setU = forest[setUIndex];</span><span class="s3">\n      </span><span class="s1">var setV = forest[setVIndex];</span><span class="s3">\n      </span><span class="s1">if (setUIndex !== setVIndex) {</span><span class="s3">\n        </span><span class="s1">A.merge(edge);</span><span class="s3">\n\n        </span><span class="s1">// combine forests for u and v</span><span class="s3">\n        </span><span class="s1">setU.merge(setV);</span><span class="s3">\n        </span><span class="s1">forest.splice(setVIndex, 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return A;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var aStarDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">root: null,</span><span class="s3">\n  </span><span class="s1">goal: null,</span><span class="s3">\n  </span><span class="s1">weight: function weight(edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">heuristic: function heuristic(edge) {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">directed: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$s = {</span><span class="s3">\n  </span><span class="s1">// Implemented from pseudocode from wikipedia</span><span class="s3">\n  </span><span class="s1">aStar: function aStar(options) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var _aStarDefaults = aStarDefaults(options),</span><span class="s3">\n      </span><span class="s1">root = _aStarDefaults.root,</span><span class="s3">\n      </span><span class="s1">goal = _aStarDefaults.goal,</span><span class="s3">\n      </span><span class="s1">heuristic = _aStarDefaults.heuristic,</span><span class="s3">\n      </span><span class="s1">directed = _aStarDefaults.directed,</span><span class="s3">\n      </span><span class="s1">weight = _aStarDefaults.weight;</span><span class="s3">\n    </span><span class="s1">root = cy.collection(root)[0];</span><span class="s3">\n    </span><span class="s1">goal = cy.collection(goal)[0];</span><span class="s3">\n    </span><span class="s1">var sid = root.id();</span><span class="s3">\n    </span><span class="s1">var tid = goal.id();</span><span class="s3">\n    </span><span class="s1">var gScore = {};</span><span class="s3">\n    </span><span class="s1">var fScore = {};</span><span class="s3">\n    </span><span class="s1">var closedSetIds = {};</span><span class="s3">\n    </span><span class="s1">var openSet = new Heap(function (a, b) {</span><span class="s3">\n      </span><span class="s1">return fScore[a.id()] - fScore[b.id()];</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var openSetIds = new Set$1();</span><span class="s3">\n    </span><span class="s1">var cameFrom = {};</span><span class="s3">\n    </span><span class="s1">var cameFromEdge = {};</span><span class="s3">\n    </span><span class="s1">var addToOpenSet = function addToOpenSet(ele, id) {</span><span class="s3">\n      </span><span class="s1">openSet.push(ele);</span><span class="s3">\n      </span><span class="s1">openSetIds.add(id);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var cMin, cMinId;</span><span class="s3">\n    </span><span class="s1">var popFromOpenSet = function popFromOpenSet() {</span><span class="s3">\n      </span><span class="s1">cMin = openSet.pop();</span><span class="s3">\n      </span><span class="s1">cMinId = cMin.id();</span><span class="s3">\n      </span><span class="s1">openSetIds[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](cMinId);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var isInOpenSet = function isInOpenSet(id) {</span><span class="s3">\n      </span><span class="s1">return openSetIds.has(id);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">addToOpenSet(root, sid);</span><span class="s3">\n    </span><span class="s1">gScore[sid] = 0;</span><span class="s3">\n    </span><span class="s1">fScore[sid] = heuristic(root);</span><span class="s3">\n\n    </span><span class="s1">// Counter</span><span class="s3">\n    </span><span class="s1">var steps = 0;</span><span class="s3">\n\n    </span><span class="s1">// Main loop</span><span class="s3">\n    </span><span class="s1">while (openSet.size() &gt; 0) {</span><span class="s3">\n      </span><span class="s1">popFromOpenSet();</span><span class="s3">\n      </span><span class="s1">steps++;</span><span class="s3">\n\n      </span><span class="s1">// If we've found our goal, then we are done</span><span class="s3">\n      </span><span class="s1">if (cMinId === tid) {</span><span class="s3">\n        </span><span class="s1">var path = [];</span><span class="s3">\n        </span><span class="s1">var pathNode = goal;</span><span class="s3">\n        </span><span class="s1">var pathNodeId = tid;</span><span class="s3">\n        </span><span class="s1">var pathEdge = cameFromEdge[pathNodeId];</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n          </span><span class="s1">path.unshift(pathNode);</span><span class="s3">\n          </span><span class="s1">if (pathEdge != null) {</span><span class="s3">\n            </span><span class="s1">path.unshift(pathEdge);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">pathNode = cameFrom[pathNodeId];</span><span class="s3">\n          </span><span class="s1">if (pathNode == null) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">pathNodeId = pathNode.id();</span><span class="s3">\n          </span><span class="s1">pathEdge = cameFromEdge[pathNodeId];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">found: true,</span><span class="s3">\n          </span><span class="s1">distance: gScore[cMinId],</span><span class="s3">\n          </span><span class="s1">path: this.spawn(path),</span><span class="s3">\n          </span><span class="s1">steps: steps</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Add cMin to processed nodes</span><span class="s3">\n      </span><span class="s1">closedSetIds[cMinId] = true;</span><span class="s3">\n\n      </span><span class="s1">// Update scores for neighbors of cMin</span><span class="s3">\n      </span><span class="s1">// Take into account if graph is directed or not</span><span class="s3">\n      </span><span class="s1">var vwEdges = cMin._private.edges;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; vwEdges.length; i++) {</span><span class="s3">\n        </span><span class="s1">var e = vwEdges[i];</span><span class="s3">\n\n        </span><span class="s1">// edge must be in set of calling eles</span><span class="s3">\n        </span><span class="s1">if (!this.hasElementWithId(e.id())) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// cMin must be the source of edge if directed</span><span class="s3">\n        </span><span class="s1">if (directed &amp;&amp; e.data('source') !== cMinId) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var wSrc = e.source();</span><span class="s3">\n        </span><span class="s1">var wTgt = e.target();</span><span class="s3">\n        </span><span class="s1">var w = wSrc.id() !== cMinId ? wSrc : wTgt;</span><span class="s3">\n        </span><span class="s1">var wid = w.id();</span><span class="s3">\n\n        </span><span class="s1">// node must be in set of calling eles</span><span class="s3">\n        </span><span class="s1">if (!this.hasElementWithId(wid)) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// if node is in closedSet, ignore it</span><span class="s3">\n        </span><span class="s1">if (closedSetIds[wid]) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// New tentative score for node w</span><span class="s3">\n        </span><span class="s1">var tempScore = gScore[cMinId] + weight(e);</span><span class="s3">\n\n        </span><span class="s1">// Update gScore for node w if:</span><span class="s3">\n        </span><span class="s1">//   w not present in openSet</span><span class="s3">\n        </span><span class="s1">// OR</span><span class="s3">\n        </span><span class="s1">//   tentative gScore is less than previous value</span><span class="s3">\n\n        </span><span class="s1">// w not in openSet</span><span class="s3">\n        </span><span class="s1">if (!isInOpenSet(wid)) {</span><span class="s3">\n          </span><span class="s1">gScore[wid] = tempScore;</span><span class="s3">\n          </span><span class="s1">fScore[wid] = tempScore + heuristic(w);</span><span class="s3">\n          </span><span class="s1">addToOpenSet(w, wid);</span><span class="s3">\n          </span><span class="s1">cameFrom[wid] = cMin;</span><span class="s3">\n          </span><span class="s1">cameFromEdge[wid] = e;</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// w already in openSet, but with greater gScore</span><span class="s3">\n        </span><span class="s1">if (tempScore &lt; gScore[wid]) {</span><span class="s3">\n          </span><span class="s1">gScore[wid] = tempScore;</span><span class="s3">\n          </span><span class="s1">fScore[wid] = tempScore + heuristic(w);</span><span class="s3">\n          </span><span class="s1">cameFrom[wid] = cMin;</span><span class="s3">\n          </span><span class="s1">cameFromEdge[wid] = e;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // End of neighbors update</span><span class="s3">\n    </span><span class="s1">} // End of main loop</span><span class="s3">\n\n    </span><span class="s1">// If we've reached here, then we've not reached our goal</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">found: false,</span><span class="s3">\n      </span><span class="s1">distance: undefined,</span><span class="s3">\n      </span><span class="s1">path: undefined,</span><span class="s3">\n      </span><span class="s1">steps: steps</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">var floydWarshallDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">weight: function weight(edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">directed: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$r = {</span><span class="s3">\n  </span><span class="s1">// Implemented from pseudocode from wikipedia</span><span class="s3">\n  </span><span class="s1">floydWarshall: function floydWarshall(options) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var _floydWarshallDefault = floydWarshallDefaults(options),</span><span class="s3">\n      </span><span class="s1">weight = _floydWarshallDefault.weight,</span><span class="s3">\n      </span><span class="s1">directed = _floydWarshallDefault.directed;</span><span class="s3">\n    </span><span class="s1">var weightFn = weight;</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes,</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges;</span><span class="s3">\n    </span><span class="s1">var N = nodes.length;</span><span class="s3">\n    </span><span class="s1">var Nsq = N * N;</span><span class="s3">\n    </span><span class="s1">var indexOf = function indexOf(node) {</span><span class="s3">\n      </span><span class="s1">return nodes.indexOf(node);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var atIndex = function atIndex(i) {</span><span class="s3">\n      </span><span class="s1">return nodes[i];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Initialize distance matrix</span><span class="s3">\n    </span><span class="s1">var dist = new Array(Nsq);</span><span class="s3">\n    </span><span class="s1">for (var n = 0; n &lt; Nsq; n++) {</span><span class="s3">\n      </span><span class="s1">var j = n % N;</span><span class="s3">\n      </span><span class="s1">var i = (n - j) / N;</span><span class="s3">\n      </span><span class="s1">if (i === j) {</span><span class="s3">\n        </span><span class="s1">dist[n] = 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dist[n] = Infinity;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Initialize matrix used for path reconstruction</span><span class="s3">\n    </span><span class="s1">// Initialize distance matrix</span><span class="s3">\n    </span><span class="s1">var next = new Array(Nsq);</span><span class="s3">\n    </span><span class="s1">var edgeNext = new Array(Nsq);</span><span class="s3">\n\n    </span><span class="s1">// Process edges</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; edges.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var edge = edges[_i];</span><span class="s3">\n      </span><span class="s1">var src = edge.source()[0];</span><span class="s3">\n      </span><span class="s1">var tgt = edge.target()[0];</span><span class="s3">\n      </span><span class="s1">if (src === tgt) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">} // exclude loops</span><span class="s3">\n\n      </span><span class="s1">var s = indexOf(src);</span><span class="s3">\n      </span><span class="s1">var t = indexOf(tgt);</span><span class="s3">\n      </span><span class="s1">var st = s * N + t; // source to target index</span><span class="s3">\n      </span><span class="s1">var _weight = weightFn(edge);</span><span class="s3">\n\n      </span><span class="s1">// Check if already process another edge between same 2 nodes</span><span class="s3">\n      </span><span class="s1">if (dist[st] &gt; _weight) {</span><span class="s3">\n        </span><span class="s1">dist[st] = _weight;</span><span class="s3">\n        </span><span class="s1">next[st] = t;</span><span class="s3">\n        </span><span class="s1">edgeNext[st] = edge;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If undirected graph, process 'reversed' edge</span><span class="s3">\n      </span><span class="s1">if (!directed) {</span><span class="s3">\n        </span><span class="s1">var ts = t * N + s; // target to source index</span><span class="s3">\n\n        </span><span class="s1">if (!directed &amp;&amp; dist[ts] &gt; _weight) {</span><span class="s3">\n          </span><span class="s1">dist[ts] = _weight;</span><span class="s3">\n          </span><span class="s1">next[ts] = s;</span><span class="s3">\n          </span><span class="s1">edgeNext[ts] = edge;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Main loop</span><span class="s3">\n    </span><span class="s1">for (var k = 0; k &lt; N; k++) {</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; N; _i2++) {</span><span class="s3">\n        </span><span class="s1">var ik = _i2 * N + k;</span><span class="s3">\n        </span><span class="s1">for (var _j = 0; _j &lt; N; _j++) {</span><span class="s3">\n          </span><span class="s1">var ij = _i2 * N + _j;</span><span class="s3">\n          </span><span class="s1">var kj = k * N + _j;</span><span class="s3">\n          </span><span class="s1">if (dist[ik] + dist[kj] &lt; dist[ij]) {</span><span class="s3">\n            </span><span class="s1">dist[ij] = dist[ik] + dist[kj];</span><span class="s3">\n            </span><span class="s1">next[ij] = next[ik];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var getArgEle = function getArgEle(ele) {</span><span class="s3">\n      </span><span class="s1">return (string(ele) ? cy.filter(ele) : ele)[0];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var indexOfArgEle = function indexOfArgEle(ele) {</span><span class="s3">\n      </span><span class="s1">return indexOf(getArgEle(ele));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var res = {</span><span class="s3">\n      </span><span class="s1">distance: function distance(from, to) {</span><span class="s3">\n        </span><span class="s1">var i = indexOfArgEle(from);</span><span class="s3">\n        </span><span class="s1">var j = indexOfArgEle(to);</span><span class="s3">\n        </span><span class="s1">return dist[i * N + j];</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">path: function path(from, to) {</span><span class="s3">\n        </span><span class="s1">var i = indexOfArgEle(from);</span><span class="s3">\n        </span><span class="s1">var j = indexOfArgEle(to);</span><span class="s3">\n        </span><span class="s1">var fromNode = atIndex(i);</span><span class="s3">\n        </span><span class="s1">if (i === j) {</span><span class="s3">\n          </span><span class="s1">return fromNode.collection();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (next[i * N + j] == null) {</span><span class="s3">\n          </span><span class="s1">return cy.collection();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var path = cy.collection();</span><span class="s3">\n        </span><span class="s1">var prev = i;</span><span class="s3">\n        </span><span class="s1">var edge;</span><span class="s3">\n        </span><span class="s1">path.merge(fromNode);</span><span class="s3">\n        </span><span class="s1">while (i !== j) {</span><span class="s3">\n          </span><span class="s1">prev = i;</span><span class="s3">\n          </span><span class="s1">i = next[i * N + j];</span><span class="s3">\n          </span><span class="s1">edge = edgeNext[prev * N + i];</span><span class="s3">\n          </span><span class="s1">path.merge(edge);</span><span class="s3">\n          </span><span class="s1">path.merge(atIndex(i));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return path;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">} // floydWarshall</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">var bellmanFordDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">weight: function weight(edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">directed: false,</span><span class="s3">\n  </span><span class="s1">root: null</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$q = {</span><span class="s3">\n  </span><span class="s1">// Implemented from pseudocode from wikipedia</span><span class="s3">\n  </span><span class="s1">bellmanFord: function bellmanFord(options) {</span><span class="s3">\n    </span><span class="s1">var _this = this;</span><span class="s3">\n    </span><span class="s1">var _bellmanFordDefaults = bellmanFordDefaults(options),</span><span class="s3">\n      </span><span class="s1">weight = _bellmanFordDefaults.weight,</span><span class="s3">\n      </span><span class="s1">directed = _bellmanFordDefaults.directed,</span><span class="s3">\n      </span><span class="s1">root = _bellmanFordDefaults.root;</span><span class="s3">\n    </span><span class="s1">var weightFn = weight;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges,</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes;</span><span class="s3">\n    </span><span class="s1">var numNodes = nodes.length;</span><span class="s3">\n    </span><span class="s1">var infoMap = new Map$1();</span><span class="s3">\n    </span><span class="s1">var hasNegativeWeightCycle = false;</span><span class="s3">\n    </span><span class="s1">var negativeWeightCycles = [];</span><span class="s3">\n    </span><span class="s1">root = cy.collection(root)[0]; // in case selector passed</span><span class="s3">\n\n    </span><span class="s1">edges.unmergeBy(function (edge) {</span><span class="s3">\n      </span><span class="s1">return edge.isLoop();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var numEdges = edges.length;</span><span class="s3">\n    </span><span class="s1">var getInfo = function getInfo(node) {</span><span class="s3">\n      </span><span class="s1">var obj = infoMap.get(node.id());</span><span class="s3">\n      </span><span class="s1">if (!obj) {</span><span class="s3">\n        </span><span class="s1">obj = {};</span><span class="s3">\n        </span><span class="s1">infoMap.set(node.id(), obj);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var getNodeFromTo = function getNodeFromTo(to) {</span><span class="s3">\n      </span><span class="s1">return (string(to) ? cy.$(to) : to)[0];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var distanceTo = function distanceTo(to) {</span><span class="s3">\n      </span><span class="s1">return getInfo(getNodeFromTo(to)).dist;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var pathTo = function pathTo(to) {</span><span class="s3">\n      </span><span class="s1">var thisStart = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : root;</span><span class="s3">\n      </span><span class="s1">var end = getNodeFromTo(to);</span><span class="s3">\n      </span><span class="s1">var path = [];</span><span class="s3">\n      </span><span class="s1">var node = end;</span><span class="s3">\n      </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (node == null) {</span><span class="s3">\n          </span><span class="s1">return _this.spawn();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var _getInfo = getInfo(node),</span><span class="s3">\n          </span><span class="s1">edge = _getInfo.edge,</span><span class="s3">\n          </span><span class="s1">pred = _getInfo.pred;</span><span class="s3">\n        </span><span class="s1">path.unshift(node[0]);</span><span class="s3">\n        </span><span class="s1">if (node.same(thisStart) &amp;&amp; path.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (edge != null) {</span><span class="s3">\n          </span><span class="s1">path.unshift(edge);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">node = pred;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return eles.spawn(path);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Initializations { dist, pred, edge }</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; numNodes; i++) {</span><span class="s3">\n      </span><span class="s1">var node = nodes[i];</span><span class="s3">\n      </span><span class="s1">var info = getInfo(node);</span><span class="s3">\n      </span><span class="s1">if (node.same(root)) {</span><span class="s3">\n        </span><span class="s1">info.dist = 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">info.dist = Infinity;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">info.pred = null;</span><span class="s3">\n      </span><span class="s1">info.edge = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Edges relaxation</span><span class="s3">\n    </span><span class="s1">var replacedEdge = false;</span><span class="s3">\n    </span><span class="s1">var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {</span><span class="s3">\n      </span><span class="s1">var dist = info1.dist + weight;</span><span class="s3">\n      </span><span class="s1">if (dist &lt; info2.dist &amp;&amp; !edge.same(info1.edge)) {</span><span class="s3">\n        </span><span class="s1">info2.dist = dist;</span><span class="s3">\n        </span><span class="s1">info2.pred = node1;</span><span class="s3">\n        </span><span class="s1">info2.edge = edge;</span><span class="s3">\n        </span><span class="s1">replacedEdge = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (var _i = 1; _i &lt; numNodes; _i++) {</span><span class="s3">\n      </span><span class="s1">replacedEdge = false;</span><span class="s3">\n      </span><span class="s1">for (var e = 0; e &lt; numEdges; e++) {</span><span class="s3">\n        </span><span class="s1">var edge = edges[e];</span><span class="s3">\n        </span><span class="s1">var src = edge.source();</span><span class="s3">\n        </span><span class="s1">var tgt = edge.target();</span><span class="s3">\n        </span><span class="s1">var _weight = weightFn(edge);</span><span class="s3">\n        </span><span class="s1">var srcInfo = getInfo(src);</span><span class="s3">\n        </span><span class="s1">var tgtInfo = getInfo(tgt);</span><span class="s3">\n        </span><span class="s1">checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);</span><span class="s3">\n\n        </span><span class="s1">// If undirected graph, we need to take into account the 'reverse' edge</span><span class="s3">\n        </span><span class="s1">if (!directed) {</span><span class="s3">\n          </span><span class="s1">checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!replacedEdge) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (replacedEdge) {</span><span class="s3">\n      </span><span class="s1">// Check for negative weight cycles</span><span class="s3">\n      </span><span class="s1">var negativeWeightCycleIds = [];</span><span class="s3">\n      </span><span class="s1">for (var _e = 0; _e &lt; numEdges; _e++) {</span><span class="s3">\n        </span><span class="s1">var _edge = edges[_e];</span><span class="s3">\n        </span><span class="s1">var _src = _edge.source();</span><span class="s3">\n        </span><span class="s1">var _tgt = _edge.target();</span><span class="s3">\n        </span><span class="s1">var _weight2 = weightFn(_edge);</span><span class="s3">\n        </span><span class="s1">var srcDist = getInfo(_src).dist;</span><span class="s3">\n        </span><span class="s1">var tgtDist = getInfo(_tgt).dist;</span><span class="s3">\n        </span><span class="s1">if (srcDist + _weight2 &lt; tgtDist || !directed &amp;&amp; tgtDist + _weight2 &lt; srcDist) {</span><span class="s3">\n          </span><span class="s1">if (!hasNegativeWeightCycle) {</span><span class="s3">\n            </span><span class="s1">warn('Graph contains a negative weight cycle for Bellman-Ford');</span><span class="s3">\n            </span><span class="s1">hasNegativeWeightCycle = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (options.findNegativeWeightCycles !== false) {</span><span class="s3">\n            </span><span class="s1">var negativeNodes = [];</span><span class="s3">\n            </span><span class="s1">if (srcDist + _weight2 &lt; tgtDist) {</span><span class="s3">\n              </span><span class="s1">negativeNodes.push(_src);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!directed &amp;&amp; tgtDist + _weight2 &lt; srcDist) {</span><span class="s3">\n              </span><span class="s1">negativeNodes.push(_tgt);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var numNegativeNodes = negativeNodes.length;</span><span class="s3">\n            </span><span class="s1">for (var n = 0; n &lt; numNegativeNodes; n++) {</span><span class="s3">\n              </span><span class="s1">var start = negativeNodes[n];</span><span class="s3">\n              </span><span class="s1">var cycle = [start];</span><span class="s3">\n              </span><span class="s1">cycle.push(getInfo(start).edge);</span><span class="s3">\n              </span><span class="s1">var _node = getInfo(start).pred;</span><span class="s3">\n              </span><span class="s1">while (cycle.indexOf(_node) === -1) {</span><span class="s3">\n                </span><span class="s1">cycle.push(_node);</span><span class="s3">\n                </span><span class="s1">cycle.push(getInfo(_node).edge);</span><span class="s3">\n                </span><span class="s1">_node = getInfo(_node).pred;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">cycle = cycle.slice(cycle.indexOf(_node));</span><span class="s3">\n              </span><span class="s1">var smallestId = cycle[0].id();</span><span class="s3">\n              </span><span class="s1">var smallestIndex = 0;</span><span class="s3">\n              </span><span class="s1">for (var c = 2; c &lt; cycle.length; c += 2) {</span><span class="s3">\n                </span><span class="s1">if (cycle[c].id() &lt; smallestId) {</span><span class="s3">\n                  </span><span class="s1">smallestId = cycle[c].id();</span><span class="s3">\n                  </span><span class="s1">smallestIndex = c;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));</span><span class="s3">\n              </span><span class="s1">cycle.push(cycle[0]);</span><span class="s3">\n              </span><span class="s1">var cycleId = cycle.map(function (el) {</span><span class="s3">\n                </span><span class="s1">return el.id();</span><span class="s3">\n              </span><span class="s1">}).join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">if (negativeWeightCycleIds.indexOf(cycleId) === -1) {</span><span class="s3">\n                </span><span class="s1">negativeWeightCycles.push(eles.spawn(cycle));</span><span class="s3">\n                </span><span class="s1">negativeWeightCycleIds.push(cycleId);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">distanceTo: distanceTo,</span><span class="s3">\n      </span><span class="s1">pathTo: pathTo,</span><span class="s3">\n      </span><span class="s1">hasNegativeWeightCycle: hasNegativeWeightCycle,</span><span class="s3">\n      </span><span class="s1">negativeWeightCycles: negativeWeightCycles</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} // bellmanFord</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">var sqrt2 = Math.sqrt(2);</span><span class="s3">\n\n</span><span class="s1">// Function which colapses 2 (meta) nodes into one</span><span class="s3">\n</span><span class="s1">// Updates the remaining edge lists</span><span class="s3">\n</span><span class="s1">// Receives as a paramater the edge which causes the collapse</span><span class="s3">\n</span><span class="s1">var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {</span><span class="s3">\n  </span><span class="s1">if (remainingEdges.length === 0) {</span><span class="s3">\n    </span><span class="s1">error(</span><span class="s3">\&quot;</span><span class="s1">Karger-Stein must be run on a connected (sub)graph</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var edgeInfo = remainingEdges[edgeIndex];</span><span class="s3">\n  </span><span class="s1">var sourceIn = edgeInfo[1];</span><span class="s3">\n  </span><span class="s1">var targetIn = edgeInfo[2];</span><span class="s3">\n  </span><span class="s1">var partition1 = nodeMap[sourceIn];</span><span class="s3">\n  </span><span class="s1">var partition2 = nodeMap[targetIn];</span><span class="s3">\n  </span><span class="s1">var newEdges = remainingEdges; // re-use array</span><span class="s3">\n\n  </span><span class="s1">// Delete all edges between partition1 and partition2</span><span class="s3">\n  </span><span class="s1">for (var i = newEdges.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">var edge = newEdges[i];</span><span class="s3">\n    </span><span class="s1">var src = edge[1];</span><span class="s3">\n    </span><span class="s1">var tgt = edge[2];</span><span class="s3">\n    </span><span class="s1">if (nodeMap[src] === partition1 &amp;&amp; nodeMap[tgt] === partition2 || nodeMap[src] === partition2 &amp;&amp; nodeMap[tgt] === partition1) {</span><span class="s3">\n      </span><span class="s1">newEdges.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// All edges pointing to partition2 should now point to partition1</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; newEdges.length; _i++) {</span><span class="s3">\n    </span><span class="s1">var _edge = newEdges[_i];</span><span class="s3">\n    </span><span class="s1">if (_edge[1] === partition2) {</span><span class="s3">\n      </span><span class="s1">// Check source</span><span class="s3">\n      </span><span class="s1">newEdges[_i] = _edge.slice(); // copy</span><span class="s3">\n      </span><span class="s1">newEdges[_i][1] = partition1;</span><span class="s3">\n    </span><span class="s1">} else if (_edge[2] === partition2) {</span><span class="s3">\n      </span><span class="s1">// Check target</span><span class="s3">\n      </span><span class="s1">newEdges[_i] = _edge.slice(); // copy</span><span class="s3">\n      </span><span class="s1">newEdges[_i][2] = partition1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Move all nodes from partition2 to partition1</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; nodeMap.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">if (nodeMap[_i2] === partition2) {</span><span class="s3">\n      </span><span class="s1">nodeMap[_i2] = partition1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newEdges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Contracts a graph until we reach a certain number of meta nodes</span><span class="s3">\n</span><span class="s1">var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {</span><span class="s3">\n  </span><span class="s1">while (size &gt; sizeLimit) {</span><span class="s3">\n    </span><span class="s1">// Choose an edge randomly</span><span class="s3">\n    </span><span class="s1">var edgeIndex = Math.floor(Math.random() * remainingEdges.length);</span><span class="s3">\n\n    </span><span class="s1">// Collapse graph based on edge</span><span class="s3">\n    </span><span class="s1">remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);</span><span class="s3">\n    </span><span class="s1">size--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return remainingEdges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var elesfn$p = {</span><span class="s3">\n  </span><span class="s1">// Computes the minimum cut of an undirected graph</span><span class="s3">\n  </span><span class="s1">// Returns the correct answer with high probability</span><span class="s3">\n  </span><span class="s1">kargerStein: function kargerStein() {</span><span class="s3">\n    </span><span class="s1">var _this = this;</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes,</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges;</span><span class="s3">\n    </span><span class="s1">edges.unmergeBy(function (edge) {</span><span class="s3">\n      </span><span class="s1">return edge.isLoop();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var numNodes = nodes.length;</span><span class="s3">\n    </span><span class="s1">var numEdges = edges.length;</span><span class="s3">\n    </span><span class="s1">var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));</span><span class="s3">\n    </span><span class="s1">var stopSize = Math.floor(numNodes / sqrt2);</span><span class="s3">\n    </span><span class="s1">if (numNodes &lt; 2) {</span><span class="s3">\n      </span><span class="s1">error('At least 2 nodes are required for Karger-Stein algorithm');</span><span class="s3">\n      </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Now store edge destination as indexes</span><span class="s3">\n    </span><span class="s1">// Format for each edge (edge index, source node index, target node index)</span><span class="s3">\n    </span><span class="s1">var edgeIndexes = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; numEdges; i++) {</span><span class="s3">\n      </span><span class="s1">var e = edges[i];</span><span class="s3">\n      </span><span class="s1">edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We will store the best cut found here</span><span class="s3">\n    </span><span class="s1">var minCutSize = Infinity;</span><span class="s3">\n    </span><span class="s1">var minCutEdgeIndexes = [];</span><span class="s3">\n    </span><span class="s1">var minCutNodeMap = new Array(numNodes);</span><span class="s3">\n\n    </span><span class="s1">// Initial meta node partition</span><span class="s3">\n    </span><span class="s1">var metaNodeMap = new Array(numNodes);</span><span class="s3">\n    </span><span class="s1">var metaNodeMap2 = new Array(numNodes);</span><span class="s3">\n    </span><span class="s1">var copyNodesMap = function copyNodesMap(from, to) {</span><span class="s3">\n      </span><span class="s1">for (var _i3 = 0; _i3 &lt; numNodes; _i3++) {</span><span class="s3">\n        </span><span class="s1">to[_i3] = from[_i3];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Main loop</span><span class="s3">\n    </span><span class="s1">for (var iter = 0; iter &lt;= numIter; iter++) {</span><span class="s3">\n      </span><span class="s1">// Reset meta node partition</span><span class="s3">\n      </span><span class="s1">for (var _i4 = 0; _i4 &lt; numNodes; _i4++) {</span><span class="s3">\n        </span><span class="s1">metaNodeMap[_i4] = _i4;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Contract until stop point (stopSize nodes)</span><span class="s3">\n      </span><span class="s1">var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);</span><span class="s3">\n      </span><span class="s1">var edgesState2 = edgesState.slice(); // copy</span><span class="s3">\n\n      </span><span class="s1">// Create a copy of the colapsed nodes state</span><span class="s3">\n      </span><span class="s1">copyNodesMap(metaNodeMap, metaNodeMap2);</span><span class="s3">\n\n      </span><span class="s1">// Run 2 iterations starting in the stop state</span><span class="s3">\n      </span><span class="s1">var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);</span><span class="s3">\n      </span><span class="s1">var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);</span><span class="s3">\n\n      </span><span class="s1">// Is any of the 2 results the best cut so far?</span><span class="s3">\n      </span><span class="s1">if (res1.length &lt;= res2.length &amp;&amp; res1.length &lt; minCutSize) {</span><span class="s3">\n        </span><span class="s1">minCutSize = res1.length;</span><span class="s3">\n        </span><span class="s1">minCutEdgeIndexes = res1;</span><span class="s3">\n        </span><span class="s1">copyNodesMap(metaNodeMap, minCutNodeMap);</span><span class="s3">\n      </span><span class="s1">} else if (res2.length &lt;= res1.length &amp;&amp; res2.length &lt; minCutSize) {</span><span class="s3">\n        </span><span class="s1">minCutSize = res2.length;</span><span class="s3">\n        </span><span class="s1">minCutEdgeIndexes = res2;</span><span class="s3">\n        </span><span class="s1">copyNodesMap(metaNodeMap2, minCutNodeMap);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} // end of main loop</span><span class="s3">\n\n    </span><span class="s1">// Construct result</span><span class="s3">\n    </span><span class="s1">var cut = this.spawn(minCutEdgeIndexes.map(function (e) {</span><span class="s3">\n      </span><span class="s1">return edges[e[0]];</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">var partition1 = this.spawn();</span><span class="s3">\n    </span><span class="s1">var partition2 = this.spawn();</span><span class="s3">\n\n    </span><span class="s1">// traverse metaNodeMap for best cut</span><span class="s3">\n    </span><span class="s1">var witnessNodePartition = minCutNodeMap[0];</span><span class="s3">\n    </span><span class="s1">for (var _i5 = 0; _i5 &lt; minCutNodeMap.length; _i5++) {</span><span class="s3">\n      </span><span class="s1">var partitionId = minCutNodeMap[_i5];</span><span class="s3">\n      </span><span class="s1">var node = nodes[_i5];</span><span class="s3">\n      </span><span class="s1">if (partitionId === witnessNodePartition) {</span><span class="s3">\n        </span><span class="s1">partition1.merge(node);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">partition2.merge(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// construct components corresponding to each disjoint subset of nodes</span><span class="s3">\n    </span><span class="s1">var constructComponent = function constructComponent(subset) {</span><span class="s3">\n      </span><span class="s1">var component = _this.spawn();</span><span class="s3">\n      </span><span class="s1">subset.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">component.merge(node);</span><span class="s3">\n        </span><span class="s1">node.connectedEdges().forEach(function (edge) {</span><span class="s3">\n          </span><span class="s1">// ensure edge is within calling collection and edge is not in cut</span><span class="s3">\n          </span><span class="s1">if (_this.contains(edge) &amp;&amp; !cut.contains(edge)) {</span><span class="s3">\n            </span><span class="s1">component.merge(edge);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">return component;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var components = [constructComponent(partition1), constructComponent(partition2)];</span><span class="s3">\n    </span><span class="s1">var ret = {</span><span class="s3">\n      </span><span class="s1">cut: cut,</span><span class="s3">\n      </span><span class="s1">components: components,</span><span class="s3">\n      </span><span class="s1">// n.b. partitions are included to be compatible with the old api spec</span><span class="s3">\n      </span><span class="s1">// (could be removed in a future major version)</span><span class="s3">\n      </span><span class="s1">partition1: partition1,</span><span class="s3">\n      </span><span class="s1">partition2: partition2</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">var copyPosition = function copyPosition(p) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: p.x,</span><span class="s3">\n    </span><span class="s1">y: p.y</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var modelToRenderedPosition$1 = function modelToRenderedPosition(p, zoom, pan) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: p.x * zoom + pan.x,</span><span class="s3">\n    </span><span class="s1">y: p.y * zoom + pan.y</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: (p.x - pan.x) / zoom,</span><span class="s3">\n    </span><span class="s1">y: (p.y - pan.y) / zoom</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var array2point = function array2point(arr) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: arr[0],</span><span class="s3">\n    </span><span class="s1">y: arr[1]</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var min = function min(arr) {</span><span class="s3">\n  </span><span class="s1">var begin = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;</span><span class="s3">\n  </span><span class="s1">var end = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : arr.length;</span><span class="s3">\n  </span><span class="s1">var min = Infinity;</span><span class="s3">\n  </span><span class="s1">for (var i = begin; i &lt; end; i++) {</span><span class="s3">\n    </span><span class="s1">var val = arr[i];</span><span class="s3">\n    </span><span class="s1">if (isFinite(val)) {</span><span class="s3">\n      </span><span class="s1">min = Math.min(val, min);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return min;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var max = function max(arr) {</span><span class="s3">\n  </span><span class="s1">var begin = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;</span><span class="s3">\n  </span><span class="s1">var end = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : arr.length;</span><span class="s3">\n  </span><span class="s1">var max = -Infinity;</span><span class="s3">\n  </span><span class="s1">for (var i = begin; i &lt; end; i++) {</span><span class="s3">\n    </span><span class="s1">var val = arr[i];</span><span class="s3">\n    </span><span class="s1">if (isFinite(val)) {</span><span class="s3">\n      </span><span class="s1">max = Math.max(val, max);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return max;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var mean = function mean(arr) {</span><span class="s3">\n  </span><span class="s1">var begin = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;</span><span class="s3">\n  </span><span class="s1">var end = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : arr.length;</span><span class="s3">\n  </span><span class="s1">var total = 0;</span><span class="s3">\n  </span><span class="s1">var n = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = begin; i &lt; end; i++) {</span><span class="s3">\n    </span><span class="s1">var val = arr[i];</span><span class="s3">\n    </span><span class="s1">if (isFinite(val)) {</span><span class="s3">\n      </span><span class="s1">total += val;</span><span class="s3">\n      </span><span class="s1">n++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return total / n;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var median = function median(arr) {</span><span class="s3">\n  </span><span class="s1">var begin = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;</span><span class="s3">\n  </span><span class="s1">var end = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : arr.length;</span><span class="s3">\n  </span><span class="s1">var copy = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : true;</span><span class="s3">\n  </span><span class="s1">var sort = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true;</span><span class="s3">\n  </span><span class="s1">var includeHoles = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : true;</span><span class="s3">\n  </span><span class="s1">if (copy) {</span><span class="s3">\n    </span><span class="s1">arr = arr.slice(begin, end);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (end &lt; arr.length) {</span><span class="s3">\n      </span><span class="s1">arr.splice(end, arr.length - end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (begin &gt; 0) {</span><span class="s3">\n      </span><span class="s1">arr.splice(0, begin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start</span><span class="s3">\n  </span><span class="s1">var off = 0; // offset from non-finite values</span><span class="s3">\n  </span><span class="s1">for (var i = arr.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">var v = arr[i];</span><span class="s3">\n    </span><span class="s1">if (includeHoles) {</span><span class="s3">\n      </span><span class="s1">if (!isFinite(v)) {</span><span class="s3">\n        </span><span class="s1">arr[i] = -Infinity;</span><span class="s3">\n        </span><span class="s1">off++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// just remove it if we don't want to consider holes</span><span class="s3">\n      </span><span class="s1">arr.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (sort) {</span><span class="s3">\n    </span><span class="s1">arr.sort(function (a, b) {</span><span class="s3">\n      </span><span class="s1">return a - b;</span><span class="s3">\n    </span><span class="s1">}); // requires copy = true if you don't want to change the orig</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var len = arr.length;</span><span class="s3">\n  </span><span class="s1">var mid = Math.floor(len / 2);</span><span class="s3">\n  </span><span class="s1">if (len % 2 !== 0) {</span><span class="s3">\n    </span><span class="s1">return arr[mid + 1 + off];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return (arr[mid - 1 + off] + arr[mid + off]) / 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var deg2rad = function deg2rad(deg) {</span><span class="s3">\n  </span><span class="s1">return Math.PI * deg / 180;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {</span><span class="s3">\n  </span><span class="s1">return Math.atan2(dispY, dispX) - Math.PI / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var log2 = Math.log2 || function (n) {</span><span class="s3">\n  </span><span class="s1">return Math.log(n) / Math.log(2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var signum = function signum(x) {</span><span class="s3">\n  </span><span class="s1">if (x &gt; 0) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">} else if (x &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var dist = function dist(p1, p2) {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(sqdist(p1, p2));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sqdist = function sqdist(p1, p2) {</span><span class="s3">\n  </span><span class="s1">var dx = p2.x - p1.x;</span><span class="s3">\n  </span><span class="s1">var dy = p2.y - p1.y;</span><span class="s3">\n  </span><span class="s1">return dx * dx + dy * dy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var inPlaceSumNormalize = function inPlaceSumNormalize(v) {</span><span class="s3">\n  </span><span class="s1">var length = v.length;</span><span class="s3">\n\n  </span><span class="s1">// First, get sum of all elements</span><span class="s3">\n  </span><span class="s1">var total = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; length; i++) {</span><span class="s3">\n    </span><span class="s1">total += v[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Now, divide each by the sum of all elements</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; length; _i++) {</span><span class="s3">\n    </span><span class="s1">v[_i] = v[_i] / total;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return v;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves</span><span class="s3">\n</span><span class="s1">var qbezierAt = function qbezierAt(p0, p1, p2, t) {</span><span class="s3">\n  </span><span class="s1">return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: qbezierAt(p0.x, p1.x, p2.x, t),</span><span class="s3">\n    </span><span class="s1">y: qbezierAt(p0.y, p1.y, p2.y, t)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var lineAt = function lineAt(p0, p1, t, d) {</span><span class="s3">\n  </span><span class="s1">var vec = {</span><span class="s3">\n    </span><span class="s1">x: p1.x - p0.x,</span><span class="s3">\n    </span><span class="s1">y: p1.y - p0.y</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var vecDist = dist(p0, p1);</span><span class="s3">\n  </span><span class="s1">var normVec = {</span><span class="s3">\n    </span><span class="s1">x: vec.x / vecDist,</span><span class="s3">\n    </span><span class="s1">y: vec.y / vecDist</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">t = t == null ? 0 : t;</span><span class="s3">\n  </span><span class="s1">d = d != null ? d : t * vecDist;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: p0.x + normVec.x * d,</span><span class="s3">\n    </span><span class="s1">y: p0.y + normVec.y * d</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var bound = function bound(min, val, max) {</span><span class="s3">\n  </span><span class="s1">return Math.max(min, Math.min(max, val));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// makes a full bb (x1, y1, x2, y2, w, h) from implicit params</span><span class="s3">\n</span><span class="s1">var makeBoundingBox = function makeBoundingBox(bb) {</span><span class="s3">\n  </span><span class="s1">if (bb == null) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x1: Infinity,</span><span class="s3">\n      </span><span class="s1">y1: Infinity,</span><span class="s3">\n      </span><span class="s1">x2: -Infinity,</span><span class="s3">\n      </span><span class="s1">y2: -Infinity,</span><span class="s3">\n      </span><span class="s1">w: 0,</span><span class="s3">\n      </span><span class="s1">h: 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (bb.x1 != null &amp;&amp; bb.y1 != null) {</span><span class="s3">\n    </span><span class="s1">if (bb.x2 != null &amp;&amp; bb.y2 != null &amp;&amp; bb.x2 &gt;= bb.x1 &amp;&amp; bb.y2 &gt;= bb.y1) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x1: bb.x1,</span><span class="s3">\n        </span><span class="s1">y1: bb.y1,</span><span class="s3">\n        </span><span class="s1">x2: bb.x2,</span><span class="s3">\n        </span><span class="s1">y2: bb.y2,</span><span class="s3">\n        </span><span class="s1">w: bb.x2 - bb.x1,</span><span class="s3">\n        </span><span class="s1">h: bb.y2 - bb.y1</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else if (bb.w != null &amp;&amp; bb.h != null &amp;&amp; bb.w &gt;= 0 &amp;&amp; bb.h &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x1: bb.x1,</span><span class="s3">\n        </span><span class="s1">y1: bb.y1,</span><span class="s3">\n        </span><span class="s1">x2: bb.x1 + bb.w,</span><span class="s3">\n        </span><span class="s1">y2: bb.y1 + bb.h,</span><span class="s3">\n        </span><span class="s1">w: bb.w,</span><span class="s3">\n        </span><span class="s1">h: bb.h</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var copyBoundingBox = function copyBoundingBox(bb) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x1: bb.x1,</span><span class="s3">\n    </span><span class="s1">x2: bb.x2,</span><span class="s3">\n    </span><span class="s1">w: bb.w,</span><span class="s3">\n    </span><span class="s1">y1: bb.y1,</span><span class="s3">\n    </span><span class="s1">y2: bb.y2,</span><span class="s3">\n    </span><span class="s1">h: bb.h</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var clearBoundingBox = function clearBoundingBox(bb) {</span><span class="s3">\n  </span><span class="s1">bb.x1 = Infinity;</span><span class="s3">\n  </span><span class="s1">bb.y1 = Infinity;</span><span class="s3">\n  </span><span class="s1">bb.x2 = -Infinity;</span><span class="s3">\n  </span><span class="s1">bb.y2 = -Infinity;</span><span class="s3">\n  </span><span class="s1">bb.w = 0;</span><span class="s3">\n  </span><span class="s1">bb.h = 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var shiftBoundingBox = function shiftBoundingBox(bb, dx, dy) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x1: bb.x1 + dx,</span><span class="s3">\n    </span><span class="s1">x2: bb.x2 + dx,</span><span class="s3">\n    </span><span class="s1">y1: bb.y1 + dy,</span><span class="s3">\n    </span><span class="s1">y2: bb.y2 + dy,</span><span class="s3">\n    </span><span class="s1">w: bb.w,</span><span class="s3">\n    </span><span class="s1">h: bb.h</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateBoundingBox = function updateBoundingBox(bb1, bb2) {</span><span class="s3">\n  </span><span class="s1">// update bb1 with bb2 bounds</span><span class="s3">\n\n  </span><span class="s1">bb1.x1 = Math.min(bb1.x1, bb2.x1);</span><span class="s3">\n  </span><span class="s1">bb1.x2 = Math.max(bb1.x2, bb2.x2);</span><span class="s3">\n  </span><span class="s1">bb1.w = bb1.x2 - bb1.x1;</span><span class="s3">\n  </span><span class="s1">bb1.y1 = Math.min(bb1.y1, bb2.y1);</span><span class="s3">\n  </span><span class="s1">bb1.y2 = Math.max(bb1.y2, bb2.y2);</span><span class="s3">\n  </span><span class="s1">bb1.h = bb1.y2 - bb1.y1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {</span><span class="s3">\n  </span><span class="s1">bb.x1 = Math.min(bb.x1, x);</span><span class="s3">\n  </span><span class="s1">bb.x2 = Math.max(bb.x2, x);</span><span class="s3">\n  </span><span class="s1">bb.w = bb.x2 - bb.x1;</span><span class="s3">\n  </span><span class="s1">bb.y1 = Math.min(bb.y1, y);</span><span class="s3">\n  </span><span class="s1">bb.y2 = Math.max(bb.y2, y);</span><span class="s3">\n  </span><span class="s1">bb.h = bb.y2 - bb.y1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var expandBoundingBox = function expandBoundingBox(bb) {</span><span class="s3">\n  </span><span class="s1">var padding = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;</span><span class="s3">\n  </span><span class="s1">bb.x1 -= padding;</span><span class="s3">\n  </span><span class="s1">bb.x2 += padding;</span><span class="s3">\n  </span><span class="s1">bb.y1 -= padding;</span><span class="s3">\n  </span><span class="s1">bb.y2 += padding;</span><span class="s3">\n  </span><span class="s1">bb.w = bb.x2 - bb.x1;</span><span class="s3">\n  </span><span class="s1">bb.h = bb.y2 - bb.y1;</span><span class="s3">\n  </span><span class="s1">return bb;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {</span><span class="s3">\n  </span><span class="s1">var padding = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : [0];</span><span class="s3">\n  </span><span class="s1">var top, right, bottom, left;</span><span class="s3">\n  </span><span class="s1">if (padding.length === 1) {</span><span class="s3">\n    </span><span class="s1">top = right = bottom = left = padding[0];</span><span class="s3">\n  </span><span class="s1">} else if (padding.length === 2) {</span><span class="s3">\n    </span><span class="s1">top = bottom = padding[0];</span><span class="s3">\n    </span><span class="s1">left = right = padding[1];</span><span class="s3">\n  </span><span class="s1">} else if (padding.length === 4) {</span><span class="s3">\n    </span><span class="s1">var _padding = _slicedToArray(padding, 4);</span><span class="s3">\n    </span><span class="s1">top = _padding[0];</span><span class="s3">\n    </span><span class="s1">right = _padding[1];</span><span class="s3">\n    </span><span class="s1">bottom = _padding[2];</span><span class="s3">\n    </span><span class="s1">left = _padding[3];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">bb.x1 -= left;</span><span class="s3">\n  </span><span class="s1">bb.x2 += right;</span><span class="s3">\n  </span><span class="s1">bb.y1 -= top;</span><span class="s3">\n  </span><span class="s1">bb.y2 += bottom;</span><span class="s3">\n  </span><span class="s1">bb.w = bb.x2 - bb.x1;</span><span class="s3">\n  </span><span class="s1">bb.h = bb.y2 - bb.y1;</span><span class="s3">\n  </span><span class="s1">return bb;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// assign the values of bb2 into bb1</span><span class="s3">\n</span><span class="s1">var assignBoundingBox = function assignBoundingBox(bb1, bb2) {</span><span class="s3">\n  </span><span class="s1">bb1.x1 = bb2.x1;</span><span class="s3">\n  </span><span class="s1">bb1.y1 = bb2.y1;</span><span class="s3">\n  </span><span class="s1">bb1.x2 = bb2.x2;</span><span class="s3">\n  </span><span class="s1">bb1.y2 = bb2.y2;</span><span class="s3">\n  </span><span class="s1">bb1.w = bb1.x2 - bb1.x1;</span><span class="s3">\n  </span><span class="s1">bb1.h = bb1.y2 - bb1.y1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {</span><span class="s3">\n  </span><span class="s1">// case: one bb to right of other</span><span class="s3">\n  </span><span class="s1">if (bb1.x1 &gt; bb2.x2) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (bb2.x1 &gt; bb1.x2) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// case: one bb to left of other</span><span class="s3">\n  </span><span class="s1">if (bb1.x2 &lt; bb2.x1) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (bb2.x2 &lt; bb1.x1) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// case: one bb above other</span><span class="s3">\n  </span><span class="s1">if (bb1.y2 &lt; bb2.y1) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (bb2.y2 &lt; bb1.y1) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// case: one bb below other</span><span class="s3">\n  </span><span class="s1">if (bb1.y1 &gt; bb2.y2) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (bb2.y1 &gt; bb1.y2) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// otherwise, must have some overlap</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var inBoundingBox = function inBoundingBox(bb, x, y) {</span><span class="s3">\n  </span><span class="s1">return bb.x1 &lt;= x &amp;&amp; x &lt;= bb.x2 &amp;&amp; bb.y1 &lt;= y &amp;&amp; y &lt;= bb.y2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var pointInBoundingBox = function pointInBoundingBox(bb, pt) {</span><span class="s3">\n  </span><span class="s1">return inBoundingBox(bb, pt.x, pt.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {</span><span class="s3">\n  </span><span class="s1">return inBoundingBox(bb1, bb2.x1, bb2.y1) &amp;&amp; inBoundingBox(bb1, bb2.x2, bb2.y2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {</span><span class="s3">\n  </span><span class="s1">var radius = arguments.length &gt; 7 &amp;&amp; arguments[7] !== undefined ? arguments[7] : 'auto';</span><span class="s3">\n  </span><span class="s1">var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;</span><span class="s3">\n  </span><span class="s1">var halfWidth = width / 2;</span><span class="s3">\n  </span><span class="s1">var halfHeight = height / 2;</span><span class="s3">\n  </span><span class="s1">cornerRadius = Math.min(cornerRadius, halfWidth, halfHeight);</span><span class="s3">\n  </span><span class="s1">var doWidth = cornerRadius !== halfWidth,</span><span class="s3">\n    </span><span class="s1">doHeight = cornerRadius !== halfHeight;</span><span class="s3">\n\n  </span><span class="s1">// Check intersections with straight line segments</span><span class="s3">\n  </span><span class="s1">var straightLineIntersections;</span><span class="s3">\n\n  </span><span class="s1">// Top segment, left to right</span><span class="s3">\n  </span><span class="s1">if (doWidth) {</span><span class="s3">\n    </span><span class="s1">var topStartX = nodeX - halfWidth + cornerRadius - padding;</span><span class="s3">\n    </span><span class="s1">var topStartY = nodeY - halfHeight - padding;</span><span class="s3">\n    </span><span class="s1">var topEndX = nodeX + halfWidth - cornerRadius + padding;</span><span class="s3">\n    </span><span class="s1">var topEndY = topStartY;</span><span class="s3">\n    </span><span class="s1">straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);</span><span class="s3">\n    </span><span class="s1">if (straightLineIntersections.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return straightLineIntersections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Right segment, top to bottom</span><span class="s3">\n  </span><span class="s1">if (doHeight) {</span><span class="s3">\n    </span><span class="s1">var rightStartX = nodeX + halfWidth + padding;</span><span class="s3">\n    </span><span class="s1">var rightStartY = nodeY - halfHeight + cornerRadius - padding;</span><span class="s3">\n    </span><span class="s1">var rightEndX = rightStartX;</span><span class="s3">\n    </span><span class="s1">var rightEndY = nodeY + halfHeight - cornerRadius + padding;</span><span class="s3">\n    </span><span class="s1">straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);</span><span class="s3">\n    </span><span class="s1">if (straightLineIntersections.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return straightLineIntersections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Bottom segment, left to right</span><span class="s3">\n  </span><span class="s1">if (doWidth) {</span><span class="s3">\n    </span><span class="s1">var bottomStartX = nodeX - halfWidth + cornerRadius - padding;</span><span class="s3">\n    </span><span class="s1">var bottomStartY = nodeY + halfHeight + padding;</span><span class="s3">\n    </span><span class="s1">var bottomEndX = nodeX + halfWidth - cornerRadius + padding;</span><span class="s3">\n    </span><span class="s1">var bottomEndY = bottomStartY;</span><span class="s3">\n    </span><span class="s1">straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);</span><span class="s3">\n    </span><span class="s1">if (straightLineIntersections.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return straightLineIntersections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Left segment, top to bottom</span><span class="s3">\n  </span><span class="s1">if (doHeight) {</span><span class="s3">\n    </span><span class="s1">var leftStartX = nodeX - halfWidth - padding;</span><span class="s3">\n    </span><span class="s1">var leftStartY = nodeY - halfHeight + cornerRadius - padding;</span><span class="s3">\n    </span><span class="s1">var leftEndX = leftStartX;</span><span class="s3">\n    </span><span class="s1">var leftEndY = nodeY + halfHeight - cornerRadius + padding;</span><span class="s3">\n    </span><span class="s1">straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);</span><span class="s3">\n    </span><span class="s1">if (straightLineIntersections.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return straightLineIntersections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check intersections with arc segments</span><span class="s3">\n  </span><span class="s1">var arcIntersections;</span><span class="s3">\n\n  </span><span class="s1">// Top Left</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var topLeftCenterX = nodeX - halfWidth + cornerRadius;</span><span class="s3">\n    </span><span class="s1">var topLeftCenterY = nodeY - halfHeight + cornerRadius;</span><span class="s3">\n    </span><span class="s1">arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);</span><span class="s3">\n\n    </span><span class="s1">// Ensure the intersection is on the desired quarter of the circle</span><span class="s3">\n    </span><span class="s1">if (arcIntersections.length &gt; 0 &amp;&amp; arcIntersections[0] &lt;= topLeftCenterX &amp;&amp; arcIntersections[1] &lt;= topLeftCenterY) {</span><span class="s3">\n      </span><span class="s1">return [arcIntersections[0], arcIntersections[1]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Top Right</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var topRightCenterX = nodeX + halfWidth - cornerRadius;</span><span class="s3">\n    </span><span class="s1">var topRightCenterY = nodeY - halfHeight + cornerRadius;</span><span class="s3">\n    </span><span class="s1">arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);</span><span class="s3">\n\n    </span><span class="s1">// Ensure the intersection is on the desired quarter of the circle</span><span class="s3">\n    </span><span class="s1">if (arcIntersections.length &gt; 0 &amp;&amp; arcIntersections[0] &gt;= topRightCenterX &amp;&amp; arcIntersections[1] &lt;= topRightCenterY) {</span><span class="s3">\n      </span><span class="s1">return [arcIntersections[0], arcIntersections[1]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Bottom Right</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var bottomRightCenterX = nodeX + halfWidth - cornerRadius;</span><span class="s3">\n    </span><span class="s1">var bottomRightCenterY = nodeY + halfHeight - cornerRadius;</span><span class="s3">\n    </span><span class="s1">arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);</span><span class="s3">\n\n    </span><span class="s1">// Ensure the intersection is on the desired quarter of the circle</span><span class="s3">\n    </span><span class="s1">if (arcIntersections.length &gt; 0 &amp;&amp; arcIntersections[0] &gt;= bottomRightCenterX &amp;&amp; arcIntersections[1] &gt;= bottomRightCenterY) {</span><span class="s3">\n      </span><span class="s1">return [arcIntersections[0], arcIntersections[1]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Bottom Left</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;</span><span class="s3">\n    </span><span class="s1">var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;</span><span class="s3">\n    </span><span class="s1">arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);</span><span class="s3">\n\n    </span><span class="s1">// Ensure the intersection is on the desired quarter of the circle</span><span class="s3">\n    </span><span class="s1">if (arcIntersections.length &gt; 0 &amp;&amp; arcIntersections[0] &lt;= bottomLeftCenterX &amp;&amp; arcIntersections[1] &gt;= bottomLeftCenterY) {</span><span class="s3">\n      </span><span class="s1">return [arcIntersections[0], arcIntersections[1]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return []; // if nothing</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {</span><span class="s3">\n  </span><span class="s1">var t = tolerance;</span><span class="s3">\n  </span><span class="s1">var x1 = Math.min(lx1, lx2);</span><span class="s3">\n  </span><span class="s1">var x2 = Math.max(lx1, lx2);</span><span class="s3">\n  </span><span class="s1">var y1 = Math.min(ly1, ly2);</span><span class="s3">\n  </span><span class="s1">var y2 = Math.max(ly1, ly2);</span><span class="s3">\n  </span><span class="s1">return x1 - t &lt;= x &amp;&amp; x &lt;= x2 + t &amp;&amp; y1 - t &lt;= y &amp;&amp; y &lt;= y2 + t;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {</span><span class="s3">\n  </span><span class="s1">var bb = {</span><span class="s3">\n    </span><span class="s1">x1: Math.min(x1, x3, x2) - tolerance,</span><span class="s3">\n    </span><span class="s1">x2: Math.max(x1, x3, x2) + tolerance,</span><span class="s3">\n    </span><span class="s1">y1: Math.min(y1, y3, y2) - tolerance,</span><span class="s3">\n    </span><span class="s1">y2: Math.max(y1, y3, y2) + tolerance</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// if outside the rough bounding box for the bezier, then it can't be a hit</span><span class="s3">\n  </span><span class="s1">if (x &lt; bb.x1 || x &gt; bb.x2 || y &lt; bb.y1 || y &gt; bb.y2) {</span><span class="s3">\n    </span><span class="s1">// console.log('bezier out of rough bb')</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// console.log('do more expensive check');</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var solveQuadratic = function solveQuadratic(a, b, c, val) {</span><span class="s3">\n  </span><span class="s1">c -= val;</span><span class="s3">\n  </span><span class="s1">var r = b * b - 4 * a * c;</span><span class="s3">\n  </span><span class="s1">if (r &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var sqrtR = Math.sqrt(r);</span><span class="s3">\n  </span><span class="s1">var denom = 2 * a;</span><span class="s3">\n  </span><span class="s1">var root1 = (-b + sqrtR) / denom;</span><span class="s3">\n  </span><span class="s1">var root2 = (-b - sqrtR) / denom;</span><span class="s3">\n  </span><span class="s1">return [root1, root2];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var solveCubic = function solveCubic(a, b, c, d, result) {</span><span class="s3">\n  </span><span class="s1">// Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where</span><span class="s3">\n  </span><span class="s1">// r is the real component, i is the imaginary component</span><span class="s3">\n\n  </span><span class="s1">// An implementation of the Cardano method from the year 1545</span><span class="s3">\n  </span><span class="s1">// http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots</span><span class="s3">\n\n  </span><span class="s1">var epsilon = 0.00001;</span><span class="s3">\n\n  </span><span class="s1">// avoid division by zero while keeping the overall expression close in value</span><span class="s3">\n  </span><span class="s1">if (a === 0) {</span><span class="s3">\n    </span><span class="s1">a = epsilon;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">b /= a;</span><span class="s3">\n  </span><span class="s1">c /= a;</span><span class="s3">\n  </span><span class="s1">d /= a;</span><span class="s3">\n  </span><span class="s1">var discriminant, q, r, dum1, s, t, term1, r13;</span><span class="s3">\n  </span><span class="s1">q = (3.0 * c - b * b) / 9.0;</span><span class="s3">\n  </span><span class="s1">r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));</span><span class="s3">\n  </span><span class="s1">r /= 54.0;</span><span class="s3">\n  </span><span class="s1">discriminant = q * q * q + r * r;</span><span class="s3">\n  </span><span class="s1">result[1] = 0;</span><span class="s3">\n  </span><span class="s1">term1 = b / 3.0;</span><span class="s3">\n  </span><span class="s1">if (discriminant &gt; 0) {</span><span class="s3">\n    </span><span class="s1">s = r + Math.sqrt(discriminant);</span><span class="s3">\n    </span><span class="s1">s = s &lt; 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);</span><span class="s3">\n    </span><span class="s1">t = r - Math.sqrt(discriminant);</span><span class="s3">\n    </span><span class="s1">t = t &lt; 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);</span><span class="s3">\n    </span><span class="s1">result[0] = -term1 + s + t;</span><span class="s3">\n    </span><span class="s1">term1 += (s + t) / 2.0;</span><span class="s3">\n    </span><span class="s1">result[4] = result[2] = -term1;</span><span class="s3">\n    </span><span class="s1">term1 = Math.sqrt(3.0) * (-t + s) / 2;</span><span class="s3">\n    </span><span class="s1">result[3] = term1;</span><span class="s3">\n    </span><span class="s1">result[5] = -term1;</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">result[5] = result[3] = 0;</span><span class="s3">\n  </span><span class="s1">if (discriminant === 0) {</span><span class="s3">\n    </span><span class="s1">r13 = r &lt; 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);</span><span class="s3">\n    </span><span class="s1">result[0] = -term1 + 2.0 * r13;</span><span class="s3">\n    </span><span class="s1">result[4] = result[2] = -(r13 + term1);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">q = -q;</span><span class="s3">\n  </span><span class="s1">dum1 = q * q * q;</span><span class="s3">\n  </span><span class="s1">dum1 = Math.acos(r / Math.sqrt(dum1));</span><span class="s3">\n  </span><span class="s1">r13 = 2.0 * Math.sqrt(q);</span><span class="s3">\n  </span><span class="s1">result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);</span><span class="s3">\n  </span><span class="s1">result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);</span><span class="s3">\n  </span><span class="s1">result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);</span><span class="s3">\n  </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {</span><span class="s3">\n  </span><span class="s1">// Find minimum distance by using the minimum of the distance</span><span class="s3">\n  </span><span class="s1">// function between the given point and the curve</span><span class="s3">\n\n  </span><span class="s1">// This gives the coefficients of the resulting cubic equation</span><span class="s3">\n  </span><span class="s1">// whose roots tell us where a possible minimum is</span><span class="s3">\n  </span><span class="s1">// (Coefficients are divided by 4)</span><span class="s3">\n\n  </span><span class="s1">var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;</span><span class="s3">\n  </span><span class="s1">var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;</span><span class="s3">\n  </span><span class="s1">var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;</span><span class="s3">\n  </span><span class="s1">var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;</span><span class="s3">\n\n  </span><span class="s1">// debug(</span><span class="s3">\&quot;</span><span class="s1">coefficients: </span><span class="s3">\&quot; </span><span class="s1">+ a / a + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ b / a + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ c / a + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ d / a);</span><span class="s3">\n\n  </span><span class="s1">var roots = [];</span><span class="s3">\n\n  </span><span class="s1">// Use the cubic solving algorithm</span><span class="s3">\n  </span><span class="s1">solveCubic(a, b, c, d, roots);</span><span class="s3">\n  </span><span class="s1">var zeroThreshold = 0.0000001;</span><span class="s3">\n  </span><span class="s1">var params = [];</span><span class="s3">\n  </span><span class="s1">for (var index = 0; index &lt; 6; index += 2) {</span><span class="s3">\n    </span><span class="s1">if (Math.abs(roots[index + 1]) &lt; zeroThreshold &amp;&amp; roots[index] &gt;= 0 &amp;&amp; roots[index] &lt;= 1.0) {</span><span class="s3">\n      </span><span class="s1">params.push(roots[index]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">params.push(1.0);</span><span class="s3">\n  </span><span class="s1">params.push(0.0);</span><span class="s3">\n  </span><span class="s1">var minDistanceSquared = -1;</span><span class="s3">\n  </span><span class="s1">var curX, curY, distSquared;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; params.length; i++) {</span><span class="s3">\n    </span><span class="s1">curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;</span><span class="s3">\n    </span><span class="s1">curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;</span><span class="s3">\n    </span><span class="s1">distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);</span><span class="s3">\n    </span><span class="s1">// debug('distance for param ' + params[i] + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ Math.sqrt(distSquared));</span><span class="s3">\n    </span><span class="s1">if (minDistanceSquared &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">if (distSquared &lt; minDistanceSquared) {</span><span class="s3">\n        </span><span class="s1">minDistanceSquared = distSquared;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">minDistanceSquared = distSquared;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return minDistanceSquared;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {</span><span class="s3">\n  </span><span class="s1">var offset = [x - x1, y - y1];</span><span class="s3">\n  </span><span class="s1">var line = [x2 - x1, y2 - y1];</span><span class="s3">\n  </span><span class="s1">var lineSq = line[0] * line[0] + line[1] * line[1];</span><span class="s3">\n  </span><span class="s1">var hypSq = offset[0] * offset[0] + offset[1] * offset[1];</span><span class="s3">\n  </span><span class="s1">var dotProduct = offset[0] * line[0] + offset[1] * line[1];</span><span class="s3">\n  </span><span class="s1">var adjSq = dotProduct * dotProduct / lineSq;</span><span class="s3">\n  </span><span class="s1">if (dotProduct &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return hypSq;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (adjSq &gt; lineSq) {</span><span class="s3">\n    </span><span class="s1">return (x - x2) * (x - x2) + (y - y2) * (y - y2);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return hypSq - adjSq;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {</span><span class="s3">\n  </span><span class="s1">var x1, y1, x2, y2;</span><span class="s3">\n  </span><span class="s1">var y3;</span><span class="s3">\n\n  </span><span class="s1">// Intersect with vertical line through (x, y)</span><span class="s3">\n  </span><span class="s1">var up = 0;</span><span class="s3">\n  </span><span class="s1">// let down = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; points.length / 2; i++) {</span><span class="s3">\n    </span><span class="s1">x1 = points[i * 2];</span><span class="s3">\n    </span><span class="s1">y1 = points[i * 2 + 1];</span><span class="s3">\n    </span><span class="s1">if (i + 1 &lt; points.length / 2) {</span><span class="s3">\n      </span><span class="s1">x2 = points[(i + 1) * 2];</span><span class="s3">\n      </span><span class="s1">y2 = points[(i + 1) * 2 + 1];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">x2 = points[(i + 1 - points.length / 2) * 2];</span><span class="s3">\n      </span><span class="s1">y2 = points[(i + 1 - points.length / 2) * 2 + 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (x1 == x &amp;&amp; x2 == x) ; else if (x1 &gt;= x &amp;&amp; x &gt;= x2 || x1 &lt;= x &amp;&amp; x &lt;= x2) {</span><span class="s3">\n      </span><span class="s1">y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;</span><span class="s3">\n      </span><span class="s1">if (y3 &gt; y) {</span><span class="s3">\n        </span><span class="s1">up++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// if( y3 &lt; y ){</span><span class="s3">\n      </span><span class="s1">// down++;</span><span class="s3">\n      </span><span class="s1">// }</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (up % 2 === 0) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {</span><span class="s3">\n  </span><span class="s1">var transformedPoints = new Array(basePoints.length);</span><span class="s3">\n\n  </span><span class="s1">// Gives negative angle</span><span class="s3">\n  </span><span class="s1">var angle;</span><span class="s3">\n  </span><span class="s1">if (direction[0] != null) {</span><span class="s3">\n    </span><span class="s1">angle = Math.atan(direction[1] / direction[0]);</span><span class="s3">\n    </span><span class="s1">if (direction[0] &lt; 0) {</span><span class="s3">\n      </span><span class="s1">angle = angle + Math.PI / 2;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">angle = -angle - Math.PI / 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">angle = direction;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var cos = Math.cos(-angle);</span><span class="s3">\n  </span><span class="s1">var sin = Math.sin(-angle);</span><span class="s3">\n\n  </span><span class="s1">//    console.log(</span><span class="s3">\&quot;</span><span class="s1">base: </span><span class="s3">\&quot; </span><span class="s1">+ basePoints);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; transformedPoints.length / 2; i++) {</span><span class="s3">\n    </span><span class="s1">transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);</span><span class="s3">\n    </span><span class="s1">transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);</span><span class="s3">\n    </span><span class="s1">transformedPoints[i * 2] += centerX;</span><span class="s3">\n    </span><span class="s1">transformedPoints[i * 2 + 1] += centerY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var points;</span><span class="s3">\n  </span><span class="s1">if (padding &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var expandedLineSet = expandPolygon(transformedPoints, -padding);</span><span class="s3">\n    </span><span class="s1">points = joinLines(expandedLineSet);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">points = transformedPoints;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pointInsidePolygonPoints(x, y, points);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height, corners) {</span><span class="s3">\n  </span><span class="s1">var cutPolygonPoints = new Array(basePoints.length * 2);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; corners.length; i++) {</span><span class="s3">\n    </span><span class="s1">var corner = corners[i];</span><span class="s3">\n    </span><span class="s1">cutPolygonPoints[i * 4 + 0] = corner.startX;</span><span class="s3">\n    </span><span class="s1">cutPolygonPoints[i * 4 + 1] = corner.startY;</span><span class="s3">\n    </span><span class="s1">cutPolygonPoints[i * 4 + 2] = corner.stopX;</span><span class="s3">\n    </span><span class="s1">cutPolygonPoints[i * 4 + 3] = corner.stopY;</span><span class="s3">\n    </span><span class="s1">var squaredDistance = Math.pow(corner.cx - x, 2) + Math.pow(corner.cy - y, 2);</span><span class="s3">\n    </span><span class="s1">if (squaredDistance &lt;= Math.pow(corner.radius, 2)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pointInsidePolygonPoints(x, y, cutPolygonPoints);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var joinLines = function joinLines(lineSet) {</span><span class="s3">\n  </span><span class="s1">var vertices = new Array(lineSet.length / 2);</span><span class="s3">\n  </span><span class="s1">var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;</span><span class="s3">\n  </span><span class="s1">var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; lineSet.length / 4; i++) {</span><span class="s3">\n    </span><span class="s1">currentLineStartX = lineSet[i * 4];</span><span class="s3">\n    </span><span class="s1">currentLineStartY = lineSet[i * 4 + 1];</span><span class="s3">\n    </span><span class="s1">currentLineEndX = lineSet[i * 4 + 2];</span><span class="s3">\n    </span><span class="s1">currentLineEndY = lineSet[i * 4 + 3];</span><span class="s3">\n    </span><span class="s1">if (i &lt; lineSet.length / 4 - 1) {</span><span class="s3">\n      </span><span class="s1">nextLineStartX = lineSet[(i + 1) * 4];</span><span class="s3">\n      </span><span class="s1">nextLineStartY = lineSet[(i + 1) * 4 + 1];</span><span class="s3">\n      </span><span class="s1">nextLineEndX = lineSet[(i + 1) * 4 + 2];</span><span class="s3">\n      </span><span class="s1">nextLineEndY = lineSet[(i + 1) * 4 + 3];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">nextLineStartX = lineSet[0];</span><span class="s3">\n      </span><span class="s1">nextLineStartY = lineSet[1];</span><span class="s3">\n      </span><span class="s1">nextLineEndX = lineSet[2];</span><span class="s3">\n      </span><span class="s1">nextLineEndY = lineSet[3];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);</span><span class="s3">\n    </span><span class="s1">vertices[i * 2] = intersection[0];</span><span class="s3">\n    </span><span class="s1">vertices[i * 2 + 1] = intersection[1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return vertices;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var expandPolygon = function expandPolygon(points, pad) {</span><span class="s3">\n  </span><span class="s1">var expandedLineSet = new Array(points.length * 2);</span><span class="s3">\n  </span><span class="s1">var currentPointX, currentPointY, nextPointX, nextPointY;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; points.length / 2; i++) {</span><span class="s3">\n    </span><span class="s1">currentPointX = points[i * 2];</span><span class="s3">\n    </span><span class="s1">currentPointY = points[i * 2 + 1];</span><span class="s3">\n    </span><span class="s1">if (i &lt; points.length / 2 - 1) {</span><span class="s3">\n      </span><span class="s1">nextPointX = points[(i + 1) * 2];</span><span class="s3">\n      </span><span class="s1">nextPointY = points[(i + 1) * 2 + 1];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">nextPointX = points[0];</span><span class="s3">\n      </span><span class="s1">nextPointY = points[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]</span><span class="s3">\n\n    </span><span class="s1">// Assume CCW polygon winding</span><span class="s3">\n\n    </span><span class="s1">var offsetX = nextPointY - currentPointY;</span><span class="s3">\n    </span><span class="s1">var offsetY = -(nextPointX - currentPointX);</span><span class="s3">\n\n    </span><span class="s1">// Normalize</span><span class="s3">\n    </span><span class="s1">var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);</span><span class="s3">\n    </span><span class="s1">var normalizedOffsetX = offsetX / offsetLength;</span><span class="s3">\n    </span><span class="s1">var normalizedOffsetY = offsetY / offsetLength;</span><span class="s3">\n    </span><span class="s1">expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;</span><span class="s3">\n    </span><span class="s1">expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;</span><span class="s3">\n    </span><span class="s1">expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;</span><span class="s3">\n    </span><span class="s1">expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return expandedLineSet;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {</span><span class="s3">\n  </span><span class="s1">var dispX = centerX - x;</span><span class="s3">\n  </span><span class="s1">var dispY = centerY - y;</span><span class="s3">\n  </span><span class="s1">dispX /= ellipseWradius;</span><span class="s3">\n  </span><span class="s1">dispY /= ellipseHradius;</span><span class="s3">\n  </span><span class="s1">var len = Math.sqrt(dispX * dispX + dispY * dispY);</span><span class="s3">\n  </span><span class="s1">var newLength = len - 1;</span><span class="s3">\n  </span><span class="s1">if (newLength &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var lenProportion = newLength / len;</span><span class="s3">\n  </span><span class="s1">return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {</span><span class="s3">\n  </span><span class="s1">x -= centerX;</span><span class="s3">\n  </span><span class="s1">y -= centerY;</span><span class="s3">\n  </span><span class="s1">x /= width / 2 + padding;</span><span class="s3">\n  </span><span class="s1">y /= height / 2 + padding;</span><span class="s3">\n  </span><span class="s1">return x * x + y * y &lt;= 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Returns intersections of increasing distance from line's start point</span><span class="s3">\n</span><span class="s1">var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {</span><span class="s3">\n  </span><span class="s1">// Calculate d, direction vector of line</span><span class="s3">\n  </span><span class="s1">var d = [x2 - x1, y2 - y1]; // Direction vector of line</span><span class="s3">\n  </span><span class="s1">var f = [x1 - centerX, y1 - centerY];</span><span class="s3">\n  </span><span class="s1">var a = d[0] * d[0] + d[1] * d[1];</span><span class="s3">\n  </span><span class="s1">var b = 2 * (f[0] * d[0] + f[1] * d[1]);</span><span class="s3">\n  </span><span class="s1">var c = f[0] * f[0] + f[1] * f[1] - radius * radius;</span><span class="s3">\n  </span><span class="s1">var discriminant = b * b - 4 * a * c;</span><span class="s3">\n  </span><span class="s1">if (discriminant &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);</span><span class="s3">\n  </span><span class="s1">var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);</span><span class="s3">\n  </span><span class="s1">var tMin = Math.min(t1, t2);</span><span class="s3">\n  </span><span class="s1">var tMax = Math.max(t1, t2);</span><span class="s3">\n  </span><span class="s1">var inRangeParams = [];</span><span class="s3">\n  </span><span class="s1">if (tMin &gt;= 0 &amp;&amp; tMin &lt;= 1) {</span><span class="s3">\n    </span><span class="s1">inRangeParams.push(tMin);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (tMax &gt;= 0 &amp;&amp; tMax &lt;= 1) {</span><span class="s3">\n    </span><span class="s1">inRangeParams.push(tMax);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (inRangeParams.length === 0) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var nearIntersectionX = inRangeParams[0] * d[0] + x1;</span><span class="s3">\n  </span><span class="s1">var nearIntersectionY = inRangeParams[0] * d[1] + y1;</span><span class="s3">\n  </span><span class="s1">if (inRangeParams.length &gt; 1) {</span><span class="s3">\n    </span><span class="s1">if (inRangeParams[0] == inRangeParams[1]) {</span><span class="s3">\n      </span><span class="s1">return [nearIntersectionX, nearIntersectionY];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var farIntersectionX = inRangeParams[1] * d[0] + x1;</span><span class="s3">\n      </span><span class="s1">var farIntersectionY = inRangeParams[1] * d[1] + y1;</span><span class="s3">\n      </span><span class="s1">return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return [nearIntersectionX, nearIntersectionY];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var midOfThree = function midOfThree(a, b, c) {</span><span class="s3">\n  </span><span class="s1">if (b &lt;= a &amp;&amp; a &lt;= c || c &lt;= a &amp;&amp; a &lt;= b) {</span><span class="s3">\n    </span><span class="s1">return a;</span><span class="s3">\n  </span><span class="s1">} else if (a &lt;= b &amp;&amp; b &lt;= c || c &lt;= b &amp;&amp; b &lt;= a) {</span><span class="s3">\n    </span><span class="s1">return b;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return c;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// (x1,y1)=&gt;(x2,y2) intersect with (x3,y3)=&gt;(x4,y4)</span><span class="s3">\n</span><span class="s1">var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {</span><span class="s3">\n  </span><span class="s1">var dx13 = x1 - x3;</span><span class="s3">\n  </span><span class="s1">var dx21 = x2 - x1;</span><span class="s3">\n  </span><span class="s1">var dx43 = x4 - x3;</span><span class="s3">\n  </span><span class="s1">var dy13 = y1 - y3;</span><span class="s3">\n  </span><span class="s1">var dy21 = y2 - y1;</span><span class="s3">\n  </span><span class="s1">var dy43 = y4 - y3;</span><span class="s3">\n  </span><span class="s1">var ua_t = dx43 * dy13 - dy43 * dx13;</span><span class="s3">\n  </span><span class="s1">var ub_t = dx21 * dy13 - dy21 * dx13;</span><span class="s3">\n  </span><span class="s1">var u_b = dy43 * dx21 - dx43 * dy21;</span><span class="s3">\n  </span><span class="s1">if (u_b !== 0) {</span><span class="s3">\n    </span><span class="s1">var ua = ua_t / u_b;</span><span class="s3">\n    </span><span class="s1">var ub = ub_t / u_b;</span><span class="s3">\n    </span><span class="s1">var flptThreshold = 0.001;</span><span class="s3">\n    </span><span class="s1">var _min = 0 - flptThreshold;</span><span class="s3">\n    </span><span class="s1">var _max = 1 + flptThreshold;</span><span class="s3">\n    </span><span class="s1">if (_min &lt;= ua &amp;&amp; ua &lt;= _max &amp;&amp; _min &lt;= ub &amp;&amp; ub &lt;= _max) {</span><span class="s3">\n      </span><span class="s1">return [x1 + ua * dx21, y1 + ua * dy21];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!infiniteLines) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return [x1 + ua * dx21, y1 + ua * dy21];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (ua_t === 0 || ub_t === 0) {</span><span class="s3">\n      </span><span class="s1">// Parallel, coincident lines. Check if overlap</span><span class="s3">\n\n      </span><span class="s1">// Check endpoint of second line</span><span class="s3">\n      </span><span class="s1">if (midOfThree(x1, x2, x4) === x4) {</span><span class="s3">\n        </span><span class="s1">return [x4, y4];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check start point of second line</span><span class="s3">\n      </span><span class="s1">if (midOfThree(x1, x2, x3) === x3) {</span><span class="s3">\n        </span><span class="s1">return [x3, y3];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Endpoint of first line</span><span class="s3">\n      </span><span class="s1">if (midOfThree(x3, x4, x2) === x2) {</span><span class="s3">\n        </span><span class="s1">return [x2, y2];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Parallel, non-coincident</span><span class="s3">\n      </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )</span><span class="s3">\n</span><span class="s1">// intersect a node polygon (pts transformed)</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )</span><span class="s3">\n</span><span class="s1">// intersect the points (no transform)</span><span class="s3">\n</span><span class="s1">var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {</span><span class="s3">\n  </span><span class="s1">var intersections = [];</span><span class="s3">\n  </span><span class="s1">var intersection;</span><span class="s3">\n  </span><span class="s1">var transformedPoints = new Array(basePoints.length);</span><span class="s3">\n  </span><span class="s1">var doTransform = true;</span><span class="s3">\n  </span><span class="s1">if (width == null) {</span><span class="s3">\n    </span><span class="s1">doTransform = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var points;</span><span class="s3">\n  </span><span class="s1">if (doTransform) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; transformedPoints.length / 2; i++) {</span><span class="s3">\n      </span><span class="s1">transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;</span><span class="s3">\n      </span><span class="s1">transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (padding &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var expandedLineSet = expandPolygon(transformedPoints, -padding);</span><span class="s3">\n      </span><span class="s1">points = joinLines(expandedLineSet);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">points = transformedPoints;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">points = basePoints;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var currentX, currentY, nextX, nextY;</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; points.length / 2; _i2++) {</span><span class="s3">\n    </span><span class="s1">currentX = points[_i2 * 2];</span><span class="s3">\n    </span><span class="s1">currentY = points[_i2 * 2 + 1];</span><span class="s3">\n    </span><span class="s1">if (_i2 &lt; points.length / 2 - 1) {</span><span class="s3">\n      </span><span class="s1">nextX = points[(_i2 + 1) * 2];</span><span class="s3">\n      </span><span class="s1">nextY = points[(_i2 + 1) * 2 + 1];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">nextX = points[0];</span><span class="s3">\n      </span><span class="s1">nextY = points[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);</span><span class="s3">\n    </span><span class="s1">if (intersection.length !== 0) {</span><span class="s3">\n      </span><span class="s1">intersections.push(intersection[0], intersection[1]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return intersections;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding, corners) {</span><span class="s3">\n  </span><span class="s1">var intersections = [];</span><span class="s3">\n  </span><span class="s1">var intersection;</span><span class="s3">\n  </span><span class="s1">var lines = new Array(basePoints.length * 2);</span><span class="s3">\n  </span><span class="s1">corners.forEach(function (corner, i) {</span><span class="s3">\n    </span><span class="s1">if (i === 0) {</span><span class="s3">\n      </span><span class="s1">lines[lines.length - 2] = corner.startX;</span><span class="s3">\n      </span><span class="s1">lines[lines.length - 1] = corner.startY;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">lines[i * 4 - 2] = corner.startX;</span><span class="s3">\n      </span><span class="s1">lines[i * 4 - 1] = corner.startY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lines[i * 4] = corner.stopX;</span><span class="s3">\n    </span><span class="s1">lines[i * 4 + 1] = corner.stopY;</span><span class="s3">\n    </span><span class="s1">intersection = intersectLineCircle(x, y, centerX, centerY, corner.cx, corner.cy, corner.radius);</span><span class="s3">\n    </span><span class="s1">if (intersection.length !== 0) {</span><span class="s3">\n      </span><span class="s1">intersections.push(intersection[0], intersection[1]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; lines.length / 4; i++) {</span><span class="s3">\n    </span><span class="s1">intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[i * 4], lines[i * 4 + 1], lines[i * 4 + 2], lines[i * 4 + 3], false);</span><span class="s3">\n    </span><span class="s1">if (intersection.length !== 0) {</span><span class="s3">\n      </span><span class="s1">intersections.push(intersection[0], intersection[1]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (intersections.length &gt; 2) {</span><span class="s3">\n    </span><span class="s1">var lowestIntersection = [intersections[0], intersections[1]];</span><span class="s3">\n    </span><span class="s1">var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);</span><span class="s3">\n    </span><span class="s1">for (var _i3 = 1; _i3 &lt; intersections.length / 2; _i3++) {</span><span class="s3">\n      </span><span class="s1">var squaredDistance = Math.pow(intersections[_i3 * 2] - x, 2) + Math.pow(intersections[_i3 * 2 + 1] - y, 2);</span><span class="s3">\n      </span><span class="s1">if (squaredDistance &lt;= lowestSquaredDistance) {</span><span class="s3">\n        </span><span class="s1">lowestIntersection[0] = intersections[_i3 * 2];</span><span class="s3">\n        </span><span class="s1">lowestIntersection[1] = intersections[_i3 * 2 + 1];</span><span class="s3">\n        </span><span class="s1">lowestSquaredDistance = squaredDistance;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return lowestIntersection;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return intersections;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var shortenIntersection = function shortenIntersection(intersection, offset, amount) {</span><span class="s3">\n  </span><span class="s1">var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];</span><span class="s3">\n  </span><span class="s1">var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);</span><span class="s3">\n  </span><span class="s1">var lenRatio = (length - amount) / length;</span><span class="s3">\n  </span><span class="s1">if (lenRatio &lt; 0) {</span><span class="s3">\n    </span><span class="s1">lenRatio = 0.00001;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {</span><span class="s3">\n  </span><span class="s1">var points = generateUnitNgonPoints(sides, rotationRadians);</span><span class="s3">\n  </span><span class="s1">points = fitPolygonToSquare(points);</span><span class="s3">\n  </span><span class="s1">return points;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var fitPolygonToSquare = function fitPolygonToSquare(points) {</span><span class="s3">\n  </span><span class="s1">var x, y;</span><span class="s3">\n  </span><span class="s1">var sides = points.length / 2;</span><span class="s3">\n  </span><span class="s1">var minX = Infinity,</span><span class="s3">\n    </span><span class="s1">minY = Infinity,</span><span class="s3">\n    </span><span class="s1">maxX = -Infinity,</span><span class="s3">\n    </span><span class="s1">maxY = -Infinity;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; sides; i++) {</span><span class="s3">\n    </span><span class="s1">x = points[2 * i];</span><span class="s3">\n    </span><span class="s1">y = points[2 * i + 1];</span><span class="s3">\n    </span><span class="s1">minX = Math.min(minX, x);</span><span class="s3">\n    </span><span class="s1">maxX = Math.max(maxX, x);</span><span class="s3">\n    </span><span class="s1">minY = Math.min(minY, y);</span><span class="s3">\n    </span><span class="s1">maxY = Math.max(maxY, y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// stretch factors</span><span class="s3">\n  </span><span class="s1">var sx = 2 / (maxX - minX);</span><span class="s3">\n  </span><span class="s1">var sy = 2 / (maxY - minY);</span><span class="s3">\n  </span><span class="s1">for (var _i4 = 0; _i4 &lt; sides; _i4++) {</span><span class="s3">\n    </span><span class="s1">x = points[2 * _i4] = points[2 * _i4] * sx;</span><span class="s3">\n    </span><span class="s1">y = points[2 * _i4 + 1] = points[2 * _i4 + 1] * sy;</span><span class="s3">\n    </span><span class="s1">minX = Math.min(minX, x);</span><span class="s3">\n    </span><span class="s1">maxX = Math.max(maxX, x);</span><span class="s3">\n    </span><span class="s1">minY = Math.min(minY, y);</span><span class="s3">\n    </span><span class="s1">maxY = Math.max(maxY, y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (minY &lt; -1) {</span><span class="s3">\n    </span><span class="s1">for (var _i5 = 0; _i5 &lt; sides; _i5++) {</span><span class="s3">\n      </span><span class="s1">y = points[2 * _i5 + 1] = points[2 * _i5 + 1] + (-1 - minY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return points;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {</span><span class="s3">\n  </span><span class="s1">var increment = 1.0 / sides * 2 * Math.PI;</span><span class="s3">\n  </span><span class="s1">var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;</span><span class="s3">\n  </span><span class="s1">startAngle += rotationRadians;</span><span class="s3">\n  </span><span class="s1">var points = new Array(sides * 2);</span><span class="s3">\n  </span><span class="s1">var currentAngle;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; sides; i++) {</span><span class="s3">\n    </span><span class="s1">currentAngle = i * increment + startAngle;</span><span class="s3">\n    </span><span class="s1">points[2 * i] = Math.cos(currentAngle); // x</span><span class="s3">\n    </span><span class="s1">points[2 * i + 1] = Math.sin(-currentAngle); // y</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return points;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Set the default radius, unless half of width or height is smaller than default</span><span class="s3">\n</span><span class="s1">var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {</span><span class="s3">\n  </span><span class="s1">return Math.min(width / 4, height / 4, 8);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Set the default radius</span><span class="s3">\n</span><span class="s1">var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {</span><span class="s3">\n  </span><span class="s1">return Math.min(width / 10, height / 10, 8);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getCutRectangleCornerLength = function getCutRectangleCornerLength() {</span><span class="s3">\n  </span><span class="s1">return 8;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {</span><span class="s3">\n  </span><span class="s1">return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get curve width, height, and control point position offsets as a percentage of node height / width</span><span class="s3">\n</span><span class="s1">var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">heightOffset: Math.min(15, 0.05 * height),</span><span class="s3">\n    </span><span class="s1">widthOffset: Math.min(100, 0.25 * width),</span><span class="s3">\n    </span><span class="s1">ctrlPtOffsetPct: 0.05</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var pageRankDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">dampingFactor: 0.8,</span><span class="s3">\n  </span><span class="s1">precision: 0.000001,</span><span class="s3">\n  </span><span class="s1">iterations: 200,</span><span class="s3">\n  </span><span class="s1">weight: function weight(edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$o = {</span><span class="s3">\n  </span><span class="s1">pageRank: function pageRank(options) {</span><span class="s3">\n    </span><span class="s1">var _pageRankDefaults = pageRankDefaults(options),</span><span class="s3">\n      </span><span class="s1">dampingFactor = _pageRankDefaults.dampingFactor,</span><span class="s3">\n      </span><span class="s1">precision = _pageRankDefaults.precision,</span><span class="s3">\n      </span><span class="s1">iterations = _pageRankDefaults.iterations,</span><span class="s3">\n      </span><span class="s1">weight = _pageRankDefaults.weight;</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">var _this$byGroup = this.byGroup(),</span><span class="s3">\n      </span><span class="s1">nodes = _this$byGroup.nodes,</span><span class="s3">\n      </span><span class="s1">edges = _this$byGroup.edges;</span><span class="s3">\n    </span><span class="s1">var numNodes = nodes.length;</span><span class="s3">\n    </span><span class="s1">var numNodesSqd = numNodes * numNodes;</span><span class="s3">\n    </span><span class="s1">var numEdges = edges.length;</span><span class="s3">\n\n    </span><span class="s1">// Construct transposed adjacency matrix</span><span class="s3">\n    </span><span class="s1">// First lets have a zeroed matrix of the right size</span><span class="s3">\n    </span><span class="s1">// We'll also keep track of the sum of each column</span><span class="s3">\n    </span><span class="s1">var matrix = new Array(numNodesSqd);</span><span class="s3">\n    </span><span class="s1">var columnSum = new Array(numNodes);</span><span class="s3">\n    </span><span class="s1">var additionalProb = (1 - dampingFactor) / numNodes;</span><span class="s3">\n\n    </span><span class="s1">// Create null matrix</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; numNodes; i++) {</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; numNodes; j++) {</span><span class="s3">\n        </span><span class="s1">var n = i * numNodes + j;</span><span class="s3">\n        </span><span class="s1">matrix[n] = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">columnSum[i] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Now, process edges</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; numEdges; _i++) {</span><span class="s3">\n      </span><span class="s1">var edge = edges[_i];</span><span class="s3">\n      </span><span class="s1">var srcId = edge.data('source');</span><span class="s3">\n      </span><span class="s1">var tgtId = edge.data('target');</span><span class="s3">\n\n      </span><span class="s1">// Don't include loops in the matrix</span><span class="s3">\n      </span><span class="s1">if (srcId === tgtId) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var s = nodes.indexOfId(srcId);</span><span class="s3">\n      </span><span class="s1">var t = nodes.indexOfId(tgtId);</span><span class="s3">\n      </span><span class="s1">var w = weight(edge);</span><span class="s3">\n      </span><span class="s1">var _n = t * numNodes + s;</span><span class="s3">\n\n      </span><span class="s1">// Update matrix</span><span class="s3">\n      </span><span class="s1">matrix[_n] += w;</span><span class="s3">\n\n      </span><span class="s1">// Update column sum</span><span class="s3">\n      </span><span class="s1">columnSum[s] += w;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Add additional probability based on damping factor</span><span class="s3">\n    </span><span class="s1">// Also, take into account columns that have sum = 0</span><span class="s3">\n    </span><span class="s1">var p = 1.0 / numNodes + additionalProb; // Shorthand</span><span class="s3">\n\n    </span><span class="s1">// Traverse matrix, column by column</span><span class="s3">\n    </span><span class="s1">for (var _j = 0; _j &lt; numNodes; _j++) {</span><span class="s3">\n      </span><span class="s1">if (columnSum[_j] === 0) {</span><span class="s3">\n        </span><span class="s1">// No 'links' out from node jth, assume equal probability for each possible node</span><span class="s3">\n        </span><span class="s1">for (var _i2 = 0; _i2 &lt; numNodes; _i2++) {</span><span class="s3">\n          </span><span class="s1">var _n2 = _i2 * numNodes + _j;</span><span class="s3">\n          </span><span class="s1">matrix[_n2] = p;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Node jth has outgoing link, compute normalized probabilities</span><span class="s3">\n        </span><span class="s1">for (var _i3 = 0; _i3 &lt; numNodes; _i3++) {</span><span class="s3">\n          </span><span class="s1">var _n3 = _i3 * numNodes + _j;</span><span class="s3">\n          </span><span class="s1">matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Compute dominant eigenvector using power method</span><span class="s3">\n    </span><span class="s1">var eigenvector = new Array(numNodes);</span><span class="s3">\n    </span><span class="s1">var temp = new Array(numNodes);</span><span class="s3">\n    </span><span class="s1">var previous;</span><span class="s3">\n\n    </span><span class="s1">// Start with a vector of all 1's</span><span class="s3">\n    </span><span class="s1">// Also, initialize a null vector which will be used as shorthand</span><span class="s3">\n    </span><span class="s1">for (var _i4 = 0; _i4 &lt; numNodes; _i4++) {</span><span class="s3">\n      </span><span class="s1">eigenvector[_i4] = 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var iter = 0; iter &lt; iterations; iter++) {</span><span class="s3">\n      </span><span class="s1">// Temp array with all 0's</span><span class="s3">\n      </span><span class="s1">for (var _i5 = 0; _i5 &lt; numNodes; _i5++) {</span><span class="s3">\n        </span><span class="s1">temp[_i5] = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Multiply matrix with previous result</span><span class="s3">\n      </span><span class="s1">for (var _i6 = 0; _i6 &lt; numNodes; _i6++) {</span><span class="s3">\n        </span><span class="s1">for (var _j2 = 0; _j2 &lt; numNodes; _j2++) {</span><span class="s3">\n          </span><span class="s1">var _n4 = _i6 * numNodes + _j2;</span><span class="s3">\n          </span><span class="s1">temp[_i6] += matrix[_n4] * eigenvector[_j2];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">inPlaceSumNormalize(temp);</span><span class="s3">\n      </span><span class="s1">previous = eigenvector;</span><span class="s3">\n      </span><span class="s1">eigenvector = temp;</span><span class="s3">\n      </span><span class="s1">temp = previous;</span><span class="s3">\n      </span><span class="s1">var diff = 0;</span><span class="s3">\n      </span><span class="s1">// Compute difference (squared module) of both vectors</span><span class="s3">\n      </span><span class="s1">for (var _i7 = 0; _i7 &lt; numNodes; _i7++) {</span><span class="s3">\n        </span><span class="s1">var delta = previous[_i7] - eigenvector[_i7];</span><span class="s3">\n        </span><span class="s1">diff += delta * delta;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If difference is less than the desired threshold, stop iterating</span><span class="s3">\n      </span><span class="s1">if (diff &lt; precision) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Construct result</span><span class="s3">\n    </span><span class="s1">var res = {</span><span class="s3">\n      </span><span class="s1">rank: function rank(node) {</span><span class="s3">\n        </span><span class="s1">node = cy.collection(node)[0];</span><span class="s3">\n        </span><span class="s1">return eigenvector[nodes.indexOf(node)];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">} // pageRank</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">var defaults$f = defaults$g({</span><span class="s3">\n  </span><span class="s1">root: null,</span><span class="s3">\n  </span><span class="s1">weight: function weight(edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">directed: false,</span><span class="s3">\n  </span><span class="s1">alpha: 0</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$n = {</span><span class="s3">\n  </span><span class="s1">degreeCentralityNormalized: function degreeCentralityNormalized(options) {</span><span class="s3">\n    </span><span class="s1">options = defaults$f(options);</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n    </span><span class="s1">var numNodes = nodes.length;</span><span class="s3">\n    </span><span class="s1">if (!options.directed) {</span><span class="s3">\n      </span><span class="s1">var degrees = {};</span><span class="s3">\n      </span><span class="s1">var maxDegree = 0;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; numNodes; i++) {</span><span class="s3">\n        </span><span class="s1">var node = nodes[i];</span><span class="s3">\n\n        </span><span class="s1">// add current node to the current options object and call degreeCentrality</span><span class="s3">\n        </span><span class="s1">options.root = node;</span><span class="s3">\n        </span><span class="s1">var currDegree = this.degreeCentrality(options);</span><span class="s3">\n        </span><span class="s1">if (maxDegree &lt; currDegree.degree) {</span><span class="s3">\n          </span><span class="s1">maxDegree = currDegree.degree;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">degrees[node.id()] = currDegree.degree;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">degree: function degree(node) {</span><span class="s3">\n          </span><span class="s1">if (maxDegree === 0) {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (string(node)) {</span><span class="s3">\n            </span><span class="s1">// from is a selector string</span><span class="s3">\n            </span><span class="s1">node = cy.filter(node);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return degrees[node.id()] / maxDegree;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var indegrees = {};</span><span class="s3">\n      </span><span class="s1">var outdegrees = {};</span><span class="s3">\n      </span><span class="s1">var maxIndegree = 0;</span><span class="s3">\n      </span><span class="s1">var maxOutdegree = 0;</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; numNodes; _i++) {</span><span class="s3">\n        </span><span class="s1">var _node = nodes[_i];</span><span class="s3">\n        </span><span class="s1">var id = _node.id();</span><span class="s3">\n\n        </span><span class="s1">// add current node to the current options object and call degreeCentrality</span><span class="s3">\n        </span><span class="s1">options.root = _node;</span><span class="s3">\n        </span><span class="s1">var _currDegree = this.degreeCentrality(options);</span><span class="s3">\n        </span><span class="s1">if (maxIndegree &lt; _currDegree.indegree) maxIndegree = _currDegree.indegree;</span><span class="s3">\n        </span><span class="s1">if (maxOutdegree &lt; _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;</span><span class="s3">\n        </span><span class="s1">indegrees[id] = _currDegree.indegree;</span><span class="s3">\n        </span><span class="s1">outdegrees[id] = _currDegree.outdegree;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">indegree: function indegree(node) {</span><span class="s3">\n          </span><span class="s1">if (maxIndegree == 0) {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (string(node)) {</span><span class="s3">\n            </span><span class="s1">// from is a selector string</span><span class="s3">\n            </span><span class="s1">node = cy.filter(node);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return indegrees[node.id()] / maxIndegree;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">outdegree: function outdegree(node) {</span><span class="s3">\n          </span><span class="s1">if (maxOutdegree === 0) {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (string(node)) {</span><span class="s3">\n            </span><span class="s1">// from is a selector string</span><span class="s3">\n            </span><span class="s1">node = cy.filter(node);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return outdegrees[node.id()] / maxOutdegree;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// degreeCentralityNormalized</span><span class="s3">\n\n  </span><span class="s1">// Implemented from the algorithm in Opsahl's paper</span><span class="s3">\n  </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Node centrality in weighted networks: Generalizing degree and shortest paths</span><span class="s3">\&quot;\n  </span><span class="s1">// check the heading 2 </span><span class="s3">\&quot;</span><span class="s1">Degree</span><span class="s3">\&quot;\n  </span><span class="s1">degreeCentrality: function degreeCentrality(options) {</span><span class="s3">\n    </span><span class="s1">options = defaults$f(options);</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var callingEles = this;</span><span class="s3">\n    </span><span class="s1">var _options = options,</span><span class="s3">\n      </span><span class="s1">root = _options.root,</span><span class="s3">\n      </span><span class="s1">weight = _options.weight,</span><span class="s3">\n      </span><span class="s1">directed = _options.directed,</span><span class="s3">\n      </span><span class="s1">alpha = _options.alpha;</span><span class="s3">\n    </span><span class="s1">root = cy.collection(root)[0];</span><span class="s3">\n    </span><span class="s1">if (!directed) {</span><span class="s3">\n      </span><span class="s1">var connEdges = root.connectedEdges().intersection(callingEles);</span><span class="s3">\n      </span><span class="s1">var k = connEdges.length;</span><span class="s3">\n      </span><span class="s1">var s = 0;</span><span class="s3">\n\n      </span><span class="s1">// Now, sum edge weights</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; connEdges.length; i++) {</span><span class="s3">\n        </span><span class="s1">s += weight(connEdges[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var edges = root.connectedEdges();</span><span class="s3">\n      </span><span class="s1">var incoming = edges.filter(function (edge) {</span><span class="s3">\n        </span><span class="s1">return edge.target().same(root) &amp;&amp; callingEles.has(edge);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">var outgoing = edges.filter(function (edge) {</span><span class="s3">\n        </span><span class="s1">return edge.source().same(root) &amp;&amp; callingEles.has(edge);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">var k_in = incoming.length;</span><span class="s3">\n      </span><span class="s1">var k_out = outgoing.length;</span><span class="s3">\n      </span><span class="s1">var s_in = 0;</span><span class="s3">\n      </span><span class="s1">var s_out = 0;</span><span class="s3">\n\n      </span><span class="s1">// Now, sum incoming edge weights</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; incoming.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">s_in += weight(incoming[_i2]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Now, sum outgoing edge weights</span><span class="s3">\n      </span><span class="s1">for (var _i3 = 0; _i3 &lt; outgoing.length; _i3++) {</span><span class="s3">\n        </span><span class="s1">s_out += weight(outgoing[_i3]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),</span><span class="s3">\n        </span><span class="s1">outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} // degreeCentrality</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">// nice, short mathematical alias</span><span class="s3">\n</span><span class="s1">elesfn$n.dc = elesfn$n.degreeCentrality;</span><span class="s3">\n</span><span class="s1">elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;</span><span class="s3">\n\n</span><span class="s1">var defaults$e = defaults$g({</span><span class="s3">\n  </span><span class="s1">harmonic: true,</span><span class="s3">\n  </span><span class="s1">weight: function weight() {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">directed: false,</span><span class="s3">\n  </span><span class="s1">root: null</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$m = {</span><span class="s3">\n  </span><span class="s1">closenessCentralityNormalized: function closenessCentralityNormalized(options) {</span><span class="s3">\n    </span><span class="s1">var _defaults = defaults$e(options),</span><span class="s3">\n      </span><span class="s1">harmonic = _defaults.harmonic,</span><span class="s3">\n      </span><span class="s1">weight = _defaults.weight,</span><span class="s3">\n      </span><span class="s1">directed = _defaults.directed;</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var closenesses = {};</span><span class="s3">\n    </span><span class="s1">var maxCloseness = 0;</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n    </span><span class="s1">var fw = this.floydWarshall({</span><span class="s3">\n      </span><span class="s1">weight: weight,</span><span class="s3">\n      </span><span class="s1">directed: directed</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// Compute closeness for every node and find the maximum closeness</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">var currCloseness = 0;</span><span class="s3">\n      </span><span class="s1">var node_i = nodes[i];</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; nodes.length; j++) {</span><span class="s3">\n        </span><span class="s1">if (i !== j) {</span><span class="s3">\n          </span><span class="s1">var d = fw.distance(node_i, nodes[j]);</span><span class="s3">\n          </span><span class="s1">if (harmonic) {</span><span class="s3">\n            </span><span class="s1">currCloseness += 1 / d;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">currCloseness += d;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!harmonic) {</span><span class="s3">\n        </span><span class="s1">currCloseness = 1 / currCloseness;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (maxCloseness &lt; currCloseness) {</span><span class="s3">\n        </span><span class="s1">maxCloseness = currCloseness;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">closenesses[node_i.id()] = currCloseness;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">closeness: function closeness(node) {</span><span class="s3">\n        </span><span class="s1">if (maxCloseness == 0) {</span><span class="s3">\n          </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (string(node)) {</span><span class="s3">\n          </span><span class="s1">// from is a selector string</span><span class="s3">\n          </span><span class="s1">node = cy.filter(node)[0].id();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// from is a node</span><span class="s3">\n          </span><span class="s1">node = node.id();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return closenesses[node] / maxCloseness;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Implemented from pseudocode from wikipedia</span><span class="s3">\n  </span><span class="s1">closenessCentrality: function closenessCentrality(options) {</span><span class="s3">\n    </span><span class="s1">var _defaults2 = defaults$e(options),</span><span class="s3">\n      </span><span class="s1">root = _defaults2.root,</span><span class="s3">\n      </span><span class="s1">weight = _defaults2.weight,</span><span class="s3">\n      </span><span class="s1">directed = _defaults2.directed,</span><span class="s3">\n      </span><span class="s1">harmonic = _defaults2.harmonic;</span><span class="s3">\n    </span><span class="s1">root = this.filter(root)[0];</span><span class="s3">\n\n    </span><span class="s1">// we need distance from this node to every other node</span><span class="s3">\n    </span><span class="s1">var dijkstra = this.dijkstra({</span><span class="s3">\n      </span><span class="s1">root: root,</span><span class="s3">\n      </span><span class="s1">weight: weight,</span><span class="s3">\n      </span><span class="s1">directed: directed</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var totalDistance = 0;</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">var n = nodes[i];</span><span class="s3">\n      </span><span class="s1">if (!n.same(root)) {</span><span class="s3">\n        </span><span class="s1">var d = dijkstra.distanceTo(n);</span><span class="s3">\n        </span><span class="s1">if (harmonic) {</span><span class="s3">\n          </span><span class="s1">totalDistance += 1 / d;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">totalDistance += d;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return harmonic ? totalDistance : 1 / totalDistance;</span><span class="s3">\n  </span><span class="s1">} // closenessCentrality</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">// nice, short mathematical alias</span><span class="s3">\n</span><span class="s1">elesfn$m.cc = elesfn$m.closenessCentrality;</span><span class="s3">\n</span><span class="s1">elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;</span><span class="s3">\n\n</span><span class="s1">var defaults$d = defaults$g({</span><span class="s3">\n  </span><span class="s1">weight: null,</span><span class="s3">\n  </span><span class="s1">directed: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$l = {</span><span class="s3">\n  </span><span class="s1">// Implemented from the algorithm in the paper </span><span class="s3">\&quot;</span><span class="s1">On Variants of Shortest-Path Betweenness Centrality and their Generic Computation</span><span class="s3">\&quot; </span><span class="s1">by Ulrik Brandes</span><span class="s3">\n  </span><span class="s1">betweennessCentrality: function betweennessCentrality(options) {</span><span class="s3">\n    </span><span class="s1">var _defaults = defaults$d(options),</span><span class="s3">\n      </span><span class="s1">directed = _defaults.directed,</span><span class="s3">\n      </span><span class="s1">weight = _defaults.weight;</span><span class="s3">\n    </span><span class="s1">var weighted = weight != null;</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n\n    </span><span class="s1">// starting</span><span class="s3">\n    </span><span class="s1">var V = this.nodes();</span><span class="s3">\n    </span><span class="s1">var A = {};</span><span class="s3">\n    </span><span class="s1">var _C = {};</span><span class="s3">\n    </span><span class="s1">var max = 0;</span><span class="s3">\n    </span><span class="s1">var C = {</span><span class="s3">\n      </span><span class="s1">set: function set(key, val) {</span><span class="s3">\n        </span><span class="s1">_C[key] = val;</span><span class="s3">\n        </span><span class="s1">if (val &gt; max) {</span><span class="s3">\n          </span><span class="s1">max = val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">get: function get(key) {</span><span class="s3">\n        </span><span class="s1">return _C[key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// A contains the neighborhoods of every node</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; V.length; i++) {</span><span class="s3">\n      </span><span class="s1">var v = V[i];</span><span class="s3">\n      </span><span class="s1">var vid = v.id();</span><span class="s3">\n      </span><span class="s1">if (directed) {</span><span class="s3">\n        </span><span class="s1">A[vid] = v.outgoers().nodes(); // get outgoers of every node</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">C.set(vid, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n      </span><span class="s1">var sid = V[s].id();</span><span class="s3">\n      </span><span class="s1">var S = []; // stack</span><span class="s3">\n      </span><span class="s1">var P = {};</span><span class="s3">\n      </span><span class="s1">var g = {};</span><span class="s3">\n      </span><span class="s1">var d = {};</span><span class="s3">\n      </span><span class="s1">var Q = new Heap(function (a, b) {</span><span class="s3">\n        </span><span class="s1">return d[a] - d[b];</span><span class="s3">\n      </span><span class="s1">}); // queue</span><span class="s3">\n\n      </span><span class="s1">// init dictionaries</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; V.length; _i++) {</span><span class="s3">\n        </span><span class="s1">var _vid = V[_i].id();</span><span class="s3">\n        </span><span class="s1">P[_vid] = [];</span><span class="s3">\n        </span><span class="s1">g[_vid] = 0;</span><span class="s3">\n        </span><span class="s1">d[_vid] = Infinity;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">g[sid] = 1; // sigma</span><span class="s3">\n      </span><span class="s1">d[sid] = 0; // distance to s</span><span class="s3">\n\n      </span><span class="s1">Q.push(sid);</span><span class="s3">\n      </span><span class="s1">while (!Q.empty()) {</span><span class="s3">\n        </span><span class="s1">var _v = Q.pop();</span><span class="s3">\n        </span><span class="s1">S.push(_v);</span><span class="s3">\n        </span><span class="s1">if (weighted) {</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; A[_v].length; j++) {</span><span class="s3">\n            </span><span class="s1">var w = A[_v][j];</span><span class="s3">\n            </span><span class="s1">var vEle = cy.getElementById(_v);</span><span class="s3">\n            </span><span class="s1">var edge = undefined;</span><span class="s3">\n            </span><span class="s1">if (vEle.edgesTo(w).length &gt; 0) {</span><span class="s3">\n              </span><span class="s1">edge = vEle.edgesTo(w)[0];</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">edge = w.edgesTo(vEle)[0];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var edgeWeight = weight(edge);</span><span class="s3">\n            </span><span class="s1">w = w.id();</span><span class="s3">\n            </span><span class="s1">if (d[w] &gt; d[_v] + edgeWeight) {</span><span class="s3">\n              </span><span class="s1">d[w] = d[_v] + edgeWeight;</span><span class="s3">\n              </span><span class="s1">if (Q.nodes.indexOf(w) &lt; 0) {</span><span class="s3">\n                </span><span class="s1">//if w is not in Q</span><span class="s3">\n                </span><span class="s1">Q.push(w);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">// update position if w is in Q</span><span class="s3">\n                </span><span class="s1">Q.updateItem(w);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">g[w] = 0;</span><span class="s3">\n              </span><span class="s1">P[w] = [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (d[w] == d[_v] + edgeWeight) {</span><span class="s3">\n              </span><span class="s1">g[w] = g[w] + g[_v];</span><span class="s3">\n              </span><span class="s1">P[w].push(_v);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">for (var _j = 0; _j &lt; A[_v].length; _j++) {</span><span class="s3">\n            </span><span class="s1">var _w = A[_v][_j].id();</span><span class="s3">\n            </span><span class="s1">if (d[_w] == Infinity) {</span><span class="s3">\n              </span><span class="s1">Q.push(_w);</span><span class="s3">\n              </span><span class="s1">d[_w] = d[_v] + 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (d[_w] == d[_v] + 1) {</span><span class="s3">\n              </span><span class="s1">g[_w] = g[_w] + g[_v];</span><span class="s3">\n              </span><span class="s1">P[_w].push(_v);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var e = {};</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; V.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">e[V[_i2].id()] = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">while (S.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">var _w2 = S.pop();</span><span class="s3">\n        </span><span class="s1">for (var _j2 = 0; _j2 &lt; P[_w2].length; _j2++) {</span><span class="s3">\n          </span><span class="s1">var _v2 = P[_w2][_j2];</span><span class="s3">\n          </span><span class="s1">e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (_w2 != V[s].id()) {</span><span class="s3">\n          </span><span class="s1">C.set(_w2, C.get(_w2) + e[_w2]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (var s = 0; s &lt; V.length; s++) {</span><span class="s3">\n      </span><span class="s1">_loop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ret = {</span><span class="s3">\n      </span><span class="s1">betweenness: function betweenness(node) {</span><span class="s3">\n        </span><span class="s1">var id = cy.collection(node).id();</span><span class="s3">\n        </span><span class="s1">return C.get(id);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">betweennessNormalized: function betweennessNormalized(node) {</span><span class="s3">\n        </span><span class="s1">if (max == 0) {</span><span class="s3">\n          </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var id = cy.collection(node).id();</span><span class="s3">\n        </span><span class="s1">return C.get(id) / max;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// alias</span><span class="s3">\n    </span><span class="s1">ret.betweennessNormalised = ret.betweennessNormalized;</span><span class="s3">\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">} // betweennessCentrality</span><span class="s3">\n</span><span class="s1">}; // elesfn</span><span class="s3">\n\n</span><span class="s1">// nice, short mathematical alias</span><span class="s3">\n</span><span class="s1">elesfn$l.bc = elesfn$l.betweennessCentrality;</span><span class="s3">\n\n</span><span class="s1">// Implemented by Zoe Xi @zoexi for GSOC 2016</span><span class="s3">\n</span><span class="s1">// https://github.com/cytoscape/cytoscape.js-markov-cluster</span><span class="s3">\n\n\n</span><span class="s1">/* eslint-disable no-unused-vars */</span><span class="s3">\n</span><span class="s1">var defaults$c = defaults$g({</span><span class="s3">\n  </span><span class="s1">expandFactor: 2,</span><span class="s3">\n  </span><span class="s1">// affects time of computation and cluster granularity to some extent: M * M</span><span class="s3">\n  </span><span class="s1">inflateFactor: 2,</span><span class="s3">\n  </span><span class="s1">// affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)</span><span class="s3">\n  </span><span class="s1">multFactor: 1,</span><span class="s3">\n  </span><span class="s1">// optional self loops for each node. Use a neutral value to improve cluster computations.</span><span class="s3">\n  </span><span class="s1">maxIterations: 20,</span><span class="s3">\n  </span><span class="s1">// maximum number of iterations of the MCL algorithm in a single run</span><span class="s3">\n  </span><span class="s1">attributes: [</span><span class="s3">\n  </span><span class="s1">// attributes/features used to group nodes, ie. similarity values between nodes</span><span class="s3">\n  </span><span class="s1">function (edge) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/* eslint-enable */</span><span class="s3">\n\n</span><span class="s1">var setOptions$3 = function setOptions(options) {</span><span class="s3">\n  </span><span class="s1">return defaults$c(options);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/* eslint-enable */</span><span class="s3">\n\n</span><span class="s1">var getSimilarity$1 = function getSimilarity(edge, attributes) {</span><span class="s3">\n  </span><span class="s1">var total = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; attributes.length; i++) {</span><span class="s3">\n    </span><span class="s1">total += attributes[i](edge);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return total;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var addLoops = function addLoops(M, n, val) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">M[i * n + i] = val;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var normalize = function normalize(M, n) {</span><span class="s3">\n  </span><span class="s1">var sum;</span><span class="s3">\n  </span><span class="s1">for (var col = 0; col &lt; n; col++) {</span><span class="s3">\n    </span><span class="s1">sum = 0;</span><span class="s3">\n    </span><span class="s1">for (var row = 0; row &lt; n; row++) {</span><span class="s3">\n      </span><span class="s1">sum += M[row * n + col];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var _row = 0; _row &lt; n; _row++) {</span><span class="s3">\n      </span><span class="s1">M[_row * n + col] = M[_row * n + col] / sum;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// TODO: blocked matrix multiplication?</span><span class="s3">\n</span><span class="s1">var mmult = function mmult(A, B, n) {</span><span class="s3">\n  </span><span class="s1">var C = new Array(n * n);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; n; j++) {</span><span class="s3">\n      </span><span class="s1">C[i * n + j] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var k = 0; k &lt; n; k++) {</span><span class="s3">\n      </span><span class="s1">for (var _j = 0; _j &lt; n; _j++) {</span><span class="s3">\n        </span><span class="s1">C[i * n + _j] += A[i * n + k] * B[k * n + _j];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return C;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var expand = function expand(M, n, expandFactor /** power **/) {</span><span class="s3">\n  </span><span class="s1">var _M = M.slice(0);</span><span class="s3">\n  </span><span class="s1">for (var p = 1; p &lt; expandFactor; p++) {</span><span class="s3">\n    </span><span class="s1">M = mmult(M, _M, n);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return M;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var inflate = function inflate(M, n, inflateFactor /** r **/) {</span><span class="s3">\n  </span><span class="s1">var _M = new Array(n * n);</span><span class="s3">\n\n  </span><span class="s1">// M(i,j) ^ inflatePower</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n * n; i++) {</span><span class="s3">\n    </span><span class="s1">_M[i] = Math.pow(M[i], inflateFactor);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">normalize(_M, n);</span><span class="s3">\n  </span><span class="s1">return _M;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hasConverged = function hasConverged(M, _M, n2, roundFactor) {</span><span class="s3">\n  </span><span class="s1">// Check that both matrices have the same elements (i,j)</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n2; i++) {</span><span class="s3">\n    </span><span class="s1">var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places</span><span class="s3">\n    </span><span class="s1">var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);</span><span class="s3">\n    </span><span class="s1">if (v1 !== v2) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var assign$2 = function assign(M, n, nodes, cy) {</span><span class="s3">\n  </span><span class="s1">var clusters = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">var cluster = [];</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; n; j++) {</span><span class="s3">\n      </span><span class="s1">// Row-wise attractors and elements that they attract belong in same cluster</span><span class="s3">\n      </span><span class="s1">if (Math.round(M[i * n + j] * 1000) / 1000 &gt; 0) {</span><span class="s3">\n        </span><span class="s1">cluster.push(nodes[j]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cluster.length !== 0) {</span><span class="s3">\n      </span><span class="s1">clusters.push(cy.collection(cluster));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var isDuplicate = function isDuplicate(c1, c2) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; c1.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!c2[i] || c1[i].id() !== c2[i].id()) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var removeDuplicates = function removeDuplicates(clusters) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; clusters.length; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; clusters.length; j++) {</span><span class="s3">\n      </span><span class="s1">if (i != j &amp;&amp; isDuplicate(clusters[i], clusters[j])) {</span><span class="s3">\n        </span><span class="s1">clusters.splice(j, 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var markovClustering = function markovClustering(options) {</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n  </span><span class="s1">var edges = this.edges();</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n\n  </span><span class="s1">// Set parameters of algorithm:</span><span class="s3">\n  </span><span class="s1">var opts = setOptions$3(options);</span><span class="s3">\n\n  </span><span class="s1">// Map each node to its position in node array</span><span class="s3">\n  </span><span class="s1">var id2position = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">id2position[nodes[i].id()] = i;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate stochastic matrix M from input graph G (should be symmetric/undirected)</span><span class="s3">\n  </span><span class="s1">var n = nodes.length,</span><span class="s3">\n    </span><span class="s1">n2 = n * n;</span><span class="s3">\n  </span><span class="s1">var M = new Array(n2),</span><span class="s3">\n    </span><span class="s1">_M;</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; n2; _i++) {</span><span class="s3">\n    </span><span class="s1">M[_i] = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var e = 0; e &lt; edges.length; e++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[e];</span><span class="s3">\n    </span><span class="s1">var _i2 = id2position[edge.source().id()];</span><span class="s3">\n    </span><span class="s1">var j = id2position[edge.target().id()];</span><span class="s3">\n    </span><span class="s1">var sim = getSimilarity$1(edge, opts.attributes);</span><span class="s3">\n    </span><span class="s1">M[_i2 * n + j] += sim; // G should be symmetric and undirected</span><span class="s3">\n    </span><span class="s1">M[j * n + _i2] += sim;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Begin Markov cluster algorithm</span><span class="s3">\n\n  </span><span class="s1">// Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal</span><span class="s3">\n  </span><span class="s1">addLoops(M, n, opts.multFactor);</span><span class="s3">\n\n  </span><span class="s1">// Step 2: M = normalize( M );</span><span class="s3">\n  </span><span class="s1">normalize(M, n);</span><span class="s3">\n  </span><span class="s1">var isStillMoving = true;</span><span class="s3">\n  </span><span class="s1">var iterations = 0;</span><span class="s3">\n  </span><span class="s1">while (isStillMoving &amp;&amp; iterations &lt; opts.maxIterations) {</span><span class="s3">\n    </span><span class="s1">isStillMoving = false;</span><span class="s3">\n\n    </span><span class="s1">// Step 3:</span><span class="s3">\n    </span><span class="s1">_M = expand(M, n, opts.expandFactor);</span><span class="s3">\n\n    </span><span class="s1">// Step 4:</span><span class="s3">\n    </span><span class="s1">M = inflate(_M, n, opts.inflateFactor);</span><span class="s3">\n\n    </span><span class="s1">// Step 5: check to see if ~steady state has been reached</span><span class="s3">\n    </span><span class="s1">if (!hasConverged(M, _M, n2, 4)) {</span><span class="s3">\n      </span><span class="s1">isStillMoving = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Build clusters from matrix</span><span class="s3">\n  </span><span class="s1">var clusters = assign$2(M, n, nodes, cy);</span><span class="s3">\n\n  </span><span class="s1">// Remove duplicate clusters due to symmetry of graph and M matrix</span><span class="s3">\n  </span><span class="s1">clusters = removeDuplicates(clusters);</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var markovClustering$1 = {</span><span class="s3">\n  </span><span class="s1">markovClustering: markovClustering,</span><span class="s3">\n  </span><span class="s1">mcl: markovClustering</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Common distance metrics for clustering algorithms</span><span class="s3">\n</span><span class="s1">// https://en.wikipedia.org/wiki/Hierarchical_clustering#Metric</span><span class="s3">\n\n</span><span class="s1">var identity$1 = function identity(x) {</span><span class="s3">\n  </span><span class="s1">return x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var absDiff = function absDiff(p, q) {</span><span class="s3">\n  </span><span class="s1">return Math.abs(q - p);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var addAbsDiff = function addAbsDiff(total, p, q) {</span><span class="s3">\n  </span><span class="s1">return total + absDiff(p, q);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var addSquaredDiff = function addSquaredDiff(total, p, q) {</span><span class="s3">\n  </span><span class="s1">return total + Math.pow(q - p, 2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sqrt = function sqrt(x) {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(x);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {</span><span class="s3">\n  </span><span class="s1">return Math.max(currentMax, absDiff(p, q));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getDistance = function getDistance(length, getP, getQ, init, visit) {</span><span class="s3">\n  </span><span class="s1">var post = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : identity$1;</span><span class="s3">\n  </span><span class="s1">var ret = init;</span><span class="s3">\n  </span><span class="s1">var p, q;</span><span class="s3">\n  </span><span class="s1">for (var dim = 0; dim &lt; length; dim++) {</span><span class="s3">\n    </span><span class="s1">p = getP(dim);</span><span class="s3">\n    </span><span class="s1">q = getQ(dim);</span><span class="s3">\n    </span><span class="s1">ret = visit(ret, p, q);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return post(ret);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var distances = {</span><span class="s3">\n  </span><span class="s1">euclidean: function euclidean(length, getP, getQ) {</span><span class="s3">\n    </span><span class="s1">if (length &gt;= 2) {</span><span class="s3">\n      </span><span class="s1">return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// for single attr case, more efficient to avoid sqrt</span><span class="s3">\n      </span><span class="s1">return getDistance(length, getP, getQ, 0, addAbsDiff);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">squaredEuclidean: function squaredEuclidean(length, getP, getQ) {</span><span class="s3">\n    </span><span class="s1">return getDistance(length, getP, getQ, 0, addSquaredDiff);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">manhattan: function manhattan(length, getP, getQ) {</span><span class="s3">\n    </span><span class="s1">return getDistance(length, getP, getQ, 0, addAbsDiff);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">max: function max(length, getP, getQ) {</span><span class="s3">\n    </span><span class="s1">return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// in case the user accidentally doesn't use camel case</span><span class="s3">\n</span><span class="s1">distances['squared-euclidean'] = distances['squaredEuclidean'];</span><span class="s3">\n</span><span class="s1">distances['squaredeuclidean'] = distances['squaredEuclidean'];</span><span class="s3">\n</span><span class="s1">function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {</span><span class="s3">\n  </span><span class="s1">var impl;</span><span class="s3">\n  </span><span class="s1">if (fn$6(method)) {</span><span class="s3">\n    </span><span class="s1">impl = method;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">impl = distances[method] || distances.euclidean;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (length === 0 &amp;&amp; fn$6(method)) {</span><span class="s3">\n    </span><span class="s1">return impl(nodeP, nodeQ);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return impl(length, getP, getQ, nodeP, nodeQ);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var defaults$b = defaults$g({</span><span class="s3">\n  </span><span class="s1">k: 2,</span><span class="s3">\n  </span><span class="s1">m: 2,</span><span class="s3">\n  </span><span class="s1">sensitivityThreshold: 0.0001,</span><span class="s3">\n  </span><span class="s1">distance: 'euclidean',</span><span class="s3">\n  </span><span class="s1">maxIterations: 10,</span><span class="s3">\n  </span><span class="s1">attributes: [],</span><span class="s3">\n  </span><span class="s1">testMode: false,</span><span class="s3">\n  </span><span class="s1">testCentroids: null</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var setOptions$2 = function setOptions(options) {</span><span class="s3">\n  </span><span class="s1">return defaults$b(options);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var getDist = function getDist(type, node, centroid, attributes, mode) {</span><span class="s3">\n  </span><span class="s1">var noNodeP = mode !== 'kMedoids';</span><span class="s3">\n  </span><span class="s1">var getP = noNodeP ? function (i) {</span><span class="s3">\n    </span><span class="s1">return centroid[i];</span><span class="s3">\n  </span><span class="s1">} : function (i) {</span><span class="s3">\n    </span><span class="s1">return attributes[i](centroid);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getQ = function getQ(i) {</span><span class="s3">\n    </span><span class="s1">return attributes[i](node);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var nodeP = centroid;</span><span class="s3">\n  </span><span class="s1">var nodeQ = node;</span><span class="s3">\n  </span><span class="s1">return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var randomCentroids = function randomCentroids(nodes, k, attributes) {</span><span class="s3">\n  </span><span class="s1">var ndim = attributes.length;</span><span class="s3">\n  </span><span class="s1">var min = new Array(ndim);</span><span class="s3">\n  </span><span class="s1">var max = new Array(ndim);</span><span class="s3">\n  </span><span class="s1">var centroids = new Array(k);</span><span class="s3">\n  </span><span class="s1">var centroid = null;</span><span class="s3">\n\n  </span><span class="s1">// Find min, max values for each attribute dimension</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; ndim; i++) {</span><span class="s3">\n    </span><span class="s1">min[i] = nodes.min(attributes[i]).value;</span><span class="s3">\n    </span><span class="s1">max[i] = nodes.max(attributes[i]).value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Build k centroids, each represented as an n-dim feature vector</span><span class="s3">\n  </span><span class="s1">for (var c = 0; c &lt; k; c++) {</span><span class="s3">\n    </span><span class="s1">centroid = [];</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; ndim; _i++) {</span><span class="s3">\n      </span><span class="s1">centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">centroids[c] = centroid;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return centroids;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var classify = function classify(node, centroids, distance, attributes, type) {</span><span class="s3">\n  </span><span class="s1">var min = Infinity;</span><span class="s3">\n  </span><span class="s1">var index = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; centroids.length; i++) {</span><span class="s3">\n    </span><span class="s1">var dist = getDist(distance, node, centroids[i], attributes, type);</span><span class="s3">\n    </span><span class="s1">if (dist &lt; min) {</span><span class="s3">\n      </span><span class="s1">min = dist;</span><span class="s3">\n      </span><span class="s1">index = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var buildCluster = function buildCluster(centroid, nodes, assignment) {</span><span class="s3">\n  </span><span class="s1">var cluster = [];</span><span class="s3">\n  </span><span class="s1">var node = null;</span><span class="s3">\n  </span><span class="s1">for (var n = 0; n &lt; nodes.length; n++) {</span><span class="s3">\n    </span><span class="s1">node = nodes[n];</span><span class="s3">\n    </span><span class="s1">if (assignment[node.id()] === centroid) {</span><span class="s3">\n      </span><span class="s1">//console.log(</span><span class="s3">\&quot;</span><span class="s1">Node </span><span class="s3">\&quot; </span><span class="s1">+ node.id() + </span><span class="s3">\&quot; </span><span class="s1">is associated with medoid #: </span><span class="s3">\&quot; </span><span class="s1">+ m);</span><span class="s3">\n      </span><span class="s1">cluster.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cluster;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {</span><span class="s3">\n  </span><span class="s1">return Math.abs(v2 - v1) &lt;= sensitivityThreshold;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; v1.length; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; v1[i].length; j++) {</span><span class="s3">\n      </span><span class="s1">var diff = Math.abs(v1[i][j] - v2[i][j]);</span><span class="s3">\n      </span><span class="s1">if (diff &gt; sensitivityThreshold) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var seenBefore = function seenBefore(node, medoids, n) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">if (node === medoids[i]) return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var randomMedoids = function randomMedoids(nodes, k) {</span><span class="s3">\n  </span><span class="s1">var medoids = new Array(k);</span><span class="s3">\n\n  </span><span class="s1">// For small data sets, the probability of medoid conflict is greater,</span><span class="s3">\n  </span><span class="s1">// so we need to check to see if we've already seen or chose this node before.</span><span class="s3">\n  </span><span class="s1">if (nodes.length &lt; 50) {</span><span class="s3">\n    </span><span class="s1">// Randomly select k medoids from the n nodes</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; k; i++) {</span><span class="s3">\n      </span><span class="s1">var node = nodes[Math.floor(Math.random() * nodes.length)];</span><span class="s3">\n\n      </span><span class="s1">// If we've already chosen this node to be a medoid, don't choose it again (for small data sets).</span><span class="s3">\n      </span><span class="s1">// Instead choose a different random node.</span><span class="s3">\n      </span><span class="s1">while (seenBefore(node, medoids, i)) {</span><span class="s3">\n        </span><span class="s1">node = nodes[Math.floor(Math.random() * nodes.length)];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">medoids[i] = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Relatively large data set, so pretty safe to not check and just select random nodes</span><span class="s3">\n    </span><span class="s1">for (var _i2 = 0; _i2 &lt; k; _i2++) {</span><span class="s3">\n      </span><span class="s1">medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return medoids;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var findCost = function findCost(potentialNewMedoid, cluster, attributes) {</span><span class="s3">\n  </span><span class="s1">var cost = 0;</span><span class="s3">\n  </span><span class="s1">for (var n = 0; n &lt; cluster.length; n++) {</span><span class="s3">\n    </span><span class="s1">cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cost;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var kMeans = function kMeans(options) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n  </span><span class="s1">var node = null;</span><span class="s3">\n\n  </span><span class="s1">// Set parameters of algorithm: # of clusters, distance metric, etc.</span><span class="s3">\n  </span><span class="s1">var opts = setOptions$2(options);</span><span class="s3">\n\n  </span><span class="s1">// Begin k-means algorithm</span><span class="s3">\n  </span><span class="s1">var clusters = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">var assignment = {};</span><span class="s3">\n  </span><span class="s1">var centroids;</span><span class="s3">\n\n  </span><span class="s1">// Step 1: Initialize centroid positions</span><span class="s3">\n  </span><span class="s1">if (opts.testMode) {</span><span class="s3">\n    </span><span class="s1">if (typeof opts.testCentroids === 'number') {</span><span class="s3">\n      </span><span class="s1">// TODO: implement a seeded random number generator.</span><span class="s3">\n      </span><span class="s1">opts.testCentroids;</span><span class="s3">\n      </span><span class="s1">centroids = randomCentroids(nodes, opts.k, opts.attributes);</span><span class="s3">\n    </span><span class="s1">} else if (_typeof(opts.testCentroids) === 'object') {</span><span class="s3">\n      </span><span class="s1">centroids = opts.testCentroids;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">centroids = randomCentroids(nodes, opts.k, opts.attributes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">centroids = randomCentroids(nodes, opts.k, opts.attributes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var isStillMoving = true;</span><span class="s3">\n  </span><span class="s1">var iterations = 0;</span><span class="s3">\n  </span><span class="s1">while (isStillMoving &amp;&amp; iterations &lt; opts.maxIterations) {</span><span class="s3">\n    </span><span class="s1">// Step 2: Assign nodes to the nearest centroid</span><span class="s3">\n    </span><span class="s1">for (var n = 0; n &lt; nodes.length; n++) {</span><span class="s3">\n      </span><span class="s1">node = nodes[n];</span><span class="s3">\n      </span><span class="s1">// Determine which cluster this node belongs to: node id =&gt; cluster #</span><span class="s3">\n      </span><span class="s1">assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Step 3: For each of the k clusters, update its centroid</span><span class="s3">\n    </span><span class="s1">isStillMoving = false;</span><span class="s3">\n    </span><span class="s1">for (var c = 0; c &lt; opts.k; c++) {</span><span class="s3">\n      </span><span class="s1">// Get all nodes that belong to this cluster</span><span class="s3">\n      </span><span class="s1">var cluster = buildCluster(c, nodes, assignment);</span><span class="s3">\n      </span><span class="s1">if (cluster.length === 0) {</span><span class="s3">\n        </span><span class="s1">// If cluster is empty, break out early &amp; move to next cluster</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Update centroids by calculating avg of all nodes within the cluster.</span><span class="s3">\n      </span><span class="s1">var ndim = opts.attributes.length;</span><span class="s3">\n      </span><span class="s1">var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]</span><span class="s3">\n      </span><span class="s1">var newCentroid = new Array(ndim);</span><span class="s3">\n      </span><span class="s1">var sum = new Array(ndim);</span><span class="s3">\n      </span><span class="s1">for (var d = 0; d &lt; ndim; d++) {</span><span class="s3">\n        </span><span class="s1">sum[d] = 0.0;</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; cluster.length; i++) {</span><span class="s3">\n          </span><span class="s1">node = cluster[i];</span><span class="s3">\n          </span><span class="s1">sum[d] += opts.attributes[d](node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">newCentroid[d] = sum[d] / cluster.length;</span><span class="s3">\n\n        </span><span class="s1">// Check to see if algorithm has converged, i.e. when centroids no longer change</span><span class="s3">\n        </span><span class="s1">if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {</span><span class="s3">\n          </span><span class="s1">isStillMoving = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">centroids[c] = newCentroid;</span><span class="s3">\n      </span><span class="s1">clusters[c] = cy.collection(cluster);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var kMedoids = function kMedoids(options) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n  </span><span class="s1">var node = null;</span><span class="s3">\n  </span><span class="s1">var opts = setOptions$2(options);</span><span class="s3">\n\n  </span><span class="s1">// Begin k-medoids algorithm</span><span class="s3">\n  </span><span class="s1">var clusters = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">var medoids;</span><span class="s3">\n  </span><span class="s1">var assignment = {};</span><span class="s3">\n  </span><span class="s1">var curCost;</span><span class="s3">\n  </span><span class="s1">var minCosts = new Array(opts.k); // minimum cost configuration for each cluster</span><span class="s3">\n\n  </span><span class="s1">// Step 1: Initialize k medoids</span><span class="s3">\n  </span><span class="s1">if (opts.testMode) {</span><span class="s3">\n    </span><span class="s1">if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {</span><span class="s3">\n      </span><span class="s1">medoids = opts.testCentroids;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">medoids = randomMedoids(nodes, opts.k);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">medoids = randomMedoids(nodes, opts.k);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var isStillMoving = true;</span><span class="s3">\n  </span><span class="s1">var iterations = 0;</span><span class="s3">\n  </span><span class="s1">while (isStillMoving &amp;&amp; iterations &lt; opts.maxIterations) {</span><span class="s3">\n    </span><span class="s1">// Step 2: Assign nodes to the nearest medoid</span><span class="s3">\n    </span><span class="s1">for (var n = 0; n &lt; nodes.length; n++) {</span><span class="s3">\n      </span><span class="s1">node = nodes[n];</span><span class="s3">\n      </span><span class="s1">// Determine which cluster this node belongs to: node id =&gt; cluster #</span><span class="s3">\n      </span><span class="s1">assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isStillMoving = false;</span><span class="s3">\n    </span><span class="s1">// Step 3: For each medoid m, and for each node associated with mediod m,</span><span class="s3">\n    </span><span class="s1">// select the node with the lowest configuration cost as new medoid.</span><span class="s3">\n    </span><span class="s1">for (var m = 0; m &lt; medoids.length; m++) {</span><span class="s3">\n      </span><span class="s1">// Get all nodes that belong to this medoid</span><span class="s3">\n      </span><span class="s1">var cluster = buildCluster(m, nodes, assignment);</span><span class="s3">\n      </span><span class="s1">if (cluster.length === 0) {</span><span class="s3">\n        </span><span class="s1">// If cluster is empty, break out early &amp; move to next cluster</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost</span><span class="s3">\n\n      </span><span class="s1">// Select different medoid if its configuration has the lowest cost</span><span class="s3">\n      </span><span class="s1">for (var _n = 0; _n &lt; cluster.length; _n++) {</span><span class="s3">\n        </span><span class="s1">curCost = findCost(cluster[_n], cluster, opts.attributes);</span><span class="s3">\n        </span><span class="s1">if (curCost &lt; minCosts[m]) {</span><span class="s3">\n          </span><span class="s1">minCosts[m] = curCost;</span><span class="s3">\n          </span><span class="s1">medoids[m] = cluster[_n];</span><span class="s3">\n          </span><span class="s1">isStillMoving = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">clusters[m] = cy.collection(cluster);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {</span><span class="s3">\n  </span><span class="s1">var numerator, denominator;</span><span class="s3">\n  </span><span class="s1">for (var n = 0; n &lt; nodes.length; n++) {</span><span class="s3">\n    </span><span class="s1">for (var c = 0; c &lt; centroids.length; c++) {</span><span class="s3">\n      </span><span class="s1">weight[n][c] = Math.pow(U[n][c], opts.m);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var _c = 0; _c &lt; centroids.length; _c++) {</span><span class="s3">\n    </span><span class="s1">for (var dim = 0; dim &lt; opts.attributes.length; dim++) {</span><span class="s3">\n      </span><span class="s1">numerator = 0;</span><span class="s3">\n      </span><span class="s1">denominator = 0;</span><span class="s3">\n      </span><span class="s1">for (var _n2 = 0; _n2 &lt; nodes.length; _n2++) {</span><span class="s3">\n        </span><span class="s1">numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);</span><span class="s3">\n        </span><span class="s1">denominator += weight[_n2][_c];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">centroids[_c][dim] = numerator / denominator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {</span><span class="s3">\n  </span><span class="s1">// Save previous step</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; U.length; i++) {</span><span class="s3">\n    </span><span class="s1">_U[i] = U[i].slice();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var sum, numerator, denominator;</span><span class="s3">\n  </span><span class="s1">var pow = 2 / (opts.m - 1);</span><span class="s3">\n  </span><span class="s1">for (var c = 0; c &lt; centroids.length; c++) {</span><span class="s3">\n    </span><span class="s1">for (var n = 0; n &lt; nodes.length; n++) {</span><span class="s3">\n      </span><span class="s1">sum = 0;</span><span class="s3">\n      </span><span class="s1">for (var k = 0; k &lt; centroids.length; k++) {</span><span class="s3">\n        </span><span class="s1">// against all other centroids</span><span class="s3">\n        </span><span class="s1">numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');</span><span class="s3">\n        </span><span class="s1">denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');</span><span class="s3">\n        </span><span class="s1">sum += Math.pow(numerator / denominator, pow);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">U[n][c] = 1 / sum;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var assign$1 = function assign(nodes, U, opts, cy) {</span><span class="s3">\n  </span><span class="s1">var clusters = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">for (var c = 0; c &lt; clusters.length; c++) {</span><span class="s3">\n    </span><span class="s1">clusters[c] = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var max;</span><span class="s3">\n  </span><span class="s1">var index;</span><span class="s3">\n  </span><span class="s1">for (var n = 0; n &lt; U.length; n++) {</span><span class="s3">\n    </span><span class="s1">// for each node (U is N x C matrix)</span><span class="s3">\n    </span><span class="s1">max = -Infinity;</span><span class="s3">\n    </span><span class="s1">index = -1;</span><span class="s3">\n    </span><span class="s1">// Determine which cluster the node is most likely to belong in</span><span class="s3">\n    </span><span class="s1">for (var _c2 = 0; _c2 &lt; U[0].length; _c2++) {</span><span class="s3">\n      </span><span class="s1">if (U[n][_c2] &gt; max) {</span><span class="s3">\n        </span><span class="s1">max = U[n][_c2];</span><span class="s3">\n        </span><span class="s1">index = _c2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clusters[index].push(nodes[n]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Turn every array into a collection of nodes</span><span class="s3">\n  </span><span class="s1">for (var _c3 = 0; _c3 &lt; clusters.length; _c3++) {</span><span class="s3">\n    </span><span class="s1">clusters[_c3] = cy.collection(clusters[_c3]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var fuzzyCMeans = function fuzzyCMeans(options) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n  </span><span class="s1">var opts = setOptions$2(options);</span><span class="s3">\n\n  </span><span class="s1">// Begin fuzzy c-means algorithm</span><span class="s3">\n  </span><span class="s1">var clusters;</span><span class="s3">\n  </span><span class="s1">var centroids;</span><span class="s3">\n  </span><span class="s1">var U;</span><span class="s3">\n  </span><span class="s1">var _U;</span><span class="s3">\n  </span><span class="s1">var weight;</span><span class="s3">\n\n  </span><span class="s1">// Step 1: Initialize letiables.</span><span class="s3">\n  </span><span class="s1">_U = new Array(nodes.length);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">// N x C matrix</span><span class="s3">\n    </span><span class="s1">_U[i] = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">U = new Array(nodes.length);</span><span class="s3">\n  </span><span class="s1">for (var _i3 = 0; _i3 &lt; nodes.length; _i3++) {</span><span class="s3">\n    </span><span class="s1">// N x C matrix</span><span class="s3">\n    </span><span class="s1">U[_i3] = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var _i4 = 0; _i4 &lt; nodes.length; _i4++) {</span><span class="s3">\n    </span><span class="s1">var total = 0;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; opts.k; j++) {</span><span class="s3">\n      </span><span class="s1">U[_i4][j] = Math.random();</span><span class="s3">\n      </span><span class="s1">total += U[_i4][j];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var _j = 0; _j &lt; opts.k; _j++) {</span><span class="s3">\n      </span><span class="s1">U[_i4][_j] = U[_i4][_j] / total;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">centroids = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">for (var _i5 = 0; _i5 &lt; opts.k; _i5++) {</span><span class="s3">\n    </span><span class="s1">centroids[_i5] = new Array(opts.attributes.length);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">weight = new Array(nodes.length);</span><span class="s3">\n  </span><span class="s1">for (var _i6 = 0; _i6 &lt; nodes.length; _i6++) {</span><span class="s3">\n    </span><span class="s1">// N x C matrix</span><span class="s3">\n    </span><span class="s1">weight[_i6] = new Array(opts.k);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// end init FCM</span><span class="s3">\n\n  </span><span class="s1">var isStillMoving = true;</span><span class="s3">\n  </span><span class="s1">var iterations = 0;</span><span class="s3">\n  </span><span class="s1">while (isStillMoving &amp;&amp; iterations &lt; opts.maxIterations) {</span><span class="s3">\n    </span><span class="s1">isStillMoving = false;</span><span class="s3">\n\n    </span><span class="s1">// Step 2: Calculate the centroids for each step.</span><span class="s3">\n    </span><span class="s1">updateCentroids(centroids, nodes, U, weight, opts);</span><span class="s3">\n\n    </span><span class="s1">// Step 3: Update the partition matrix U.</span><span class="s3">\n    </span><span class="s1">updateMembership(U, _U, centroids, nodes, opts);</span><span class="s3">\n\n    </span><span class="s1">// Step 4: Check for convergence.</span><span class="s3">\n    </span><span class="s1">if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {</span><span class="s3">\n      </span><span class="s1">isStillMoving = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Assign nodes to clusters with highest probability.</span><span class="s3">\n  </span><span class="s1">clusters = assign$1(nodes, U, opts, cy);</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">clusters: clusters,</span><span class="s3">\n    </span><span class="s1">degreeOfMembership: U</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var kClustering = {</span><span class="s3">\n  </span><span class="s1">kMeans: kMeans,</span><span class="s3">\n  </span><span class="s1">kMedoids: kMedoids,</span><span class="s3">\n  </span><span class="s1">fuzzyCMeans: fuzzyCMeans,</span><span class="s3">\n  </span><span class="s1">fcm: fuzzyCMeans</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Implemented by Zoe Xi @zoexi for GSOC 2016</span><span class="s3">\n</span><span class="s1">// https://github.com/cytoscape/cytoscape.js-hierarchical</span><span class="s3">\n\n</span><span class="s1">var defaults$a = defaults$g({</span><span class="s3">\n  </span><span class="s1">distance: 'euclidean',</span><span class="s3">\n  </span><span class="s1">// distance metric to compare nodes</span><span class="s3">\n  </span><span class="s1">linkage: 'min',</span><span class="s3">\n  </span><span class="s1">// linkage criterion : how to determine the distance between clusters of nodes</span><span class="s3">\n  </span><span class="s1">mode: 'threshold',</span><span class="s3">\n  </span><span class="s1">// mode:'threshold' =&gt; clusters must be threshold distance apart</span><span class="s3">\n  </span><span class="s1">threshold: Infinity,</span><span class="s3">\n  </span><span class="s1">// the distance threshold</span><span class="s3">\n  </span><span class="s1">// mode:'dendrogram' =&gt; the nodes are organised as leaves in a tree (siblings are close), merging makes clusters</span><span class="s3">\n  </span><span class="s1">addDendrogram: false,</span><span class="s3">\n  </span><span class="s1">// whether to add the dendrogram to the graph for viz</span><span class="s3">\n  </span><span class="s1">dendrogramDepth: 0,</span><span class="s3">\n  </span><span class="s1">// depth at which dendrogram branches are merged into the returned clusters</span><span class="s3">\n  </span><span class="s1">attributes: [] // array of attr functions</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var linkageAliases = {</span><span class="s3">\n  </span><span class="s1">'single': 'min',</span><span class="s3">\n  </span><span class="s1">'complete': 'max'</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var setOptions$1 = function setOptions(options) {</span><span class="s3">\n  </span><span class="s1">var opts = defaults$a(options);</span><span class="s3">\n  </span><span class="s1">var preferredAlias = linkageAliases[opts.linkage];</span><span class="s3">\n  </span><span class="s1">if (preferredAlias != null) {</span><span class="s3">\n    </span><span class="s1">opts.linkage = preferredAlias;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return opts;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {</span><span class="s3">\n  </span><span class="s1">// Find two closest clusters from cached mins</span><span class="s3">\n  </span><span class="s1">var minKey = 0;</span><span class="s3">\n  </span><span class="s1">var min = Infinity;</span><span class="s3">\n  </span><span class="s1">var dist;</span><span class="s3">\n  </span><span class="s1">var attrs = opts.attributes;</span><span class="s3">\n  </span><span class="s1">var getDist = function getDist(n1, n2) {</span><span class="s3">\n    </span><span class="s1">return clusteringDistance(opts.distance, attrs.length, function (i) {</span><span class="s3">\n      </span><span class="s1">return attrs[i](n1);</span><span class="s3">\n    </span><span class="s1">}, function (i) {</span><span class="s3">\n      </span><span class="s1">return attrs[i](n2);</span><span class="s3">\n    </span><span class="s1">}, n1, n2);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; clusters.length; i++) {</span><span class="s3">\n    </span><span class="s1">var key = clusters[i].key;</span><span class="s3">\n    </span><span class="s1">var _dist = dists[key][mins[key]];</span><span class="s3">\n    </span><span class="s1">if (_dist &lt; min) {</span><span class="s3">\n      </span><span class="s1">minKey = key;</span><span class="s3">\n      </span><span class="s1">min = _dist;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (opts.mode === 'threshold' &amp;&amp; min &gt;= opts.threshold || opts.mode === 'dendrogram' &amp;&amp; clusters.length === 1) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var c1 = index[minKey];</span><span class="s3">\n  </span><span class="s1">var c2 = index[mins[minKey]];</span><span class="s3">\n  </span><span class="s1">var merged;</span><span class="s3">\n\n  </span><span class="s1">// Merge two closest clusters</span><span class="s3">\n  </span><span class="s1">if (opts.mode === 'dendrogram') {</span><span class="s3">\n    </span><span class="s1">merged = {</span><span class="s3">\n      </span><span class="s1">left: c1,</span><span class="s3">\n      </span><span class="s1">right: c2,</span><span class="s3">\n      </span><span class="s1">key: c1.key</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">merged = {</span><span class="s3">\n      </span><span class="s1">value: c1.value.concat(c2.value),</span><span class="s3">\n      </span><span class="s1">key: c1.key</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">clusters[c1.index] = merged;</span><span class="s3">\n  </span><span class="s1">clusters.splice(c2.index, 1);</span><span class="s3">\n  </span><span class="s1">index[c1.key] = merged;</span><span class="s3">\n\n  </span><span class="s1">// Update distances with new merged cluster</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; clusters.length; _i++) {</span><span class="s3">\n    </span><span class="s1">var cur = clusters[_i];</span><span class="s3">\n    </span><span class="s1">if (c1.key === cur.key) {</span><span class="s3">\n      </span><span class="s1">dist = Infinity;</span><span class="s3">\n    </span><span class="s1">} else if (opts.linkage === 'min') {</span><span class="s3">\n      </span><span class="s1">dist = dists[c1.key][cur.key];</span><span class="s3">\n      </span><span class="s1">if (dists[c1.key][cur.key] &gt; dists[c2.key][cur.key]) {</span><span class="s3">\n        </span><span class="s1">dist = dists[c2.key][cur.key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (opts.linkage === 'max') {</span><span class="s3">\n      </span><span class="s1">dist = dists[c1.key][cur.key];</span><span class="s3">\n      </span><span class="s1">if (dists[c1.key][cur.key] &lt; dists[c2.key][cur.key]) {</span><span class="s3">\n        </span><span class="s1">dist = dists[c2.key][cur.key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (opts.linkage === 'mean') {</span><span class="s3">\n      </span><span class="s1">dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Update cached mins</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; clusters.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var key1 = clusters[_i2].key;</span><span class="s3">\n    </span><span class="s1">if (mins[key1] === c1.key || mins[key1] === c2.key) {</span><span class="s3">\n      </span><span class="s1">var _min = key1;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; clusters.length; j++) {</span><span class="s3">\n        </span><span class="s1">var key2 = clusters[j].key;</span><span class="s3">\n        </span><span class="s1">if (dists[key1][key2] &lt; dists[key1][_min]) {</span><span class="s3">\n          </span><span class="s1">_min = key2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">mins[key1] = _min;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clusters[_i2].index = _i2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Clean up meta data used for clustering</span><span class="s3">\n  </span><span class="s1">c1.key = c2.key = c1.index = c2.index = null;</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var _getAllChildren = function getAllChildren(root, arr, cy) {</span><span class="s3">\n  </span><span class="s1">if (!root) return;</span><span class="s3">\n  </span><span class="s1">if (root.value) {</span><span class="s3">\n    </span><span class="s1">arr.push(root.value);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (root.left) _getAllChildren(root.left, arr);</span><span class="s3">\n    </span><span class="s1">if (root.right) _getAllChildren(root.right, arr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var _buildDendrogram = function buildDendrogram(root, cy) {</span><span class="s3">\n  </span><span class="s1">if (!root) return '';</span><span class="s3">\n  </span><span class="s1">if (root.left &amp;&amp; root.right) {</span><span class="s3">\n    </span><span class="s1">var leftStr = _buildDendrogram(root.left, cy);</span><span class="s3">\n    </span><span class="s1">var rightStr = _buildDendrogram(root.right, cy);</span><span class="s3">\n    </span><span class="s1">var node = cy.add({</span><span class="s3">\n      </span><span class="s1">group: 'nodes',</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">id: leftStr + ',' + rightStr</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">cy.add({</span><span class="s3">\n      </span><span class="s1">group: 'edges',</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">source: leftStr,</span><span class="s3">\n        </span><span class="s1">target: node.id()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">cy.add({</span><span class="s3">\n      </span><span class="s1">group: 'edges',</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">source: rightStr,</span><span class="s3">\n        </span><span class="s1">target: node.id()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return node.id();</span><span class="s3">\n  </span><span class="s1">} else if (root.value) {</span><span class="s3">\n    </span><span class="s1">return root.value.id();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var _buildClustersFromTree = function buildClustersFromTree(root, k, cy) {</span><span class="s3">\n  </span><span class="s1">if (!root) return [];</span><span class="s3">\n  </span><span class="s1">var left = [],</span><span class="s3">\n    </span><span class="s1">right = [],</span><span class="s3">\n    </span><span class="s1">leaves = [];</span><span class="s3">\n  </span><span class="s1">if (k === 0) {</span><span class="s3">\n    </span><span class="s1">// don't cut tree, simply return all nodes as 1 single cluster</span><span class="s3">\n    </span><span class="s1">if (root.left) _getAllChildren(root.left, left);</span><span class="s3">\n    </span><span class="s1">if (root.right) _getAllChildren(root.right, right);</span><span class="s3">\n    </span><span class="s1">leaves = left.concat(right);</span><span class="s3">\n    </span><span class="s1">return [cy.collection(leaves)];</span><span class="s3">\n  </span><span class="s1">} else if (k === 1) {</span><span class="s3">\n    </span><span class="s1">// cut at root</span><span class="s3">\n\n    </span><span class="s1">if (root.value) {</span><span class="s3">\n      </span><span class="s1">// leaf node</span><span class="s3">\n      </span><span class="s1">return [cy.collection(root.value)];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (root.left) _getAllChildren(root.left, left);</span><span class="s3">\n      </span><span class="s1">if (root.right) _getAllChildren(root.right, right);</span><span class="s3">\n      </span><span class="s1">return [cy.collection(left), cy.collection(right)];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (root.value) {</span><span class="s3">\n      </span><span class="s1">return [cy.collection(root.value)];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (root.left) left = _buildClustersFromTree(root.left, k - 1, cy);</span><span class="s3">\n      </span><span class="s1">if (root.right) right = _buildClustersFromTree(root.right, k - 1, cy);</span><span class="s3">\n      </span><span class="s1">return left.concat(right);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var hierarchicalClustering = function hierarchicalClustering(options) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n\n  </span><span class="s1">// Set parameters of algorithm: linkage type, distance metric, etc.</span><span class="s3">\n  </span><span class="s1">var opts = setOptions$1(options);</span><span class="s3">\n  </span><span class="s1">var attrs = opts.attributes;</span><span class="s3">\n  </span><span class="s1">var getDist = function getDist(n1, n2) {</span><span class="s3">\n    </span><span class="s1">return clusteringDistance(opts.distance, attrs.length, function (i) {</span><span class="s3">\n      </span><span class="s1">return attrs[i](n1);</span><span class="s3">\n    </span><span class="s1">}, function (i) {</span><span class="s3">\n      </span><span class="s1">return attrs[i](n2);</span><span class="s3">\n    </span><span class="s1">}, n1, n2);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// Begin hierarchical algorithm</span><span class="s3">\n  </span><span class="s1">var clusters = [];</span><span class="s3">\n  </span><span class="s1">var dists = []; // distances between each pair of clusters</span><span class="s3">\n  </span><span class="s1">var mins = []; // closest cluster for each cluster</span><span class="s3">\n  </span><span class="s1">var index = []; // hash of all clusters by key</span><span class="s3">\n\n  </span><span class="s1">// In agglomerative (bottom-up) clustering, each node starts as its own cluster</span><span class="s3">\n  </span><span class="s1">for (var n = 0; n &lt; nodes.length; n++) {</span><span class="s3">\n    </span><span class="s1">var cluster = {</span><span class="s3">\n      </span><span class="s1">value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],</span><span class="s3">\n      </span><span class="s1">key: n,</span><span class="s3">\n      </span><span class="s1">index: n</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">clusters[n] = cluster;</span><span class="s3">\n    </span><span class="s1">index[n] = cluster;</span><span class="s3">\n    </span><span class="s1">dists[n] = [];</span><span class="s3">\n    </span><span class="s1">mins[n] = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Calculate the distance between each pair of clusters</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; clusters.length; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt;= i; j++) {</span><span class="s3">\n      </span><span class="s1">var dist = undefined;</span><span class="s3">\n      </span><span class="s1">if (opts.mode === 'dendrogram') {</span><span class="s3">\n        </span><span class="s1">// modes store cluster values differently</span><span class="s3">\n        </span><span class="s1">dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">dists[i][j] = dist;</span><span class="s3">\n      </span><span class="s1">dists[j][i] = dist;</span><span class="s3">\n      </span><span class="s1">if (dist &lt; dists[i][mins[i]]) {</span><span class="s3">\n        </span><span class="s1">mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Find the closest pair of clusters and merge them into a single cluster.</span><span class="s3">\n  </span><span class="s1">// Update distances between new cluster and each of the old clusters, and loop until threshold reached.</span><span class="s3">\n  </span><span class="s1">var merged = mergeClosest(clusters, index, dists, mins, opts);</span><span class="s3">\n  </span><span class="s1">while (merged) {</span><span class="s3">\n    </span><span class="s1">merged = mergeClosest(clusters, index, dists, mins, opts);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var retClusters;</span><span class="s3">\n\n  </span><span class="s1">// Dendrogram mode builds the hierarchy and adds intermediary nodes + edges</span><span class="s3">\n  </span><span class="s1">// in addition to returning the clusters.</span><span class="s3">\n  </span><span class="s1">if (opts.mode === 'dendrogram') {</span><span class="s3">\n    </span><span class="s1">retClusters = _buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);</span><span class="s3">\n    </span><span class="s1">if (opts.addDendrogram) _buildDendrogram(clusters[0], cy);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Regular mode simply returns the clusters</span><span class="s3">\n\n    </span><span class="s1">retClusters = new Array(clusters.length);</span><span class="s3">\n    </span><span class="s1">clusters.forEach(function (cluster, i) {</span><span class="s3">\n      </span><span class="s1">// Clean up meta data used for clustering</span><span class="s3">\n      </span><span class="s1">cluster.key = cluster.index = null;</span><span class="s3">\n      </span><span class="s1">retClusters[i] = cy.collection(cluster.value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return retClusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hierarchicalClustering$1 = {</span><span class="s3">\n  </span><span class="s1">hierarchicalClustering: hierarchicalClustering,</span><span class="s3">\n  </span><span class="s1">hca: hierarchicalClustering</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Implemented by Zoe Xi @zoexi for GSOC 2016</span><span class="s3">\n</span><span class="s1">// https://github.com/cytoscape/cytoscape.js-affinity-propagation</span><span class="s3">\n\n</span><span class="s1">var defaults$9 = defaults$g({</span><span class="s3">\n  </span><span class="s1">distance: 'euclidean',</span><span class="s3">\n  </span><span class="s1">// distance metric to compare attributes between two nodes</span><span class="s3">\n  </span><span class="s1">preference: 'median',</span><span class="s3">\n  </span><span class="s1">// suitability of a data point to serve as an exemplar</span><span class="s3">\n  </span><span class="s1">damping: 0.8,</span><span class="s3">\n  </span><span class="s1">// damping factor between [0.5, 1)</span><span class="s3">\n  </span><span class="s1">maxIterations: 1000,</span><span class="s3">\n  </span><span class="s1">// max number of iterations to run</span><span class="s3">\n  </span><span class="s1">minIterations: 100,</span><span class="s3">\n  </span><span class="s1">// min number of iterations to run in order for clustering to stop</span><span class="s3">\n  </span><span class="s1">attributes: [// functions to quantify the similarity between any two points</span><span class="s3">\n    </span><span class="s1">// e.g. node =&gt; node.data('weight')</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var setOptions = function setOptions(options) {</span><span class="s3">\n  </span><span class="s1">var dmp = options.damping;</span><span class="s3">\n  </span><span class="s1">var pref = options.preference;</span><span class="s3">\n  </span><span class="s1">if (!(0.5 &lt;= dmp &amp;&amp; dmp &lt; 1)) {</span><span class="s3">\n    </span><span class="s1">error(</span><span class="s3">\&quot;</span><span class="s1">Damping must range on [0.5, 1).  Got: </span><span class="s3">\&quot;</span><span class="s1">.concat(dmp));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var validPrefs = ['median', 'mean', 'min', 'max'];</span><span class="s3">\n  </span><span class="s1">if (!(validPrefs.some(function (v) {</span><span class="s3">\n    </span><span class="s1">return v === pref;</span><span class="s3">\n  </span><span class="s1">}) || number$1(pref))) {</span><span class="s3">\n    </span><span class="s1">error(</span><span class="s3">\&quot;</span><span class="s1">Preference must be one of [</span><span class="s3">\&quot;</span><span class="s1">.concat(validPrefs.map(function (p) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">.concat(p, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}).join(', '), </span><span class="s3">\&quot;</span><span class="s1">] or a number.  Got: </span><span class="s3">\&quot;</span><span class="s1">).concat(pref));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return defaults$9(options);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var getSimilarity = function getSimilarity(type, n1, n2, attributes) {</span><span class="s3">\n  </span><span class="s1">var attr = function attr(n, i) {</span><span class="s3">\n    </span><span class="s1">return attributes[i](n);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// nb negative because similarity should have an inverse relationship to distance</span><span class="s3">\n  </span><span class="s1">return -clusteringDistance(type, attributes.length, function (i) {</span><span class="s3">\n    </span><span class="s1">return attr(n1, i);</span><span class="s3">\n  </span><span class="s1">}, function (i) {</span><span class="s3">\n    </span><span class="s1">return attr(n2, i);</span><span class="s3">\n  </span><span class="s1">}, n1, n2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getPreference = function getPreference(S, preference) {</span><span class="s3">\n  </span><span class="s1">// larger preference = greater # of clusters</span><span class="s3">\n  </span><span class="s1">var p = null;</span><span class="s3">\n  </span><span class="s1">if (preference === 'median') {</span><span class="s3">\n    </span><span class="s1">p = median(S);</span><span class="s3">\n  </span><span class="s1">} else if (preference === 'mean') {</span><span class="s3">\n    </span><span class="s1">p = mean(S);</span><span class="s3">\n  </span><span class="s1">} else if (preference === 'min') {</span><span class="s3">\n    </span><span class="s1">p = min(S);</span><span class="s3">\n  </span><span class="s1">} else if (preference === 'max') {</span><span class="s3">\n    </span><span class="s1">p = max(S);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Custom preference number, as set by user</span><span class="s3">\n    </span><span class="s1">p = preference;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return p;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var findExemplars = function findExemplars(n, R, A) {</span><span class="s3">\n  </span><span class="s1">var indices = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">if (R[i * n + i] + A[i * n + i] &gt; 0) {</span><span class="s3">\n      </span><span class="s1">indices.push(i);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return indices;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var assignClusters = function assignClusters(n, S, exemplars) {</span><span class="s3">\n  </span><span class="s1">var clusters = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">var index = -1;</span><span class="s3">\n    </span><span class="s1">var max = -Infinity;</span><span class="s3">\n    </span><span class="s1">for (var ei = 0; ei &lt; exemplars.length; ei++) {</span><span class="s3">\n      </span><span class="s1">var e = exemplars[ei];</span><span class="s3">\n      </span><span class="s1">if (S[i * n + e] &gt; max) {</span><span class="s3">\n        </span><span class="s1">index = e;</span><span class="s3">\n        </span><span class="s1">max = S[i * n + e];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (index &gt; 0) {</span><span class="s3">\n      </span><span class="s1">clusters.push(index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var _ei = 0; _ei &lt; exemplars.length; _ei++) {</span><span class="s3">\n    </span><span class="s1">clusters[exemplars[_ei]] = exemplars[_ei];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var assign = function assign(n, S, exemplars) {</span><span class="s3">\n  </span><span class="s1">var clusters = assignClusters(n, S, exemplars);</span><span class="s3">\n  </span><span class="s1">for (var ei = 0; ei &lt; exemplars.length; ei++) {</span><span class="s3">\n    </span><span class="s1">var ii = [];</span><span class="s3">\n    </span><span class="s1">for (var c = 0; c &lt; clusters.length; c++) {</span><span class="s3">\n      </span><span class="s1">if (clusters[c] === exemplars[ei]) {</span><span class="s3">\n        </span><span class="s1">ii.push(c);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var maxI = -1;</span><span class="s3">\n    </span><span class="s1">var maxSum = -Infinity;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; ii.length; i++) {</span><span class="s3">\n      </span><span class="s1">var sum = 0;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; ii.length; j++) {</span><span class="s3">\n        </span><span class="s1">sum += S[ii[j] * n + ii[i]];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (sum &gt; maxSum) {</span><span class="s3">\n        </span><span class="s1">maxI = i;</span><span class="s3">\n        </span><span class="s1">maxSum = sum;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">exemplars[ei] = ii[maxI];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">clusters = assignClusters(n, S, exemplars);</span><span class="s3">\n  </span><span class="s1">return clusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var affinityPropagation = function affinityPropagation(options) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n  </span><span class="s1">var opts = setOptions(options);</span><span class="s3">\n\n  </span><span class="s1">// Map each node to its position in node array</span><span class="s3">\n  </span><span class="s1">var id2position = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">id2position[nodes[i].id()] = i;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Begin affinity propagation algorithm</span><span class="s3">\n\n  </span><span class="s1">var n; // number of data points</span><span class="s3">\n  </span><span class="s1">var n2; // size of matrices</span><span class="s3">\n  </span><span class="s1">var S; // similarity matrix (1D array)</span><span class="s3">\n  </span><span class="s1">var p; // preference/suitability of a data point to serve as an exemplar</span><span class="s3">\n  </span><span class="s1">var R; // responsibility matrix (1D array)</span><span class="s3">\n  </span><span class="s1">var A; // availability matrix (1D array)</span><span class="s3">\n\n  </span><span class="s1">n = nodes.length;</span><span class="s3">\n  </span><span class="s1">n2 = n * n;</span><span class="s3">\n\n  </span><span class="s1">// Initialize and build S similarity matrix</span><span class="s3">\n  </span><span class="s1">S = new Array(n2);</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; n2; _i++) {</span><span class="s3">\n    </span><span class="s1">S[_i] = -Infinity; // for cases where two data points shouldn't be linked together</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; n; _i2++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; n; j++) {</span><span class="s3">\n      </span><span class="s1">if (_i2 !== j) {</span><span class="s3">\n        </span><span class="s1">S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Place preferences on the diagonal of S</span><span class="s3">\n  </span><span class="s1">p = getPreference(S, opts.preference);</span><span class="s3">\n  </span><span class="s1">for (var _i3 = 0; _i3 &lt; n; _i3++) {</span><span class="s3">\n    </span><span class="s1">S[_i3 * n + _i3] = p;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Initialize R responsibility matrix</span><span class="s3">\n  </span><span class="s1">R = new Array(n2);</span><span class="s3">\n  </span><span class="s1">for (var _i4 = 0; _i4 &lt; n2; _i4++) {</span><span class="s3">\n    </span><span class="s1">R[_i4] = 0.0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Initialize A availability matrix</span><span class="s3">\n  </span><span class="s1">A = new Array(n2);</span><span class="s3">\n  </span><span class="s1">for (var _i5 = 0; _i5 &lt; n2; _i5++) {</span><span class="s3">\n    </span><span class="s1">A[_i5] = 0.0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var old = new Array(n);</span><span class="s3">\n  </span><span class="s1">var Rp = new Array(n);</span><span class="s3">\n  </span><span class="s1">var se = new Array(n);</span><span class="s3">\n  </span><span class="s1">for (var _i6 = 0; _i6 &lt; n; _i6++) {</span><span class="s3">\n    </span><span class="s1">old[_i6] = 0.0;</span><span class="s3">\n    </span><span class="s1">Rp[_i6] = 0.0;</span><span class="s3">\n    </span><span class="s1">se[_i6] = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var e = new Array(n * opts.minIterations);</span><span class="s3">\n  </span><span class="s1">for (var _i7 = 0; _i7 &lt; e.length; _i7++) {</span><span class="s3">\n    </span><span class="s1">e[_i7] = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var iter;</span><span class="s3">\n  </span><span class="s1">for (iter = 0; iter &lt; opts.maxIterations; iter++) {</span><span class="s3">\n    </span><span class="s1">// main algorithmic loop</span><span class="s3">\n\n    </span><span class="s1">// Update R responsibility matrix</span><span class="s3">\n    </span><span class="s1">for (var _i8 = 0; _i8 &lt; n; _i8++) {</span><span class="s3">\n      </span><span class="s1">var max = -Infinity,</span><span class="s3">\n        </span><span class="s1">max2 = -Infinity,</span><span class="s3">\n        </span><span class="s1">maxI = -1,</span><span class="s3">\n        </span><span class="s1">AS = 0.0;</span><span class="s3">\n      </span><span class="s1">for (var _j = 0; _j &lt; n; _j++) {</span><span class="s3">\n        </span><span class="s1">old[_j] = R[_i8 * n + _j];</span><span class="s3">\n        </span><span class="s1">AS = A[_i8 * n + _j] + S[_i8 * n + _j];</span><span class="s3">\n        </span><span class="s1">if (AS &gt;= max) {</span><span class="s3">\n          </span><span class="s1">max2 = max;</span><span class="s3">\n          </span><span class="s1">max = AS;</span><span class="s3">\n          </span><span class="s1">maxI = _j;</span><span class="s3">\n        </span><span class="s1">} else if (AS &gt; max2) {</span><span class="s3">\n          </span><span class="s1">max2 = AS;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var _j2 = 0; _j2 &lt; n; _j2++) {</span><span class="s3">\n        </span><span class="s1">R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Update A availability matrix</span><span class="s3">\n    </span><span class="s1">for (var _i9 = 0; _i9 &lt; n; _i9++) {</span><span class="s3">\n      </span><span class="s1">var sum = 0;</span><span class="s3">\n      </span><span class="s1">for (var _j3 = 0; _j3 &lt; n; _j3++) {</span><span class="s3">\n        </span><span class="s1">old[_j3] = A[_j3 * n + _i9];</span><span class="s3">\n        </span><span class="s1">Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);</span><span class="s3">\n        </span><span class="s1">sum += Rp[_j3];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">sum -= Rp[_i9];</span><span class="s3">\n      </span><span class="s1">Rp[_i9] = R[_i9 * n + _i9];</span><span class="s3">\n      </span><span class="s1">sum += Rp[_i9];</span><span class="s3">\n      </span><span class="s1">for (var _j4 = 0; _j4 &lt; n; _j4++) {</span><span class="s3">\n        </span><span class="s1">A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Check for convergence</span><span class="s3">\n    </span><span class="s1">var K = 0;</span><span class="s3">\n    </span><span class="s1">for (var _i10 = 0; _i10 &lt; n; _i10++) {</span><span class="s3">\n      </span><span class="s1">var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] &gt; 0 ? 1 : 0;</span><span class="s3">\n      </span><span class="s1">e[iter % opts.minIterations * n + _i10] = E;</span><span class="s3">\n      </span><span class="s1">K += E;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (K &gt; 0 &amp;&amp; (iter &gt;= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {</span><span class="s3">\n      </span><span class="s1">var _sum = 0;</span><span class="s3">\n      </span><span class="s1">for (var _i11 = 0; _i11 &lt; n; _i11++) {</span><span class="s3">\n        </span><span class="s1">se[_i11] = 0;</span><span class="s3">\n        </span><span class="s1">for (var _j5 = 0; _j5 &lt; opts.minIterations; _j5++) {</span><span class="s3">\n          </span><span class="s1">se[_i11] += e[_j5 * n + _i11];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (se[_i11] === 0 || se[_i11] === opts.minIterations) {</span><span class="s3">\n          </span><span class="s1">_sum++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (_sum === n) {</span><span class="s3">\n        </span><span class="s1">// then we have convergence</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Identify exemplars (cluster centers)</span><span class="s3">\n  </span><span class="s1">var exemplarsIndices = findExemplars(n, R, A);</span><span class="s3">\n\n  </span><span class="s1">// Assign nodes to clusters</span><span class="s3">\n  </span><span class="s1">var clusterIndices = assign(n, S, exemplarsIndices);</span><span class="s3">\n  </span><span class="s1">var clusters = {};</span><span class="s3">\n  </span><span class="s1">for (var c = 0; c &lt; exemplarsIndices.length; c++) {</span><span class="s3">\n    </span><span class="s1">clusters[exemplarsIndices[c]] = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var _i12 = 0; _i12 &lt; nodes.length; _i12++) {</span><span class="s3">\n    </span><span class="s1">var pos = id2position[nodes[_i12].id()];</span><span class="s3">\n    </span><span class="s1">var clusterIndex = clusterIndices[pos];</span><span class="s3">\n    </span><span class="s1">if (clusterIndex != null) {</span><span class="s3">\n      </span><span class="s1">// the node may have not been assigned a cluster if no valid attributes were specified</span><span class="s3">\n      </span><span class="s1">clusters[clusterIndex].push(nodes[_i12]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var retClusters = new Array(exemplarsIndices.length);</span><span class="s3">\n  </span><span class="s1">for (var _c = 0; _c &lt; exemplarsIndices.length; _c++) {</span><span class="s3">\n    </span><span class="s1">retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return retClusters;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var affinityPropagation$1 = {</span><span class="s3">\n  </span><span class="s1">affinityPropagation: affinityPropagation,</span><span class="s3">\n  </span><span class="s1">ap: affinityPropagation</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var hierholzerDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">root: undefined,</span><span class="s3">\n  </span><span class="s1">directed: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$k = {</span><span class="s3">\n  </span><span class="s1">hierholzer: function hierholzer(options) {</span><span class="s3">\n    </span><span class="s1">if (!plainObject(options)) {</span><span class="s3">\n      </span><span class="s1">var args = arguments;</span><span class="s3">\n      </span><span class="s1">options = {</span><span class="s3">\n        </span><span class="s1">root: args[0],</span><span class="s3">\n        </span><span class="s1">directed: args[1]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _hierholzerDefaults = hierholzerDefaults(options),</span><span class="s3">\n      </span><span class="s1">root = _hierholzerDefaults.root,</span><span class="s3">\n      </span><span class="s1">directed = _hierholzerDefaults.directed;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var dflag = false;</span><span class="s3">\n    </span><span class="s1">var oddIn;</span><span class="s3">\n    </span><span class="s1">var oddOut;</span><span class="s3">\n    </span><span class="s1">var startVertex;</span><span class="s3">\n    </span><span class="s1">if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();</span><span class="s3">\n    </span><span class="s1">var nodes = {};</span><span class="s3">\n    </span><span class="s1">var edges = {};</span><span class="s3">\n    </span><span class="s1">if (directed) {</span><span class="s3">\n      </span><span class="s1">eles.forEach(function (ele) {</span><span class="s3">\n        </span><span class="s1">var id = ele.id();</span><span class="s3">\n        </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n          </span><span class="s1">var ind = ele.indegree(true);</span><span class="s3">\n          </span><span class="s1">var outd = ele.outdegree(true);</span><span class="s3">\n          </span><span class="s1">var d1 = ind - outd;</span><span class="s3">\n          </span><span class="s1">var d2 = outd - ind;</span><span class="s3">\n          </span><span class="s1">if (d1 == 1) {</span><span class="s3">\n            </span><span class="s1">if (oddIn) dflag = true;else oddIn = id;</span><span class="s3">\n          </span><span class="s1">} else if (d2 == 1) {</span><span class="s3">\n            </span><span class="s1">if (oddOut) dflag = true;else oddOut = id;</span><span class="s3">\n          </span><span class="s1">} else if (d2 &gt; 1 || d1 &gt; 1) {</span><span class="s3">\n            </span><span class="s1">dflag = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">nodes[id] = [];</span><span class="s3">\n          </span><span class="s1">ele.outgoers().forEach(function (e) {</span><span class="s3">\n            </span><span class="s1">if (e.isEdge()) nodes[id].push(e.id());</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">edges[id] = [undefined, ele.target().id()];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">eles.forEach(function (ele) {</span><span class="s3">\n        </span><span class="s1">var id = ele.id();</span><span class="s3">\n        </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n          </span><span class="s1">var d = ele.degree(true);</span><span class="s3">\n          </span><span class="s1">if (d % 2) {</span><span class="s3">\n            </span><span class="s1">if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">nodes[id] = [];</span><span class="s3">\n          </span><span class="s1">ele.connectedEdges().forEach(function (e) {</span><span class="s3">\n            </span><span class="s1">return nodes[id].push(e.id());</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">edges[id] = [ele.source().id(), ele.target().id()];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var result = {</span><span class="s3">\n      </span><span class="s1">found: false,</span><span class="s3">\n      </span><span class="s1">trail: undefined</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (dflag) return result;else if (oddOut &amp;&amp; oddIn) {</span><span class="s3">\n      </span><span class="s1">if (directed) {</span><span class="s3">\n        </span><span class="s1">if (startVertex &amp;&amp; oddOut != startVertex) {</span><span class="s3">\n          </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">startVertex = oddOut;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (startVertex &amp;&amp; oddOut != startVertex &amp;&amp; oddIn != startVertex) {</span><span class="s3">\n          </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">} else if (!startVertex) {</span><span class="s3">\n          </span><span class="s1">startVertex = oddOut;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!startVertex) startVertex = eles[0].id();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var walk = function walk(v) {</span><span class="s3">\n      </span><span class="s1">var currentNode = v;</span><span class="s3">\n      </span><span class="s1">var subtour = [v];</span><span class="s3">\n      </span><span class="s1">var adj, adjTail, adjHead;</span><span class="s3">\n      </span><span class="s1">while (nodes[currentNode].length) {</span><span class="s3">\n        </span><span class="s1">adj = nodes[currentNode].shift();</span><span class="s3">\n        </span><span class="s1">adjTail = edges[adj][0];</span><span class="s3">\n        </span><span class="s1">adjHead = edges[adj][1];</span><span class="s3">\n        </span><span class="s1">if (currentNode != adjHead) {</span><span class="s3">\n          </span><span class="s1">nodes[adjHead] = nodes[adjHead].filter(function (e) {</span><span class="s3">\n            </span><span class="s1">return e != adj;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">currentNode = adjHead;</span><span class="s3">\n        </span><span class="s1">} else if (!directed &amp;&amp; currentNode != adjTail) {</span><span class="s3">\n          </span><span class="s1">nodes[adjTail] = nodes[adjTail].filter(function (e) {</span><span class="s3">\n            </span><span class="s1">return e != adj;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">currentNode = adjTail;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">subtour.unshift(adj);</span><span class="s3">\n        </span><span class="s1">subtour.unshift(currentNode);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return subtour;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var trail = [];</span><span class="s3">\n    </span><span class="s1">var subtour = [];</span><span class="s3">\n    </span><span class="s1">subtour = walk(startVertex);</span><span class="s3">\n    </span><span class="s1">while (subtour.length != 1) {</span><span class="s3">\n      </span><span class="s1">if (nodes[subtour[0]].length == 0) {</span><span class="s3">\n        </span><span class="s1">trail.unshift(eles.getElementById(subtour.shift()));</span><span class="s3">\n        </span><span class="s1">trail.unshift(eles.getElementById(subtour.shift()));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">subtour = walk(subtour.shift()).concat(subtour);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">trail.unshift(eles.getElementById(subtour.shift())); // final node</span><span class="s3">\n\n    </span><span class="s1">for (var d in nodes) {</span><span class="s3">\n      </span><span class="s1">if (nodes[d].length) {</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result.found = true;</span><span class="s3">\n    </span><span class="s1">result.trail = this.spawn(trail, true);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {</span><span class="s3">\n  </span><span class="s1">var eles = this;</span><span class="s3">\n  </span><span class="s1">var nodes = {};</span><span class="s3">\n  </span><span class="s1">var id = 0;</span><span class="s3">\n  </span><span class="s1">var edgeCount = 0;</span><span class="s3">\n  </span><span class="s1">var components = [];</span><span class="s3">\n  </span><span class="s1">var stack = [];</span><span class="s3">\n  </span><span class="s1">var visitedEdges = {};</span><span class="s3">\n  </span><span class="s1">var buildComponent = function buildComponent(x, y) {</span><span class="s3">\n    </span><span class="s1">var i = stack.length - 1;</span><span class="s3">\n    </span><span class="s1">var cutset = [];</span><span class="s3">\n    </span><span class="s1">var component = eles.spawn();</span><span class="s3">\n    </span><span class="s1">while (stack[i].x != x || stack[i].y != y) {</span><span class="s3">\n      </span><span class="s1">cutset.push(stack.pop().edge);</span><span class="s3">\n      </span><span class="s1">i--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cutset.push(stack.pop().edge);</span><span class="s3">\n    </span><span class="s1">cutset.forEach(function (edge) {</span><span class="s3">\n      </span><span class="s1">var connectedNodes = edge.connectedNodes().intersection(eles);</span><span class="s3">\n      </span><span class="s1">component.merge(edge);</span><span class="s3">\n      </span><span class="s1">connectedNodes.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">var nodeId = node.id();</span><span class="s3">\n        </span><span class="s1">var connectedEdges = node.connectedEdges().intersection(eles);</span><span class="s3">\n        </span><span class="s1">component.merge(node);</span><span class="s3">\n        </span><span class="s1">if (!nodes[nodeId].cutVertex) {</span><span class="s3">\n          </span><span class="s1">component.merge(connectedEdges);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">component.merge(connectedEdges.filter(function (edge) {</span><span class="s3">\n            </span><span class="s1">return edge.isLoop();</span><span class="s3">\n          </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">components.push(component);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var _biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {</span><span class="s3">\n    </span><span class="s1">if (root === parent) edgeCount += 1;</span><span class="s3">\n    </span><span class="s1">nodes[currentNode] = {</span><span class="s3">\n      </span><span class="s1">id: id,</span><span class="s3">\n      </span><span class="s1">low: id++,</span><span class="s3">\n      </span><span class="s1">cutVertex: false</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);</span><span class="s3">\n    </span><span class="s1">if (edges.size() === 0) {</span><span class="s3">\n      </span><span class="s1">components.push(eles.spawn(eles.getElementById(currentNode)));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var sourceId, targetId, otherNodeId, edgeId;</span><span class="s3">\n      </span><span class="s1">edges.forEach(function (edge) {</span><span class="s3">\n        </span><span class="s1">sourceId = edge.source().id();</span><span class="s3">\n        </span><span class="s1">targetId = edge.target().id();</span><span class="s3">\n        </span><span class="s1">otherNodeId = sourceId === currentNode ? targetId : sourceId;</span><span class="s3">\n        </span><span class="s1">if (otherNodeId !== parent) {</span><span class="s3">\n          </span><span class="s1">edgeId = edge.id();</span><span class="s3">\n          </span><span class="s1">if (!visitedEdges[edgeId]) {</span><span class="s3">\n            </span><span class="s1">visitedEdges[edgeId] = true;</span><span class="s3">\n            </span><span class="s1">stack.push({</span><span class="s3">\n              </span><span class="s1">x: currentNode,</span><span class="s3">\n              </span><span class="s1">y: otherNodeId,</span><span class="s3">\n              </span><span class="s1">edge: edge</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!(otherNodeId in nodes)) {</span><span class="s3">\n            </span><span class="s1">_biconnectedSearch(root, otherNodeId, currentNode);</span><span class="s3">\n            </span><span class="s1">nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);</span><span class="s3">\n            </span><span class="s1">if (nodes[currentNode].id &lt;= nodes[otherNodeId].low) {</span><span class="s3">\n              </span><span class="s1">nodes[currentNode].cutVertex = true;</span><span class="s3">\n              </span><span class="s1">buildComponent(currentNode, otherNodeId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">eles.forEach(function (ele) {</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">var nodeId = ele.id();</span><span class="s3">\n      </span><span class="s1">if (!(nodeId in nodes)) {</span><span class="s3">\n        </span><span class="s1">edgeCount = 0;</span><span class="s3">\n        </span><span class="s1">_biconnectedSearch(nodeId, nodeId);</span><span class="s3">\n        </span><span class="s1">nodes[nodeId].cutVertex = edgeCount &gt; 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var cutVertices = Object.keys(nodes).filter(function (id) {</span><span class="s3">\n    </span><span class="s1">return nodes[id].cutVertex;</span><span class="s3">\n  </span><span class="s1">}).map(function (id) {</span><span class="s3">\n    </span><span class="s1">return eles.getElementById(id);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">cut: eles.spawn(cutVertices),</span><span class="s3">\n    </span><span class="s1">components: components</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var hopcroftTarjanBiconnected$1 = {</span><span class="s3">\n  </span><span class="s1">hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,</span><span class="s3">\n  </span><span class="s1">htbc: hopcroftTarjanBiconnected,</span><span class="s3">\n  </span><span class="s1">htb: hopcroftTarjanBiconnected,</span><span class="s3">\n  </span><span class="s1">hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var tarjanStronglyConnected = function tarjanStronglyConnected() {</span><span class="s3">\n  </span><span class="s1">var eles = this;</span><span class="s3">\n  </span><span class="s1">var nodes = {};</span><span class="s3">\n  </span><span class="s1">var index = 0;</span><span class="s3">\n  </span><span class="s1">var components = [];</span><span class="s3">\n  </span><span class="s1">var stack = [];</span><span class="s3">\n  </span><span class="s1">var cut = eles.spawn(eles);</span><span class="s3">\n  </span><span class="s1">var _stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {</span><span class="s3">\n    </span><span class="s1">stack.push(sourceNodeId);</span><span class="s3">\n    </span><span class="s1">nodes[sourceNodeId] = {</span><span class="s3">\n      </span><span class="s1">index: index,</span><span class="s3">\n      </span><span class="s1">low: index++,</span><span class="s3">\n      </span><span class="s1">explored: false</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);</span><span class="s3">\n    </span><span class="s1">connectedEdges.forEach(function (edge) {</span><span class="s3">\n      </span><span class="s1">var targetNodeId = edge.target().id();</span><span class="s3">\n      </span><span class="s1">if (targetNodeId !== sourceNodeId) {</span><span class="s3">\n        </span><span class="s1">if (!(targetNodeId in nodes)) {</span><span class="s3">\n          </span><span class="s1">_stronglyConnectedSearch(targetNodeId);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!nodes[targetNodeId].explored) {</span><span class="s3">\n          </span><span class="s1">nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {</span><span class="s3">\n      </span><span class="s1">var componentNodes = eles.spawn();</span><span class="s3">\n      </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">var nodeId = stack.pop();</span><span class="s3">\n        </span><span class="s1">componentNodes.merge(eles.getElementById(nodeId));</span><span class="s3">\n        </span><span class="s1">nodes[nodeId].low = nodes[sourceNodeId].index;</span><span class="s3">\n        </span><span class="s1">nodes[nodeId].explored = true;</span><span class="s3">\n        </span><span class="s1">if (nodeId === sourceNodeId) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var componentEdges = componentNodes.edgesWith(componentNodes);</span><span class="s3">\n      </span><span class="s1">var component = componentNodes.merge(componentEdges);</span><span class="s3">\n      </span><span class="s1">components.push(component);</span><span class="s3">\n      </span><span class="s1">cut = cut.difference(component);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">eles.forEach(function (ele) {</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">var nodeId = ele.id();</span><span class="s3">\n      </span><span class="s1">if (!(nodeId in nodes)) {</span><span class="s3">\n        </span><span class="s1">_stronglyConnectedSearch(nodeId);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">cut: cut,</span><span class="s3">\n    </span><span class="s1">components: components</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var tarjanStronglyConnected$1 = {</span><span class="s3">\n  </span><span class="s1">tarjanStronglyConnected: tarjanStronglyConnected,</span><span class="s3">\n  </span><span class="s1">tsc: tarjanStronglyConnected,</span><span class="s3">\n  </span><span class="s1">tscc: tarjanStronglyConnected,</span><span class="s3">\n  </span><span class="s1">tarjanStronglyConnectedComponents: tarjanStronglyConnected</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var elesfn$j = {};</span><span class="s3">\n</span><span class="s1">[elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(elesfn$j, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/*!</span><span class="s3">\n</span><span class="s1">Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable</span><span class="s3">\n</span><span class="s1">Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)</span><span class="s3">\n</span><span class="s1">Licensed under The MIT License (http://opensource.org/licenses/MIT)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/*  promise states [Promises/A+ 2.1]  */</span><span class="s3">\n</span><span class="s1">var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */</span><span class="s3">\n</span><span class="s1">var STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */</span><span class="s3">\n</span><span class="s1">var STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */</span><span class="s3">\n\n</span><span class="s1">/*  promise object constructor  */</span><span class="s3">\n</span><span class="s1">var _api = function api(executor) {</span><span class="s3">\n  </span><span class="s1">/*  optionally support non-constructor/plain-function call  */</span><span class="s3">\n  </span><span class="s1">if (!(this instanceof _api)) return new _api(executor);</span><span class="s3">\n\n  </span><span class="s1">/*  initialize object  */</span><span class="s3">\n  </span><span class="s1">this.id = 'Thenable/1.0.7';</span><span class="s3">\n  </span><span class="s1">this.state = STATE_PENDING; /*  initial state  */</span><span class="s3">\n  </span><span class="s1">this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */</span><span class="s3">\n  </span><span class="s1">this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */</span><span class="s3">\n  </span><span class="s1">this.onFulfilled = []; /*  initial handlers  */</span><span class="s3">\n  </span><span class="s1">this.onRejected = []; /*  initial handlers  */</span><span class="s3">\n\n  </span><span class="s1">/*  provide optional information-hiding proxy  */</span><span class="s3">\n  </span><span class="s1">this.proxy = {</span><span class="s3">\n    </span><span class="s1">then: this.then.bind(this)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/*  support optional executor function  */</span><span class="s3">\n  </span><span class="s1">if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*  promise API methods  */</span><span class="s3">\n</span><span class="s1">_api.prototype = {</span><span class="s3">\n  </span><span class="s1">/*  promise resolving methods  */</span><span class="s3">\n  </span><span class="s1">fulfill: function fulfill(value) {</span><span class="s3">\n    </span><span class="s1">return deliver(this, STATE_FULFILLED, 'fulfillValue', value);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">reject: function reject(value) {</span><span class="s3">\n    </span><span class="s1">return deliver(this, STATE_REJECTED, 'rejectReason', value);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">/*  </span><span class="s3">\&quot;</span><span class="s1">The then Method</span><span class="s3">\&quot; </span><span class="s1">[Promises/A+ 1.1, 1.2, 2.2]  */</span><span class="s3">\n  </span><span class="s1">then: function then(onFulfilled, onRejected) {</span><span class="s3">\n    </span><span class="s1">var curr = this;</span><span class="s3">\n    </span><span class="s1">var next = new _api(); /*  [Promises/A+ 2.2.7]  */</span><span class="s3">\n    </span><span class="s1">curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */</span><span class="s3">\n    </span><span class="s1">curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */</span><span class="s3">\n    </span><span class="s1">execute(curr);</span><span class="s3">\n    </span><span class="s1">return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*  deliver an action  */</span><span class="s3">\n</span><span class="s1">var deliver = function deliver(curr, state, name, value) {</span><span class="s3">\n  </span><span class="s1">if (curr.state === STATE_PENDING) {</span><span class="s3">\n    </span><span class="s1">curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */</span><span class="s3">\n    </span><span class="s1">curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */</span><span class="s3">\n    </span><span class="s1">execute(curr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return curr;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*  execute all handlers  */</span><span class="s3">\n</span><span class="s1">var execute = function execute(curr) {</span><span class="s3">\n  </span><span class="s1">if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*  execute particular set of handlers  */</span><span class="s3">\n</span><span class="s1">var execute_handlers = function execute_handlers(curr, name, value) {</span><span class="s3">\n  </span><span class="s1">/* global setImmediate: true */</span><span class="s3">\n  </span><span class="s1">/* global setTimeout: true */</span><span class="s3">\n\n  </span><span class="s1">/*  short-circuit processing  */</span><span class="s3">\n  </span><span class="s1">if (curr[name].length === 0) return;</span><span class="s3">\n\n  </span><span class="s1">/*  iterate over all handlers, exactly once  */</span><span class="s3">\n  </span><span class="s1">var handlers = curr[name];</span><span class="s3">\n  </span><span class="s1">curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */</span><span class="s3">\n  </span><span class="s1">var func = function func() {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; handlers.length; i++) handlers[i](value); /*  [Promises/A+ 2.2.5]  */</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */</span><span class="s3">\n  </span><span class="s1">if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*  generate a resolver function  */</span><span class="s3">\n</span><span class="s1">var resolver = function resolver(cb, next, method) {</span><span class="s3">\n  </span><span class="s1">return function (value) {</span><span class="s3">\n    </span><span class="s1">if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */</span><span class="s3">\n      </span><span class="s1">next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */else {</span><span class="s3">\n      </span><span class="s1">var result;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">result = cb(value);</span><span class="s3">\n      </span><span class="s1">} /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */ catch (e) {</span><span class="s3">\n        </span><span class="s1">next.reject(e); /*  [Promises/A+ 2.2.7.2]  */</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*  </span><span class="s3">\&quot;</span><span class="s1">Promise Resolution Procedure</span><span class="s3">\&quot;  </span><span class="s1">*/ /*  [Promises/A+ 2.3]  */</span><span class="s3">\n</span><span class="s1">var _resolve = function resolve(promise, x) {</span><span class="s3">\n  </span><span class="s1">/*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */</span><span class="s3">\n  </span><span class="s1">if (promise === x || promise.proxy === x) {</span><span class="s3">\n    </span><span class="s1">promise.reject(new TypeError('cannot resolve promise with itself'));</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/*  surgically check for a </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot; </span><span class="s1">method</span><span class="s3">\n    </span><span class="s1">(mainly to just call the </span><span class="s3">\&quot;</span><span class="s1">getter</span><span class="s3">\&quot; </span><span class="s1">of </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot; </span><span class="s1">only once)  */</span><span class="s3">\n  </span><span class="s1">var then;</span><span class="s3">\n  </span><span class="s1">if (_typeof(x) === 'object' &amp;&amp; x !== null || typeof x === 'function') {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">then = x.then;</span><span class="s3">\n    </span><span class="s1">} /*  [Promises/A+ 2.3.3.1, 3.5]  */ catch (e) {</span><span class="s3">\n      </span><span class="s1">promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/*  handle own Thenables    [Promises/A+ 2.3.2]</span><span class="s3">\n    </span><span class="s1">and similar </span><span class="s3">\&quot;</span><span class="s1">thenables</span><span class="s3">\&quot; </span><span class="s1">[Promises/A+ 2.3.3]  */</span><span class="s3">\n  </span><span class="s1">if (typeof then === 'function') {</span><span class="s3">\n    </span><span class="s1">var resolved = false;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">/*  call retrieved </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot; </span><span class="s1">method */ /*  [Promises/A+ 2.3.3.3]  */</span><span class="s3">\n      </span><span class="s1">then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */</span><span class="s3">\n      </span><span class="s1">function (y) {</span><span class="s3">\n        </span><span class="s1">if (resolved) return;</span><span class="s3">\n        </span><span class="s1">resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */</span><span class="s3">\n        </span><span class="s1">if (y === x) /*  [Promises/A+ 3.6]  */</span><span class="s3">\n          </span><span class="s1">promise.reject(new TypeError('circular thenable chain'));else _resolve(promise, y);</span><span class="s3">\n      </span><span class="s1">}, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */</span><span class="s3">\n      </span><span class="s1">function (r) {</span><span class="s3">\n        </span><span class="s1">if (resolved) return;</span><span class="s3">\n        </span><span class="s1">resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */</span><span class="s3">\n        </span><span class="s1">promise.reject(r);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n      </span><span class="s1">if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */</span><span class="s3">\n        </span><span class="s1">promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/*  handle other values  */</span><span class="s3">\n  </span><span class="s1">promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// so we always have Promise.all()</span><span class="s3">\n</span><span class="s1">_api.all = function (ps) {</span><span class="s3">\n  </span><span class="s1">return new _api(function (resolveAll, rejectAll) {</span><span class="s3">\n    </span><span class="s1">var vals = new Array(ps.length);</span><span class="s3">\n    </span><span class="s1">var doneCount = 0;</span><span class="s3">\n    </span><span class="s1">var fulfill = function fulfill(i, val) {</span><span class="s3">\n      </span><span class="s1">vals[i] = val;</span><span class="s3">\n      </span><span class="s1">doneCount++;</span><span class="s3">\n      </span><span class="s1">if (doneCount === ps.length) {</span><span class="s3">\n        </span><span class="s1">resolveAll(vals);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; ps.length; i++) {</span><span class="s3">\n      </span><span class="s1">(function (i) {</span><span class="s3">\n        </span><span class="s1">var p = ps[i];</span><span class="s3">\n        </span><span class="s1">var isPromise = p != null &amp;&amp; p.then != null;</span><span class="s3">\n        </span><span class="s1">if (isPromise) {</span><span class="s3">\n          </span><span class="s1">p.then(function (val) {</span><span class="s3">\n            </span><span class="s1">fulfill(i, val);</span><span class="s3">\n          </span><span class="s1">}, function (err) {</span><span class="s3">\n            </span><span class="s1">rejectAll(err);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var val = p;</span><span class="s3">\n          </span><span class="s1">fulfill(i, val);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})(i);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">_api.resolve = function (val) {</span><span class="s3">\n  </span><span class="s1">return new _api(function (resolve, reject) {</span><span class="s3">\n    </span><span class="s1">resolve(val);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">_api.reject = function (val) {</span><span class="s3">\n  </span><span class="s1">return new _api(function (resolve, reject) {</span><span class="s3">\n    </span><span class="s1">reject(val);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var Promise$1 = typeof Promise !== 'undefined' ? Promise : _api; // eslint-disable-line no-undef</span><span class="s3">\n\n</span><span class="s1">var Animation = function Animation(target, opts, opts2) {</span><span class="s3">\n  </span><span class="s1">var isCore = core(target);</span><span class="s3">\n  </span><span class="s1">var isEle = !isCore;</span><span class="s3">\n  </span><span class="s1">var _p = this._private = extend({</span><span class="s3">\n    </span><span class="s1">duration: 1000</span><span class="s3">\n  </span><span class="s1">}, opts, opts2);</span><span class="s3">\n  </span><span class="s1">_p.target = target;</span><span class="s3">\n  </span><span class="s1">_p.style = _p.style || _p.css;</span><span class="s3">\n  </span><span class="s1">_p.started = false;</span><span class="s3">\n  </span><span class="s1">_p.playing = false;</span><span class="s3">\n  </span><span class="s1">_p.hooked = false;</span><span class="s3">\n  </span><span class="s1">_p.applying = false;</span><span class="s3">\n  </span><span class="s1">_p.progress = 0;</span><span class="s3">\n  </span><span class="s1">_p.completes = [];</span><span class="s3">\n  </span><span class="s1">_p.frames = [];</span><span class="s3">\n  </span><span class="s1">if (_p.complete &amp;&amp; fn$6(_p.complete)) {</span><span class="s3">\n    </span><span class="s1">_p.completes.push(_p.complete);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isEle) {</span><span class="s3">\n    </span><span class="s1">var pos = target.position();</span><span class="s3">\n    </span><span class="s1">_p.startPosition = _p.startPosition || {</span><span class="s3">\n      </span><span class="s1">x: pos.x,</span><span class="s3">\n      </span><span class="s1">y: pos.y</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">_p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isCore) {</span><span class="s3">\n    </span><span class="s1">var pan = target.pan();</span><span class="s3">\n    </span><span class="s1">_p.startPan = {</span><span class="s3">\n      </span><span class="s1">x: pan.x,</span><span class="s3">\n      </span><span class="s1">y: pan.y</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">_p.startZoom = target.zoom();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// for future timeline/animations impl</span><span class="s3">\n  </span><span class="s1">this.length = 1;</span><span class="s3">\n  </span><span class="s1">this[0] = this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var anifn = Animation.prototype;</span><span class="s3">\n</span><span class="s1">extend(anifn, {</span><span class="s3">\n  </span><span class="s1">instanceString: function instanceString() {</span><span class="s3">\n    </span><span class="s1">return 'animation';</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hook: function hook() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (!_p.hooked) {</span><span class="s3">\n      </span><span class="s1">// add to target's animation queue</span><span class="s3">\n      </span><span class="s1">var q;</span><span class="s3">\n      </span><span class="s1">var tAni = _p.target._private.animation;</span><span class="s3">\n      </span><span class="s1">if (_p.queue) {</span><span class="s3">\n        </span><span class="s1">q = tAni.queue;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">q = tAni.current;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">q.push(this);</span><span class="s3">\n\n      </span><span class="s1">// add to the animation loop pool</span><span class="s3">\n      </span><span class="s1">if (elementOrCollection(_p.target)) {</span><span class="s3">\n        </span><span class="s1">_p.target.cy().addToAnimationPool(_p.target);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_p.hooked = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">play: function play() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n\n    </span><span class="s1">// autorewind</span><span class="s3">\n    </span><span class="s1">if (_p.progress === 1) {</span><span class="s3">\n      </span><span class="s1">_p.progress = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.playing = true;</span><span class="s3">\n    </span><span class="s1">_p.started = false; // needs to be started by animation loop</span><span class="s3">\n    </span><span class="s1">_p.stopped = false;</span><span class="s3">\n    </span><span class="s1">this.hook();</span><span class="s3">\n\n    </span><span class="s1">// the animation loop will start the animation...</span><span class="s3">\n\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">playing: function playing() {</span><span class="s3">\n    </span><span class="s1">return this._private.playing;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">apply: function apply() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">_p.applying = true;</span><span class="s3">\n    </span><span class="s1">_p.started = false; // needs to be started by animation loop</span><span class="s3">\n    </span><span class="s1">_p.stopped = false;</span><span class="s3">\n    </span><span class="s1">this.hook();</span><span class="s3">\n\n    </span><span class="s1">// the animation loop will apply the animation at this progress</span><span class="s3">\n\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">applying: function applying() {</span><span class="s3">\n    </span><span class="s1">return this._private.applying;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">pause: function pause() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">_p.playing = false;</span><span class="s3">\n    </span><span class="s1">_p.started = false;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">stop: function stop() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">_p.playing = false;</span><span class="s3">\n    </span><span class="s1">_p.started = false;</span><span class="s3">\n    </span><span class="s1">_p.stopped = true; // to be removed from animation queues</span><span class="s3">\n\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">rewind: function rewind() {</span><span class="s3">\n    </span><span class="s1">return this.progress(0);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">fastforward: function fastforward() {</span><span class="s3">\n    </span><span class="s1">return this.progress(1);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">time: function time(t) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (t === undefined) {</span><span class="s3">\n      </span><span class="s1">return _p.progress * _p.duration;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this.progress(t / _p.duration);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">progress: function progress(p) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var wasPlaying = _p.playing;</span><span class="s3">\n    </span><span class="s1">if (p === undefined) {</span><span class="s3">\n      </span><span class="s1">return _p.progress;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (wasPlaying) {</span><span class="s3">\n        </span><span class="s1">this.pause();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_p.progress = p;</span><span class="s3">\n      </span><span class="s1">_p.started = false;</span><span class="s3">\n      </span><span class="s1">if (wasPlaying) {</span><span class="s3">\n        </span><span class="s1">this.play();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">completed: function completed() {</span><span class="s3">\n    </span><span class="s1">return this._private.progress === 1;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">reverse: function reverse() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var wasPlaying = _p.playing;</span><span class="s3">\n    </span><span class="s1">if (wasPlaying) {</span><span class="s3">\n      </span><span class="s1">this.pause();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.progress = 1 - _p.progress;</span><span class="s3">\n    </span><span class="s1">_p.started = false;</span><span class="s3">\n    </span><span class="s1">var swap = function swap(a, b) {</span><span class="s3">\n      </span><span class="s1">var _pa = _p[a];</span><span class="s3">\n      </span><span class="s1">if (_pa == null) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_p[a] = _p[b];</span><span class="s3">\n      </span><span class="s1">_p[b] = _pa;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">swap('zoom', 'startZoom');</span><span class="s3">\n    </span><span class="s1">swap('pan', 'startPan');</span><span class="s3">\n    </span><span class="s1">swap('position', 'startPosition');</span><span class="s3">\n\n    </span><span class="s1">// swap styles</span><span class="s3">\n    </span><span class="s1">if (_p.style) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; _p.style.length; i++) {</span><span class="s3">\n        </span><span class="s1">var prop = _p.style[i];</span><span class="s3">\n        </span><span class="s1">var name = prop.name;</span><span class="s3">\n        </span><span class="s1">var startStyleProp = _p.startStyle[name];</span><span class="s3">\n        </span><span class="s1">_p.startStyle[name] = prop;</span><span class="s3">\n        </span><span class="s1">_p.style[i] = startStyleProp;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (wasPlaying) {</span><span class="s3">\n      </span><span class="s1">this.play();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">promise: function promise(type) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var arr;</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case 'frame':</span><span class="s3">\n        </span><span class="s1">arr = _p.frames;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">case 'complete':</span><span class="s3">\n      </span><span class="s1">case 'completed':</span><span class="s3">\n        </span><span class="s1">arr = _p.completes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new Promise$1(function (resolve, reject) {</span><span class="s3">\n      </span><span class="s1">arr.push(function () {</span><span class="s3">\n        </span><span class="s1">resolve();</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">anifn.complete = anifn.completed;</span><span class="s3">\n</span><span class="s1">anifn.run = anifn.play;</span><span class="s3">\n</span><span class="s1">anifn.running = anifn.playing;</span><span class="s3">\n\n</span><span class="s1">var define$3 = {</span><span class="s3">\n  </span><span class="s1">animated: function animated() {</span><span class="s3">\n    </span><span class="s1">return function animatedImpl() {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var ele = all[0];</span><span class="s3">\n      </span><span class="s1">if (ele) {</span><span class="s3">\n        </span><span class="s1">return ele._private.animation.current.length &gt; 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// animated</span><span class="s3">\n\n  </span><span class="s1">clearQueue: function clearQueue() {</span><span class="s3">\n    </span><span class="s1">return function clearQueueImpl() {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; all.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = all[i];</span><span class="s3">\n        </span><span class="s1">ele._private.animation.queue = [];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// clearQueue</span><span class="s3">\n\n  </span><span class="s1">delay: function delay() {</span><span class="s3">\n    </span><span class="s1">return function delayImpl(time, complete) {</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this.animate({</span><span class="s3">\n        </span><span class="s1">delay: time,</span><span class="s3">\n        </span><span class="s1">duration: time,</span><span class="s3">\n        </span><span class="s1">complete: complete</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// delay</span><span class="s3">\n\n  </span><span class="s1">delayAnimation: function delayAnimation() {</span><span class="s3">\n    </span><span class="s1">return function delayAnimationImpl(time, complete) {</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this.animation({</span><span class="s3">\n        </span><span class="s1">delay: time,</span><span class="s3">\n        </span><span class="s1">duration: time,</span><span class="s3">\n        </span><span class="s1">complete: complete</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// delay</span><span class="s3">\n\n  </span><span class="s1">animation: function animation() {</span><span class="s3">\n    </span><span class="s1">return function animationImpl(properties, params) {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">var isCore = !selfIsArrayLike;</span><span class="s3">\n      </span><span class="s1">var isEles = !isCore;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var style = cy.style();</span><span class="s3">\n      </span><span class="s1">properties = extend({}, properties, params);</span><span class="s3">\n      </span><span class="s1">var propertiesEmpty = Object.keys(properties).length === 0;</span><span class="s3">\n      </span><span class="s1">if (propertiesEmpty) {</span><span class="s3">\n        </span><span class="s1">return new Animation(all[0], properties); // nothing to animate</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (properties.duration === undefined) {</span><span class="s3">\n        </span><span class="s1">properties.duration = 400;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">switch (properties.duration) {</span><span class="s3">\n        </span><span class="s1">case 'slow':</span><span class="s3">\n          </span><span class="s1">properties.duration = 600;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'fast':</span><span class="s3">\n          </span><span class="s1">properties.duration = 200;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isEles) {</span><span class="s3">\n        </span><span class="s1">properties.style = style.getPropsList(properties.style || properties.css);</span><span class="s3">\n        </span><span class="s1">properties.css = undefined;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isEles &amp;&amp; properties.renderedPosition != null) {</span><span class="s3">\n        </span><span class="s1">var rpos = properties.renderedPosition;</span><span class="s3">\n        </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n        </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n        </span><span class="s1">properties.position = renderedToModelPosition(rpos, zoom, pan);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// override pan w/ panBy if set</span><span class="s3">\n      </span><span class="s1">if (isCore &amp;&amp; properties.panBy != null) {</span><span class="s3">\n        </span><span class="s1">var panBy = properties.panBy;</span><span class="s3">\n        </span><span class="s1">var cyPan = cy.pan();</span><span class="s3">\n        </span><span class="s1">properties.pan = {</span><span class="s3">\n          </span><span class="s1">x: cyPan.x + panBy.x,</span><span class="s3">\n          </span><span class="s1">y: cyPan.y + panBy.y</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// override pan w/ center if set</span><span class="s3">\n      </span><span class="s1">var center = properties.center || properties.centre;</span><span class="s3">\n      </span><span class="s1">if (isCore &amp;&amp; center != null) {</span><span class="s3">\n        </span><span class="s1">var centerPan = cy.getCenterPan(center.eles, properties.zoom);</span><span class="s3">\n        </span><span class="s1">if (centerPan != null) {</span><span class="s3">\n          </span><span class="s1">properties.pan = centerPan;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// override pan &amp; zoom w/ fit if set</span><span class="s3">\n      </span><span class="s1">if (isCore &amp;&amp; properties.fit != null) {</span><span class="s3">\n        </span><span class="s1">var fit = properties.fit;</span><span class="s3">\n        </span><span class="s1">var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);</span><span class="s3">\n        </span><span class="s1">if (fitVp != null) {</span><span class="s3">\n          </span><span class="s1">properties.pan = fitVp.pan;</span><span class="s3">\n          </span><span class="s1">properties.zoom = fitVp.zoom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// override zoom (&amp; potentially pan) w/ zoom obj if set</span><span class="s3">\n      </span><span class="s1">if (isCore &amp;&amp; plainObject(properties.zoom)) {</span><span class="s3">\n        </span><span class="s1">var vp = cy.getZoomedViewport(properties.zoom);</span><span class="s3">\n        </span><span class="s1">if (vp != null) {</span><span class="s3">\n          </span><span class="s1">if (vp.zoomed) {</span><span class="s3">\n            </span><span class="s1">properties.zoom = vp.zoom;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (vp.panned) {</span><span class="s3">\n            </span><span class="s1">properties.pan = vp.pan;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return new Animation(all[0], properties);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// animate</span><span class="s3">\n\n  </span><span class="s1">animate: function animate() {</span><span class="s3">\n    </span><span class="s1">return function animateImpl(properties, params) {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">properties = extend({}, properties, params);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// manually hook and run the animation</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; all.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = all[i];</span><span class="s3">\n        </span><span class="s1">var queue = ele.animated() &amp;&amp; (properties.queue === undefined || properties.queue);</span><span class="s3">\n        </span><span class="s1">var ani = ele.animation(properties, queue ? {</span><span class="s3">\n          </span><span class="s1">queue: true</span><span class="s3">\n        </span><span class="s1">} : undefined);</span><span class="s3">\n        </span><span class="s1">ani.play();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this; // chaining</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// animate</span><span class="s3">\n\n  </span><span class="s1">stop: function stop() {</span><span class="s3">\n    </span><span class="s1">return function stopImpl(clearQueue, jumpToEnd) {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n      </span><span class="s1">var cy = this._private.cy || this;</span><span class="s3">\n      </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; all.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = all[i];</span><span class="s3">\n        </span><span class="s1">var _p = ele._private;</span><span class="s3">\n        </span><span class="s1">var anis = _p.animation.current;</span><span class="s3">\n        </span><span class="s1">for (var j = 0; j &lt; anis.length; j++) {</span><span class="s3">\n          </span><span class="s1">var ani = anis[j];</span><span class="s3">\n          </span><span class="s1">var ani_p = ani._private;</span><span class="s3">\n          </span><span class="s1">if (jumpToEnd) {</span><span class="s3">\n            </span><span class="s1">// next iteration of the animation loop, the animation</span><span class="s3">\n            </span><span class="s1">// will go straight to the end and be removed</span><span class="s3">\n            </span><span class="s1">ani_p.duration = 0;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// clear the queue of future animations</span><span class="s3">\n        </span><span class="s1">if (clearQueue) {</span><span class="s3">\n          </span><span class="s1">_p.animation.queue = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!jumpToEnd) {</span><span class="s3">\n          </span><span class="s1">_p.animation.current = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// we have to notify (the animation loop doesn't do it for us on `stop`)</span><span class="s3">\n      </span><span class="s1">cy.notify('draw');</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} // stop</span><span class="s3">\n</span><span class="s1">}; // define</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as an `Array` object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an array, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray(document.body.children);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var isArray_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredIsArray;</span><span class="s3">\n\n</span><span class="s1">function requireIsArray () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredIsArray) return isArray_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredIsArray = 1;</span><span class="s3">\n\t</span><span class="s1">var isArray = Array.isArray;</span><span class="s3">\n\n\t</span><span class="s1">isArray_1 = isArray;</span><span class="s3">\n\t</span><span class="s1">return isArray_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _isKey;</span><span class="s3">\n</span><span class="s1">var hasRequired_isKey;</span><span class="s3">\n\n</span><span class="s1">function require_isKey () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_isKey) return _isKey;</span><span class="s3">\n\t</span><span class="s1">hasRequired_isKey = 1;</span><span class="s3">\n\t</span><span class="s1">var isArray = requireIsArray(),</span><span class="s3">\n\t    </span><span class="s1">isSymbol = requireIsSymbol();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to match property names within property paths. */</span><span class="s3">\n\t</span><span class="s1">var reIsDeepProp = /</span><span class="s3">\\</span><span class="s1">.|</span><span class="s3">\\</span><span class="s1">[(?:[^[</span><span class="s3">\\</span><span class="s1">]]*|([</span><span class="s3">\&quot;</span><span class="s1">'])(?:(?!</span><span class="s3">\\</span><span class="s1">1)[^</span><span class="s3">\\\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.)*?</span><span class="s3">\\</span><span class="s1">1)</span><span class="s3">\\</span><span class="s1">]/,</span><span class="s3">\n\t    </span><span class="s1">reIsPlainProp = /^</span><span class="s3">\\</span><span class="s1">w*$/;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if `value` is a property name and not a property path.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n\t </span><span class="s1">* @param {Object} [object] The object to query keys on.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a property name, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function isKey(value, object) {</span><span class="s3">\n\t  </span><span class="s1">if (isArray(value)) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var type = typeof value;</span><span class="s3">\n\t  </span><span class="s1">if (type == 'number' || type == 'symbol' || type == 'boolean' ||</span><span class="s3">\n\t      </span><span class="s1">value == null || isSymbol(value)) {</span><span class="s3">\n\t    </span><span class="s1">return true;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||</span><span class="s3">\n\t    </span><span class="s1">(object != null &amp;&amp; value in Object(object));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_isKey = isKey;</span><span class="s3">\n\t</span><span class="s1">return _isKey;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var isFunction_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredIsFunction;</span><span class="s3">\n\n</span><span class="s1">function requireIsFunction () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredIsFunction) return isFunction_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredIsFunction = 1;</span><span class="s3">\n\t</span><span class="s1">var baseGetTag = require_baseGetTag(),</span><span class="s3">\n\t    </span><span class="s1">isObject = requireIsObject();</span><span class="s3">\n\n\t</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n\t</span><span class="s1">var asyncTag = '[object AsyncFunction]',</span><span class="s3">\n\t    </span><span class="s1">funcTag = '[object Function]',</span><span class="s3">\n\t    </span><span class="s1">genTag = '[object GeneratorFunction]',</span><span class="s3">\n\t    </span><span class="s1">proxyTag = '[object Proxy]';</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if `value` is classified as a `Function` object.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 0.1.0</span><span class="s3">\n\t </span><span class="s1">* @category Lang</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a function, else `false`.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.isFunction(_);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; true</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.isFunction(/abc/);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; false</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function isFunction(value) {</span><span class="s3">\n\t  </span><span class="s1">if (!isObject(value)) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">// The use of `Object#toString` avoids issues with the `typeof` operator</span><span class="s3">\n\t  </span><span class="s1">// in Safari 9 which returns 'object' for typed arrays and other constructors.</span><span class="s3">\n\t  </span><span class="s1">var tag = baseGetTag(value);</span><span class="s3">\n\t  </span><span class="s1">return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isFunction_1 = isFunction;</span><span class="s3">\n\t</span><span class="s1">return isFunction_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _coreJsData;</span><span class="s3">\n</span><span class="s1">var hasRequired_coreJsData;</span><span class="s3">\n\n</span><span class="s1">function require_coreJsData () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_coreJsData) return _coreJsData;</span><span class="s3">\n\t</span><span class="s1">hasRequired_coreJsData = 1;</span><span class="s3">\n\t</span><span class="s1">var root = require_root();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect overreaching core-js shims. */</span><span class="s3">\n\t</span><span class="s1">var coreJsData = root['__core-js_shared__'];</span><span class="s3">\n\n\t</span><span class="s1">_coreJsData = coreJsData;</span><span class="s3">\n\t</span><span class="s1">return _coreJsData;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _isMasked;</span><span class="s3">\n</span><span class="s1">var hasRequired_isMasked;</span><span class="s3">\n\n</span><span class="s1">function require_isMasked () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_isMasked) return _isMasked;</span><span class="s3">\n\t</span><span class="s1">hasRequired_isMasked = 1;</span><span class="s3">\n\t</span><span class="s1">var coreJsData = require_coreJsData();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect methods masquerading as native. */</span><span class="s3">\n\t</span><span class="s1">var maskSrcKey = (function() {</span><span class="s3">\n\t  </span><span class="s1">var uid = /[^.]+$/.exec(coreJsData &amp;&amp; coreJsData.keys &amp;&amp; coreJsData.keys.IE_PROTO || '');</span><span class="s3">\n\t  </span><span class="s1">return uid ? ('Symbol(src)_1.' + uid) : '';</span><span class="s3">\n\t</span><span class="s1">}());</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if `func` has its source masked.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Function} func The function to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if `func` is masked, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function isMasked(func) {</span><span class="s3">\n\t  </span><span class="s1">return !!maskSrcKey &amp;&amp; (maskSrcKey in func);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_isMasked = isMasked;</span><span class="s3">\n\t</span><span class="s1">return _isMasked;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\n</span><span class="s1">var _toSource;</span><span class="s3">\n</span><span class="s1">var hasRequired_toSource;</span><span class="s3">\n\n</span><span class="s1">function require_toSource () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_toSource) return _toSource;</span><span class="s3">\n\t</span><span class="s1">hasRequired_toSource = 1;</span><span class="s3">\n\t</span><span class="s1">var funcProto = Function.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to resolve the decompiled source of functions. */</span><span class="s3">\n\t</span><span class="s1">var funcToString = funcProto.toString;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `func` to its source code.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Function} func The function to convert.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the source code.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toSource(func) {</span><span class="s3">\n\t  </span><span class="s1">if (func != null) {</span><span class="s3">\n\t    </span><span class="s1">try {</span><span class="s3">\n\t      </span><span class="s1">return funcToString.call(func);</span><span class="s3">\n\t    </span><span class="s1">} catch (e) {}</span><span class="s3">\n\t    </span><span class="s1">try {</span><span class="s3">\n\t      </span><span class="s1">return (func + '');</span><span class="s3">\n\t    </span><span class="s1">} catch (e) {}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return '';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_toSource = toSource;</span><span class="s3">\n\t</span><span class="s1">return _toSource;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseIsNative;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseIsNative;</span><span class="s3">\n\n</span><span class="s1">function require_baseIsNative () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseIsNative) return _baseIsNative;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseIsNative = 1;</span><span class="s3">\n\t</span><span class="s1">var isFunction = requireIsFunction(),</span><span class="s3">\n\t    </span><span class="s1">isMasked = require_isMasked(),</span><span class="s3">\n\t    </span><span class="s1">isObject = requireIsObject(),</span><span class="s3">\n\t    </span><span class="s1">toSource = require_toSource();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Used to match `RegExp`</span><span class="s3">\n\t </span><span class="s1">* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">var reRegExpChar = /[</span><span class="s3">\\\\</span><span class="s1">^$.*+?()[</span><span class="s3">\\</span><span class="s1">]{}|]/g;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect host constructors (Safari). */</span><span class="s3">\n\t</span><span class="s1">var reIsHostCtor = /^</span><span class="s3">\\</span><span class="s1">[object .+?Constructor</span><span class="s3">\\</span><span class="s1">]$/;</span><span class="s3">\n\n\t</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\t</span><span class="s1">var funcProto = Function.prototype,</span><span class="s3">\n\t    </span><span class="s1">objectProto = Object.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to resolve the decompiled source of functions. */</span><span class="s3">\n\t</span><span class="s1">var funcToString = funcProto.toString;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n\t</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect if a method is native. */</span><span class="s3">\n\t</span><span class="s1">var reIsNative = RegExp('^' +</span><span class="s3">\n\t  </span><span class="s1">funcToString.call(hasOwnProperty).replace(reRegExpChar, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n\t  </span><span class="s1">.replace(/hasOwnProperty|(function).*?(?=</span><span class="s3">\\\\\\</span><span class="s1">()| for .+?(?=</span><span class="s3">\\\\\\</span><span class="s1">])/g, '$1.*?') + '$'</span><span class="s3">\n\t</span><span class="s1">);</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `_.isNative` without bad shim checks.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a native function,</span><span class="s3">\n\t </span><span class="s1">*  else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseIsNative(value) {</span><span class="s3">\n\t  </span><span class="s1">if (!isObject(value) || isMasked(value)) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var pattern = isFunction(value) ? reIsNative : reIsHostCtor;</span><span class="s3">\n\t  </span><span class="s1">return pattern.test(toSource(value));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseIsNative = baseIsNative;</span><span class="s3">\n\t</span><span class="s1">return _baseIsNative;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the value at `key` of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} [object] The object to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the property value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var _getValue;</span><span class="s3">\n</span><span class="s1">var hasRequired_getValue;</span><span class="s3">\n\n</span><span class="s1">function require_getValue () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_getValue) return _getValue;</span><span class="s3">\n\t</span><span class="s1">hasRequired_getValue = 1;</span><span class="s3">\n\t</span><span class="s1">function getValue(object, key) {</span><span class="s3">\n\t  </span><span class="s1">return object == null ? undefined : object[key];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_getValue = getValue;</span><span class="s3">\n\t</span><span class="s1">return _getValue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _getNative;</span><span class="s3">\n</span><span class="s1">var hasRequired_getNative;</span><span class="s3">\n\n</span><span class="s1">function require_getNative () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_getNative) return _getNative;</span><span class="s3">\n\t</span><span class="s1">hasRequired_getNative = 1;</span><span class="s3">\n\t</span><span class="s1">var baseIsNative = require_baseIsNative(),</span><span class="s3">\n\t    </span><span class="s1">getValue = require_getValue();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the native function at `key` of `object`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the method to get.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the function if it's native, else `undefined`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function getNative(object, key) {</span><span class="s3">\n\t  </span><span class="s1">var value = getValue(object, key);</span><span class="s3">\n\t  </span><span class="s1">return baseIsNative(value) ? value : undefined;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_getNative = getNative;</span><span class="s3">\n\t</span><span class="s1">return _getNative;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _nativeCreate;</span><span class="s3">\n</span><span class="s1">var hasRequired_nativeCreate;</span><span class="s3">\n\n</span><span class="s1">function require_nativeCreate () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_nativeCreate) return _nativeCreate;</span><span class="s3">\n\t</span><span class="s1">hasRequired_nativeCreate = 1;</span><span class="s3">\n\t</span><span class="s1">var getNative = require_getNative();</span><span class="s3">\n\n\t</span><span class="s1">/* Built-in method references that are verified to be native. */</span><span class="s3">\n\t</span><span class="s1">var nativeCreate = getNative(Object, 'create');</span><span class="s3">\n\n\t</span><span class="s1">_nativeCreate = nativeCreate;</span><span class="s3">\n\t</span><span class="s1">return _nativeCreate;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _hashClear;</span><span class="s3">\n</span><span class="s1">var hasRequired_hashClear;</span><span class="s3">\n\n</span><span class="s1">function require_hashClear () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_hashClear) return _hashClear;</span><span class="s3">\n\t</span><span class="s1">hasRequired_hashClear = 1;</span><span class="s3">\n\t</span><span class="s1">var nativeCreate = require_nativeCreate();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Removes all key-value entries from the hash.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name clear</span><span class="s3">\n\t </span><span class="s1">* @memberOf Hash</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function hashClear() {</span><span class="s3">\n\t  </span><span class="s1">this.__data__ = nativeCreate ? nativeCreate(null) : {};</span><span class="s3">\n\t  </span><span class="s1">this.size = 0;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_hashClear = hashClear;</span><span class="s3">\n\t</span><span class="s1">return _hashClear;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes `key` and its value from the hash.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name delete</span><span class="s3">\n </span><span class="s1">* @memberOf Hash</span><span class="s3">\n </span><span class="s1">* @param {Object} hash The hash to modify.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var _hashDelete;</span><span class="s3">\n</span><span class="s1">var hasRequired_hashDelete;</span><span class="s3">\n\n</span><span class="s1">function require_hashDelete () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_hashDelete) return _hashDelete;</span><span class="s3">\n\t</span><span class="s1">hasRequired_hashDelete = 1;</span><span class="s3">\n\t</span><span class="s1">function hashDelete(key) {</span><span class="s3">\n\t  </span><span class="s1">var result = this.has(key) &amp;&amp; delete this.__data__[key];</span><span class="s3">\n\t  </span><span class="s1">this.size -= result ? 1 : 0;</span><span class="s3">\n\t  </span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_hashDelete = hashDelete;</span><span class="s3">\n\t</span><span class="s1">return _hashDelete;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _hashGet;</span><span class="s3">\n</span><span class="s1">var hasRequired_hashGet;</span><span class="s3">\n\n</span><span class="s1">function require_hashGet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_hashGet) return _hashGet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_hashGet = 1;</span><span class="s3">\n\t</span><span class="s1">var nativeCreate = require_nativeCreate();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to stand-in for `undefined` hash values. */</span><span class="s3">\n\t</span><span class="s1">var HASH_UNDEFINED = '__lodash_hash_undefined__';</span><span class="s3">\n\n\t</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\t</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n\t</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the hash value for `key`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name get</span><span class="s3">\n\t </span><span class="s1">* @memberOf Hash</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function hashGet(key) {</span><span class="s3">\n\t  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n\t  </span><span class="s1">if (nativeCreate) {</span><span class="s3">\n\t    </span><span class="s1">var result = data[key];</span><span class="s3">\n\t    </span><span class="s1">return result === HASH_UNDEFINED ? undefined : result;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return hasOwnProperty.call(data, key) ? data[key] : undefined;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_hashGet = hashGet;</span><span class="s3">\n\t</span><span class="s1">return _hashGet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _hashHas;</span><span class="s3">\n</span><span class="s1">var hasRequired_hashHas;</span><span class="s3">\n\n</span><span class="s1">function require_hashHas () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_hashHas) return _hashHas;</span><span class="s3">\n\t</span><span class="s1">hasRequired_hashHas = 1;</span><span class="s3">\n\t</span><span class="s1">var nativeCreate = require_nativeCreate();</span><span class="s3">\n\n\t</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\t</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n\t</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if a hash value for `key` exists.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name has</span><span class="s3">\n\t </span><span class="s1">* @memberOf Hash</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function hashHas(key) {</span><span class="s3">\n\t  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n\t  </span><span class="s1">return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_hashHas = hashHas;</span><span class="s3">\n\t</span><span class="s1">return _hashHas;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _hashSet;</span><span class="s3">\n</span><span class="s1">var hasRequired_hashSet;</span><span class="s3">\n\n</span><span class="s1">function require_hashSet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_hashSet) return _hashSet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_hashSet = 1;</span><span class="s3">\n\t</span><span class="s1">var nativeCreate = require_nativeCreate();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to stand-in for `undefined` hash values. */</span><span class="s3">\n\t</span><span class="s1">var HASH_UNDEFINED = '__lodash_hash_undefined__';</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Sets the hash `key` to `value`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name set</span><span class="s3">\n\t </span><span class="s1">* @memberOf Hash</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n\t </span><span class="s1">* @returns {Object} Returns the hash instance.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function hashSet(key, value) {</span><span class="s3">\n\t  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n\t  </span><span class="s1">this.size += this.has(key) ? 0 : 1;</span><span class="s3">\n\t  </span><span class="s1">data[key] = (nativeCreate &amp;&amp; value === undefined) ? HASH_UNDEFINED : value;</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_hashSet = hashSet;</span><span class="s3">\n\t</span><span class="s1">return _hashSet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _Hash;</span><span class="s3">\n</span><span class="s1">var hasRequired_Hash;</span><span class="s3">\n\n</span><span class="s1">function require_Hash () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_Hash) return _Hash;</span><span class="s3">\n\t</span><span class="s1">hasRequired_Hash = 1;</span><span class="s3">\n\t</span><span class="s1">var hashClear = require_hashClear(),</span><span class="s3">\n\t    </span><span class="s1">hashDelete = require_hashDelete(),</span><span class="s3">\n\t    </span><span class="s1">hashGet = require_hashGet(),</span><span class="s3">\n\t    </span><span class="s1">hashHas = require_hashHas(),</span><span class="s3">\n\t    </span><span class="s1">hashSet = require_hashSet();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates a hash object.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @constructor</span><span class="s3">\n\t </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function Hash(entries) {</span><span class="s3">\n\t  </span><span class="s1">var index = -1,</span><span class="s3">\n\t      </span><span class="s1">length = entries == null ? 0 : entries.length;</span><span class="s3">\n\n\t  </span><span class="s1">this.clear();</span><span class="s3">\n\t  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">var entry = entries[index];</span><span class="s3">\n\t    </span><span class="s1">this.set(entry[0], entry[1]);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Add methods to `Hash`.</span><span class="s3">\n\t</span><span class="s1">Hash.prototype.clear = hashClear;</span><span class="s3">\n\t</span><span class="s1">Hash.prototype['delete'] = hashDelete;</span><span class="s3">\n\t</span><span class="s1">Hash.prototype.get = hashGet;</span><span class="s3">\n\t</span><span class="s1">Hash.prototype.has = hashHas;</span><span class="s3">\n\t</span><span class="s1">Hash.prototype.set = hashSet;</span><span class="s3">\n\n\t</span><span class="s1">_Hash = Hash;</span><span class="s3">\n\t</span><span class="s1">return _Hash;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes all key-value entries from the list cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name clear</span><span class="s3">\n </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var _listCacheClear;</span><span class="s3">\n</span><span class="s1">var hasRequired_listCacheClear;</span><span class="s3">\n\n</span><span class="s1">function require_listCacheClear () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_listCacheClear) return _listCacheClear;</span><span class="s3">\n\t</span><span class="s1">hasRequired_listCacheClear = 1;</span><span class="s3">\n\t</span><span class="s1">function listCacheClear() {</span><span class="s3">\n\t  </span><span class="s1">this.__data__ = [];</span><span class="s3">\n\t  </span><span class="s1">this.size = 0;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_listCacheClear = listCacheClear;</span><span class="s3">\n\t</span><span class="s1">return _listCacheClear;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs a</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* comparison between two values to determine if they are equivalent.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">* var other = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq(object, object);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq(object, other);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq('a', 'a');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq('a', Object('a'));</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq(NaN, NaN);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var eq_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredEq;</span><span class="s3">\n\n</span><span class="s1">function requireEq () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredEq) return eq_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredEq = 1;</span><span class="s3">\n\t</span><span class="s1">function eq(value, other) {</span><span class="s3">\n\t  </span><span class="s1">return value === other || (value !== value &amp;&amp; other !== other);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">eq_1 = eq;</span><span class="s3">\n\t</span><span class="s1">return eq_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _assocIndexOf;</span><span class="s3">\n</span><span class="s1">var hasRequired_assocIndexOf;</span><span class="s3">\n\n</span><span class="s1">function require_assocIndexOf () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_assocIndexOf) return _assocIndexOf;</span><span class="s3">\n\t</span><span class="s1">hasRequired_assocIndexOf = 1;</span><span class="s3">\n\t</span><span class="s1">var eq = requireEq();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the index at which the `key` is found in `array` of key-value pairs.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n\t </span><span class="s1">* @param {*} key The key to search for.</span><span class="s3">\n\t </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function assocIndexOf(array, key) {</span><span class="s3">\n\t  </span><span class="s1">var length = array.length;</span><span class="s3">\n\t  </span><span class="s1">while (length--) {</span><span class="s3">\n\t    </span><span class="s1">if (eq(array[length][0], key)) {</span><span class="s3">\n\t      </span><span class="s1">return length;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return -1;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_assocIndexOf = assocIndexOf;</span><span class="s3">\n\t</span><span class="s1">return _assocIndexOf;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _listCacheDelete;</span><span class="s3">\n</span><span class="s1">var hasRequired_listCacheDelete;</span><span class="s3">\n\n</span><span class="s1">function require_listCacheDelete () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_listCacheDelete) return _listCacheDelete;</span><span class="s3">\n\t</span><span class="s1">hasRequired_listCacheDelete = 1;</span><span class="s3">\n\t</span><span class="s1">var assocIndexOf = require_assocIndexOf();</span><span class="s3">\n\n\t</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\t</span><span class="s1">var arrayProto = Array.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Built-in value references. */</span><span class="s3">\n\t</span><span class="s1">var splice = arrayProto.splice;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Removes `key` and its value from the list cache.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name delete</span><span class="s3">\n\t </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function listCacheDelete(key) {</span><span class="s3">\n\t  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n\t      </span><span class="s1">index = assocIndexOf(data, key);</span><span class="s3">\n\n\t  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var lastIndex = data.length - 1;</span><span class="s3">\n\t  </span><span class="s1">if (index == lastIndex) {</span><span class="s3">\n\t    </span><span class="s1">data.pop();</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">splice.call(data, index, 1);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">--this.size;</span><span class="s3">\n\t  </span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_listCacheDelete = listCacheDelete;</span><span class="s3">\n\t</span><span class="s1">return _listCacheDelete;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _listCacheGet;</span><span class="s3">\n</span><span class="s1">var hasRequired_listCacheGet;</span><span class="s3">\n\n</span><span class="s1">function require_listCacheGet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_listCacheGet) return _listCacheGet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_listCacheGet = 1;</span><span class="s3">\n\t</span><span class="s1">var assocIndexOf = require_assocIndexOf();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the list cache value for `key`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name get</span><span class="s3">\n\t </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function listCacheGet(key) {</span><span class="s3">\n\t  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n\t      </span><span class="s1">index = assocIndexOf(data, key);</span><span class="s3">\n\n\t  </span><span class="s1">return index &lt; 0 ? undefined : data[index][1];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_listCacheGet = listCacheGet;</span><span class="s3">\n\t</span><span class="s1">return _listCacheGet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _listCacheHas;</span><span class="s3">\n</span><span class="s1">var hasRequired_listCacheHas;</span><span class="s3">\n\n</span><span class="s1">function require_listCacheHas () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_listCacheHas) return _listCacheHas;</span><span class="s3">\n\t</span><span class="s1">hasRequired_listCacheHas = 1;</span><span class="s3">\n\t</span><span class="s1">var assocIndexOf = require_assocIndexOf();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if a list cache value for `key` exists.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name has</span><span class="s3">\n\t </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function listCacheHas(key) {</span><span class="s3">\n\t  </span><span class="s1">return assocIndexOf(this.__data__, key) &gt; -1;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_listCacheHas = listCacheHas;</span><span class="s3">\n\t</span><span class="s1">return _listCacheHas;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _listCacheSet;</span><span class="s3">\n</span><span class="s1">var hasRequired_listCacheSet;</span><span class="s3">\n\n</span><span class="s1">function require_listCacheSet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_listCacheSet) return _listCacheSet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_listCacheSet = 1;</span><span class="s3">\n\t</span><span class="s1">var assocIndexOf = require_assocIndexOf();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Sets the list cache `key` to `value`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name set</span><span class="s3">\n\t </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n\t </span><span class="s1">* @returns {Object} Returns the list cache instance.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function listCacheSet(key, value) {</span><span class="s3">\n\t  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n\t      </span><span class="s1">index = assocIndexOf(data, key);</span><span class="s3">\n\n\t  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n\t    </span><span class="s1">++this.size;</span><span class="s3">\n\t    </span><span class="s1">data.push([key, value]);</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">data[index][1] = value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_listCacheSet = listCacheSet;</span><span class="s3">\n\t</span><span class="s1">return _listCacheSet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _ListCache;</span><span class="s3">\n</span><span class="s1">var hasRequired_ListCache;</span><span class="s3">\n\n</span><span class="s1">function require_ListCache () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_ListCache) return _ListCache;</span><span class="s3">\n\t</span><span class="s1">hasRequired_ListCache = 1;</span><span class="s3">\n\t</span><span class="s1">var listCacheClear = require_listCacheClear(),</span><span class="s3">\n\t    </span><span class="s1">listCacheDelete = require_listCacheDelete(),</span><span class="s3">\n\t    </span><span class="s1">listCacheGet = require_listCacheGet(),</span><span class="s3">\n\t    </span><span class="s1">listCacheHas = require_listCacheHas(),</span><span class="s3">\n\t    </span><span class="s1">listCacheSet = require_listCacheSet();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates an list cache object.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @constructor</span><span class="s3">\n\t </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function ListCache(entries) {</span><span class="s3">\n\t  </span><span class="s1">var index = -1,</span><span class="s3">\n\t      </span><span class="s1">length = entries == null ? 0 : entries.length;</span><span class="s3">\n\n\t  </span><span class="s1">this.clear();</span><span class="s3">\n\t  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">var entry = entries[index];</span><span class="s3">\n\t    </span><span class="s1">this.set(entry[0], entry[1]);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Add methods to `ListCache`.</span><span class="s3">\n\t</span><span class="s1">ListCache.prototype.clear = listCacheClear;</span><span class="s3">\n\t</span><span class="s1">ListCache.prototype['delete'] = listCacheDelete;</span><span class="s3">\n\t</span><span class="s1">ListCache.prototype.get = listCacheGet;</span><span class="s3">\n\t</span><span class="s1">ListCache.prototype.has = listCacheHas;</span><span class="s3">\n\t</span><span class="s1">ListCache.prototype.set = listCacheSet;</span><span class="s3">\n\n\t</span><span class="s1">_ListCache = ListCache;</span><span class="s3">\n\t</span><span class="s1">return _ListCache;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _Map;</span><span class="s3">\n</span><span class="s1">var hasRequired_Map;</span><span class="s3">\n\n</span><span class="s1">function require_Map () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_Map) return _Map;</span><span class="s3">\n\t</span><span class="s1">hasRequired_Map = 1;</span><span class="s3">\n\t</span><span class="s1">var getNative = require_getNative(),</span><span class="s3">\n\t    </span><span class="s1">root = require_root();</span><span class="s3">\n\n\t</span><span class="s1">/* Built-in method references that are verified to be native. */</span><span class="s3">\n\t</span><span class="s1">var Map = getNative(root, 'Map');</span><span class="s3">\n\n\t</span><span class="s1">_Map = Map;</span><span class="s3">\n\t</span><span class="s1">return _Map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _mapCacheClear;</span><span class="s3">\n</span><span class="s1">var hasRequired_mapCacheClear;</span><span class="s3">\n\n</span><span class="s1">function require_mapCacheClear () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_mapCacheClear) return _mapCacheClear;</span><span class="s3">\n\t</span><span class="s1">hasRequired_mapCacheClear = 1;</span><span class="s3">\n\t</span><span class="s1">var Hash = require_Hash(),</span><span class="s3">\n\t    </span><span class="s1">ListCache = require_ListCache(),</span><span class="s3">\n\t    </span><span class="s1">Map = require_Map();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Removes all key-value entries from the map.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name clear</span><span class="s3">\n\t </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function mapCacheClear() {</span><span class="s3">\n\t  </span><span class="s1">this.size = 0;</span><span class="s3">\n\t  </span><span class="s1">this.__data__ = {</span><span class="s3">\n\t    </span><span class="s1">'hash': new Hash,</span><span class="s3">\n\t    </span><span class="s1">'map': new (Map || ListCache),</span><span class="s3">\n\t    </span><span class="s1">'string': new Hash</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_mapCacheClear = mapCacheClear;</span><span class="s3">\n\t</span><span class="s1">return _mapCacheClear;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is suitable for use as unique object key.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is suitable, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var _isKeyable;</span><span class="s3">\n</span><span class="s1">var hasRequired_isKeyable;</span><span class="s3">\n\n</span><span class="s1">function require_isKeyable () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_isKeyable) return _isKeyable;</span><span class="s3">\n\t</span><span class="s1">hasRequired_isKeyable = 1;</span><span class="s3">\n\t</span><span class="s1">function isKeyable(value) {</span><span class="s3">\n\t  </span><span class="s1">var type = typeof value;</span><span class="s3">\n\t  </span><span class="s1">return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')</span><span class="s3">\n\t    </span><span class="s1">? (value !== '__proto__')</span><span class="s3">\n\t    </span><span class="s1">: (value === null);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_isKeyable = isKeyable;</span><span class="s3">\n\t</span><span class="s1">return _isKeyable;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _getMapData;</span><span class="s3">\n</span><span class="s1">var hasRequired_getMapData;</span><span class="s3">\n\n</span><span class="s1">function require_getMapData () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_getMapData) return _getMapData;</span><span class="s3">\n\t</span><span class="s1">hasRequired_getMapData = 1;</span><span class="s3">\n\t</span><span class="s1">var isKeyable = require_isKeyable();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the data for `map`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Object} map The map to query.</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The reference key.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the map data.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function getMapData(map, key) {</span><span class="s3">\n\t  </span><span class="s1">var data = map.__data__;</span><span class="s3">\n\t  </span><span class="s1">return isKeyable(key)</span><span class="s3">\n\t    </span><span class="s1">? data[typeof key == 'string' ? 'string' : 'hash']</span><span class="s3">\n\t    </span><span class="s1">: data.map;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_getMapData = getMapData;</span><span class="s3">\n\t</span><span class="s1">return _getMapData;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _mapCacheDelete;</span><span class="s3">\n</span><span class="s1">var hasRequired_mapCacheDelete;</span><span class="s3">\n\n</span><span class="s1">function require_mapCacheDelete () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_mapCacheDelete) return _mapCacheDelete;</span><span class="s3">\n\t</span><span class="s1">hasRequired_mapCacheDelete = 1;</span><span class="s3">\n\t</span><span class="s1">var getMapData = require_getMapData();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Removes `key` and its value from the map.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name delete</span><span class="s3">\n\t </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function mapCacheDelete(key) {</span><span class="s3">\n\t  </span><span class="s1">var result = getMapData(this, key)['delete'](key);</span><span class="s3">\n\t  </span><span class="s1">this.size -= result ? 1 : 0;</span><span class="s3">\n\t  </span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_mapCacheDelete = mapCacheDelete;</span><span class="s3">\n\t</span><span class="s1">return _mapCacheDelete;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _mapCacheGet;</span><span class="s3">\n</span><span class="s1">var hasRequired_mapCacheGet;</span><span class="s3">\n\n</span><span class="s1">function require_mapCacheGet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_mapCacheGet) return _mapCacheGet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_mapCacheGet = 1;</span><span class="s3">\n\t</span><span class="s1">var getMapData = require_getMapData();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the map value for `key`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name get</span><span class="s3">\n\t </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function mapCacheGet(key) {</span><span class="s3">\n\t  </span><span class="s1">return getMapData(this, key).get(key);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_mapCacheGet = mapCacheGet;</span><span class="s3">\n\t</span><span class="s1">return _mapCacheGet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _mapCacheHas;</span><span class="s3">\n</span><span class="s1">var hasRequired_mapCacheHas;</span><span class="s3">\n\n</span><span class="s1">function require_mapCacheHas () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_mapCacheHas) return _mapCacheHas;</span><span class="s3">\n\t</span><span class="s1">hasRequired_mapCacheHas = 1;</span><span class="s3">\n\t</span><span class="s1">var getMapData = require_getMapData();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if a map value for `key` exists.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name has</span><span class="s3">\n\t </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function mapCacheHas(key) {</span><span class="s3">\n\t  </span><span class="s1">return getMapData(this, key).has(key);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_mapCacheHas = mapCacheHas;</span><span class="s3">\n\t</span><span class="s1">return _mapCacheHas;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _mapCacheSet;</span><span class="s3">\n</span><span class="s1">var hasRequired_mapCacheSet;</span><span class="s3">\n\n</span><span class="s1">function require_mapCacheSet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_mapCacheSet) return _mapCacheSet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_mapCacheSet = 1;</span><span class="s3">\n\t</span><span class="s1">var getMapData = require_getMapData();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Sets the map `key` to `value`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @name set</span><span class="s3">\n\t </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n\t </span><span class="s1">* @returns {Object} Returns the map cache instance.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function mapCacheSet(key, value) {</span><span class="s3">\n\t  </span><span class="s1">var data = getMapData(this, key),</span><span class="s3">\n\t      </span><span class="s1">size = data.size;</span><span class="s3">\n\n\t  </span><span class="s1">data.set(key, value);</span><span class="s3">\n\t  </span><span class="s1">this.size += data.size == size ? 0 : 1;</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_mapCacheSet = mapCacheSet;</span><span class="s3">\n\t</span><span class="s1">return _mapCacheSet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _MapCache;</span><span class="s3">\n</span><span class="s1">var hasRequired_MapCache;</span><span class="s3">\n\n</span><span class="s1">function require_MapCache () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_MapCache) return _MapCache;</span><span class="s3">\n\t</span><span class="s1">hasRequired_MapCache = 1;</span><span class="s3">\n\t</span><span class="s1">var mapCacheClear = require_mapCacheClear(),</span><span class="s3">\n\t    </span><span class="s1">mapCacheDelete = require_mapCacheDelete(),</span><span class="s3">\n\t    </span><span class="s1">mapCacheGet = require_mapCacheGet(),</span><span class="s3">\n\t    </span><span class="s1">mapCacheHas = require_mapCacheHas(),</span><span class="s3">\n\t    </span><span class="s1">mapCacheSet = require_mapCacheSet();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates a map cache object to store key-value pairs.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @constructor</span><span class="s3">\n\t </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function MapCache(entries) {</span><span class="s3">\n\t  </span><span class="s1">var index = -1,</span><span class="s3">\n\t      </span><span class="s1">length = entries == null ? 0 : entries.length;</span><span class="s3">\n\n\t  </span><span class="s1">this.clear();</span><span class="s3">\n\t  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">var entry = entries[index];</span><span class="s3">\n\t    </span><span class="s1">this.set(entry[0], entry[1]);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Add methods to `MapCache`.</span><span class="s3">\n\t</span><span class="s1">MapCache.prototype.clear = mapCacheClear;</span><span class="s3">\n\t</span><span class="s1">MapCache.prototype['delete'] = mapCacheDelete;</span><span class="s3">\n\t</span><span class="s1">MapCache.prototype.get = mapCacheGet;</span><span class="s3">\n\t</span><span class="s1">MapCache.prototype.has = mapCacheHas;</span><span class="s3">\n\t</span><span class="s1">MapCache.prototype.set = mapCacheSet;</span><span class="s3">\n\n\t</span><span class="s1">_MapCache = MapCache;</span><span class="s3">\n\t</span><span class="s1">return _MapCache;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var memoize_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredMemoize;</span><span class="s3">\n\n</span><span class="s1">function requireMemoize () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredMemoize) return memoize_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredMemoize = 1;</span><span class="s3">\n\t</span><span class="s1">var MapCache = require_MapCache();</span><span class="s3">\n\n\t</span><span class="s1">/** Error message constants. */</span><span class="s3">\n\t</span><span class="s1">var FUNC_ERROR_TEXT = 'Expected a function';</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates a function that memoizes the result of `func`. If `resolver` is</span><span class="s3">\n\t </span><span class="s1">* provided, it determines the cache key for storing the result based on the</span><span class="s3">\n\t </span><span class="s1">* arguments provided to the memoized function. By default, the first argument</span><span class="s3">\n\t </span><span class="s1">* provided to the memoized function is used as the map cache key. The `func`</span><span class="s3">\n\t </span><span class="s1">* is invoked with the `this` binding of the memoized function.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* **Note:** The cache is exposed as the `cache` property on the memoized</span><span class="s3">\n\t </span><span class="s1">* function. Its creation may be customized by replacing the `_.memoize.Cache`</span><span class="s3">\n\t </span><span class="s1">* constructor with one whose instances implement the</span><span class="s3">\n\t </span><span class="s1">* [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)</span><span class="s3">\n\t </span><span class="s1">* method interface of `clear`, `delete`, `get`, `has`, and `set`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 0.1.0</span><span class="s3">\n\t </span><span class="s1">* @category Function</span><span class="s3">\n\t </span><span class="s1">* @param {Function} func The function to have its output memoized.</span><span class="s3">\n\t </span><span class="s1">* @param {Function} [resolver] The function to resolve the cache key.</span><span class="s3">\n\t </span><span class="s1">* @returns {Function} Returns the new memoized function.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* var object = { 'a': 1, 'b': 2 };</span><span class="s3">\n\t </span><span class="s1">* var other = { 'c': 3, 'd': 4 };</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* var values = _.memoize(_.values);</span><span class="s3">\n\t </span><span class="s1">* values(object);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; [1, 2]</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* values(other);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; [3, 4]</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* object.a = 2;</span><span class="s3">\n\t </span><span class="s1">* values(object);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; [1, 2]</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* // Modify the result cache.</span><span class="s3">\n\t </span><span class="s1">* values.cache.set(object, ['a', 'b']);</span><span class="s3">\n\t </span><span class="s1">* values(object);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; ['a', 'b']</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* // Replace `_.memoize.Cache`.</span><span class="s3">\n\t </span><span class="s1">* _.memoize.Cache = WeakMap;</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function memoize(func, resolver) {</span><span class="s3">\n\t  </span><span class="s1">if (typeof func != 'function' || (resolver != null &amp;&amp; typeof resolver != 'function')) {</span><span class="s3">\n\t    </span><span class="s1">throw new TypeError(FUNC_ERROR_TEXT);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var memoized = function() {</span><span class="s3">\n\t    </span><span class="s1">var args = arguments,</span><span class="s3">\n\t        </span><span class="s1">key = resolver ? resolver.apply(this, args) : args[0],</span><span class="s3">\n\t        </span><span class="s1">cache = memoized.cache;</span><span class="s3">\n\n\t    </span><span class="s1">if (cache.has(key)) {</span><span class="s3">\n\t      </span><span class="s1">return cache.get(key);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">var result = func.apply(this, args);</span><span class="s3">\n\t    </span><span class="s1">memoized.cache = cache.set(key, result) || cache;</span><span class="s3">\n\t    </span><span class="s1">return result;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t  </span><span class="s1">memoized.cache = new (memoize.Cache || MapCache);</span><span class="s3">\n\t  </span><span class="s1">return memoized;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Expose `MapCache`.</span><span class="s3">\n\t</span><span class="s1">memoize.Cache = MapCache;</span><span class="s3">\n\n\t</span><span class="s1">memoize_1 = memoize;</span><span class="s3">\n\t</span><span class="s1">return memoize_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _memoizeCapped;</span><span class="s3">\n</span><span class="s1">var hasRequired_memoizeCapped;</span><span class="s3">\n\n</span><span class="s1">function require_memoizeCapped () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_memoizeCapped) return _memoizeCapped;</span><span class="s3">\n\t</span><span class="s1">hasRequired_memoizeCapped = 1;</span><span class="s3">\n\t</span><span class="s1">var memoize = requireMemoize();</span><span class="s3">\n\n\t</span><span class="s1">/** Used as the maximum memoize cache size. */</span><span class="s3">\n\t</span><span class="s1">var MAX_MEMOIZE_SIZE = 500;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A specialized version of `_.memoize` which clears the memoized function's</span><span class="s3">\n\t </span><span class="s1">* cache when it exceeds `MAX_MEMOIZE_SIZE`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Function} func The function to have its output memoized.</span><span class="s3">\n\t </span><span class="s1">* @returns {Function} Returns the new memoized function.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function memoizeCapped(func) {</span><span class="s3">\n\t  </span><span class="s1">var result = memoize(func, function(key) {</span><span class="s3">\n\t    </span><span class="s1">if (cache.size === MAX_MEMOIZE_SIZE) {</span><span class="s3">\n\t      </span><span class="s1">cache.clear();</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">return key;</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\n\t  </span><span class="s1">var cache = result.cache;</span><span class="s3">\n\t  </span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_memoizeCapped = memoizeCapped;</span><span class="s3">\n\t</span><span class="s1">return _memoizeCapped;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _stringToPath;</span><span class="s3">\n</span><span class="s1">var hasRequired_stringToPath;</span><span class="s3">\n\n</span><span class="s1">function require_stringToPath () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_stringToPath) return _stringToPath;</span><span class="s3">\n\t</span><span class="s1">hasRequired_stringToPath = 1;</span><span class="s3">\n\t</span><span class="s1">var memoizeCapped = require_memoizeCapped();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to match property names within property paths. */</span><span class="s3">\n\t</span><span class="s1">var rePropName = /[^.[</span><span class="s3">\\</span><span class="s1">]]+|</span><span class="s3">\\</span><span class="s1">[(?:(-?</span><span class="s3">\\</span><span class="s1">d+(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?)|([</span><span class="s3">\&quot;</span><span class="s1">'])((?:(?!</span><span class="s3">\\</span><span class="s1">2)[^</span><span class="s3">\\\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.)*?)</span><span class="s3">\\</span><span class="s1">2)</span><span class="s3">\\</span><span class="s1">]|(?=(?:</span><span class="s3">\\</span><span class="s1">.|</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">])(?:</span><span class="s3">\\</span><span class="s1">.|</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]|$))/g;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to match backslashes in property paths. */</span><span class="s3">\n\t</span><span class="s1">var reEscapeChar = /</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)?/g;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `string` to a property path array.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {string} string The string to convert.</span><span class="s3">\n\t </span><span class="s1">* @returns {Array} Returns the property path array.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">var stringToPath = memoizeCapped(function(string) {</span><span class="s3">\n\t  </span><span class="s1">var result = [];</span><span class="s3">\n\t  </span><span class="s1">if (string.charCodeAt(0) === 46 /* . */) {</span><span class="s3">\n\t    </span><span class="s1">result.push('');</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">string.replace(rePropName, function(match, number, quote, subString) {</span><span class="s3">\n\t    </span><span class="s1">result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\n\t</span><span class="s1">_stringToPath = stringToPath;</span><span class="s3">\n\t</span><span class="s1">return _stringToPath;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.map` for arrays without support for iteratee</span><span class="s3">\n </span><span class="s1">* shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new mapped array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var _arrayMap;</span><span class="s3">\n</span><span class="s1">var hasRequired_arrayMap;</span><span class="s3">\n\n</span><span class="s1">function require_arrayMap () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_arrayMap) return _arrayMap;</span><span class="s3">\n\t</span><span class="s1">hasRequired_arrayMap = 1;</span><span class="s3">\n\t</span><span class="s1">function arrayMap(array, iteratee) {</span><span class="s3">\n\t  </span><span class="s1">var index = -1,</span><span class="s3">\n\t      </span><span class="s1">length = array == null ? 0 : array.length,</span><span class="s3">\n\t      </span><span class="s1">result = Array(length);</span><span class="s3">\n\n\t  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">result[index] = iteratee(array[index], index, array);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_arrayMap = arrayMap;</span><span class="s3">\n\t</span><span class="s1">return _arrayMap;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseToString;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseToString;</span><span class="s3">\n\n</span><span class="s1">function require_baseToString () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseToString) return _baseToString;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseToString = 1;</span><span class="s3">\n\t</span><span class="s1">var Symbol = require_Symbol(),</span><span class="s3">\n\t    </span><span class="s1">arrayMap = require_arrayMap(),</span><span class="s3">\n\t    </span><span class="s1">isArray = requireIsArray(),</span><span class="s3">\n\t    </span><span class="s1">isSymbol = requireIsSymbol();</span><span class="s3">\n\n\t</span><span class="s1">/** Used to convert symbols to primitives and strings. */</span><span class="s3">\n\t</span><span class="s1">var symbolProto = Symbol ? Symbol.prototype : undefined,</span><span class="s3">\n\t    </span><span class="s1">symbolToString = symbolProto ? symbolProto.toString : undefined;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `_.toString` which doesn't convert nullish</span><span class="s3">\n\t </span><span class="s1">* values to empty strings.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to process.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the string.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseToString(value) {</span><span class="s3">\n\t  </span><span class="s1">// Exit early for strings to avoid a performance hit in some environments.</span><span class="s3">\n\t  </span><span class="s1">if (typeof value == 'string') {</span><span class="s3">\n\t    </span><span class="s1">return value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (isArray(value)) {</span><span class="s3">\n\t    </span><span class="s1">// Recursively convert values (susceptible to call stack limits).</span><span class="s3">\n\t    </span><span class="s1">return arrayMap(value, baseToString) + '';</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (isSymbol(value)) {</span><span class="s3">\n\t    </span><span class="s1">return symbolToString ? symbolToString.call(value) : '';</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var result = (value + '');</span><span class="s3">\n\t  </span><span class="s1">return (result == '0' &amp;&amp; (1 / value) == -Infinity) ? '-0' : result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseToString = baseToString;</span><span class="s3">\n\t</span><span class="s1">return _baseToString;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var toString_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredToString;</span><span class="s3">\n\n</span><span class="s1">function requireToString () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredToString) return toString_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredToString = 1;</span><span class="s3">\n\t</span><span class="s1">var baseToString = require_baseToString();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `value` to a string. An empty string is returned for `null`</span><span class="s3">\n\t </span><span class="s1">* and `undefined` values. The sign of `-0` is preserved.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 4.0.0</span><span class="s3">\n\t </span><span class="s1">* @category Lang</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n\t </span><span class="s1">* @returns {string} Returns the converted string.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toString(null);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; ''</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toString(-0);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; '-0'</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toString([1, 2, 3]);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; '1,2,3'</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toString(value) {</span><span class="s3">\n\t  </span><span class="s1">return value == null ? '' : baseToString(value);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString_1 = toString;</span><span class="s3">\n\t</span><span class="s1">return toString_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _castPath;</span><span class="s3">\n</span><span class="s1">var hasRequired_castPath;</span><span class="s3">\n\n</span><span class="s1">function require_castPath () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_castPath) return _castPath;</span><span class="s3">\n\t</span><span class="s1">hasRequired_castPath = 1;</span><span class="s3">\n\t</span><span class="s1">var isArray = requireIsArray(),</span><span class="s3">\n\t    </span><span class="s1">isKey = require_isKey(),</span><span class="s3">\n\t    </span><span class="s1">stringToPath = require_stringToPath(),</span><span class="s3">\n\t    </span><span class="s1">toString = requireToString();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Casts `value` to a path array if it's not one.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to inspect.</span><span class="s3">\n\t </span><span class="s1">* @param {Object} [object] The object to query keys on.</span><span class="s3">\n\t </span><span class="s1">* @returns {Array} Returns the cast property path array.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function castPath(value, object) {</span><span class="s3">\n\t  </span><span class="s1">if (isArray(value)) {</span><span class="s3">\n\t    </span><span class="s1">return value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return isKey(value, object) ? [value] : stringToPath(toString(value));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_castPath = castPath;</span><span class="s3">\n\t</span><span class="s1">return _castPath;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _toKey;</span><span class="s3">\n</span><span class="s1">var hasRequired_toKey;</span><span class="s3">\n\n</span><span class="s1">function require_toKey () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_toKey) return _toKey;</span><span class="s3">\n\t</span><span class="s1">hasRequired_toKey = 1;</span><span class="s3">\n\t</span><span class="s1">var isSymbol = requireIsSymbol();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `value` to a string key if it's not a string or symbol.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to inspect.</span><span class="s3">\n\t </span><span class="s1">* @returns {string|symbol} Returns the key.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toKey(value) {</span><span class="s3">\n\t  </span><span class="s1">if (typeof value == 'string' || isSymbol(value)) {</span><span class="s3">\n\t    </span><span class="s1">return value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var result = (value + '');</span><span class="s3">\n\t  </span><span class="s1">return (result == '0' &amp;&amp; (1 / value) == -Infinity) ? '-0' : result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_toKey = toKey;</span><span class="s3">\n\t</span><span class="s1">return _toKey;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseGet;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseGet;</span><span class="s3">\n\n</span><span class="s1">function require_baseGet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseGet) return _baseGet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseGet = 1;</span><span class="s3">\n\t</span><span class="s1">var castPath = require_castPath(),</span><span class="s3">\n\t    </span><span class="s1">toKey = require_toKey();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `_.get` without support for default values.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n\t </span><span class="s1">* @param {Array|string} path The path of the property to get.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the resolved value.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseGet(object, path) {</span><span class="s3">\n\t  </span><span class="s1">path = castPath(path, object);</span><span class="s3">\n\n\t  </span><span class="s1">var index = 0,</span><span class="s3">\n\t      </span><span class="s1">length = path.length;</span><span class="s3">\n\n\t  </span><span class="s1">while (object != null &amp;&amp; index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">object = object[toKey(path[index++])];</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return (index &amp;&amp; index == length) ? object : undefined;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseGet = baseGet;</span><span class="s3">\n\t</span><span class="s1">return _baseGet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var get_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredGet;</span><span class="s3">\n\n</span><span class="s1">function requireGet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredGet) return get_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredGet = 1;</span><span class="s3">\n\t</span><span class="s1">var baseGet = require_baseGet();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Gets the value at `path` of `object`. If the resolved value is</span><span class="s3">\n\t </span><span class="s1">* `undefined`, the `defaultValue` is returned in its place.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 3.7.0</span><span class="s3">\n\t </span><span class="s1">* @category Object</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n\t </span><span class="s1">* @param {Array|string} path The path of the property to get.</span><span class="s3">\n\t </span><span class="s1">* @param {*} [defaultValue] The value returned for `undefined` resolved values.</span><span class="s3">\n\t </span><span class="s1">* @returns {*} Returns the resolved value.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* var object = { 'a': [{ 'b': { 'c': 3 } }] };</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.get(object, 'a[0].b.c');</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 3</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.get(object, ['a', '0', 'b', 'c']);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 3</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.get(object, 'a.b.c', 'default');</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 'default'</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function get(object, path, defaultValue) {</span><span class="s3">\n\t  </span><span class="s1">var result = object == null ? undefined : baseGet(object, path);</span><span class="s3">\n\t  </span><span class="s1">return result === undefined ? defaultValue : result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">get_1 = get;</span><span class="s3">\n\t</span><span class="s1">return get_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var getExports = requireGet();</span><span class="s3">\n</span><span class="s1">var get = /*@__PURE__*/getDefaultExportFromCjs(getExports);</span><span class="s3">\n\n</span><span class="s1">var _defineProperty;</span><span class="s3">\n</span><span class="s1">var hasRequired_defineProperty;</span><span class="s3">\n\n</span><span class="s1">function require_defineProperty () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_defineProperty) return _defineProperty;</span><span class="s3">\n\t</span><span class="s1">hasRequired_defineProperty = 1;</span><span class="s3">\n\t</span><span class="s1">var getNative = require_getNative();</span><span class="s3">\n\n\t</span><span class="s1">var defineProperty = (function() {</span><span class="s3">\n\t  </span><span class="s1">try {</span><span class="s3">\n\t    </span><span class="s1">var func = getNative(Object, 'defineProperty');</span><span class="s3">\n\t    </span><span class="s1">func({}, '', {});</span><span class="s3">\n\t    </span><span class="s1">return func;</span><span class="s3">\n\t  </span><span class="s1">} catch (e) {}</span><span class="s3">\n\t</span><span class="s1">}());</span><span class="s3">\n\n\t</span><span class="s1">_defineProperty = defineProperty;</span><span class="s3">\n\t</span><span class="s1">return _defineProperty;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseAssignValue;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseAssignValue;</span><span class="s3">\n\n</span><span class="s1">function require_baseAssignValue () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseAssignValue) return _baseAssignValue;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseAssignValue = 1;</span><span class="s3">\n\t</span><span class="s1">var defineProperty = require_defineProperty();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `assignValue` and `assignMergeValue` without</span><span class="s3">\n\t </span><span class="s1">* value checks.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the property to assign.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to assign.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseAssignValue(object, key, value) {</span><span class="s3">\n\t  </span><span class="s1">if (key == '__proto__' &amp;&amp; defineProperty) {</span><span class="s3">\n\t    </span><span class="s1">defineProperty(object, key, {</span><span class="s3">\n\t      </span><span class="s1">'configurable': true,</span><span class="s3">\n\t      </span><span class="s1">'enumerable': true,</span><span class="s3">\n\t      </span><span class="s1">'value': value,</span><span class="s3">\n\t      </span><span class="s1">'writable': true</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">object[key] = value;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseAssignValue = baseAssignValue;</span><span class="s3">\n\t</span><span class="s1">return _baseAssignValue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _assignValue;</span><span class="s3">\n</span><span class="s1">var hasRequired_assignValue;</span><span class="s3">\n\n</span><span class="s1">function require_assignValue () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_assignValue) return _assignValue;</span><span class="s3">\n\t</span><span class="s1">hasRequired_assignValue = 1;</span><span class="s3">\n\t</span><span class="s1">var baseAssignValue = require_baseAssignValue(),</span><span class="s3">\n\t    </span><span class="s1">eq = requireEq();</span><span class="s3">\n\n\t</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n\t</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n\t</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Assigns `value` to `key` of `object` if the existing value is not equivalent</span><span class="s3">\n\t </span><span class="s1">* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n\t </span><span class="s1">* for equality comparisons.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n\t </span><span class="s1">* @param {string} key The key of the property to assign.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to assign.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function assignValue(object, key, value) {</span><span class="s3">\n\t  </span><span class="s1">var objValue = object[key];</span><span class="s3">\n\t  </span><span class="s1">if (!(hasOwnProperty.call(object, key) &amp;&amp; eq(objValue, value)) ||</span><span class="s3">\n\t      </span><span class="s1">(value === undefined &amp;&amp; !(key in object))) {</span><span class="s3">\n\t    </span><span class="s1">baseAssignValue(object, key, value);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_assignValue = assignValue;</span><span class="s3">\n\t</span><span class="s1">return _assignValue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n\n</span><span class="s1">var _isIndex;</span><span class="s3">\n</span><span class="s1">var hasRequired_isIndex;</span><span class="s3">\n\n</span><span class="s1">function require_isIndex () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_isIndex) return _isIndex;</span><span class="s3">\n\t</span><span class="s1">hasRequired_isIndex = 1;</span><span class="s3">\n\t</span><span class="s1">var MAX_SAFE_INTEGER = 9007199254740991;</span><span class="s3">\n\n\t</span><span class="s1">/** Used to detect unsigned integer values. */</span><span class="s3">\n\t</span><span class="s1">var reIsUint = /^(?:0|[1-9]</span><span class="s3">\\</span><span class="s1">d*)$/;</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Checks if `value` is a valid array-like index.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n\t </span><span class="s1">* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.</span><span class="s3">\n\t </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function isIndex(value, length) {</span><span class="s3">\n\t  </span><span class="s1">var type = typeof value;</span><span class="s3">\n\t  </span><span class="s1">length = length == null ? MAX_SAFE_INTEGER : length;</span><span class="s3">\n\n\t  </span><span class="s1">return !!length &amp;&amp;</span><span class="s3">\n\t    </span><span class="s1">(type == 'number' ||</span><span class="s3">\n\t      </span><span class="s1">(type != 'symbol' &amp;&amp; reIsUint.test(value))) &amp;&amp;</span><span class="s3">\n\t        </span><span class="s1">(value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_isIndex = isIndex;</span><span class="s3">\n\t</span><span class="s1">return _isIndex;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var _baseSet;</span><span class="s3">\n</span><span class="s1">var hasRequired_baseSet;</span><span class="s3">\n\n</span><span class="s1">function require_baseSet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_baseSet) return _baseSet;</span><span class="s3">\n\t</span><span class="s1">hasRequired_baseSet = 1;</span><span class="s3">\n\t</span><span class="s1">var assignValue = require_assignValue(),</span><span class="s3">\n\t    </span><span class="s1">castPath = require_castPath(),</span><span class="s3">\n\t    </span><span class="s1">isIndex = require_isIndex(),</span><span class="s3">\n\t    </span><span class="s1">isObject = requireIsObject(),</span><span class="s3">\n\t    </span><span class="s1">toKey = require_toKey();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The base implementation of `_.set`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @private</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n\t </span><span class="s1">* @param {Array|string} path The path of the property to set.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n\t </span><span class="s1">* @param {Function} [customizer] The function to customize path creation.</span><span class="s3">\n\t </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function baseSet(object, path, value, customizer) {</span><span class="s3">\n\t  </span><span class="s1">if (!isObject(object)) {</span><span class="s3">\n\t    </span><span class="s1">return object;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">path = castPath(path, object);</span><span class="s3">\n\n\t  </span><span class="s1">var index = -1,</span><span class="s3">\n\t      </span><span class="s1">length = path.length,</span><span class="s3">\n\t      </span><span class="s1">lastIndex = length - 1,</span><span class="s3">\n\t      </span><span class="s1">nested = object;</span><span class="s3">\n\n\t  </span><span class="s1">while (nested != null &amp;&amp; ++index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">var key = toKey(path[index]),</span><span class="s3">\n\t        </span><span class="s1">newValue = value;</span><span class="s3">\n\n\t    </span><span class="s1">if (key === '__proto__' || key === 'constructor' || key === 'prototype') {</span><span class="s3">\n\t      </span><span class="s1">return object;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\n\t    </span><span class="s1">if (index != lastIndex) {</span><span class="s3">\n\t      </span><span class="s1">var objValue = nested[key];</span><span class="s3">\n\t      </span><span class="s1">newValue = customizer ? customizer(objValue, key, nested) : undefined;</span><span class="s3">\n\t      </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n\t        </span><span class="s1">newValue = isObject(objValue)</span><span class="s3">\n\t          </span><span class="s1">? objValue</span><span class="s3">\n\t          </span><span class="s1">: (isIndex(path[index + 1]) ? [] : {});</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">assignValue(nested, key, newValue);</span><span class="s3">\n\t    </span><span class="s1">nested = nested[key];</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return object;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_baseSet = baseSet;</span><span class="s3">\n\t</span><span class="s1">return _baseSet;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var set_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredSet;</span><span class="s3">\n\n</span><span class="s1">function requireSet () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredSet) return set_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredSet = 1;</span><span class="s3">\n\t</span><span class="s1">var baseSet = require_baseSet();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Sets the value at `path` of `object`. If a portion of `path` doesn't exist,</span><span class="s3">\n\t </span><span class="s1">* it's created. Arrays are created for missing index properties while objects</span><span class="s3">\n\t </span><span class="s1">* are created for all other missing properties. Use `_.setWith` to customize</span><span class="s3">\n\t </span><span class="s1">* `path` creation.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 3.7.0</span><span class="s3">\n\t </span><span class="s1">* @category Object</span><span class="s3">\n\t </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n\t </span><span class="s1">* @param {Array|string} path The path of the property to set.</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n\t </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* var object = { 'a': [{ 'b': { 'c': 3 } }] };</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.set(object, 'a[0].b.c', 4);</span><span class="s3">\n\t </span><span class="s1">* console.log(object.a[0].b.c);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 4</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.set(object, ['x', '0', 'y', 'z'], 5);</span><span class="s3">\n\t </span><span class="s1">* console.log(object.x[0].y.z);</span><span class="s3">\n\t </span><span class="s1">* // =&gt; 5</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function set(object, path, value) {</span><span class="s3">\n\t  </span><span class="s1">return object == null ? object : baseSet(object, path, value);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">set_1 = set;</span><span class="s3">\n\t</span><span class="s1">return set_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var setExports = requireSet();</span><span class="s3">\n</span><span class="s1">var set = /*@__PURE__*/getDefaultExportFromCjs(setExports);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copies the values of `source` to `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} source The array to copy values from.</span><span class="s3">\n </span><span class="s1">* @param {Array} [array=[]] The array to copy values to.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns `array`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var _copyArray;</span><span class="s3">\n</span><span class="s1">var hasRequired_copyArray;</span><span class="s3">\n\n</span><span class="s1">function require_copyArray () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequired_copyArray) return _copyArray;</span><span class="s3">\n\t</span><span class="s1">hasRequired_copyArray = 1;</span><span class="s3">\n\t</span><span class="s1">function copyArray(source, array) {</span><span class="s3">\n\t  </span><span class="s1">var index = -1,</span><span class="s3">\n\t      </span><span class="s1">length = source.length;</span><span class="s3">\n\n\t  </span><span class="s1">array || (array = Array(length));</span><span class="s3">\n\t  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n\t    </span><span class="s1">array[index] = source[index];</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return array;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_copyArray = copyArray;</span><span class="s3">\n\t</span><span class="s1">return _copyArray;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var toPath_1;</span><span class="s3">\n</span><span class="s1">var hasRequiredToPath;</span><span class="s3">\n\n</span><span class="s1">function requireToPath () {</span><span class="s3">\n\t</span><span class="s1">if (hasRequiredToPath) return toPath_1;</span><span class="s3">\n\t</span><span class="s1">hasRequiredToPath = 1;</span><span class="s3">\n\t</span><span class="s1">var arrayMap = require_arrayMap(),</span><span class="s3">\n\t    </span><span class="s1">copyArray = require_copyArray(),</span><span class="s3">\n\t    </span><span class="s1">isArray = requireIsArray(),</span><span class="s3">\n\t    </span><span class="s1">isSymbol = requireIsSymbol(),</span><span class="s3">\n\t    </span><span class="s1">stringToPath = require_stringToPath(),</span><span class="s3">\n\t    </span><span class="s1">toKey = require_toKey(),</span><span class="s3">\n\t    </span><span class="s1">toString = requireToString();</span><span class="s3">\n\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts `value` to a property path array.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @static</span><span class="s3">\n\t </span><span class="s1">* @memberOf _</span><span class="s3">\n\t </span><span class="s1">* @since 4.0.0</span><span class="s3">\n\t </span><span class="s1">* @category Util</span><span class="s3">\n\t </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n\t </span><span class="s1">* @returns {Array} Returns the new property path array.</span><span class="s3">\n\t </span><span class="s1">* @example</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toPath('a.b.c');</span><span class="s3">\n\t </span><span class="s1">* // =&gt; ['a', 'b', 'c']</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* _.toPath('a[0].b.c');</span><span class="s3">\n\t </span><span class="s1">* // =&gt; ['a', '0', 'b', 'c']</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toPath(value) {</span><span class="s3">\n\t  </span><span class="s1">if (isArray(value)) {</span><span class="s3">\n\t    </span><span class="s1">return arrayMap(value, toKey);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toPath_1 = toPath;</span><span class="s3">\n\t</span><span class="s1">return toPath_1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var toPathExports = requireToPath();</span><span class="s3">\n</span><span class="s1">var toPath = /*@__PURE__*/getDefaultExportFromCjs(toPathExports);</span><span class="s3">\n\n</span><span class="s1">var define$2 = {</span><span class="s3">\n  </span><span class="s1">// access data field</span><span class="s3">\n  </span><span class="s1">data: function data(params) {</span><span class="s3">\n    </span><span class="s1">var defaults = {</span><span class="s3">\n      </span><span class="s1">field: 'data',</span><span class="s3">\n      </span><span class="s1">bindingEvent: 'data',</span><span class="s3">\n      </span><span class="s1">allowBinding: false,</span><span class="s3">\n      </span><span class="s1">allowSetting: false,</span><span class="s3">\n      </span><span class="s1">allowGetting: false,</span><span class="s3">\n      </span><span class="s1">settingEvent: 'data',</span><span class="s3">\n      </span><span class="s1">settingTriggersEvent: false,</span><span class="s3">\n      </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n      </span><span class="s1">immutableKeys: {},</span><span class="s3">\n      </span><span class="s1">// key =&gt; true if immutable</span><span class="s3">\n      </span><span class="s1">updateStyle: false,</span><span class="s3">\n      </span><span class="s1">beforeGet: function beforeGet(self) {},</span><span class="s3">\n      </span><span class="s1">beforeSet: function beforeSet(self, obj) {},</span><span class="s3">\n      </span><span class="s1">onSet: function onSet(self) {},</span><span class="s3">\n      </span><span class="s1">canSet: function canSet(self) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">params = extend({}, defaults, params);</span><span class="s3">\n    </span><span class="s1">return function dataImpl(name, value) {</span><span class="s3">\n      </span><span class="s1">var p = params;</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n      </span><span class="s1">var single = selfIsArrayLike ? self[0] : self;</span><span class="s3">\n\n      </span><span class="s1">// .data('foo', ...)</span><span class="s3">\n      </span><span class="s1">if (string(name)) {</span><span class="s3">\n        </span><span class="s1">// set or get property</span><span class="s3">\n        </span><span class="s1">var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot </span><span class="s3">\n        </span><span class="s1">var path = isPathLike &amp;&amp; toPath(name);</span><span class="s3">\n\n        </span><span class="s1">// .data('foo')</span><span class="s3">\n        </span><span class="s1">if (p.allowGetting &amp;&amp; value === undefined) {</span><span class="s3">\n          </span><span class="s1">// get</span><span class="s3">\n\n          </span><span class="s1">var ret;</span><span class="s3">\n          </span><span class="s1">if (single) {</span><span class="s3">\n            </span><span class="s1">p.beforeGet(single);</span><span class="s3">\n\n            </span><span class="s1">// check if it's path and a field with the same name doesn't exist</span><span class="s3">\n            </span><span class="s1">if (path &amp;&amp; single._private[p.field][name] === undefined) {</span><span class="s3">\n              </span><span class="s1">ret = get(single._private[p.field], path);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">ret = single._private[p.field][name];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return ret;</span><span class="s3">\n\n          </span><span class="s1">// .data('foo', 'bar')</span><span class="s3">\n        </span><span class="s1">} else if (p.allowSetting &amp;&amp; value !== undefined) {</span><span class="s3">\n          </span><span class="s1">// set</span><span class="s3">\n          </span><span class="s1">var valid = !p.immutableKeys[name];</span><span class="s3">\n          </span><span class="s1">if (valid) {</span><span class="s3">\n            </span><span class="s1">var change = _defineProperty$1({}, name, value);</span><span class="s3">\n            </span><span class="s1">p.beforeSet(self, change);</span><span class="s3">\n            </span><span class="s1">for (var i = 0, l = all.length; i &lt; l; i++) {</span><span class="s3">\n              </span><span class="s1">var ele = all[i];</span><span class="s3">\n              </span><span class="s1">if (p.canSet(ele)) {</span><span class="s3">\n                </span><span class="s1">if (path &amp;&amp; single._private[p.field][name] === undefined) {</span><span class="s3">\n                  </span><span class="s1">set(ele._private[p.field], path, value);</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">ele._private[p.field][name] = value;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// update mappers if asked</span><span class="s3">\n            </span><span class="s1">if (p.updateStyle) {</span><span class="s3">\n              </span><span class="s1">self.updateStyle();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// call onSet callback</span><span class="s3">\n            </span><span class="s1">p.onSet(self);</span><span class="s3">\n            </span><span class="s1">if (p.settingTriggersEvent) {</span><span class="s3">\n              </span><span class="s1">self[p.triggerFnName](p.settingEvent);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// .data({ 'foo': 'bar' })</span><span class="s3">\n      </span><span class="s1">} else if (p.allowSetting &amp;&amp; plainObject(name)) {</span><span class="s3">\n        </span><span class="s1">// extend</span><span class="s3">\n        </span><span class="s1">var obj = name;</span><span class="s3">\n        </span><span class="s1">var k, v;</span><span class="s3">\n        </span><span class="s1">var keys = Object.keys(obj);</span><span class="s3">\n        </span><span class="s1">p.beforeSet(self, obj);</span><span class="s3">\n        </span><span class="s1">for (var _i = 0; _i &lt; keys.length; _i++) {</span><span class="s3">\n          </span><span class="s1">k = keys[_i];</span><span class="s3">\n          </span><span class="s1">v = obj[k];</span><span class="s3">\n          </span><span class="s1">var _valid = !p.immutableKeys[k];</span><span class="s3">\n          </span><span class="s1">if (_valid) {</span><span class="s3">\n            </span><span class="s1">for (var j = 0; j &lt; all.length; j++) {</span><span class="s3">\n              </span><span class="s1">var _ele = all[j];</span><span class="s3">\n              </span><span class="s1">if (p.canSet(_ele)) {</span><span class="s3">\n                </span><span class="s1">_ele._private[p.field][k] = v;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// update mappers if asked</span><span class="s3">\n        </span><span class="s1">if (p.updateStyle) {</span><span class="s3">\n          </span><span class="s1">self.updateStyle();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// call onSet callback</span><span class="s3">\n        </span><span class="s1">p.onSet(self);</span><span class="s3">\n        </span><span class="s1">if (p.settingTriggersEvent) {</span><span class="s3">\n          </span><span class="s1">self[p.triggerFnName](p.settingEvent);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// .data(function(){ ... })</span><span class="s3">\n      </span><span class="s1">} else if (p.allowBinding &amp;&amp; fn$6(name)) {</span><span class="s3">\n        </span><span class="s1">// bind to event</span><span class="s3">\n        </span><span class="s1">var fn = name;</span><span class="s3">\n        </span><span class="s1">self.on(p.bindingEvent, fn);</span><span class="s3">\n\n        </span><span class="s1">// .data()</span><span class="s3">\n      </span><span class="s1">} else if (p.allowGetting &amp;&amp; name === undefined) {</span><span class="s3">\n        </span><span class="s1">// get whole object</span><span class="s3">\n        </span><span class="s1">var _ret;</span><span class="s3">\n        </span><span class="s1">if (single) {</span><span class="s3">\n          </span><span class="s1">p.beforeGet(single);</span><span class="s3">\n          </span><span class="s1">_ret = single._private[p.field];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return _ret;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return self; // maintain chainability</span><span class="s3">\n    </span><span class="s1">}; // function</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// data</span><span class="s3">\n\n  </span><span class="s1">// remove data field</span><span class="s3">\n  </span><span class="s1">removeData: function removeData(params) {</span><span class="s3">\n    </span><span class="s1">var defaults = {</span><span class="s3">\n      </span><span class="s1">field: 'data',</span><span class="s3">\n      </span><span class="s1">event: 'data',</span><span class="s3">\n      </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n      </span><span class="s1">triggerEvent: false,</span><span class="s3">\n      </span><span class="s1">immutableKeys: {} // key =&gt; true if immutable</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">params = extend({}, defaults, params);</span><span class="s3">\n    </span><span class="s1">return function removeDataImpl(names) {</span><span class="s3">\n      </span><span class="s1">var p = params;</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var selfIsArrayLike = self.length !== undefined;</span><span class="s3">\n      </span><span class="s1">var all = selfIsArrayLike ? self : [self]; // put in array if not array-like</span><span class="s3">\n\n      </span><span class="s1">// .removeData('foo bar')</span><span class="s3">\n      </span><span class="s1">if (string(names)) {</span><span class="s3">\n        </span><span class="s1">// then get the list of keys, and delete them</span><span class="s3">\n        </span><span class="s1">var keys = names.split(/</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n        </span><span class="s1">var l = keys.length;</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; l; i++) {</span><span class="s3">\n          </span><span class="s1">// delete each non-empty key</span><span class="s3">\n          </span><span class="s1">var key = keys[i];</span><span class="s3">\n          </span><span class="s1">if (emptyString(key)) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var valid = !p.immutableKeys[key]; // not valid if immutable</span><span class="s3">\n          </span><span class="s1">if (valid) {</span><span class="s3">\n            </span><span class="s1">for (var i_a = 0, l_a = all.length; i_a &lt; l_a; i_a++) {</span><span class="s3">\n              </span><span class="s1">all[i_a]._private[p.field][key] = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (p.triggerEvent) {</span><span class="s3">\n          </span><span class="s1">self[p.triggerFnName](p.event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// .removeData()</span><span class="s3">\n      </span><span class="s1">} else if (names === undefined) {</span><span class="s3">\n        </span><span class="s1">// then delete all keys</span><span class="s3">\n\n        </span><span class="s1">for (var _i_a = 0, _l_a = all.length; _i_a &lt; _l_a; _i_a++) {</span><span class="s3">\n          </span><span class="s1">var _privateFields = all[_i_a]._private[p.field];</span><span class="s3">\n          </span><span class="s1">var _keys = Object.keys(_privateFields);</span><span class="s3">\n          </span><span class="s1">for (var _i2 = 0; _i2 &lt; _keys.length; _i2++) {</span><span class="s3">\n            </span><span class="s1">var _key = _keys[_i2];</span><span class="s3">\n            </span><span class="s1">var validKeyToDelete = !p.immutableKeys[_key];</span><span class="s3">\n            </span><span class="s1">if (validKeyToDelete) {</span><span class="s3">\n              </span><span class="s1">_privateFields[_key] = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (p.triggerEvent) {</span><span class="s3">\n          </span><span class="s1">self[p.triggerFnName](p.event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return self; // maintain chaining</span><span class="s3">\n    </span><span class="s1">}; // function</span><span class="s3">\n  </span><span class="s1">} // removeData</span><span class="s3">\n</span><span class="s1">}; // define</span><span class="s3">\n\n</span><span class="s1">var define$1 = {</span><span class="s3">\n  </span><span class="s1">eventAliasesOn: function eventAliasesOn(proto) {</span><span class="s3">\n    </span><span class="s1">var p = proto;</span><span class="s3">\n    </span><span class="s1">p.addListener = p.listen = p.bind = p.on;</span><span class="s3">\n    </span><span class="s1">p.unlisten = p.unbind = p.off = p.removeListener;</span><span class="s3">\n    </span><span class="s1">p.trigger = p.emit;</span><span class="s3">\n\n    </span><span class="s1">// this is just a wrapper alias of .on()</span><span class="s3">\n    </span><span class="s1">p.pon = p.promiseOn = function (events, selector) {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var args = Array.prototype.slice.call(arguments, 0);</span><span class="s3">\n      </span><span class="s1">return new Promise$1(function (resolve, reject) {</span><span class="s3">\n        </span><span class="s1">var callback = function callback(e) {</span><span class="s3">\n          </span><span class="s1">self.off.apply(self, offArgs);</span><span class="s3">\n          </span><span class="s1">resolve(e);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var onArgs = args.concat([callback]);</span><span class="s3">\n        </span><span class="s1">var offArgs = onArgs.concat([]);</span><span class="s3">\n        </span><span class="s1">self.on.apply(self, onArgs);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}; // define</span><span class="s3">\n\n</span><span class="s1">// use this module to cherry pick functions into your prototype</span><span class="s3">\n</span><span class="s1">// (useful for functions shared between the core and collections, for example)</span><span class="s3">\n\n</span><span class="s1">var define = {};</span><span class="s3">\n</span><span class="s1">[define$3, define$2, define$1].forEach(function (m) {</span><span class="s3">\n  </span><span class="s1">extend(define, m);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var elesfn$i = {</span><span class="s3">\n  </span><span class="s1">animate: define.animate(),</span><span class="s3">\n  </span><span class="s1">animation: define.animation(),</span><span class="s3">\n  </span><span class="s1">animated: define.animated(),</span><span class="s3">\n  </span><span class="s1">clearQueue: define.clearQueue(),</span><span class="s3">\n  </span><span class="s1">delay: define.delay(),</span><span class="s3">\n  </span><span class="s1">delayAnimation: define.delayAnimation(),</span><span class="s3">\n  </span><span class="s1">stop: define.stop()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var elesfn$h = {</span><span class="s3">\n  </span><span class="s1">classes: function classes(_classes) {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">if (_classes === undefined) {</span><span class="s3">\n      </span><span class="s1">var ret = [];</span><span class="s3">\n      </span><span class="s1">self[0]._private.classes.forEach(function (cls) {</span><span class="s3">\n        </span><span class="s1">return ret.push(cls);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">return ret;</span><span class="s3">\n    </span><span class="s1">} else if (!array(_classes)) {</span><span class="s3">\n      </span><span class="s1">// extract classes from string</span><span class="s3">\n      </span><span class="s1">_classes = (_classes || '').match(/</span><span class="s3">\\</span><span class="s1">S+/g) || [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var changed = [];</span><span class="s3">\n    </span><span class="s1">var classesSet = new Set$1(_classes);</span><span class="s3">\n\n    </span><span class="s1">// check and update each ele</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; self.length; j++) {</span><span class="s3">\n      </span><span class="s1">var ele = self[j];</span><span class="s3">\n      </span><span class="s1">var _p = ele._private;</span><span class="s3">\n      </span><span class="s1">var eleClasses = _p.classes;</span><span class="s3">\n      </span><span class="s1">var changedEle = false;</span><span class="s3">\n\n      </span><span class="s1">// check if ele has all of the passed classes</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; _classes.length; i++) {</span><span class="s3">\n        </span><span class="s1">var cls = _classes[i];</span><span class="s3">\n        </span><span class="s1">var eleHasClass = eleClasses.has(cls);</span><span class="s3">\n        </span><span class="s1">if (!eleHasClass) {</span><span class="s3">\n          </span><span class="s1">changedEle = true;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// check if ele has classes outside of those passed</span><span class="s3">\n      </span><span class="s1">if (!changedEle) {</span><span class="s3">\n        </span><span class="s1">changedEle = eleClasses.size !== _classes.length;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (changedEle) {</span><span class="s3">\n        </span><span class="s1">_p.classes = classesSet;</span><span class="s3">\n        </span><span class="s1">changed.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// trigger update style on those eles that had class changes</span><span class="s3">\n    </span><span class="s1">if (changed.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.spawn(changed).updateStyle().emit('class');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return self;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">addClass: function addClass(classes) {</span><span class="s3">\n    </span><span class="s1">return this.toggleClass(classes, true);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hasClass: function hasClass(className) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">return ele != null &amp;&amp; ele._private.classes.has(className);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">toggleClass: function toggleClass(classes, toggle) {</span><span class="s3">\n    </span><span class="s1">if (!array(classes)) {</span><span class="s3">\n      </span><span class="s1">// extract classes from string</span><span class="s3">\n      </span><span class="s1">classes = classes.match(/</span><span class="s3">\\</span><span class="s1">S+/g) || [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">var toggleUndefd = toggle === undefined;</span><span class="s3">\n    </span><span class="s1">var changed = []; // eles who had classes changed</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0, il = self.length; i &lt; il; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = self[i];</span><span class="s3">\n      </span><span class="s1">var eleClasses = ele._private.classes;</span><span class="s3">\n      </span><span class="s1">var changedEle = false;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; classes.length; j++) {</span><span class="s3">\n        </span><span class="s1">var cls = classes[j];</span><span class="s3">\n        </span><span class="s1">var hasClass = eleClasses.has(cls);</span><span class="s3">\n        </span><span class="s1">var changedNow = false;</span><span class="s3">\n        </span><span class="s1">if (toggle || toggleUndefd &amp;&amp; !hasClass) {</span><span class="s3">\n          </span><span class="s1">eleClasses.add(cls);</span><span class="s3">\n          </span><span class="s1">changedNow = true;</span><span class="s3">\n        </span><span class="s1">} else if (!toggle || toggleUndefd &amp;&amp; hasClass) {</span><span class="s3">\n          </span><span class="s1">eleClasses[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](cls);</span><span class="s3">\n          </span><span class="s1">changedNow = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!changedEle &amp;&amp; changedNow) {</span><span class="s3">\n          </span><span class="s1">changed.push(ele);</span><span class="s3">\n          </span><span class="s1">changedEle = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // for j classes</span><span class="s3">\n    </span><span class="s1">} // for i eles</span><span class="s3">\n\n    </span><span class="s1">// trigger update style on those eles that had class changes</span><span class="s3">\n    </span><span class="s1">if (changed.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.spawn(changed).updateStyle().emit('class');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return self;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeClass: function removeClass(classes) {</span><span class="s3">\n    </span><span class="s1">return this.toggleClass(classes, false);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">flashClass: function flashClass(classes, duration) {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">if (duration == null) {</span><span class="s3">\n      </span><span class="s1">duration = 250;</span><span class="s3">\n    </span><span class="s1">} else if (duration === 0) {</span><span class="s3">\n      </span><span class="s1">return self; // nothing to do really</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">self.addClass(classes);</span><span class="s3">\n    </span><span class="s1">setTimeout(function () {</span><span class="s3">\n      </span><span class="s1">self.removeClass(classes);</span><span class="s3">\n    </span><span class="s1">}, duration);</span><span class="s3">\n    </span><span class="s1">return self;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;</span><span class="s3">\n\n</span><span class="s1">// tokens in the query language</span><span class="s3">\n</span><span class="s1">var tokens = {</span><span class="s3">\n  </span><span class="s1">metaChar: '[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\\&quot;\\\\</span><span class="s1">#</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">&amp;</span><span class="s3">\\\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">&lt;</span><span class="s3">\\\\</span><span class="s1">=</span><span class="s3">\\\\</span><span class="s1">&gt;</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">{</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\\\</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">~]',</span><span class="s3">\n  </span><span class="s1">// chars we need to escape in let names, etc</span><span class="s3">\n  </span><span class="s1">comparatorOp: '=|</span><span class="s3">\\\\</span><span class="s1">!=|&gt;|&gt;=|&lt;|&lt;=|</span><span class="s3">\\\\</span><span class="s1">$=|</span><span class="s3">\\\\</span><span class="s1">^=|</span><span class="s3">\\\\</span><span class="s1">*=',</span><span class="s3">\n  </span><span class="s1">// binary comparison op (used in data selectors)</span><span class="s3">\n  </span><span class="s1">boolOp: '</span><span class="s3">\\\\</span><span class="s1">?|</span><span class="s3">\\\\</span><span class="s1">!|</span><span class="s3">\\\\</span><span class="s1">^',</span><span class="s3">\n  </span><span class="s1">// boolean (unary) operators (used in data selectors)</span><span class="s3">\n  </span><span class="s1">string: '</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\\\\\\&quot;</span><span class="s1">|[^</span><span class="s3">\&quot;</span><span class="s1">])*</span><span class="s3">\&quot;</span><span class="s1">' + '|' + </span><span class="s3">\&quot;</span><span class="s1">'(?:</span><span class="s3">\\\\\\\\</span><span class="s1">'|[^'])*'</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">// string literals (used in data selectors) -- doublequotes | singlequotes</span><span class="s3">\n  </span><span class="s1">number: number,</span><span class="s3">\n  </span><span class="s1">// number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123</span><span class="s3">\n  </span><span class="s1">meta: 'degree|indegree|outdegree',</span><span class="s3">\n  </span><span class="s1">// allowed metadata fields (i.e. allowed functions to use from Collection)</span><span class="s3">\n  </span><span class="s1">separator: '</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*',</span><span class="s3">\n  </span><span class="s1">// queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass</span><span class="s3">\n  </span><span class="s1">descendant: '</span><span class="s3">\\\\</span><span class="s1">s+',</span><span class="s3">\n  </span><span class="s1">child: '</span><span class="s3">\\\\</span><span class="s1">s+&gt;</span><span class="s3">\\\\</span><span class="s1">s+',</span><span class="s3">\n  </span><span class="s1">subject: '</span><span class="s3">\\\\</span><span class="s1">$',</span><span class="s3">\n  </span><span class="s1">group: 'node|edge|</span><span class="s3">\\\\</span><span class="s1">*',</span><span class="s3">\n  </span><span class="s1">directedEdge: '</span><span class="s3">\\\\</span><span class="s1">s+-&gt;</span><span class="s3">\\\\</span><span class="s1">s+',</span><span class="s3">\n  </span><span class="s1">undirectedEdge: '</span><span class="s3">\\\\</span><span class="s1">s+&lt;-&gt;</span><span class="s3">\\\\</span><span class="s1">s+'</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">tokens.variable = '(?:[</span><span class="s3">\\\\</span><span class="s1">w-.]|(?:</span><span class="s3">\\\\\\\\</span><span class="s1">' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods</span><span class="s3">\n</span><span class="s1">tokens.className = '(?:[</span><span class="s3">\\\\</span><span class="s1">w-]|(?:</span><span class="s3">\\\\\\\\</span><span class="s1">' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name</span><span class="s3">\n</span><span class="s1">tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number</span><span class="s3">\n</span><span class="s1">tokens.id = tokens.variable; // an element id (follows variable conventions)</span><span class="s3">\n\n</span><span class="s1">(function () {</span><span class="s3">\n  </span><span class="s1">var ops, op, i;</span><span class="s3">\n\n  </span><span class="s1">// add @ variants to comparatorOp</span><span class="s3">\n  </span><span class="s1">ops = tokens.comparatorOp.split('|');</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; ops.length; i++) {</span><span class="s3">\n    </span><span class="s1">op = ops[i];</span><span class="s3">\n    </span><span class="s1">tokens.comparatorOp += '|@' + op;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add ! variants to comparatorOp</span><span class="s3">\n  </span><span class="s1">ops = tokens.comparatorOp.split('|');</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; ops.length; i++) {</span><span class="s3">\n    </span><span class="s1">op = ops[i];</span><span class="s3">\n    </span><span class="s1">if (op.indexOf('!') &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">} // skip ops that explicitly contain !</span><span class="s3">\n    </span><span class="s1">if (op === '=') {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">} // skip = b/c != is explicitly defined</span><span class="s3">\n\n    </span><span class="s1">tokens.comparatorOp += '|</span><span class="s3">\\\\</span><span class="s1">!' + op;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Make a new query object</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @prop type {Type} The type enum (int) of the query</span><span class="s3">\n </span><span class="s1">* @prop checks List of checks to make against an ele to test for a match</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var newQuery = function newQuery() {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">checks: []</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A check type enum-like object.  Uses integer values for fast match() lookup.</span><span class="s3">\n </span><span class="s1">* The ordering does not matter as long as the ints are unique.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Type = {</span><span class="s3">\n  </span><span class="s1">/** E.g. node */</span><span class="s3">\n  </span><span class="s1">GROUP: 0,</span><span class="s3">\n  </span><span class="s1">/** A collection of elements */</span><span class="s3">\n  </span><span class="s1">COLLECTION: 1,</span><span class="s3">\n  </span><span class="s1">/** A filter(ele) function */</span><span class="s3">\n  </span><span class="s1">FILTER: 2,</span><span class="s3">\n  </span><span class="s1">/** E.g. [foo &gt; 1] */</span><span class="s3">\n  </span><span class="s1">DATA_COMPARE: 3,</span><span class="s3">\n  </span><span class="s1">/** E.g. [foo] */</span><span class="s3">\n  </span><span class="s1">DATA_EXIST: 4,</span><span class="s3">\n  </span><span class="s1">/** E.g. [?foo] */</span><span class="s3">\n  </span><span class="s1">DATA_BOOL: 5,</span><span class="s3">\n  </span><span class="s1">/** E.g. [[degree &gt; 2]] */</span><span class="s3">\n  </span><span class="s1">META_COMPARE: 6,</span><span class="s3">\n  </span><span class="s1">/** E.g. :selected */</span><span class="s3">\n  </span><span class="s1">STATE: 7,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo */</span><span class="s3">\n  </span><span class="s1">ID: 8,</span><span class="s3">\n  </span><span class="s1">/** E.g. .foo */</span><span class="s3">\n  </span><span class="s1">CLASS: 9,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo &lt;-&gt; #bar */</span><span class="s3">\n  </span><span class="s1">UNDIRECTED_EDGE: 10,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo -&gt; #bar */</span><span class="s3">\n  </span><span class="s1">DIRECTED_EDGE: 11,</span><span class="s3">\n  </span><span class="s1">/** E.g. $#foo -&gt; #bar */</span><span class="s3">\n  </span><span class="s1">NODE_SOURCE: 12,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo -&gt; $#bar */</span><span class="s3">\n  </span><span class="s1">NODE_TARGET: 13,</span><span class="s3">\n  </span><span class="s1">/** E.g. $#foo &lt;-&gt; #bar */</span><span class="s3">\n  </span><span class="s1">NODE_NEIGHBOR: 14,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo &gt; #bar */</span><span class="s3">\n  </span><span class="s1">CHILD: 15,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo #bar */</span><span class="s3">\n  </span><span class="s1">DESCENDANT: 16,</span><span class="s3">\n  </span><span class="s1">/** E.g. $#foo &gt; #bar */</span><span class="s3">\n  </span><span class="s1">PARENT: 17,</span><span class="s3">\n  </span><span class="s1">/** E.g. $#foo #bar */</span><span class="s3">\n  </span><span class="s1">ANCESTOR: 18,</span><span class="s3">\n  </span><span class="s1">/** E.g. #foo &gt; $bar &gt; #baz */</span><span class="s3">\n  </span><span class="s1">COMPOUND_SPLIT: 19,</span><span class="s3">\n  </span><span class="s1">/** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */</span><span class="s3">\n  </span><span class="s1">TRUE: 20</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var stateSelectors = [{</span><span class="s3">\n  </span><span class="s1">selector: ':selected',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.selected();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':unselected',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.selected();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':selectable',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.selectable();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':unselectable',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.selectable();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':locked',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.locked();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':unlocked',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.locked();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':visible',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.visible();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':hidden',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.visible();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':transparent',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.transparent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':grabbed',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.grabbed();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':free',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.grabbed();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':removed',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.removed();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':inside',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.removed();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':grabbable',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.grabbable();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':ungrabbable',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.grabbable();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':animated',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.animated();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':unanimated',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.animated();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':parent',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isParent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':childless',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isChildless();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':child',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isChild();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':orphan',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isOrphan();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':nonorphan',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isChild();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':compound',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">return ele.isParent();</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return ele.source().isParent() || ele.target().isParent();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':loop',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isLoop();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':simple',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isSimple();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':active',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.active();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':inactive',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.active();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':backgrounding',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.backgrounding();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">selector: ':nonbackgrounding',</span><span class="s3">\n  </span><span class="s1">matches: function matches(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.backgrounding();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}].sort(function (a, b) {</span><span class="s3">\n  </span><span class="s1">// n.b. selectors that are starting substrings of others must have the longer ones first</span><span class="s3">\n  </span><span class="s1">return descending(a.selector, b.selector);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var lookup = function () {</span><span class="s3">\n  </span><span class="s1">var selToFn = {};</span><span class="s3">\n  </span><span class="s1">var s;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; stateSelectors.length; i++) {</span><span class="s3">\n    </span><span class="s1">s = stateSelectors[i];</span><span class="s3">\n    </span><span class="s1">selToFn[s.selector] = s.matches;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return selToFn;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">var stateSelectorMatches = function stateSelectorMatches(sel, ele) {</span><span class="s3">\n  </span><span class="s1">return lookup[sel](ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var stateSelectorRegex = '(' + stateSelectors.map(function (s) {</span><span class="s3">\n  </span><span class="s1">return s.selector;</span><span class="s3">\n</span><span class="s1">}).join('|') + ')';</span><span class="s3">\n\n</span><span class="s1">// when a token like a variable has escaped meta characters, we need to clean the backslashes out</span><span class="s3">\n</span><span class="s1">// so that values get compared properly in Selector.filter()</span><span class="s3">\n</span><span class="s1">var cleanMetaChars = function cleanMetaChars(str) {</span><span class="s3">\n  </span><span class="s1">return str.replace(new RegExp('</span><span class="s3">\\\\\\\\</span><span class="s1">(' + tokens.metaChar + ')', 'g'), function (match, $1) {</span><span class="s3">\n    </span><span class="s1">return $1;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {</span><span class="s3">\n  </span><span class="s1">selector[selector.length - 1] = replacementQuery;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// NOTE: add new expression syntax here to have it recognised by the parser;</span><span class="s3">\n</span><span class="s1">// - a query contains all adjacent (i.e. no separator in between) expressions;</span><span class="s3">\n</span><span class="s1">// - the current query is stored in selector[i]</span><span class="s3">\n</span><span class="s1">// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward</span><span class="s3">\n</span><span class="s1">var exprs = [{</span><span class="s3">\n  </span><span class="s1">name: 'group',</span><span class="s3">\n  </span><span class="s1">// just used for identifying when debugging</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '(' + tokens.group + ')',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref) {</span><span class="s3">\n    </span><span class="s1">var _ref2 = _slicedToArray(_ref, 1),</span><span class="s3">\n      </span><span class="s1">group = _ref2[0];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.GROUP,</span><span class="s3">\n      </span><span class="s1">value: group === '*' ? group : group + 's'</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'state',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: stateSelectorRegex,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref3) {</span><span class="s3">\n    </span><span class="s1">var _ref4 = _slicedToArray(_ref3, 1),</span><span class="s3">\n      </span><span class="s1">state = _ref4[0];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.STATE,</span><span class="s3">\n      </span><span class="s1">value: state</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'id',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '</span><span class="s3">\\\\</span><span class="s1">#(' + tokens.id + ')',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref5) {</span><span class="s3">\n    </span><span class="s1">var _ref6 = _slicedToArray(_ref5, 1),</span><span class="s3">\n      </span><span class="s1">id = _ref6[0];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.ID,</span><span class="s3">\n      </span><span class="s1">value: cleanMetaChars(id)</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'className',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '</span><span class="s3">\\\\</span><span class="s1">.(' + tokens.className + ')',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref7) {</span><span class="s3">\n    </span><span class="s1">var _ref8 = _slicedToArray(_ref7, 1),</span><span class="s3">\n      </span><span class="s1">className = _ref8[0];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.CLASS,</span><span class="s3">\n      </span><span class="s1">value: cleanMetaChars(className)</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'dataExists',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.variable + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">]',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref9) {</span><span class="s3">\n    </span><span class="s1">var _ref10 = _slicedToArray(_ref9, 1),</span><span class="s3">\n      </span><span class="s1">variable = _ref10[0];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.DATA_EXIST,</span><span class="s3">\n      </span><span class="s1">field: cleanMetaChars(variable)</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'dataCompare',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.variable + ')</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.comparatorOp + ')</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.value + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">]',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref11) {</span><span class="s3">\n    </span><span class="s1">var _ref12 = _slicedToArray(_ref11, 3),</span><span class="s3">\n      </span><span class="s1">variable = _ref12[0],</span><span class="s3">\n      </span><span class="s1">comparatorOp = _ref12[1],</span><span class="s3">\n      </span><span class="s1">value = _ref12[2];</span><span class="s3">\n    </span><span class="s1">var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;</span><span class="s3">\n    </span><span class="s1">if (valueIsString) {</span><span class="s3">\n      </span><span class="s1">value = value.substring(1, value.length - 1);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">value = parseFloat(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.DATA_COMPARE,</span><span class="s3">\n      </span><span class="s1">field: cleanMetaChars(variable),</span><span class="s3">\n      </span><span class="s1">operator: comparatorOp,</span><span class="s3">\n      </span><span class="s1">value: value</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'dataBool',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.boolOp + ')</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.variable + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">]',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref13) {</span><span class="s3">\n    </span><span class="s1">var _ref14 = _slicedToArray(_ref13, 2),</span><span class="s3">\n      </span><span class="s1">boolOp = _ref14[0],</span><span class="s3">\n      </span><span class="s1">variable = _ref14[1];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.DATA_BOOL,</span><span class="s3">\n      </span><span class="s1">field: cleanMetaChars(variable),</span><span class="s3">\n      </span><span class="s1">operator: boolOp</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'metaCompare',</span><span class="s3">\n  </span><span class="s1">query: true,</span><span class="s3">\n  </span><span class="s1">regex: '</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.meta + ')</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.comparatorOp + ')</span><span class="s3">\\\\</span><span class="s1">s*(' + tokens.number + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">]',</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query, _ref15) {</span><span class="s3">\n    </span><span class="s1">var _ref16 = _slicedToArray(_ref15, 3),</span><span class="s3">\n      </span><span class="s1">meta = _ref16[0],</span><span class="s3">\n      </span><span class="s1">comparatorOp = _ref16[1],</span><span class="s3">\n      </span><span class="s1">number = _ref16[2];</span><span class="s3">\n    </span><span class="s1">query.checks.push({</span><span class="s3">\n      </span><span class="s1">type: Type.META_COMPARE,</span><span class="s3">\n      </span><span class="s1">field: cleanMetaChars(meta),</span><span class="s3">\n      </span><span class="s1">operator: comparatorOp,</span><span class="s3">\n      </span><span class="s1">value: parseFloat(number)</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'nextQuery',</span><span class="s3">\n  </span><span class="s1">separator: true,</span><span class="s3">\n  </span><span class="s1">regex: tokens.separator,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query) {</span><span class="s3">\n    </span><span class="s1">var currentSubject = selector.currentSubject;</span><span class="s3">\n    </span><span class="s1">var edgeCount = selector.edgeCount;</span><span class="s3">\n    </span><span class="s1">var compoundCount = selector.compoundCount;</span><span class="s3">\n    </span><span class="s1">var lastQ = selector[selector.length - 1];</span><span class="s3">\n    </span><span class="s1">if (currentSubject != null) {</span><span class="s3">\n      </span><span class="s1">lastQ.subject = currentSubject;</span><span class="s3">\n      </span><span class="s1">selector.currentSubject = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lastQ.edgeCount = edgeCount;</span><span class="s3">\n    </span><span class="s1">lastQ.compoundCount = compoundCount;</span><span class="s3">\n    </span><span class="s1">selector.edgeCount = 0;</span><span class="s3">\n    </span><span class="s1">selector.compoundCount = 0;</span><span class="s3">\n\n    </span><span class="s1">// go on to next query</span><span class="s3">\n    </span><span class="s1">var nextQuery = selector[selector.length++] = newQuery();</span><span class="s3">\n    </span><span class="s1">return nextQuery; // this is the new query to be filled by the following exprs</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'directedEdge',</span><span class="s3">\n  </span><span class="s1">separator: true,</span><span class="s3">\n  </span><span class="s1">regex: tokens.directedEdge,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query) {</span><span class="s3">\n    </span><span class="s1">if (selector.currentSubject == null) {</span><span class="s3">\n      </span><span class="s1">// undirected edge</span><span class="s3">\n      </span><span class="s1">var edgeQuery = newQuery();</span><span class="s3">\n      </span><span class="s1">var source = query;</span><span class="s3">\n      </span><span class="s1">var target = newQuery();</span><span class="s3">\n      </span><span class="s1">edgeQuery.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.DIRECTED_EDGE,</span><span class="s3">\n        </span><span class="s1">source: source,</span><span class="s3">\n        </span><span class="s1">target: target</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// the query in the selector should be the edge rather than the source</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, query, edgeQuery);</span><span class="s3">\n      </span><span class="s1">selector.edgeCount++;</span><span class="s3">\n\n      </span><span class="s1">// we're now populating the target query with expressions that follow</span><span class="s3">\n      </span><span class="s1">return target;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// source/target</span><span class="s3">\n      </span><span class="s1">var srcTgtQ = newQuery();</span><span class="s3">\n      </span><span class="s1">var _source = query;</span><span class="s3">\n      </span><span class="s1">var _target = newQuery();</span><span class="s3">\n      </span><span class="s1">srcTgtQ.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.NODE_SOURCE,</span><span class="s3">\n        </span><span class="s1">source: _source,</span><span class="s3">\n        </span><span class="s1">target: _target</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// the query in the selector should be the neighbourhood rather than the node</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, query, srcTgtQ);</span><span class="s3">\n      </span><span class="s1">selector.edgeCount++;</span><span class="s3">\n      </span><span class="s1">return _target; // now populating the target with the following expressions</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'undirectedEdge',</span><span class="s3">\n  </span><span class="s1">separator: true,</span><span class="s3">\n  </span><span class="s1">regex: tokens.undirectedEdge,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query) {</span><span class="s3">\n    </span><span class="s1">if (selector.currentSubject == null) {</span><span class="s3">\n      </span><span class="s1">// undirected edge</span><span class="s3">\n      </span><span class="s1">var edgeQuery = newQuery();</span><span class="s3">\n      </span><span class="s1">var source = query;</span><span class="s3">\n      </span><span class="s1">var target = newQuery();</span><span class="s3">\n      </span><span class="s1">edgeQuery.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.UNDIRECTED_EDGE,</span><span class="s3">\n        </span><span class="s1">nodes: [source, target]</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// the query in the selector should be the edge rather than the source</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, query, edgeQuery);</span><span class="s3">\n      </span><span class="s1">selector.edgeCount++;</span><span class="s3">\n\n      </span><span class="s1">// we're now populating the target query with expressions that follow</span><span class="s3">\n      </span><span class="s1">return target;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// neighbourhood</span><span class="s3">\n      </span><span class="s1">var nhoodQ = newQuery();</span><span class="s3">\n      </span><span class="s1">var node = query;</span><span class="s3">\n      </span><span class="s1">var neighbor = newQuery();</span><span class="s3">\n      </span><span class="s1">nhoodQ.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.NODE_NEIGHBOR,</span><span class="s3">\n        </span><span class="s1">node: node,</span><span class="s3">\n        </span><span class="s1">neighbor: neighbor</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// the query in the selector should be the neighbourhood rather than the node</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, query, nhoodQ);</span><span class="s3">\n      </span><span class="s1">return neighbor; // now populating the neighbor with following expressions</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'child',</span><span class="s3">\n  </span><span class="s1">separator: true,</span><span class="s3">\n  </span><span class="s1">regex: tokens.child,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query) {</span><span class="s3">\n    </span><span class="s1">if (selector.currentSubject == null) {</span><span class="s3">\n      </span><span class="s1">// default: child query</span><span class="s3">\n      </span><span class="s1">var parentChildQuery = newQuery();</span><span class="s3">\n      </span><span class="s1">var child = newQuery();</span><span class="s3">\n      </span><span class="s1">var parent = selector[selector.length - 1];</span><span class="s3">\n      </span><span class="s1">parentChildQuery.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.CHILD,</span><span class="s3">\n        </span><span class="s1">parent: parent,</span><span class="s3">\n        </span><span class="s1">child: child</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// the query in the selector should be the '&gt;' itself</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, query, parentChildQuery);</span><span class="s3">\n      </span><span class="s1">selector.compoundCount++;</span><span class="s3">\n\n      </span><span class="s1">// we're now populating the child query with expressions that follow</span><span class="s3">\n      </span><span class="s1">return child;</span><span class="s3">\n    </span><span class="s1">} else if (selector.currentSubject === query) {</span><span class="s3">\n      </span><span class="s1">// compound split query</span><span class="s3">\n      </span><span class="s1">var compound = newQuery();</span><span class="s3">\n      </span><span class="s1">var left = selector[selector.length - 1];</span><span class="s3">\n      </span><span class="s1">var right = newQuery();</span><span class="s3">\n      </span><span class="s1">var subject = newQuery();</span><span class="s3">\n      </span><span class="s1">var _child = newQuery();</span><span class="s3">\n      </span><span class="s1">var _parent = newQuery();</span><span class="s3">\n\n      </span><span class="s1">// set up the root compound q</span><span class="s3">\n      </span><span class="s1">compound.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.COMPOUND_SPLIT,</span><span class="s3">\n        </span><span class="s1">left: left,</span><span class="s3">\n        </span><span class="s1">right: right,</span><span class="s3">\n        </span><span class="s1">subject: subject</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// populate the subject and replace the q at the old spot (within left) with TRUE</span><span class="s3">\n      </span><span class="s1">subject.checks = query.checks; // take the checks from the left</span><span class="s3">\n      </span><span class="s1">query.checks = [{</span><span class="s3">\n        </span><span class="s1">type: Type.TRUE</span><span class="s3">\n      </span><span class="s1">}]; // checks under left refs the subject implicitly</span><span class="s3">\n\n      </span><span class="s1">// set up the right q</span><span class="s3">\n      </span><span class="s1">_parent.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.TRUE</span><span class="s3">\n      </span><span class="s1">}); // parent implicitly refs the subject</span><span class="s3">\n      </span><span class="s1">right.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.PARENT,</span><span class="s3">\n        </span><span class="s1">// type is swapped on right side queries</span><span class="s3">\n        </span><span class="s1">parent: _parent,</span><span class="s3">\n        </span><span class="s1">child: _child // empty for now</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, left, compound);</span><span class="s3">\n\n      </span><span class="s1">// update the ref since we moved things around for `query`</span><span class="s3">\n      </span><span class="s1">selector.currentSubject = subject;</span><span class="s3">\n      </span><span class="s1">selector.compoundCount++;</span><span class="s3">\n      </span><span class="s1">return _child; // now populating the right side's child</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// parent query</span><span class="s3">\n      </span><span class="s1">// info for parent query</span><span class="s3">\n      </span><span class="s1">var _parent2 = newQuery();</span><span class="s3">\n      </span><span class="s1">var _child2 = newQuery();</span><span class="s3">\n      </span><span class="s1">var pcQChecks = [{</span><span class="s3">\n        </span><span class="s1">type: Type.PARENT,</span><span class="s3">\n        </span><span class="s1">parent: _parent2,</span><span class="s3">\n        </span><span class="s1">child: _child2</span><span class="s3">\n      </span><span class="s1">}];</span><span class="s3">\n\n      </span><span class="s1">// the parent-child query takes the place of the query previously being populated</span><span class="s3">\n      </span><span class="s1">_parent2.checks = query.checks; // the previous query contains the checks for the parent</span><span class="s3">\n      </span><span class="s1">query.checks = pcQChecks; // pc query takes over</span><span class="s3">\n\n      </span><span class="s1">selector.compoundCount++;</span><span class="s3">\n      </span><span class="s1">return _child2; // we're now populating the child</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'descendant',</span><span class="s3">\n  </span><span class="s1">separator: true,</span><span class="s3">\n  </span><span class="s1">regex: tokens.descendant,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query) {</span><span class="s3">\n    </span><span class="s1">if (selector.currentSubject == null) {</span><span class="s3">\n      </span><span class="s1">// default: descendant query</span><span class="s3">\n      </span><span class="s1">var ancChQuery = newQuery();</span><span class="s3">\n      </span><span class="s1">var descendant = newQuery();</span><span class="s3">\n      </span><span class="s1">var ancestor = selector[selector.length - 1];</span><span class="s3">\n      </span><span class="s1">ancChQuery.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.DESCENDANT,</span><span class="s3">\n        </span><span class="s1">ancestor: ancestor,</span><span class="s3">\n        </span><span class="s1">descendant: descendant</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// the query in the selector should be the '&gt;' itself</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, query, ancChQuery);</span><span class="s3">\n      </span><span class="s1">selector.compoundCount++;</span><span class="s3">\n\n      </span><span class="s1">// we're now populating the descendant query with expressions that follow</span><span class="s3">\n      </span><span class="s1">return descendant;</span><span class="s3">\n    </span><span class="s1">} else if (selector.currentSubject === query) {</span><span class="s3">\n      </span><span class="s1">// compound split query</span><span class="s3">\n      </span><span class="s1">var compound = newQuery();</span><span class="s3">\n      </span><span class="s1">var left = selector[selector.length - 1];</span><span class="s3">\n      </span><span class="s1">var right = newQuery();</span><span class="s3">\n      </span><span class="s1">var subject = newQuery();</span><span class="s3">\n      </span><span class="s1">var _descendant = newQuery();</span><span class="s3">\n      </span><span class="s1">var _ancestor = newQuery();</span><span class="s3">\n\n      </span><span class="s1">// set up the root compound q</span><span class="s3">\n      </span><span class="s1">compound.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.COMPOUND_SPLIT,</span><span class="s3">\n        </span><span class="s1">left: left,</span><span class="s3">\n        </span><span class="s1">right: right,</span><span class="s3">\n        </span><span class="s1">subject: subject</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// populate the subject and replace the q at the old spot (within left) with TRUE</span><span class="s3">\n      </span><span class="s1">subject.checks = query.checks; // take the checks from the left</span><span class="s3">\n      </span><span class="s1">query.checks = [{</span><span class="s3">\n        </span><span class="s1">type: Type.TRUE</span><span class="s3">\n      </span><span class="s1">}]; // checks under left refs the subject implicitly</span><span class="s3">\n\n      </span><span class="s1">// set up the right q</span><span class="s3">\n      </span><span class="s1">_ancestor.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.TRUE</span><span class="s3">\n      </span><span class="s1">}); // ancestor implicitly refs the subject</span><span class="s3">\n      </span><span class="s1">right.checks.push({</span><span class="s3">\n        </span><span class="s1">type: Type.ANCESTOR,</span><span class="s3">\n        </span><span class="s1">// type is swapped on right side queries</span><span class="s3">\n        </span><span class="s1">ancestor: _ancestor,</span><span class="s3">\n        </span><span class="s1">descendant: _descendant // empty for now</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">replaceLastQuery(selector, left, compound);</span><span class="s3">\n\n      </span><span class="s1">// update the ref since we moved things around for `query`</span><span class="s3">\n      </span><span class="s1">selector.currentSubject = subject;</span><span class="s3">\n      </span><span class="s1">selector.compoundCount++;</span><span class="s3">\n      </span><span class="s1">return _descendant; // now populating the right side's descendant</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// ancestor query</span><span class="s3">\n      </span><span class="s1">// info for parent query</span><span class="s3">\n      </span><span class="s1">var _ancestor2 = newQuery();</span><span class="s3">\n      </span><span class="s1">var _descendant2 = newQuery();</span><span class="s3">\n      </span><span class="s1">var adQChecks = [{</span><span class="s3">\n        </span><span class="s1">type: Type.ANCESTOR,</span><span class="s3">\n        </span><span class="s1">ancestor: _ancestor2,</span><span class="s3">\n        </span><span class="s1">descendant: _descendant2</span><span class="s3">\n      </span><span class="s1">}];</span><span class="s3">\n\n      </span><span class="s1">// the parent-child query takes the place of the query previously being populated</span><span class="s3">\n      </span><span class="s1">_ancestor2.checks = query.checks; // the previous query contains the checks for the parent</span><span class="s3">\n      </span><span class="s1">query.checks = adQChecks; // pc query takes over</span><span class="s3">\n\n      </span><span class="s1">selector.compoundCount++;</span><span class="s3">\n      </span><span class="s1">return _descendant2; // we're now populating the child</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'subject',</span><span class="s3">\n  </span><span class="s1">modifier: true,</span><span class="s3">\n  </span><span class="s1">regex: tokens.subject,</span><span class="s3">\n  </span><span class="s1">populate: function populate(selector, query) {</span><span class="s3">\n    </span><span class="s1">if (selector.currentSubject != null &amp;&amp; selector.currentSubject !== query) {</span><span class="s3">\n      </span><span class="s1">warn('Redefinition of subject in selector `' + selector.toString() + '`');</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">selector.currentSubject = query;</span><span class="s3">\n    </span><span class="s1">var topQ = selector[selector.length - 1];</span><span class="s3">\n    </span><span class="s1">var topChk = topQ.checks[0];</span><span class="s3">\n    </span><span class="s1">var topType = topChk == null ? null : topChk.type;</span><span class="s3">\n    </span><span class="s1">if (topType === Type.DIRECTED_EDGE) {</span><span class="s3">\n      </span><span class="s1">// directed edge with subject on the target</span><span class="s3">\n\n      </span><span class="s1">// change to target node check</span><span class="s3">\n      </span><span class="s1">topChk.type = Type.NODE_TARGET;</span><span class="s3">\n    </span><span class="s1">} else if (topType === Type.UNDIRECTED_EDGE) {</span><span class="s3">\n      </span><span class="s1">// undirected edge with subject on the second node</span><span class="s3">\n\n      </span><span class="s1">// change to neighbor check</span><span class="s3">\n      </span><span class="s1">topChk.type = Type.NODE_NEIGHBOR;</span><span class="s3">\n      </span><span class="s1">topChk.node = topChk.nodes[1]; // second node is subject</span><span class="s3">\n      </span><span class="s1">topChk.neighbor = topChk.nodes[0];</span><span class="s3">\n\n      </span><span class="s1">// clean up unused fields for new type</span><span class="s3">\n      </span><span class="s1">topChk.nodes = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}];</span><span class="s3">\n</span><span class="s1">exprs.forEach(function (e) {</span><span class="s3">\n  </span><span class="s1">return e.regexObj = new RegExp('^' + e.regex);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Of all the expressions, find the first match in the remaining text.</span><span class="s3">\n </span><span class="s1">* @param {string} remaining The remaining text to parse</span><span class="s3">\n </span><span class="s1">* @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var consumeExpr = function consumeExpr(remaining) {</span><span class="s3">\n  </span><span class="s1">var expr;</span><span class="s3">\n  </span><span class="s1">var match;</span><span class="s3">\n  </span><span class="s1">var name;</span><span class="s3">\n  </span><span class="s1">for (var j = 0; j &lt; exprs.length; j++) {</span><span class="s3">\n    </span><span class="s1">var e = exprs[j];</span><span class="s3">\n    </span><span class="s1">var n = e.name;</span><span class="s3">\n    </span><span class="s1">var m = remaining.match(e.regexObj);</span><span class="s3">\n    </span><span class="s1">if (m != null) {</span><span class="s3">\n      </span><span class="s1">match = m;</span><span class="s3">\n      </span><span class="s1">expr = e;</span><span class="s3">\n      </span><span class="s1">name = n;</span><span class="s3">\n      </span><span class="s1">var consumed = m[0];</span><span class="s3">\n      </span><span class="s1">remaining = remaining.substring(consumed.length);</span><span class="s3">\n      </span><span class="s1">break; // we've consumed one expr, so we can return now</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">expr: expr,</span><span class="s3">\n    </span><span class="s1">match: match,</span><span class="s3">\n    </span><span class="s1">name: name,</span><span class="s3">\n    </span><span class="s1">remaining: remaining</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Consume all the leading whitespace</span><span class="s3">\n </span><span class="s1">* @param {string} remaining The text to consume</span><span class="s3">\n </span><span class="s1">* @returns The text with the leading whitespace removed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var consumeWhitespace = function consumeWhitespace(remaining) {</span><span class="s3">\n  </span><span class="s1">var match = remaining.match(/^</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n  </span><span class="s1">if (match) {</span><span class="s3">\n    </span><span class="s1">var consumed = match[0];</span><span class="s3">\n    </span><span class="s1">remaining = remaining.substring(consumed.length);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return remaining;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse the string and store the parsed representation in the Selector.</span><span class="s3">\n </span><span class="s1">* @param {string} selector The selector string</span><span class="s3">\n </span><span class="s1">* @returns `true` if the selector was successfully parsed, `false` otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var parse = function parse(selector) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var remaining = self.inputText = selector;</span><span class="s3">\n  </span><span class="s1">var currentQuery = self[0] = newQuery();</span><span class="s3">\n  </span><span class="s1">self.length = 1;</span><span class="s3">\n  </span><span class="s1">remaining = consumeWhitespace(remaining); // get rid of leading whitespace</span><span class="s3">\n\n  </span><span class="s1">for (;;) {</span><span class="s3">\n    </span><span class="s1">var exprInfo = consumeExpr(remaining);</span><span class="s3">\n    </span><span class="s1">if (exprInfo.expr == null) {</span><span class="s3">\n      </span><span class="s1">warn('The selector `' + selector + '`is invalid');</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var args = exprInfo.match.slice(1);</span><span class="s3">\n\n      </span><span class="s1">// let the token populate the selector object in currentQuery</span><span class="s3">\n      </span><span class="s1">var ret = exprInfo.expr.populate(self, currentQuery, args);</span><span class="s3">\n      </span><span class="s1">if (ret === false) {</span><span class="s3">\n        </span><span class="s1">return false; // exit if population failed</span><span class="s3">\n      </span><span class="s1">} else if (ret != null) {</span><span class="s3">\n        </span><span class="s1">currentQuery = ret; // change the current query to be filled if the expr specifies</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remaining = exprInfo.remaining;</span><span class="s3">\n\n    </span><span class="s1">// we're done when there's nothing left to parse</span><span class="s3">\n    </span><span class="s1">if (remaining.match(/^</span><span class="s3">\\</span><span class="s1">s*$/)) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var lastQ = self[self.length - 1];</span><span class="s3">\n  </span><span class="s1">if (self.currentSubject != null) {</span><span class="s3">\n    </span><span class="s1">lastQ.subject = self.currentSubject;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">lastQ.edgeCount = self.edgeCount;</span><span class="s3">\n  </span><span class="s1">lastQ.compoundCount = self.compoundCount;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; self.length; i++) {</span><span class="s3">\n    </span><span class="s1">var q = self[i];</span><span class="s3">\n\n    </span><span class="s1">// in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations</span><span class="s3">\n    </span><span class="s1">if (q.compoundCount &gt; 0 &amp;&amp; q.edgeCount &gt; 0) {</span><span class="s3">\n      </span><span class="s1">warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (q.edgeCount &gt; 1) {</span><span class="s3">\n      </span><span class="s1">warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else if (q.edgeCount === 1) {</span><span class="s3">\n      </span><span class="s1">warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true; // success</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the selector represented as a string.  This value uses default formatting,</span><span class="s3">\n </span><span class="s1">* so things like spacing may differ from the input text passed to the constructor.</span><span class="s3">\n </span><span class="s1">* @returns {string} The selector string</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var toString = function toString() {</span><span class="s3">\n  </span><span class="s1">if (this.toStringCache != null) {</span><span class="s3">\n    </span><span class="s1">return this.toStringCache;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var clean = function clean(obj) {</span><span class="s3">\n    </span><span class="s1">if (obj == null) {</span><span class="s3">\n      </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var cleanVal = function cleanVal(val) {</span><span class="s3">\n    </span><span class="s1">if (string(val)) {</span><span class="s3">\n      </span><span class="s1">return '</span><span class="s3">\&quot;</span><span class="s1">' + val + '</span><span class="s3">\&quot;</span><span class="s1">';</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return clean(val);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var space = function space(val) {</span><span class="s3">\n    </span><span class="s1">return ' ' + val + ' ';</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var checkToString = function checkToString(check, subject) {</span><span class="s3">\n    </span><span class="s1">var type = check.type,</span><span class="s3">\n      </span><span class="s1">value = check.value;</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case Type.GROUP:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var group = clean(value);</span><span class="s3">\n          </span><span class="s1">return group.substring(0, group.length - 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.DATA_COMPARE:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var field = check.field,</span><span class="s3">\n            </span><span class="s1">operator = check.operator;</span><span class="s3">\n          </span><span class="s1">return '[' + field + space(clean(operator)) + cleanVal(value) + ']';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.DATA_BOOL:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var _operator = check.operator,</span><span class="s3">\n            </span><span class="s1">_field = check.field;</span><span class="s3">\n          </span><span class="s1">return '[' + clean(_operator) + _field + ']';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.DATA_EXIST:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var _field2 = check.field;</span><span class="s3">\n          </span><span class="s1">return '[' + _field2 + ']';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.META_COMPARE:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var _operator2 = check.operator,</span><span class="s3">\n            </span><span class="s1">_field3 = check.field;</span><span class="s3">\n          </span><span class="s1">return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.STATE:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.ID:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">return '#' + value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.CLASS:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">return '.' + value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.PARENT:</span><span class="s3">\n      </span><span class="s1">case Type.CHILD:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">return queryToString(check.parent, subject) + space('&gt;') + queryToString(check.child, subject);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.ANCESTOR:</span><span class="s3">\n      </span><span class="s1">case Type.DESCENDANT:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.COMPOUND_SPLIT:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var lhs = queryToString(check.left, subject);</span><span class="s3">\n          </span><span class="s1">var sub = queryToString(check.subject, subject);</span><span class="s3">\n          </span><span class="s1">var rhs = queryToString(check.right, subject);</span><span class="s3">\n          </span><span class="s1">return lhs + (lhs.length &gt; 0 ? ' ' : '') + sub + rhs;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Type.TRUE:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">return '';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var queryToString = function queryToString(query, subject) {</span><span class="s3">\n    </span><span class="s1">return query.checks.reduce(function (str, chk, i) {</span><span class="s3">\n      </span><span class="s1">return str + (subject === query &amp;&amp; i === 0 ? '$' : '') + checkToString(chk, subject);</span><span class="s3">\n    </span><span class="s1">}, '');</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var str = '';</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var query = this[i];</span><span class="s3">\n    </span><span class="s1">str += queryToString(query, query.subject);</span><span class="s3">\n    </span><span class="s1">if (this.length &gt; 1 &amp;&amp; i &lt; this.length - 1) {</span><span class="s3">\n      </span><span class="s1">str += ', ';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.toStringCache = str;</span><span class="s3">\n  </span><span class="s1">return str;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var parse$1 = {</span><span class="s3">\n  </span><span class="s1">parse: parse,</span><span class="s3">\n  </span><span class="s1">toString: toString</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var valCmp = function valCmp(fieldVal, operator, value) {</span><span class="s3">\n  </span><span class="s1">var matches;</span><span class="s3">\n  </span><span class="s1">var isFieldStr = string(fieldVal);</span><span class="s3">\n  </span><span class="s1">var isFieldNum = number$1(fieldVal);</span><span class="s3">\n  </span><span class="s1">var isValStr = string(value);</span><span class="s3">\n  </span><span class="s1">var fieldStr, valStr;</span><span class="s3">\n  </span><span class="s1">var caseInsensitive = false;</span><span class="s3">\n  </span><span class="s1">var notExpr = false;</span><span class="s3">\n  </span><span class="s1">var isIneqCmp = false;</span><span class="s3">\n  </span><span class="s1">if (operator.indexOf('!') &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">operator = operator.replace('!', '');</span><span class="s3">\n    </span><span class="s1">notExpr = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (operator.indexOf('@') &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">operator = operator.replace('@', '');</span><span class="s3">\n    </span><span class="s1">caseInsensitive = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isFieldStr || isValStr || caseInsensitive) {</span><span class="s3">\n    </span><span class="s1">fieldStr = !isFieldStr &amp;&amp; !isFieldNum ? '' : '' + fieldVal;</span><span class="s3">\n    </span><span class="s1">valStr = '' + value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if we're doing a case insensitive comparison, then we're using a STRING comparison</span><span class="s3">\n  </span><span class="s1">// even if we're comparing numbers</span><span class="s3">\n  </span><span class="s1">if (caseInsensitive) {</span><span class="s3">\n    </span><span class="s1">fieldVal = fieldStr = fieldStr.toLowerCase();</span><span class="s3">\n    </span><span class="s1">value = valStr = valStr.toLowerCase();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">switch (operator) {</span><span class="s3">\n    </span><span class="s1">case '*=':</span><span class="s3">\n      </span><span class="s1">matches = fieldStr.indexOf(valStr) &gt;= 0;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '$=':</span><span class="s3">\n      </span><span class="s1">matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) &gt;= 0;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '^=':</span><span class="s3">\n      </span><span class="s1">matches = fieldStr.indexOf(valStr) === 0;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '=':</span><span class="s3">\n      </span><span class="s1">matches = fieldVal === value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '&gt;':</span><span class="s3">\n      </span><span class="s1">isIneqCmp = true;</span><span class="s3">\n      </span><span class="s1">matches = fieldVal &gt; value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '&gt;=':</span><span class="s3">\n      </span><span class="s1">isIneqCmp = true;</span><span class="s3">\n      </span><span class="s1">matches = fieldVal &gt;= value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '&lt;':</span><span class="s3">\n      </span><span class="s1">isIneqCmp = true;</span><span class="s3">\n      </span><span class="s1">matches = fieldVal &lt; value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case '&lt;=':</span><span class="s3">\n      </span><span class="s1">isIneqCmp = true;</span><span class="s3">\n      </span><span class="s1">matches = fieldVal &lt;= value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">matches = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// apply the not op, but null vals for inequalities should always stay non-matching</span><span class="s3">\n  </span><span class="s1">if (notExpr &amp;&amp; (fieldVal != null || !isIneqCmp)) {</span><span class="s3">\n    </span><span class="s1">matches = !matches;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return matches;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var boolCmp = function boolCmp(fieldVal, operator) {</span><span class="s3">\n  </span><span class="s1">switch (operator) {</span><span class="s3">\n    </span><span class="s1">case '?':</span><span class="s3">\n      </span><span class="s1">return fieldVal ? true : false;</span><span class="s3">\n    </span><span class="s1">case '!':</span><span class="s3">\n      </span><span class="s1">return fieldVal ? false : true;</span><span class="s3">\n    </span><span class="s1">case '^':</span><span class="s3">\n      </span><span class="s1">return fieldVal === undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var existCmp = function existCmp(fieldVal) {</span><span class="s3">\n  </span><span class="s1">return fieldVal !== undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var data$1 = function data(ele, field) {</span><span class="s3">\n  </span><span class="s1">return ele.data(field);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var meta = function meta(ele, field) {</span><span class="s3">\n  </span><span class="s1">return ele[field]();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/** A lookup of `match(check, ele)` functions by `Type` int */</span><span class="s3">\n</span><span class="s1">var match = [];</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns whether the query matches for the element</span><span class="s3">\n </span><span class="s1">* @param query The `{ type, value, ... }` query object</span><span class="s3">\n </span><span class="s1">* @param ele The element to compare against</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var matches$1 = function matches(query, ele) {</span><span class="s3">\n  </span><span class="s1">return query.checks.every(function (chk) {</span><span class="s3">\n    </span><span class="s1">return match[chk.type](chk, ele);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.GROUP] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var group = check.value;</span><span class="s3">\n  </span><span class="s1">return group === '*' || group === ele.group();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.STATE] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var stateSelector = check.value;</span><span class="s3">\n  </span><span class="s1">return stateSelectorMatches(stateSelector, ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.ID] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var id = check.value;</span><span class="s3">\n  </span><span class="s1">return ele.id() === id;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.CLASS] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var cls = check.value;</span><span class="s3">\n  </span><span class="s1">return ele.hasClass(cls);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.META_COMPARE] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var field = check.field,</span><span class="s3">\n    </span><span class="s1">operator = check.operator,</span><span class="s3">\n    </span><span class="s1">value = check.value;</span><span class="s3">\n  </span><span class="s1">return valCmp(meta(ele, field), operator, value);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.DATA_COMPARE] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var field = check.field,</span><span class="s3">\n    </span><span class="s1">operator = check.operator,</span><span class="s3">\n    </span><span class="s1">value = check.value;</span><span class="s3">\n  </span><span class="s1">return valCmp(data$1(ele, field), operator, value);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.DATA_BOOL] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var field = check.field,</span><span class="s3">\n    </span><span class="s1">operator = check.operator;</span><span class="s3">\n  </span><span class="s1">return boolCmp(data$1(ele, field), operator);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.DATA_EXIST] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var field = check.field;</span><span class="s3">\n    </span><span class="s1">check.operator;</span><span class="s3">\n  </span><span class="s1">return existCmp(data$1(ele, field));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.UNDIRECTED_EDGE] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var qA = check.nodes[0];</span><span class="s3">\n  </span><span class="s1">var qB = check.nodes[1];</span><span class="s3">\n  </span><span class="s1">var src = ele.source();</span><span class="s3">\n  </span><span class="s1">var tgt = ele.target();</span><span class="s3">\n  </span><span class="s1">return matches$1(qA, src) &amp;&amp; matches$1(qB, tgt) || matches$1(qB, src) &amp;&amp; matches$1(qA, tgt);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.NODE_NEIGHBOR] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.node, ele) &amp;&amp; ele.neighborhood().some(function (n) {</span><span class="s3">\n    </span><span class="s1">return n.isNode() &amp;&amp; matches$1(check.neighbor, n);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.DIRECTED_EDGE] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.source, ele.source()) &amp;&amp; matches$1(check.target, ele.target());</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.NODE_SOURCE] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.source, ele) &amp;&amp; ele.outgoers().some(function (n) {</span><span class="s3">\n    </span><span class="s1">return n.isNode() &amp;&amp; matches$1(check.target, n);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.NODE_TARGET] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.target, ele) &amp;&amp; ele.incomers().some(function (n) {</span><span class="s3">\n    </span><span class="s1">return n.isNode() &amp;&amp; matches$1(check.source, n);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.CHILD] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.child, ele) &amp;&amp; matches$1(check.parent, ele.parent());</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.PARENT] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.parent, ele) &amp;&amp; ele.children().some(function (c) {</span><span class="s3">\n    </span><span class="s1">return matches$1(check.child, c);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.DESCENDANT] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.descendant, ele) &amp;&amp; ele.ancestors().some(function (a) {</span><span class="s3">\n    </span><span class="s1">return matches$1(check.ancestor, a);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.ANCESTOR] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.ancestor, ele) &amp;&amp; ele.descendants().some(function (d) {</span><span class="s3">\n    </span><span class="s1">return matches$1(check.descendant, d);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.COMPOUND_SPLIT] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">return matches$1(check.subject, ele) &amp;&amp; matches$1(check.left, ele) &amp;&amp; matches$1(check.right, ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.TRUE] = function () {</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.COLLECTION] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var collection = check.value;</span><span class="s3">\n  </span><span class="s1">return collection.has(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">match[Type.FILTER] = function (check, ele) {</span><span class="s3">\n  </span><span class="s1">var filter = check.value;</span><span class="s3">\n  </span><span class="s1">return filter(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// filter an existing collection</span><span class="s3">\n</span><span class="s1">var filter = function filter(collection) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n\n  </span><span class="s1">// for 1 id #foo queries, just get the element</span><span class="s3">\n  </span><span class="s1">if (self.length === 1 &amp;&amp; self[0].checks.length === 1 &amp;&amp; self[0].checks[0].type === Type.ID) {</span><span class="s3">\n    </span><span class="s1">return collection.getElementById(self[0].checks[0].value).collection();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var selectorFunction = function selectorFunction(element) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; self.length; j++) {</span><span class="s3">\n      </span><span class="s1">var query = self[j];</span><span class="s3">\n      </span><span class="s1">if (matches$1(query, element)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (self.text() == null) {</span><span class="s3">\n    </span><span class="s1">selectorFunction = function selectorFunction() {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return collection.filter(selectorFunction);</span><span class="s3">\n</span><span class="s1">}; // filter</span><span class="s3">\n\n</span><span class="s1">// does selector match a single element?</span><span class="s3">\n</span><span class="s1">var matches = function matches(ele) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">for (var j = 0; j &lt; self.length; j++) {</span><span class="s3">\n    </span><span class="s1">var query = self[j];</span><span class="s3">\n    </span><span class="s1">if (matches$1(query, ele)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}; // matches</span><span class="s3">\n\n</span><span class="s1">var matching = {</span><span class="s3">\n  </span><span class="s1">matches: matches,</span><span class="s3">\n  </span><span class="s1">filter: filter</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var Selector = function Selector(selector) {</span><span class="s3">\n  </span><span class="s1">this.inputText = selector;</span><span class="s3">\n  </span><span class="s1">this.currentSubject = null;</span><span class="s3">\n  </span><span class="s1">this.compoundCount = 0;</span><span class="s3">\n  </span><span class="s1">this.edgeCount = 0;</span><span class="s3">\n  </span><span class="s1">this.length = 0;</span><span class="s3">\n  </span><span class="s1">if (selector == null || string(selector) &amp;&amp; selector.match(/^</span><span class="s3">\\</span><span class="s1">s*$/)) ; else if (elementOrCollection(selector)) {</span><span class="s3">\n    </span><span class="s1">this.addQuery({</span><span class="s3">\n      </span><span class="s1">checks: [{</span><span class="s3">\n        </span><span class="s1">type: Type.COLLECTION,</span><span class="s3">\n        </span><span class="s1">value: selector.collection()</span><span class="s3">\n      </span><span class="s1">}]</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (fn$6(selector)) {</span><span class="s3">\n    </span><span class="s1">this.addQuery({</span><span class="s3">\n      </span><span class="s1">checks: [{</span><span class="s3">\n        </span><span class="s1">type: Type.FILTER,</span><span class="s3">\n        </span><span class="s1">value: selector</span><span class="s3">\n      </span><span class="s1">}]</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (string(selector)) {</span><span class="s3">\n    </span><span class="s1">if (!this.parse(selector)) {</span><span class="s3">\n      </span><span class="s1">this.invalid = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">error('A selector must be created from a string; found ');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var selfn = Selector.prototype;</span><span class="s3">\n</span><span class="s1">[parse$1, matching].forEach(function (p) {</span><span class="s3">\n  </span><span class="s1">return extend(selfn, p);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">selfn.text = function () {</span><span class="s3">\n  </span><span class="s1">return this.inputText;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">selfn.size = function () {</span><span class="s3">\n  </span><span class="s1">return this.length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">selfn.eq = function (i) {</span><span class="s3">\n  </span><span class="s1">return this[i];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">selfn.sameText = function (otherSel) {</span><span class="s3">\n  </span><span class="s1">return !this.invalid &amp;&amp; !otherSel.invalid &amp;&amp; this.text() === otherSel.text();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">selfn.addQuery = function (q) {</span><span class="s3">\n  </span><span class="s1">this[this.length++] = q;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">selfn.selector = selfn.toString;</span><span class="s3">\n\n</span><span class="s1">var elesfn$g = {</span><span class="s3">\n  </span><span class="s1">allAre: function allAre(selector) {</span><span class="s3">\n    </span><span class="s1">var selObj = new Selector(selector);</span><span class="s3">\n    </span><span class="s1">return this.every(function (ele) {</span><span class="s3">\n      </span><span class="s1">return selObj.matches(ele);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">is: function is(selector) {</span><span class="s3">\n    </span><span class="s1">var selObj = new Selector(selector);</span><span class="s3">\n    </span><span class="s1">return this.some(function (ele) {</span><span class="s3">\n      </span><span class="s1">return selObj.matches(ele);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">some: function some(fn, thisArg) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);</span><span class="s3">\n      </span><span class="s1">if (ret) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">every: function every(fn, thisArg) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);</span><span class="s3">\n      </span><span class="s1">if (!ret) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">same: function same(collection) {</span><span class="s3">\n    </span><span class="s1">// cheap collection ref check</span><span class="s3">\n    </span><span class="s1">if (this === collection) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">collection = this.cy().collection(collection);</span><span class="s3">\n    </span><span class="s1">var thisLength = this.length;</span><span class="s3">\n    </span><span class="s1">var collectionLength = collection.length;</span><span class="s3">\n\n    </span><span class="s1">// cheap length check</span><span class="s3">\n    </span><span class="s1">if (thisLength !== collectionLength) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// cheap element ref check</span><span class="s3">\n    </span><span class="s1">if (thisLength === 1) {</span><span class="s3">\n      </span><span class="s1">return this[0] === collection[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.every(function (ele) {</span><span class="s3">\n      </span><span class="s1">return collection.hasElementWithId(ele.id());</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">anySame: function anySame(collection) {</span><span class="s3">\n    </span><span class="s1">collection = this.cy().collection(collection);</span><span class="s3">\n    </span><span class="s1">return this.some(function (ele) {</span><span class="s3">\n      </span><span class="s1">return collection.hasElementWithId(ele.id());</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">allAreNeighbors: function allAreNeighbors(collection) {</span><span class="s3">\n    </span><span class="s1">collection = this.cy().collection(collection);</span><span class="s3">\n    </span><span class="s1">var nhood = this.neighborhood();</span><span class="s3">\n    </span><span class="s1">return collection.every(function (ele) {</span><span class="s3">\n      </span><span class="s1">return nhood.hasElementWithId(ele.id());</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">contains: function contains(collection) {</span><span class="s3">\n    </span><span class="s1">collection = this.cy().collection(collection);</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">return collection.every(function (ele) {</span><span class="s3">\n      </span><span class="s1">return self.hasElementWithId(ele.id());</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;</span><span class="s3">\n</span><span class="s1">elesfn$g.has = elesfn$g.contains;</span><span class="s3">\n</span><span class="s1">elesfn$g.equal = elesfn$g.equals = elesfn$g.same;</span><span class="s3">\n\n</span><span class="s1">var cache = function cache(fn, name) {</span><span class="s3">\n  </span><span class="s1">return function traversalCache(arg1, arg2, arg3, arg4) {</span><span class="s3">\n    </span><span class="s1">var selectorOrEles = arg1;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var key;</span><span class="s3">\n    </span><span class="s1">if (selectorOrEles == null) {</span><span class="s3">\n      </span><span class="s1">key = '';</span><span class="s3">\n    </span><span class="s1">} else if (elementOrCollection(selectorOrEles) &amp;&amp; selectorOrEles.length === 1) {</span><span class="s3">\n      </span><span class="s1">key = selectorOrEles.id();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (eles.length === 1 &amp;&amp; key) {</span><span class="s3">\n      </span><span class="s1">var _p = eles[0]._private;</span><span class="s3">\n      </span><span class="s1">var tch = _p.traversalCache = _p.traversalCache || {};</span><span class="s3">\n      </span><span class="s1">var ch = tch[name] = tch[name] || [];</span><span class="s3">\n      </span><span class="s1">var hash = hashString(key);</span><span class="s3">\n      </span><span class="s1">var cacheHit = ch[hash];</span><span class="s3">\n      </span><span class="s1">if (cacheHit) {</span><span class="s3">\n        </span><span class="s1">return cacheHit;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return fn.call(eles, arg1, arg2, arg3, arg4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var elesfn$f = {</span><span class="s3">\n  </span><span class="s1">parent: function parent(selector) {</span><span class="s3">\n    </span><span class="s1">var parents = [];</span><span class="s3">\n\n    </span><span class="s1">// optimisation for single ele call</span><span class="s3">\n    </span><span class="s1">if (this.length === 1) {</span><span class="s3">\n      </span><span class="s1">var parent = this[0]._private.parent;</span><span class="s3">\n      </span><span class="s1">if (parent) {</span><span class="s3">\n        </span><span class="s1">return parent;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">var _parent = ele._private.parent;</span><span class="s3">\n      </span><span class="s1">if (_parent) {</span><span class="s3">\n        </span><span class="s1">parents.push(_parent);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(parents, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">parents: function parents(selector) {</span><span class="s3">\n    </span><span class="s1">var parents = [];</span><span class="s3">\n    </span><span class="s1">var eles = this.parent();</span><span class="s3">\n    </span><span class="s1">while (eles.nonempty()) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = eles[i];</span><span class="s3">\n        </span><span class="s1">parents.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">eles = eles.parent();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(parents, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">commonAncestors: function commonAncestors(selector) {</span><span class="s3">\n    </span><span class="s1">var ancestors;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">var parents = ele.parents();</span><span class="s3">\n      </span><span class="s1">ancestors = ancestors || parents;</span><span class="s3">\n      </span><span class="s1">ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ancestors.filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">orphans: function orphans(selector) {</span><span class="s3">\n    </span><span class="s1">return this.stdFilter(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isOrphan();</span><span class="s3">\n    </span><span class="s1">}).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">nonorphans: function nonorphans(selector) {</span><span class="s3">\n    </span><span class="s1">return this.stdFilter(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isChild();</span><span class="s3">\n    </span><span class="s1">}).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">children: cache(function (selector) {</span><span class="s3">\n    </span><span class="s1">var children = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">var eleChildren = ele._private.children;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; eleChildren.length; j++) {</span><span class="s3">\n        </span><span class="s1">children.push(eleChildren[j]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(children, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">}, 'children'),</span><span class="s3">\n  </span><span class="s1">siblings: function siblings(selector) {</span><span class="s3">\n    </span><span class="s1">return this.parent().children().not(this).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isParent: function isParent() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isNode() &amp;&amp; ele._private.children.length !== 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isChildless: function isChildless() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isNode() &amp;&amp; ele._private.children.length === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isChild: function isChild() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isNode() &amp;&amp; ele._private.parent != null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isOrphan: function isOrphan() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isNode() &amp;&amp; ele._private.parent == null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">descendants: function descendants(selector) {</span><span class="s3">\n    </span><span class="s1">var elements = [];</span><span class="s3">\n    </span><span class="s1">function add(eles) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = eles[i];</span><span class="s3">\n        </span><span class="s1">elements.push(ele);</span><span class="s3">\n        </span><span class="s1">if (ele.children().nonempty()) {</span><span class="s3">\n          </span><span class="s1">add(ele.children());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">add(this.children());</span><span class="s3">\n    </span><span class="s1">return this.spawn(elements, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function forEachCompound(eles, fn, includeSelf, recursiveStep) {</span><span class="s3">\n  </span><span class="s1">var q = [];</span><span class="s3">\n  </span><span class="s1">var did = new Set$1();</span><span class="s3">\n  </span><span class="s1">var cy = eles.cy();</span><span class="s3">\n  </span><span class="s1">var hasCompounds = cy.hasCompoundNodes();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">if (includeSelf) {</span><span class="s3">\n      </span><span class="s1">q.push(ele);</span><span class="s3">\n    </span><span class="s1">} else if (hasCompounds) {</span><span class="s3">\n      </span><span class="s1">recursiveStep(q, did, ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (q.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var _ele = q.shift();</span><span class="s3">\n    </span><span class="s1">fn(_ele);</span><span class="s3">\n    </span><span class="s1">did.add(_ele.id());</span><span class="s3">\n    </span><span class="s1">if (hasCompounds) {</span><span class="s3">\n      </span><span class="s1">recursiveStep(q, did, _ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return eles;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addChildren(q, did, ele) {</span><span class="s3">\n  </span><span class="s1">if (ele.isParent()) {</span><span class="s3">\n    </span><span class="s1">var children = ele._private.children;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n      </span><span class="s1">var child = children[i];</span><span class="s3">\n      </span><span class="s1">if (!did.has(child.id())) {</span><span class="s3">\n        </span><span class="s1">q.push(child);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// very efficient version of eles.add( eles.descendants() ).forEach()</span><span class="s3">\n</span><span class="s1">// for internal use</span><span class="s3">\n</span><span class="s1">elesfn$f.forEachDown = function (fn) {</span><span class="s3">\n  </span><span class="s1">var includeSelf = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n  </span><span class="s1">return forEachCompound(this, fn, includeSelf, addChildren);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function addParent(q, did, ele) {</span><span class="s3">\n  </span><span class="s1">if (ele.isChild()) {</span><span class="s3">\n    </span><span class="s1">var parent = ele._private.parent;</span><span class="s3">\n    </span><span class="s1">if (!did.has(parent.id())) {</span><span class="s3">\n      </span><span class="s1">q.push(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">elesfn$f.forEachUp = function (fn) {</span><span class="s3">\n  </span><span class="s1">var includeSelf = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n  </span><span class="s1">return forEachCompound(this, fn, includeSelf, addParent);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function addParentAndChildren(q, did, ele) {</span><span class="s3">\n  </span><span class="s1">addParent(q, did, ele);</span><span class="s3">\n  </span><span class="s1">addChildren(q, did, ele);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">elesfn$f.forEachUpAndDown = function (fn) {</span><span class="s3">\n  </span><span class="s1">var includeSelf = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n  </span><span class="s1">return forEachCompound(this, fn, includeSelf, addParentAndChildren);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">elesfn$f.ancestors = elesfn$f.parents;</span><span class="s3">\n\n</span><span class="s1">var fn$5, elesfn$e;</span><span class="s3">\n</span><span class="s1">fn$5 = elesfn$e = {</span><span class="s3">\n  </span><span class="s1">data: define.data({</span><span class="s3">\n    </span><span class="s1">field: 'data',</span><span class="s3">\n    </span><span class="s1">bindingEvent: 'data',</span><span class="s3">\n    </span><span class="s1">allowBinding: true,</span><span class="s3">\n    </span><span class="s1">allowSetting: true,</span><span class="s3">\n    </span><span class="s1">settingEvent: 'data',</span><span class="s3">\n    </span><span class="s1">settingTriggersEvent: true,</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">allowGetting: true,</span><span class="s3">\n    </span><span class="s1">immutableKeys: {</span><span class="s3">\n      </span><span class="s1">'id': true,</span><span class="s3">\n      </span><span class="s1">'source': true,</span><span class="s3">\n      </span><span class="s1">'target': true,</span><span class="s3">\n      </span><span class="s1">'parent': true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">removeData: define.removeData({</span><span class="s3">\n    </span><span class="s1">field: 'data',</span><span class="s3">\n    </span><span class="s1">event: 'data',</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">triggerEvent: true,</span><span class="s3">\n    </span><span class="s1">immutableKeys: {</span><span class="s3">\n      </span><span class="s1">'id': true,</span><span class="s3">\n      </span><span class="s1">'source': true,</span><span class="s3">\n      </span><span class="s1">'target': true,</span><span class="s3">\n      </span><span class="s1">'parent': true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">scratch: define.data({</span><span class="s3">\n    </span><span class="s1">field: 'scratch',</span><span class="s3">\n    </span><span class="s1">bindingEvent: 'scratch',</span><span class="s3">\n    </span><span class="s1">allowBinding: true,</span><span class="s3">\n    </span><span class="s1">allowSetting: true,</span><span class="s3">\n    </span><span class="s1">settingEvent: 'scratch',</span><span class="s3">\n    </span><span class="s1">settingTriggersEvent: true,</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">allowGetting: true,</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">removeScratch: define.removeData({</span><span class="s3">\n    </span><span class="s1">field: 'scratch',</span><span class="s3">\n    </span><span class="s1">event: 'scratch',</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">triggerEvent: true,</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">rscratch: define.data({</span><span class="s3">\n    </span><span class="s1">field: 'rscratch',</span><span class="s3">\n    </span><span class="s1">allowBinding: false,</span><span class="s3">\n    </span><span class="s1">allowSetting: true,</span><span class="s3">\n    </span><span class="s1">settingTriggersEvent: false,</span><span class="s3">\n    </span><span class="s1">allowGetting: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">removeRscratch: define.removeData({</span><span class="s3">\n    </span><span class="s1">field: 'rscratch',</span><span class="s3">\n    </span><span class="s1">triggerEvent: false</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">id: function id() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele._private.data.id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">fn$5.attr = fn$5.data;</span><span class="s3">\n</span><span class="s1">fn$5.removeAttr = fn$5.removeData;</span><span class="s3">\n</span><span class="s1">var data = elesfn$e;</span><span class="s3">\n\n</span><span class="s1">var elesfn$d = {};</span><span class="s3">\n</span><span class="s1">function defineDegreeFunction(callback) {</span><span class="s3">\n  </span><span class="s1">return function (includeLoops) {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">if (includeLoops === undefined) {</span><span class="s3">\n      </span><span class="s1">includeLoops = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (self.length === 0) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (self.isNode() &amp;&amp; !self.removed()) {</span><span class="s3">\n      </span><span class="s1">var degree = 0;</span><span class="s3">\n      </span><span class="s1">var node = self[0];</span><span class="s3">\n      </span><span class="s1">var connectedEdges = node._private.edges;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; connectedEdges.length; i++) {</span><span class="s3">\n        </span><span class="s1">var edge = connectedEdges[i];</span><span class="s3">\n        </span><span class="s1">if (!includeLoops &amp;&amp; edge.isLoop()) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">degree += callback(node, edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return degree;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">extend(elesfn$d, {</span><span class="s3">\n  </span><span class="s1">degree: defineDegreeFunction(function (node, edge) {</span><span class="s3">\n    </span><span class="s1">if (edge.source().same(edge.target())) {</span><span class="s3">\n      </span><span class="s1">return 2;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">indegree: defineDegreeFunction(function (node, edge) {</span><span class="s3">\n    </span><span class="s1">if (edge.target().same(node)) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">outdegree: defineDegreeFunction(function (node, edge) {</span><span class="s3">\n    </span><span class="s1">if (edge.source().same(node)) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function defineDegreeBoundsFunction(degreeFn, callback) {</span><span class="s3">\n  </span><span class="s1">return function (includeLoops) {</span><span class="s3">\n    </span><span class="s1">var ret;</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = nodes[i];</span><span class="s3">\n      </span><span class="s1">var degree = ele[degreeFn](includeLoops);</span><span class="s3">\n      </span><span class="s1">if (degree !== undefined &amp;&amp; (ret === undefined || callback(degree, ret))) {</span><span class="s3">\n        </span><span class="s1">ret = degree;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">extend(elesfn$d, {</span><span class="s3">\n  </span><span class="s1">minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {</span><span class="s3">\n    </span><span class="s1">return degree &lt; min;</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {</span><span class="s3">\n    </span><span class="s1">return degree &gt; max;</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {</span><span class="s3">\n    </span><span class="s1">return degree &lt; min;</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {</span><span class="s3">\n    </span><span class="s1">return degree &gt; max;</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {</span><span class="s3">\n    </span><span class="s1">return degree &lt; min;</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {</span><span class="s3">\n    </span><span class="s1">return degree &gt; max;</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">extend(elesfn$d, {</span><span class="s3">\n  </span><span class="s1">totalDegree: function totalDegree(includeLoops) {</span><span class="s3">\n    </span><span class="s1">var total = 0;</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">total += nodes[i].degree(includeLoops);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return total;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var fn$4, elesfn$c;</span><span class="s3">\n</span><span class="s1">var beforePositionSet = function beforePositionSet(eles, newPos, silent) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">if (!ele.locked()) {</span><span class="s3">\n      </span><span class="s1">var oldPos = ele._private.position;</span><span class="s3">\n      </span><span class="s1">var delta = {</span><span class="s3">\n        </span><span class="s1">x: newPos.x != null ? newPos.x - oldPos.x : 0,</span><span class="s3">\n        </span><span class="s1">y: newPos.y != null ? newPos.y - oldPos.y : 0</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (ele.isParent() &amp;&amp; !(delta.x === 0 &amp;&amp; delta.y === 0)) {</span><span class="s3">\n        </span><span class="s1">ele.children().shift(delta, silent);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ele.dirtyBoundingBoxCache();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var positionDef = {</span><span class="s3">\n  </span><span class="s1">field: 'position',</span><span class="s3">\n  </span><span class="s1">bindingEvent: 'position',</span><span class="s3">\n  </span><span class="s1">allowBinding: true,</span><span class="s3">\n  </span><span class="s1">allowSetting: true,</span><span class="s3">\n  </span><span class="s1">settingEvent: 'position',</span><span class="s3">\n  </span><span class="s1">settingTriggersEvent: true,</span><span class="s3">\n  </span><span class="s1">triggerFnName: 'emitAndNotify',</span><span class="s3">\n  </span><span class="s1">allowGetting: true,</span><span class="s3">\n  </span><span class="s1">validKeys: ['x', 'y'],</span><span class="s3">\n  </span><span class="s1">beforeGet: function beforeGet(ele) {</span><span class="s3">\n    </span><span class="s1">ele.updateCompoundBounds();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">beforeSet: function beforeSet(eles, newPos) {</span><span class="s3">\n    </span><span class="s1">beforePositionSet(eles, newPos, false);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">onSet: function onSet(eles) {</span><span class="s3">\n    </span><span class="s1">eles.dirtyCompoundBoundsCache();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">canSet: function canSet(ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.locked();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">fn$4 = elesfn$c = {</span><span class="s3">\n  </span><span class="s1">position: define.data(positionDef),</span><span class="s3">\n  </span><span class="s1">// position but no notification to renderer</span><span class="s3">\n  </span><span class="s1">silentPosition: define.data(extend({}, positionDef, {</span><span class="s3">\n    </span><span class="s1">allowBinding: false,</span><span class="s3">\n    </span><span class="s1">allowSetting: true,</span><span class="s3">\n    </span><span class="s1">settingTriggersEvent: false,</span><span class="s3">\n    </span><span class="s1">allowGetting: false,</span><span class="s3">\n    </span><span class="s1">beforeSet: function beforeSet(eles, newPos) {</span><span class="s3">\n      </span><span class="s1">beforePositionSet(eles, newPos, true);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">onSet: function onSet(eles) {</span><span class="s3">\n      </span><span class="s1">eles.dirtyCompoundBoundsCache();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})),</span><span class="s3">\n  </span><span class="s1">positions: function positions(pos, silent) {</span><span class="s3">\n    </span><span class="s1">if (plainObject(pos)) {</span><span class="s3">\n      </span><span class="s1">if (silent) {</span><span class="s3">\n        </span><span class="s1">this.silentPosition(pos);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.position(pos);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (fn$6(pos)) {</span><span class="s3">\n      </span><span class="s1">var _fn = pos;</span><span class="s3">\n      </span><span class="s1">var cy = this.cy();</span><span class="s3">\n      </span><span class="s1">cy.startBatch();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = this[i];</span><span class="s3">\n        </span><span class="s1">var _pos = undefined;</span><span class="s3">\n        </span><span class="s1">if (_pos = _fn(ele, i)) {</span><span class="s3">\n          </span><span class="s1">if (silent) {</span><span class="s3">\n            </span><span class="s1">ele.silentPosition(_pos);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">ele.position(_pos);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cy.endBatch();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">silentPositions: function silentPositions(pos) {</span><span class="s3">\n    </span><span class="s1">return this.positions(pos, true);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">shift: function shift(dim, val, silent) {</span><span class="s3">\n    </span><span class="s1">var delta;</span><span class="s3">\n    </span><span class="s1">if (plainObject(dim)) {</span><span class="s3">\n      </span><span class="s1">delta = {</span><span class="s3">\n        </span><span class="s1">x: number$1(dim.x) ? dim.x : 0,</span><span class="s3">\n        </span><span class="s1">y: number$1(dim.y) ? dim.y : 0</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">silent = val;</span><span class="s3">\n    </span><span class="s1">} else if (string(dim) &amp;&amp; number$1(val)) {</span><span class="s3">\n      </span><span class="s1">delta = {</span><span class="s3">\n        </span><span class="s1">x: 0,</span><span class="s3">\n        </span><span class="s1">y: 0</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">delta[dim] = val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (delta != null) {</span><span class="s3">\n      </span><span class="s1">var cy = this.cy();</span><span class="s3">\n      </span><span class="s1">cy.startBatch();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = this[i];</span><span class="s3">\n\n        </span><span class="s1">// exclude any node that is a descendant of the calling collection</span><span class="s3">\n        </span><span class="s1">if (cy.hasCompoundNodes() &amp;&amp; ele.isChild() &amp;&amp; ele.ancestors().anySame(this)) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var pos = ele.position();</span><span class="s3">\n        </span><span class="s1">var newPos = {</span><span class="s3">\n          </span><span class="s1">x: pos.x + delta.x,</span><span class="s3">\n          </span><span class="s1">y: pos.y + delta.y</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (silent) {</span><span class="s3">\n          </span><span class="s1">ele.silentPosition(newPos);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">ele.position(newPos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cy.endBatch();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">silentShift: function silentShift(dim, val) {</span><span class="s3">\n    </span><span class="s1">if (plainObject(dim)) {</span><span class="s3">\n      </span><span class="s1">this.shift(dim, true);</span><span class="s3">\n    </span><span class="s1">} else if (string(dim) &amp;&amp; number$1(val)) {</span><span class="s3">\n      </span><span class="s1">this.shift(dim, val, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// get/set the rendered (i.e. on screen) positon of the element</span><span class="s3">\n  </span><span class="s1">renderedPosition: function renderedPosition(dim, val) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n    </span><span class="s1">var rpos = plainObject(dim) ? dim : undefined;</span><span class="s3">\n    </span><span class="s1">var setting = rpos !== undefined || val !== undefined &amp;&amp; string(dim);</span><span class="s3">\n    </span><span class="s1">if (ele &amp;&amp; ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">// must have an element and must be a node to return position</span><span class="s3">\n      </span><span class="s1">if (setting) {</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n          </span><span class="s1">var _ele = this[i];</span><span class="s3">\n          </span><span class="s1">if (val !== undefined) {</span><span class="s3">\n            </span><span class="s1">// set one dimension</span><span class="s3">\n            </span><span class="s1">_ele.position(dim, (val - pan[dim]) / zoom);</span><span class="s3">\n          </span><span class="s1">} else if (rpos !== undefined) {</span><span class="s3">\n            </span><span class="s1">// set whole position</span><span class="s3">\n            </span><span class="s1">_ele.position(renderedToModelPosition(rpos, zoom, pan));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// getting</span><span class="s3">\n        </span><span class="s1">var pos = ele.position();</span><span class="s3">\n        </span><span class="s1">rpos = modelToRenderedPosition$1(pos, zoom, pan);</span><span class="s3">\n        </span><span class="s1">if (dim === undefined) {</span><span class="s3">\n          </span><span class="s1">// then return the whole rendered position</span><span class="s3">\n          </span><span class="s1">return rpos;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// then return the specified dimension</span><span class="s3">\n          </span><span class="s1">return rpos[dim];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (!setting) {</span><span class="s3">\n      </span><span class="s1">return undefined; // for empty collection case</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// get/set the position relative to the parent</span><span class="s3">\n  </span><span class="s1">relativePosition: function relativePosition(dim, val) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var ppos = plainObject(dim) ? dim : undefined;</span><span class="s3">\n    </span><span class="s1">var setting = ppos !== undefined || val !== undefined &amp;&amp; string(dim);</span><span class="s3">\n    </span><span class="s1">var hasCompoundNodes = cy.hasCompoundNodes();</span><span class="s3">\n    </span><span class="s1">if (ele &amp;&amp; ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">// must have an element and must be a node to return position</span><span class="s3">\n      </span><span class="s1">if (setting) {</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n          </span><span class="s1">var _ele2 = this[i];</span><span class="s3">\n          </span><span class="s1">var parent = hasCompoundNodes ? _ele2.parent() : null;</span><span class="s3">\n          </span><span class="s1">var hasParent = parent &amp;&amp; parent.length &gt; 0;</span><span class="s3">\n          </span><span class="s1">var relativeToParent = hasParent;</span><span class="s3">\n          </span><span class="s1">if (hasParent) {</span><span class="s3">\n            </span><span class="s1">parent = parent[0];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var origin = relativeToParent ? parent.position() : {</span><span class="s3">\n            </span><span class="s1">x: 0,</span><span class="s3">\n            </span><span class="s1">y: 0</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">if (val !== undefined) {</span><span class="s3">\n            </span><span class="s1">// set one dimension</span><span class="s3">\n            </span><span class="s1">_ele2.position(dim, val + origin[dim]);</span><span class="s3">\n          </span><span class="s1">} else if (ppos !== undefined) {</span><span class="s3">\n            </span><span class="s1">// set whole position</span><span class="s3">\n            </span><span class="s1">_ele2.position({</span><span class="s3">\n              </span><span class="s1">x: ppos.x + origin.x,</span><span class="s3">\n              </span><span class="s1">y: ppos.y + origin.y</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// getting</span><span class="s3">\n        </span><span class="s1">var pos = ele.position();</span><span class="s3">\n        </span><span class="s1">var _parent = hasCompoundNodes ? ele.parent() : null;</span><span class="s3">\n        </span><span class="s1">var _hasParent = _parent &amp;&amp; _parent.length &gt; 0;</span><span class="s3">\n        </span><span class="s1">var _relativeToParent = _hasParent;</span><span class="s3">\n        </span><span class="s1">if (_hasParent) {</span><span class="s3">\n          </span><span class="s1">_parent = _parent[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var _origin = _relativeToParent ? _parent.position() : {</span><span class="s3">\n          </span><span class="s1">x: 0,</span><span class="s3">\n          </span><span class="s1">y: 0</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">ppos = {</span><span class="s3">\n          </span><span class="s1">x: pos.x - _origin.x,</span><span class="s3">\n          </span><span class="s1">y: pos.y - _origin.y</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (dim === undefined) {</span><span class="s3">\n          </span><span class="s1">// then return the whole rendered position</span><span class="s3">\n          </span><span class="s1">return ppos;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// then return the specified dimension</span><span class="s3">\n          </span><span class="s1">return ppos[dim];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (!setting) {</span><span class="s3">\n      </span><span class="s1">return undefined; // for empty collection case</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">fn$4.modelPosition = fn$4.point = fn$4.position;</span><span class="s3">\n</span><span class="s1">fn$4.modelPositions = fn$4.points = fn$4.positions;</span><span class="s3">\n</span><span class="s1">fn$4.renderedPoint = fn$4.renderedPosition;</span><span class="s3">\n</span><span class="s1">fn$4.relativePoint = fn$4.relativePosition;</span><span class="s3">\n</span><span class="s1">var position = elesfn$c;</span><span class="s3">\n\n</span><span class="s1">var fn$3, elesfn$b;</span><span class="s3">\n</span><span class="s1">fn$3 = elesfn$b = {};</span><span class="s3">\n</span><span class="s1">elesfn$b.renderedBoundingBox = function (options) {</span><span class="s3">\n  </span><span class="s1">var bb = this.boundingBox(options);</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n  </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n  </span><span class="s1">var x1 = bb.x1 * zoom + pan.x;</span><span class="s3">\n  </span><span class="s1">var x2 = bb.x2 * zoom + pan.x;</span><span class="s3">\n  </span><span class="s1">var y1 = bb.y1 * zoom + pan.y;</span><span class="s3">\n  </span><span class="s1">var y2 = bb.y2 * zoom + pan.y;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x1: x1,</span><span class="s3">\n    </span><span class="s1">x2: x2,</span><span class="s3">\n    </span><span class="s1">y1: y1,</span><span class="s3">\n    </span><span class="s1">y2: y2,</span><span class="s3">\n    </span><span class="s1">w: x2 - x1,</span><span class="s3">\n    </span><span class="s1">h: y2 - y1</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$b.dirtyCompoundBoundsCache = function () {</span><span class="s3">\n  </span><span class="s1">var silent = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : false;</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.forEachUp(function (ele) {</span><span class="s3">\n    </span><span class="s1">if (ele.isParent()) {</span><span class="s3">\n      </span><span class="s1">var _p = ele._private;</span><span class="s3">\n      </span><span class="s1">_p.compoundBoundsClean = false;</span><span class="s3">\n      </span><span class="s1">_p.bbCache = null;</span><span class="s3">\n      </span><span class="s1">if (!silent) {</span><span class="s3">\n        </span><span class="s1">ele.emitAndNotify('bounds');</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$b.updateCompoundBounds = function () {</span><span class="s3">\n  </span><span class="s1">var force = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : false;</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n\n  </span><span class="s1">// not possible to do on non-compound graphs or with the style disabled</span><span class="s3">\n  </span><span class="s1">if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// save cycles when batching -- but bounds will be stale (or not exist yet)</span><span class="s3">\n  </span><span class="s1">if (!force &amp;&amp; cy.batching()) {</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function update(parent) {</span><span class="s3">\n    </span><span class="s1">if (!parent.isParent()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _p = parent._private;</span><span class="s3">\n    </span><span class="s1">var children = parent.children();</span><span class="s3">\n    </span><span class="s1">var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';</span><span class="s3">\n    </span><span class="s1">var min = {</span><span class="s3">\n      </span><span class="s1">width: {</span><span class="s3">\n        </span><span class="s1">val: parent.pstyle('min-width').pfValue,</span><span class="s3">\n        </span><span class="s1">left: parent.pstyle('min-width-bias-left'),</span><span class="s3">\n        </span><span class="s1">right: parent.pstyle('min-width-bias-right')</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">height: {</span><span class="s3">\n        </span><span class="s1">val: parent.pstyle('min-height').pfValue,</span><span class="s3">\n        </span><span class="s1">top: parent.pstyle('min-height-bias-top'),</span><span class="s3">\n        </span><span class="s1">bottom: parent.pstyle('min-height-bias-bottom')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var bb = children.boundingBox({</span><span class="s3">\n      </span><span class="s1">includeLabels: includeLabels,</span><span class="s3">\n      </span><span class="s1">includeOverlays: false,</span><span class="s3">\n      </span><span class="s1">// updating the compound bounds happens outside of the regular</span><span class="s3">\n      </span><span class="s1">// cache cycle (i.e. before fired events)</span><span class="s3">\n      </span><span class="s1">useCache: false</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var pos = _p.position;</span><span class="s3">\n\n    </span><span class="s1">// if children take up zero area then keep position and fall back on stylesheet w/h</span><span class="s3">\n    </span><span class="s1">if (bb.w === 0 || bb.h === 0) {</span><span class="s3">\n      </span><span class="s1">bb = {</span><span class="s3">\n        </span><span class="s1">w: parent.pstyle('width').pfValue,</span><span class="s3">\n        </span><span class="s1">h: parent.pstyle('height').pfValue</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">bb.x1 = pos.x - bb.w / 2;</span><span class="s3">\n      </span><span class="s1">bb.x2 = pos.x + bb.w / 2;</span><span class="s3">\n      </span><span class="s1">bb.y1 = pos.y - bb.h / 2;</span><span class="s3">\n      </span><span class="s1">bb.y2 = pos.y + bb.h / 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function computeBiasValues(propDiff, propBias, propBiasComplement) {</span><span class="s3">\n      </span><span class="s1">var biasDiff = 0;</span><span class="s3">\n      </span><span class="s1">var biasComplementDiff = 0;</span><span class="s3">\n      </span><span class="s1">var biasTotal = propBias + propBiasComplement;</span><span class="s3">\n      </span><span class="s1">if (propDiff &gt; 0 &amp;&amp; biasTotal &gt; 0) {</span><span class="s3">\n        </span><span class="s1">biasDiff = propBias / biasTotal * propDiff;</span><span class="s3">\n        </span><span class="s1">biasComplementDiff = propBiasComplement / biasTotal * propDiff;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">biasDiff: biasDiff,</span><span class="s3">\n        </span><span class="s1">biasComplementDiff: biasComplementDiff</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function computePaddingValues(width, height, paddingObject, relativeTo) {</span><span class="s3">\n      </span><span class="s1">// Assuming percentage is number from 0 to 1</span><span class="s3">\n      </span><span class="s1">if (paddingObject.units === '%') {</span><span class="s3">\n        </span><span class="s1">switch (relativeTo) {</span><span class="s3">\n          </span><span class="s1">case 'width':</span><span class="s3">\n            </span><span class="s1">return width &gt; 0 ? paddingObject.pfValue * width : 0;</span><span class="s3">\n          </span><span class="s1">case 'height':</span><span class="s3">\n            </span><span class="s1">return height &gt; 0 ? paddingObject.pfValue * height : 0;</span><span class="s3">\n          </span><span class="s1">case 'average':</span><span class="s3">\n            </span><span class="s1">return width &gt; 0 &amp;&amp; height &gt; 0 ? paddingObject.pfValue * (width + height) / 2 : 0;</span><span class="s3">\n          </span><span class="s1">case 'min':</span><span class="s3">\n            </span><span class="s1">return width &gt; 0 &amp;&amp; height &gt; 0 ? width &gt; height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;</span><span class="s3">\n          </span><span class="s1">case 'max':</span><span class="s3">\n            </span><span class="s1">return width &gt; 0 &amp;&amp; height &gt; 0 ? width &gt; height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (paddingObject.units === 'px') {</span><span class="s3">\n        </span><span class="s1">return paddingObject.pfValue;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var leftVal = min.width.left.value;</span><span class="s3">\n    </span><span class="s1">if (min.width.left.units === 'px' &amp;&amp; min.width.val &gt; 0) {</span><span class="s3">\n      </span><span class="s1">leftVal = leftVal * 100 / min.width.val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var rightVal = min.width.right.value;</span><span class="s3">\n    </span><span class="s1">if (min.width.right.units === 'px' &amp;&amp; min.width.val &gt; 0) {</span><span class="s3">\n      </span><span class="s1">rightVal = rightVal * 100 / min.width.val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var topVal = min.height.top.value;</span><span class="s3">\n    </span><span class="s1">if (min.height.top.units === 'px' &amp;&amp; min.height.val &gt; 0) {</span><span class="s3">\n      </span><span class="s1">topVal = topVal * 100 / min.height.val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var bottomVal = min.height.bottom.value;</span><span class="s3">\n    </span><span class="s1">if (min.height.bottom.units === 'px' &amp;&amp; min.height.val &gt; 0) {</span><span class="s3">\n      </span><span class="s1">bottomVal = bottomVal * 100 / min.height.val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);</span><span class="s3">\n    </span><span class="s1">var diffLeft = widthBiasDiffs.biasDiff;</span><span class="s3">\n    </span><span class="s1">var diffRight = widthBiasDiffs.biasComplementDiff;</span><span class="s3">\n    </span><span class="s1">var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);</span><span class="s3">\n    </span><span class="s1">var diffTop = heightBiasDiffs.biasDiff;</span><span class="s3">\n    </span><span class="s1">var diffBottom = heightBiasDiffs.biasComplementDiff;</span><span class="s3">\n    </span><span class="s1">_p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);</span><span class="s3">\n    </span><span class="s1">_p.autoWidth = Math.max(bb.w, min.width.val);</span><span class="s3">\n    </span><span class="s1">pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;</span><span class="s3">\n    </span><span class="s1">_p.autoHeight = Math.max(bb.h, min.height.val);</span><span class="s3">\n    </span><span class="s1">pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = this[i];</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">if (!_p.compoundBoundsClean || force) {</span><span class="s3">\n      </span><span class="s1">update(ele);</span><span class="s3">\n      </span><span class="s1">if (!cy.batching()) {</span><span class="s3">\n        </span><span class="s1">_p.compoundBoundsClean = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var noninf = function noninf(x) {</span><span class="s3">\n  </span><span class="s1">if (x === Infinity || x === -Infinity) {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateBounds = function updateBounds(b, x1, y1, x2, y2) {</span><span class="s3">\n  </span><span class="s1">// don't update with zero area boxes</span><span class="s3">\n  </span><span class="s1">if (x2 - x1 === 0 || y2 - y1 === 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// don't update with null dim</span><span class="s3">\n  </span><span class="s1">if (x1 == null || y1 == null || x2 == null || y2 == null) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">b.x1 = x1 &lt; b.x1 ? x1 : b.x1;</span><span class="s3">\n  </span><span class="s1">b.x2 = x2 &gt; b.x2 ? x2 : b.x2;</span><span class="s3">\n  </span><span class="s1">b.y1 = y1 &lt; b.y1 ? y1 : b.y1;</span><span class="s3">\n  </span><span class="s1">b.y2 = y2 &gt; b.y2 ? y2 : b.y2;</span><span class="s3">\n  </span><span class="s1">b.w = b.x2 - b.x1;</span><span class="s3">\n  </span><span class="s1">b.h = b.y2 - b.y1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {</span><span class="s3">\n  </span><span class="s1">if (b2 == null) {</span><span class="s3">\n    </span><span class="s1">return b;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var prefixedProperty = function prefixedProperty(obj, field, prefix) {</span><span class="s3">\n  </span><span class="s1">return getPrefixedProperty(obj, field, prefix);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {</span><span class="s3">\n  </span><span class="s1">if (ele.cy().headless()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var rstyle = _p.rstyle;</span><span class="s3">\n  </span><span class="s1">var halfArW = rstyle.arrowWidth / 2;</span><span class="s3">\n  </span><span class="s1">var arrowType = ele.pstyle(prefix + '-arrow-shape').value;</span><span class="s3">\n  </span><span class="s1">var x;</span><span class="s3">\n  </span><span class="s1">var y;</span><span class="s3">\n  </span><span class="s1">if (arrowType !== 'none') {</span><span class="s3">\n    </span><span class="s1">if (prefix === 'source') {</span><span class="s3">\n      </span><span class="s1">x = rstyle.srcX;</span><span class="s3">\n      </span><span class="s1">y = rstyle.srcY;</span><span class="s3">\n    </span><span class="s1">} else if (prefix === 'target') {</span><span class="s3">\n      </span><span class="s1">x = rstyle.tgtX;</span><span class="s3">\n      </span><span class="s1">y = rstyle.tgtY;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">x = rstyle.midX;</span><span class="s3">\n      </span><span class="s1">y = rstyle.midY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// always store the individual arrow bounds</span><span class="s3">\n    </span><span class="s1">var bbs = _p.arrowBounds = _p.arrowBounds || {};</span><span class="s3">\n    </span><span class="s1">var bb = bbs[prefix] = bbs[prefix] || {};</span><span class="s3">\n    </span><span class="s1">bb.x1 = x - halfArW;</span><span class="s3">\n    </span><span class="s1">bb.y1 = y - halfArW;</span><span class="s3">\n    </span><span class="s1">bb.x2 = x + halfArW;</span><span class="s3">\n    </span><span class="s1">bb.y2 = y + halfArW;</span><span class="s3">\n    </span><span class="s1">bb.w = bb.x2 - bb.x1;</span><span class="s3">\n    </span><span class="s1">bb.h = bb.y2 - bb.y1;</span><span class="s3">\n    </span><span class="s1">expandBoundingBox(bb, 1);</span><span class="s3">\n    </span><span class="s1">updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {</span><span class="s3">\n  </span><span class="s1">if (ele.cy().headless()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var prefixDash;</span><span class="s3">\n  </span><span class="s1">if (prefix) {</span><span class="s3">\n    </span><span class="s1">prefixDash = prefix + '-';</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">prefixDash = '';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var rstyle = _p.rstyle;</span><span class="s3">\n  </span><span class="s1">var label = ele.pstyle(prefixDash + 'label').strValue;</span><span class="s3">\n  </span><span class="s1">if (label) {</span><span class="s3">\n    </span><span class="s1">var halign = ele.pstyle('text-halign');</span><span class="s3">\n    </span><span class="s1">var valign = ele.pstyle('text-valign');</span><span class="s3">\n    </span><span class="s1">var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);</span><span class="s3">\n    </span><span class="s1">var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);</span><span class="s3">\n    </span><span class="s1">var labelX = prefixedProperty(rstyle, 'labelX', prefix);</span><span class="s3">\n    </span><span class="s1">var labelY = prefixedProperty(rstyle, 'labelY', prefix);</span><span class="s3">\n    </span><span class="s1">var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;</span><span class="s3">\n    </span><span class="s1">var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;</span><span class="s3">\n    </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n    </span><span class="s1">var rotation = ele.pstyle(prefixDash + 'text-rotation');</span><span class="s3">\n    </span><span class="s1">var outlineWidth = ele.pstyle('text-outline-width').pfValue;</span><span class="s3">\n    </span><span class="s1">var borderWidth = ele.pstyle('text-border-width').pfValue;</span><span class="s3">\n    </span><span class="s1">var halfBorderWidth = borderWidth / 2;</span><span class="s3">\n    </span><span class="s1">var padding = ele.pstyle('text-background-padding').pfValue;</span><span class="s3">\n    </span><span class="s1">var marginOfError = 2; // expand to work around browser dimension inaccuracies</span><span class="s3">\n\n    </span><span class="s1">var lh = labelHeight;</span><span class="s3">\n    </span><span class="s1">var lw = labelWidth;</span><span class="s3">\n    </span><span class="s1">var lw_2 = lw / 2;</span><span class="s3">\n    </span><span class="s1">var lh_2 = lh / 2;</span><span class="s3">\n    </span><span class="s1">var lx1, lx2, ly1, ly2;</span><span class="s3">\n    </span><span class="s1">if (isEdge) {</span><span class="s3">\n      </span><span class="s1">lx1 = labelX - lw_2;</span><span class="s3">\n      </span><span class="s1">lx2 = labelX + lw_2;</span><span class="s3">\n      </span><span class="s1">ly1 = labelY - lh_2;</span><span class="s3">\n      </span><span class="s1">ly2 = labelY + lh_2;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">switch (halign.value) {</span><span class="s3">\n        </span><span class="s1">case 'left':</span><span class="s3">\n          </span><span class="s1">lx1 = labelX - lw;</span><span class="s3">\n          </span><span class="s1">lx2 = labelX;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'center':</span><span class="s3">\n          </span><span class="s1">lx1 = labelX - lw_2;</span><span class="s3">\n          </span><span class="s1">lx2 = labelX + lw_2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'right':</span><span class="s3">\n          </span><span class="s1">lx1 = labelX;</span><span class="s3">\n          </span><span class="s1">lx2 = labelX + lw;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">switch (valign.value) {</span><span class="s3">\n        </span><span class="s1">case 'top':</span><span class="s3">\n          </span><span class="s1">ly1 = labelY - lh;</span><span class="s3">\n          </span><span class="s1">ly2 = labelY;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'center':</span><span class="s3">\n          </span><span class="s1">ly1 = labelY - lh_2;</span><span class="s3">\n          </span><span class="s1">ly2 = labelY + lh_2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'bottom':</span><span class="s3">\n          </span><span class="s1">ly1 = labelY;</span><span class="s3">\n          </span><span class="s1">ly2 = labelY + lh;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// shift by margin and expand by outline and border</span><span class="s3">\n    </span><span class="s1">var leftPad = marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;</span><span class="s3">\n    </span><span class="s1">var rightPad = marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;</span><span class="s3">\n    </span><span class="s1">var topPad = marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;</span><span class="s3">\n    </span><span class="s1">var botPad = marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;</span><span class="s3">\n    </span><span class="s1">lx1 += leftPad;</span><span class="s3">\n    </span><span class="s1">lx2 += rightPad;</span><span class="s3">\n    </span><span class="s1">ly1 += topPad;</span><span class="s3">\n    </span><span class="s1">ly2 += botPad;</span><span class="s3">\n\n    </span><span class="s1">// always store the unrotated label bounds separately</span><span class="s3">\n    </span><span class="s1">var bbPrefix = prefix || 'main';</span><span class="s3">\n    </span><span class="s1">var bbs = _p.labelBounds;</span><span class="s3">\n    </span><span class="s1">var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};</span><span class="s3">\n    </span><span class="s1">bb.x1 = lx1;</span><span class="s3">\n    </span><span class="s1">bb.y1 = ly1;</span><span class="s3">\n    </span><span class="s1">bb.x2 = lx2;</span><span class="s3">\n    </span><span class="s1">bb.y2 = ly2;</span><span class="s3">\n    </span><span class="s1">bb.w = lx2 - lx1;</span><span class="s3">\n    </span><span class="s1">bb.h = ly2 - ly1;</span><span class="s3">\n    </span><span class="s1">bb.leftPad = leftPad;</span><span class="s3">\n    </span><span class="s1">bb.rightPad = rightPad;</span><span class="s3">\n    </span><span class="s1">bb.topPad = topPad;</span><span class="s3">\n    </span><span class="s1">bb.botPad = botPad;</span><span class="s3">\n    </span><span class="s1">var isAutorotate = isEdge &amp;&amp; rotation.strValue === 'autorotate';</span><span class="s3">\n    </span><span class="s1">var isPfValue = rotation.pfValue != null &amp;&amp; rotation.pfValue !== 0;</span><span class="s3">\n    </span><span class="s1">if (isAutorotate || isPfValue) {</span><span class="s3">\n      </span><span class="s1">var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;</span><span class="s3">\n      </span><span class="s1">var cos = Math.cos(theta);</span><span class="s3">\n      </span><span class="s1">var sin = Math.sin(theta);</span><span class="s3">\n\n      </span><span class="s1">// rotation point (default value for center-center)</span><span class="s3">\n      </span><span class="s1">var xo = (lx1 + lx2) / 2;</span><span class="s3">\n      </span><span class="s1">var yo = (ly1 + ly2) / 2;</span><span class="s3">\n      </span><span class="s1">if (!isEdge) {</span><span class="s3">\n        </span><span class="s1">switch (halign.value) {</span><span class="s3">\n          </span><span class="s1">case 'left':</span><span class="s3">\n            </span><span class="s1">xo = lx2;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 'right':</span><span class="s3">\n            </span><span class="s1">xo = lx1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (valign.value) {</span><span class="s3">\n          </span><span class="s1">case 'top':</span><span class="s3">\n            </span><span class="s1">yo = ly2;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 'bottom':</span><span class="s3">\n            </span><span class="s1">yo = ly1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var rotate = function rotate(x, y) {</span><span class="s3">\n        </span><span class="s1">x = x - xo;</span><span class="s3">\n        </span><span class="s1">y = y - yo;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">x: x * cos - y * sin + xo,</span><span class="s3">\n          </span><span class="s1">y: x * sin + y * cos + yo</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var px1y1 = rotate(lx1, ly1);</span><span class="s3">\n      </span><span class="s1">var px1y2 = rotate(lx1, ly2);</span><span class="s3">\n      </span><span class="s1">var px2y1 = rotate(lx2, ly1);</span><span class="s3">\n      </span><span class="s1">var px2y2 = rotate(lx2, ly2);</span><span class="s3">\n      </span><span class="s1">lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);</span><span class="s3">\n      </span><span class="s1">lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);</span><span class="s3">\n      </span><span class="s1">ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);</span><span class="s3">\n      </span><span class="s1">ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var bbPrefixRot = bbPrefix + 'Rot';</span><span class="s3">\n    </span><span class="s1">var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};</span><span class="s3">\n    </span><span class="s1">bbRot.x1 = lx1;</span><span class="s3">\n    </span><span class="s1">bbRot.y1 = ly1;</span><span class="s3">\n    </span><span class="s1">bbRot.x2 = lx2;</span><span class="s3">\n    </span><span class="s1">bbRot.y2 = ly2;</span><span class="s3">\n    </span><span class="s1">bbRot.w = lx2 - lx1;</span><span class="s3">\n    </span><span class="s1">bbRot.h = ly2 - ly1;</span><span class="s3">\n    </span><span class="s1">updateBounds(bounds, lx1, ly1, lx2, ly2);</span><span class="s3">\n    </span><span class="s1">updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return bounds;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var updateBoundsFromOutline = function updateBoundsFromOutline(bounds, ele) {</span><span class="s3">\n  </span><span class="s1">if (ele.cy().headless()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var outlineOpacity = ele.pstyle('outline-opacity').value;</span><span class="s3">\n  </span><span class="s1">var outlineWidth = ele.pstyle('outline-width').value;</span><span class="s3">\n  </span><span class="s1">if (outlineOpacity &gt; 0 &amp;&amp; outlineWidth &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var outlineOffset = ele.pstyle('outline-offset').value;</span><span class="s3">\n    </span><span class="s1">var nodeShape = ele.pstyle('shape').value;</span><span class="s3">\n    </span><span class="s1">var outlineSize = outlineWidth + outlineOffset;</span><span class="s3">\n    </span><span class="s1">var scaleX = (bounds.w + outlineSize * 2) / bounds.w;</span><span class="s3">\n    </span><span class="s1">var scaleY = (bounds.h + outlineSize * 2) / bounds.h;</span><span class="s3">\n    </span><span class="s1">var xOffset = 0;</span><span class="s3">\n    </span><span class="s1">var yOffset = 0;</span><span class="s3">\n    </span><span class="s1">if ([</span><span class="s3">\&quot;</span><span class="s1">diamond</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">pentagon</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">round-triangle</span><span class="s3">\&quot;</span><span class="s1">].includes(nodeShape)) {</span><span class="s3">\n      </span><span class="s1">scaleX = (bounds.w + outlineSize * 2.4) / bounds.w;</span><span class="s3">\n      </span><span class="s1">yOffset = -outlineSize / 3.6;</span><span class="s3">\n    </span><span class="s1">} else if ([</span><span class="s3">\&quot;</span><span class="s1">concave-hexagon</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">rhomboid</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">right-rhomboid</span><span class="s3">\&quot;</span><span class="s1">].includes(nodeShape)) {</span><span class="s3">\n      </span><span class="s1">scaleX = (bounds.w + outlineSize * 2.4) / bounds.w;</span><span class="s3">\n    </span><span class="s1">} else if (nodeShape === </span><span class="s3">\&quot;</span><span class="s1">star</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">scaleX = (bounds.w + outlineSize * 2.8) / bounds.w;</span><span class="s3">\n      </span><span class="s1">scaleY = (bounds.h + outlineSize * 2.6) / bounds.h;</span><span class="s3">\n      </span><span class="s1">yOffset = -outlineSize / 3.8;</span><span class="s3">\n    </span><span class="s1">} else if (nodeShape === </span><span class="s3">\&quot;</span><span class="s1">triangle</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">scaleX = (bounds.w + outlineSize * 2.8) / bounds.w;</span><span class="s3">\n      </span><span class="s1">scaleY = (bounds.h + outlineSize * 2.4) / bounds.h;</span><span class="s3">\n      </span><span class="s1">yOffset = -outlineSize / 1.4;</span><span class="s3">\n    </span><span class="s1">} else if (nodeShape === </span><span class="s3">\&quot;</span><span class="s1">vee</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">scaleX = (bounds.w + outlineSize * 4.4) / bounds.w;</span><span class="s3">\n      </span><span class="s1">scaleY = (bounds.h + outlineSize * 3.8) / bounds.h;</span><span class="s3">\n      </span><span class="s1">yOffset = -outlineSize * .5;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var hDelta = bounds.h * scaleY - bounds.h;</span><span class="s3">\n    </span><span class="s1">var wDelta = bounds.w * scaleX - bounds.w;</span><span class="s3">\n    </span><span class="s1">expandBoundingBoxSides(bounds, [Math.ceil(hDelta / 2), Math.ceil(wDelta / 2)]);</span><span class="s3">\n    </span><span class="s1">if (xOffset != 0 || yOffset !== 0) {</span><span class="s3">\n      </span><span class="s1">var oBounds = shiftBoundingBox(bounds, xOffset, yOffset);</span><span class="s3">\n      </span><span class="s1">updateBoundingBox(bounds, oBounds);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get the bounding box of the elements (in raw model position)</span><span class="s3">\n</span><span class="s1">var boundingBoxImpl = function boundingBoxImpl(ele, options) {</span><span class="s3">\n  </span><span class="s1">var cy = ele._private.cy;</span><span class="s3">\n  </span><span class="s1">var styleEnabled = cy.styleEnabled();</span><span class="s3">\n  </span><span class="s1">var headless = cy.headless();</span><span class="s3">\n  </span><span class="s1">var bounds = makeBoundingBox();</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var isNode = ele.isNode();</span><span class="s3">\n  </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n  </span><span class="s1">var ex1, ex2, ey1, ey2; // extrema of body / lines</span><span class="s3">\n  </span><span class="s1">var x, y; // node pos</span><span class="s3">\n  </span><span class="s1">var rstyle = _p.rstyle;</span><span class="s3">\n  </span><span class="s1">var manualExpansion = isNode &amp;&amp; styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0];</span><span class="s3">\n\n  </span><span class="s1">// must use `display` prop only, as reading `compound.width()` causes recursion</span><span class="s3">\n  </span><span class="s1">// (other factors like width values will be considered later in this function anyway)</span><span class="s3">\n  </span><span class="s1">var isDisplayed = function isDisplayed(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.pstyle('display').value !== 'none';</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var displayed = !styleEnabled || isDisplayed(ele)</span><span class="s3">\n\n  </span><span class="s1">// must take into account connected nodes b/c of implicit edge hiding on display:none node</span><span class="s3">\n  </span><span class="s1">&amp;&amp; (!isEdge || isDisplayed(ele.source()) &amp;&amp; isDisplayed(ele.target()));</span><span class="s3">\n  </span><span class="s1">if (displayed) {</span><span class="s3">\n    </span><span class="s1">// displayed suffices, since we will find zero area eles anyway</span><span class="s3">\n    </span><span class="s1">var overlayOpacity = 0;</span><span class="s3">\n    </span><span class="s1">var overlayPadding = 0;</span><span class="s3">\n    </span><span class="s1">if (styleEnabled &amp;&amp; options.includeOverlays) {</span><span class="s3">\n      </span><span class="s1">overlayOpacity = ele.pstyle('overlay-opacity').value;</span><span class="s3">\n      </span><span class="s1">if (overlayOpacity !== 0) {</span><span class="s3">\n        </span><span class="s1">overlayPadding = ele.pstyle('overlay-padding').value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var underlayOpacity = 0;</span><span class="s3">\n    </span><span class="s1">var underlayPadding = 0;</span><span class="s3">\n    </span><span class="s1">if (styleEnabled &amp;&amp; options.includeUnderlays) {</span><span class="s3">\n      </span><span class="s1">underlayOpacity = ele.pstyle('underlay-opacity').value;</span><span class="s3">\n      </span><span class="s1">if (underlayOpacity !== 0) {</span><span class="s3">\n        </span><span class="s1">underlayPadding = ele.pstyle('underlay-padding').value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var padding = Math.max(overlayPadding, underlayPadding);</span><span class="s3">\n    </span><span class="s1">var w = 0;</span><span class="s3">\n    </span><span class="s1">var wHalf = 0;</span><span class="s3">\n    </span><span class="s1">if (styleEnabled) {</span><span class="s3">\n      </span><span class="s1">w = ele.pstyle('width').pfValue;</span><span class="s3">\n      </span><span class="s1">wHalf = w / 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isNode &amp;&amp; options.includeNodes) {</span><span class="s3">\n      </span><span class="s1">var pos = ele.position();</span><span class="s3">\n      </span><span class="s1">x = pos.x;</span><span class="s3">\n      </span><span class="s1">y = pos.y;</span><span class="s3">\n      </span><span class="s1">var _w = ele.outerWidth();</span><span class="s3">\n      </span><span class="s1">var halfW = _w / 2;</span><span class="s3">\n      </span><span class="s1">var h = ele.outerHeight();</span><span class="s3">\n      </span><span class="s1">var halfH = h / 2;</span><span class="s3">\n\n      </span><span class="s1">// handle node dimensions</span><span class="s3">\n      </span><span class="s1">/////////////////////////</span><span class="s3">\n\n      </span><span class="s1">ex1 = x - halfW;</span><span class="s3">\n      </span><span class="s1">ex2 = x + halfW;</span><span class="s3">\n      </span><span class="s1">ey1 = y - halfH;</span><span class="s3">\n      </span><span class="s1">ey2 = y + halfH;</span><span class="s3">\n      </span><span class="s1">updateBounds(bounds, ex1, ey1, ex2, ey2);</span><span class="s3">\n      </span><span class="s1">if (styleEnabled &amp;&amp; options.includeOutlines) {</span><span class="s3">\n        </span><span class="s1">updateBoundsFromOutline(bounds, ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (isEdge &amp;&amp; options.includeEdges) {</span><span class="s3">\n      </span><span class="s1">if (styleEnabled &amp;&amp; !headless) {</span><span class="s3">\n        </span><span class="s1">var curveStyle = ele.pstyle('curve-style').strValue;</span><span class="s3">\n\n        </span><span class="s1">// handle edge dimensions (rough box estimate)</span><span class="s3">\n        </span><span class="s1">//////////////////////////////////////////////</span><span class="s3">\n\n        </span><span class="s1">ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);</span><span class="s3">\n        </span><span class="s1">ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);</span><span class="s3">\n        </span><span class="s1">ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);</span><span class="s3">\n        </span><span class="s1">ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);</span><span class="s3">\n\n        </span><span class="s1">// take into account edge width</span><span class="s3">\n        </span><span class="s1">ex1 -= wHalf;</span><span class="s3">\n        </span><span class="s1">ex2 += wHalf;</span><span class="s3">\n        </span><span class="s1">ey1 -= wHalf;</span><span class="s3">\n        </span><span class="s1">ey2 += wHalf;</span><span class="s3">\n        </span><span class="s1">updateBounds(bounds, ex1, ey1, ex2, ey2);</span><span class="s3">\n\n        </span><span class="s1">// precise edges</span><span class="s3">\n        </span><span class="s1">////////////////</span><span class="s3">\n\n        </span><span class="s1">if (curveStyle === 'haystack') {</span><span class="s3">\n          </span><span class="s1">var hpts = rstyle.haystackPts;</span><span class="s3">\n          </span><span class="s1">if (hpts &amp;&amp; hpts.length === 2) {</span><span class="s3">\n            </span><span class="s1">ex1 = hpts[0].x;</span><span class="s3">\n            </span><span class="s1">ey1 = hpts[0].y;</span><span class="s3">\n            </span><span class="s1">ex2 = hpts[1].x;</span><span class="s3">\n            </span><span class="s1">ey2 = hpts[1].y;</span><span class="s3">\n            </span><span class="s1">if (ex1 &gt; ex2) {</span><span class="s3">\n              </span><span class="s1">var temp = ex1;</span><span class="s3">\n              </span><span class="s1">ex1 = ex2;</span><span class="s3">\n              </span><span class="s1">ex2 = temp;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (ey1 &gt; ey2) {</span><span class="s3">\n              </span><span class="s1">var _temp = ey1;</span><span class="s3">\n              </span><span class="s1">ey1 = ey2;</span><span class="s3">\n              </span><span class="s1">ey2 = _temp;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle.endsWith('segments') || curveStyle.endsWith('taxi')) {</span><span class="s3">\n          </span><span class="s1">var pts;</span><span class="s3">\n          </span><span class="s1">switch (curveStyle) {</span><span class="s3">\n            </span><span class="s1">case 'bezier':</span><span class="s3">\n            </span><span class="s1">case 'unbundled-bezier':</span><span class="s3">\n              </span><span class="s1">pts = rstyle.bezierPts;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'segments':</span><span class="s3">\n            </span><span class="s1">case 'taxi':</span><span class="s3">\n            </span><span class="s1">case 'round-segments':</span><span class="s3">\n            </span><span class="s1">case 'round-taxi':</span><span class="s3">\n              </span><span class="s1">pts = rstyle.linePts;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (pts != null) {</span><span class="s3">\n            </span><span class="s1">for (var j = 0; j &lt; pts.length; j++) {</span><span class="s3">\n              </span><span class="s1">var pt = pts[j];</span><span class="s3">\n              </span><span class="s1">ex1 = pt.x - wHalf;</span><span class="s3">\n              </span><span class="s1">ex2 = pt.x + wHalf;</span><span class="s3">\n              </span><span class="s1">ey1 = pt.y - wHalf;</span><span class="s3">\n              </span><span class="s1">ey2 = pt.y + wHalf;</span><span class="s3">\n              </span><span class="s1">updateBounds(bounds, ex1, ey1, ex2, ey2);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} // bezier-like or segment-like edge</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// headless or style disabled</span><span class="s3">\n\n        </span><span class="s1">// fallback on source and target positions</span><span class="s3">\n        </span><span class="s1">//////////////////////////////////////////</span><span class="s3">\n\n        </span><span class="s1">var n1 = ele.source();</span><span class="s3">\n        </span><span class="s1">var n1pos = n1.position();</span><span class="s3">\n        </span><span class="s1">var n2 = ele.target();</span><span class="s3">\n        </span><span class="s1">var n2pos = n2.position();</span><span class="s3">\n        </span><span class="s1">ex1 = n1pos.x;</span><span class="s3">\n        </span><span class="s1">ex2 = n2pos.x;</span><span class="s3">\n        </span><span class="s1">ey1 = n1pos.y;</span><span class="s3">\n        </span><span class="s1">ey2 = n2pos.y;</span><span class="s3">\n        </span><span class="s1">if (ex1 &gt; ex2) {</span><span class="s3">\n          </span><span class="s1">var _temp2 = ex1;</span><span class="s3">\n          </span><span class="s1">ex1 = ex2;</span><span class="s3">\n          </span><span class="s1">ex2 = _temp2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ey1 &gt; ey2) {</span><span class="s3">\n          </span><span class="s1">var _temp3 = ey1;</span><span class="s3">\n          </span><span class="s1">ey1 = ey2;</span><span class="s3">\n          </span><span class="s1">ey2 = _temp3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// take into account edge width</span><span class="s3">\n        </span><span class="s1">ex1 -= wHalf;</span><span class="s3">\n        </span><span class="s1">ex2 += wHalf;</span><span class="s3">\n        </span><span class="s1">ey1 -= wHalf;</span><span class="s3">\n        </span><span class="s1">ey2 += wHalf;</span><span class="s3">\n        </span><span class="s1">updateBounds(bounds, ex1, ey1, ex2, ey2);</span><span class="s3">\n      </span><span class="s1">} // headless or style disabled</span><span class="s3">\n    </span><span class="s1">} // edges</span><span class="s3">\n\n    </span><span class="s1">// handle edge arrow size</span><span class="s3">\n    </span><span class="s1">/////////////////////////</span><span class="s3">\n\n    </span><span class="s1">if (styleEnabled &amp;&amp; options.includeEdges &amp;&amp; isEdge) {</span><span class="s3">\n      </span><span class="s1">updateBoundsFromArrow(bounds, ele, 'mid-source');</span><span class="s3">\n      </span><span class="s1">updateBoundsFromArrow(bounds, ele, 'mid-target');</span><span class="s3">\n      </span><span class="s1">updateBoundsFromArrow(bounds, ele, 'source');</span><span class="s3">\n      </span><span class="s1">updateBoundsFromArrow(bounds, ele, 'target');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// ghost</span><span class="s3">\n    </span><span class="s1">////////</span><span class="s3">\n\n    </span><span class="s1">if (styleEnabled) {</span><span class="s3">\n      </span><span class="s1">var ghost = ele.pstyle('ghost').value === 'yes';</span><span class="s3">\n      </span><span class="s1">if (ghost) {</span><span class="s3">\n        </span><span class="s1">var gx = ele.pstyle('ghost-offset-x').pfValue;</span><span class="s3">\n        </span><span class="s1">var gy = ele.pstyle('ghost-offset-y').pfValue;</span><span class="s3">\n        </span><span class="s1">updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// always store the body bounds separately from the labels</span><span class="s3">\n    </span><span class="s1">var bbBody = _p.bodyBounds = _p.bodyBounds || {};</span><span class="s3">\n    </span><span class="s1">assignBoundingBox(bbBody, bounds);</span><span class="s3">\n    </span><span class="s1">expandBoundingBoxSides(bbBody, manualExpansion);</span><span class="s3">\n    </span><span class="s1">expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies</span><span class="s3">\n\n    </span><span class="s1">// overlay</span><span class="s3">\n    </span><span class="s1">//////////</span><span class="s3">\n\n    </span><span class="s1">if (styleEnabled) {</span><span class="s3">\n      </span><span class="s1">ex1 = bounds.x1;</span><span class="s3">\n      </span><span class="s1">ex2 = bounds.x2;</span><span class="s3">\n      </span><span class="s1">ey1 = bounds.y1;</span><span class="s3">\n      </span><span class="s1">ey2 = bounds.y2;</span><span class="s3">\n      </span><span class="s1">updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// always store the body bounds separately from the labels</span><span class="s3">\n    </span><span class="s1">var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};</span><span class="s3">\n    </span><span class="s1">assignBoundingBox(bbOverlay, bounds);</span><span class="s3">\n    </span><span class="s1">expandBoundingBoxSides(bbOverlay, manualExpansion);</span><span class="s3">\n    </span><span class="s1">expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies</span><span class="s3">\n\n    </span><span class="s1">// handle label dimensions</span><span class="s3">\n    </span><span class="s1">//////////////////////////</span><span class="s3">\n\n    </span><span class="s1">var bbLabels = _p.labelBounds = _p.labelBounds || {};</span><span class="s3">\n    </span><span class="s1">if (bbLabels.all != null) {</span><span class="s3">\n      </span><span class="s1">clearBoundingBox(bbLabels.all);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">bbLabels.all = makeBoundingBox();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (styleEnabled &amp;&amp; options.includeLabels) {</span><span class="s3">\n      </span><span class="s1">if (options.includeMainLabels) {</span><span class="s3">\n        </span><span class="s1">updateBoundsFromLabel(bounds, ele, null);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isEdge) {</span><span class="s3">\n        </span><span class="s1">if (options.includeSourceLabels) {</span><span class="s3">\n          </span><span class="s1">updateBoundsFromLabel(bounds, ele, 'source');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (options.includeTargetLabels) {</span><span class="s3">\n          </span><span class="s1">updateBoundsFromLabel(bounds, ele, 'target');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} // style enabled for labels</span><span class="s3">\n  </span><span class="s1">} // if displayed</span><span class="s3">\n\n  </span><span class="s1">bounds.x1 = noninf(bounds.x1);</span><span class="s3">\n  </span><span class="s1">bounds.y1 = noninf(bounds.y1);</span><span class="s3">\n  </span><span class="s1">bounds.x2 = noninf(bounds.x2);</span><span class="s3">\n  </span><span class="s1">bounds.y2 = noninf(bounds.y2);</span><span class="s3">\n  </span><span class="s1">bounds.w = noninf(bounds.x2 - bounds.x1);</span><span class="s3">\n  </span><span class="s1">bounds.h = noninf(bounds.y2 - bounds.y1);</span><span class="s3">\n  </span><span class="s1">if (bounds.w &gt; 0 &amp;&amp; bounds.h &gt; 0 &amp;&amp; displayed) {</span><span class="s3">\n    </span><span class="s1">expandBoundingBoxSides(bounds, manualExpansion);</span><span class="s3">\n\n    </span><span class="s1">// expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides</span><span class="s3">\n    </span><span class="s1">expandBoundingBox(bounds, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return bounds;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getKey = function getKey(opts) {</span><span class="s3">\n  </span><span class="s1">var i = 0;</span><span class="s3">\n  </span><span class="s1">var tf = function tf(val) {</span><span class="s3">\n    </span><span class="s1">return (val ? 1 : 0) &lt;&lt; i++;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var key = 0;</span><span class="s3">\n  </span><span class="s1">key += tf(opts.incudeNodes);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeEdges);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeLabels);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeMainLabels);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeSourceLabels);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeTargetLabels);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeOverlays);</span><span class="s3">\n  </span><span class="s1">key += tf(opts.includeOutlines);</span><span class="s3">\n  </span><span class="s1">return key;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {</span><span class="s3">\n  </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n    </span><span class="s1">var p1 = ele.source().position();</span><span class="s3">\n    </span><span class="s1">var p2 = ele.target().position();</span><span class="s3">\n    </span><span class="s1">var r = function r(x) {</span><span class="s3">\n      </span><span class="s1">return Math.round(x);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var bb;</span><span class="s3">\n  </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n  </span><span class="s1">var key = opts == null ? defBbOptsKey : getKey(opts);</span><span class="s3">\n  </span><span class="s1">var usingDefOpts = key === defBbOptsKey;</span><span class="s3">\n  </span><span class="s1">var currPosKey = getBoundingBoxPosKey(ele);</span><span class="s3">\n  </span><span class="s1">var isPosKeySame = _p.bbCachePosKey === currPosKey;</span><span class="s3">\n  </span><span class="s1">var useCache = opts.useCache;</span><span class="s3">\n  </span><span class="s1">var isDirty = function isDirty(ele) {</span><span class="s3">\n    </span><span class="s1">return ele._private.bbCache == null || ele._private.styleDirty;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var needRecalc = !useCache || isDirty(ele) || isEdge &amp;&amp; (isDirty(ele.source()) || isDirty(ele.target()));</span><span class="s3">\n  </span><span class="s1">if (needRecalc) {</span><span class="s3">\n    </span><span class="s1">if (!isPosKeySame) {</span><span class="s3">\n      </span><span class="s1">ele.recalculateRenderedStyle(useCache);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bb = boundingBoxImpl(ele, defBbOpts);</span><span class="s3">\n    </span><span class="s1">_p.bbCache = bb;</span><span class="s3">\n    </span><span class="s1">_p.bbCachePosKey = currPosKey;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">bb = _p.bbCache;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// not using def opts =&gt; need to build up bb from combination of sub bbs</span><span class="s3">\n  </span><span class="s1">if (!usingDefOpts) {</span><span class="s3">\n    </span><span class="s1">var isNode = ele.isNode();</span><span class="s3">\n    </span><span class="s1">bb = makeBoundingBox();</span><span class="s3">\n    </span><span class="s1">if (opts.includeNodes &amp;&amp; isNode || opts.includeEdges &amp;&amp; !isNode) {</span><span class="s3">\n      </span><span class="s1">if (opts.includeOverlays) {</span><span class="s3">\n        </span><span class="s1">updateBoundsFromBox(bb, _p.overlayBounds);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">updateBoundsFromBox(bb, _p.bodyBounds);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (opts.includeLabels) {</span><span class="s3">\n      </span><span class="s1">if (opts.includeMainLabels &amp;&amp; (!isEdge || opts.includeSourceLabels &amp;&amp; opts.includeTargetLabels)) {</span><span class="s3">\n        </span><span class="s1">updateBoundsFromBox(bb, _p.labelBounds.all);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (opts.includeMainLabels) {</span><span class="s3">\n          </span><span class="s1">updateBoundsFromBox(bb, _p.labelBounds.mainRot);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (opts.includeSourceLabels) {</span><span class="s3">\n          </span><span class="s1">updateBoundsFromBox(bb, _p.labelBounds.sourceRot);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (opts.includeTargetLabels) {</span><span class="s3">\n          </span><span class="s1">updateBoundsFromBox(bb, _p.labelBounds.targetRot);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bb.w = bb.x2 - bb.x1;</span><span class="s3">\n    </span><span class="s1">bb.h = bb.y2 - bb.y1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return bb;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var defBbOpts = {</span><span class="s3">\n  </span><span class="s1">includeNodes: true,</span><span class="s3">\n  </span><span class="s1">includeEdges: true,</span><span class="s3">\n  </span><span class="s1">includeLabels: true,</span><span class="s3">\n  </span><span class="s1">includeMainLabels: true,</span><span class="s3">\n  </span><span class="s1">includeSourceLabels: true,</span><span class="s3">\n  </span><span class="s1">includeTargetLabels: true,</span><span class="s3">\n  </span><span class="s1">includeOverlays: true,</span><span class="s3">\n  </span><span class="s1">includeUnderlays: true,</span><span class="s3">\n  </span><span class="s1">includeOutlines: true,</span><span class="s3">\n  </span><span class="s1">useCache: true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var defBbOptsKey = getKey(defBbOpts);</span><span class="s3">\n</span><span class="s1">var filledBbOpts = defaults$g(defBbOpts);</span><span class="s3">\n</span><span class="s1">elesfn$b.boundingBox = function (options) {</span><span class="s3">\n  </span><span class="s1">var bounds;</span><span class="s3">\n\n  </span><span class="s1">// the main usecase is ele.boundingBox() for a single element with no/def options</span><span class="s3">\n  </span><span class="s1">// specified s.t. the cache is used, so check for this case to make it faster by</span><span class="s3">\n  </span><span class="s1">// avoiding the overhead of the rest of the function</span><span class="s3">\n  </span><span class="s1">if (this.length === 1 &amp;&amp; this[0]._private.bbCache != null &amp;&amp; !this[0]._private.styleDirty &amp;&amp; (options === undefined || options.useCache === undefined || options.useCache === true)) {</span><span class="s3">\n    </span><span class="s1">if (options === undefined) {</span><span class="s3">\n      </span><span class="s1">options = defBbOpts;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">options = filledBbOpts(options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bounds = cachedBoundingBoxImpl(this[0], options);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">bounds = makeBoundingBox();</span><span class="s3">\n    </span><span class="s1">options = options || defBbOpts;</span><span class="s3">\n    </span><span class="s1">var opts = filledBbOpts(options);</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var cy = eles.cy();</span><span class="s3">\n    </span><span class="s1">var styleEnabled = cy.styleEnabled();</span><span class="s3">\n    </span><span class="s1">if (styleEnabled) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = eles[i];</span><span class="s3">\n        </span><span class="s1">var _p = ele._private;</span><span class="s3">\n        </span><span class="s1">var currPosKey = getBoundingBoxPosKey(ele);</span><span class="s3">\n        </span><span class="s1">var isPosKeySame = _p.bbCachePosKey === currPosKey;</span><span class="s3">\n        </span><span class="s1">var useCache = opts.useCache &amp;&amp; isPosKeySame &amp;&amp; !_p.styleDirty;</span><span class="s3">\n        </span><span class="s1">ele.recalculateRenderedStyle(useCache);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.updateCompoundBounds(!options.useCache);</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; eles.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var _ele = eles[_i];</span><span class="s3">\n      </span><span class="s1">updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">bounds.x1 = noninf(bounds.x1);</span><span class="s3">\n  </span><span class="s1">bounds.y1 = noninf(bounds.y1);</span><span class="s3">\n  </span><span class="s1">bounds.x2 = noninf(bounds.x2);</span><span class="s3">\n  </span><span class="s1">bounds.y2 = noninf(bounds.y2);</span><span class="s3">\n  </span><span class="s1">bounds.w = noninf(bounds.x2 - bounds.x1);</span><span class="s3">\n  </span><span class="s1">bounds.h = noninf(bounds.y2 - bounds.y1);</span><span class="s3">\n  </span><span class="s1">return bounds;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$b.dirtyBoundingBoxCache = function () {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var _p = this[i]._private;</span><span class="s3">\n    </span><span class="s1">_p.bbCache = null;</span><span class="s3">\n    </span><span class="s1">_p.bbCachePosKey = null;</span><span class="s3">\n    </span><span class="s1">_p.bodyBounds = null;</span><span class="s3">\n    </span><span class="s1">_p.overlayBounds = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.all = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.source = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.target = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.main = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.sourceRot = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.targetRot = null;</span><span class="s3">\n    </span><span class="s1">_p.labelBounds.mainRot = null;</span><span class="s3">\n    </span><span class="s1">_p.arrowBounds.source = null;</span><span class="s3">\n    </span><span class="s1">_p.arrowBounds.target = null;</span><span class="s3">\n    </span><span class="s1">_p.arrowBounds['mid-source'] = null;</span><span class="s3">\n    </span><span class="s1">_p.arrowBounds['mid-target'] = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.emitAndNotify('bounds');</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// private helper to get bounding box for custom node positions</span><span class="s3">\n</span><span class="s1">// - good for perf in certain cases but currently requires dirtying the rendered style</span><span class="s3">\n</span><span class="s1">// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...</span><span class="s3">\n</span><span class="s1">// - try to use for only things like discrete layouts where the node position would change anyway</span><span class="s3">\n</span><span class="s1">elesfn$b.boundingBoxAt = function (fn) {</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var hasCompoundNodes = cy.hasCompoundNodes();</span><span class="s3">\n  </span><span class="s1">var parents = cy.collection();</span><span class="s3">\n  </span><span class="s1">if (hasCompoundNodes) {</span><span class="s3">\n    </span><span class="s1">parents = nodes.filter(function (node) {</span><span class="s3">\n      </span><span class="s1">return node.isParent();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">nodes = nodes.not(parents);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (plainObject(fn)) {</span><span class="s3">\n    </span><span class="s1">var obj = fn;</span><span class="s3">\n    </span><span class="s1">fn = function fn() {</span><span class="s3">\n      </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var storeOldPos = function storeOldPos(node, i) {</span><span class="s3">\n    </span><span class="s1">return node._private.bbAtOldPos = fn(node, i);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getOldPos = function getOldPos(node) {</span><span class="s3">\n    </span><span class="s1">return node._private.bbAtOldPos;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">cy.startBatch();</span><span class="s3">\n  </span><span class="s1">nodes.forEach(storeOldPos).silentPositions(fn);</span><span class="s3">\n  </span><span class="s1">if (hasCompoundNodes) {</span><span class="s3">\n    </span><span class="s1">parents.dirtyCompoundBoundsCache();</span><span class="s3">\n    </span><span class="s1">parents.dirtyBoundingBoxCache();</span><span class="s3">\n    </span><span class="s1">parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var bb = copyBoundingBox(this.boundingBox({</span><span class="s3">\n    </span><span class="s1">useCache: false</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">nodes.silentPositions(getOldPos);</span><span class="s3">\n  </span><span class="s1">if (hasCompoundNodes) {</span><span class="s3">\n    </span><span class="s1">parents.dirtyCompoundBoundsCache();</span><span class="s3">\n    </span><span class="s1">parents.dirtyBoundingBoxCache();</span><span class="s3">\n    </span><span class="s1">parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">cy.endBatch();</span><span class="s3">\n  </span><span class="s1">return bb;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;</span><span class="s3">\n</span><span class="s1">fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;</span><span class="s3">\n</span><span class="s1">var bounds = elesfn$b;</span><span class="s3">\n\n</span><span class="s1">var fn$2, elesfn$a;</span><span class="s3">\n</span><span class="s1">fn$2 = elesfn$a = {};</span><span class="s3">\n</span><span class="s1">var defineDimFns = function defineDimFns(opts) {</span><span class="s3">\n  </span><span class="s1">opts.uppercaseName = capitalize(opts.name);</span><span class="s3">\n  </span><span class="s1">opts.autoName = 'auto' + opts.uppercaseName;</span><span class="s3">\n  </span><span class="s1">opts.labelName = 'label' + opts.uppercaseName;</span><span class="s3">\n  </span><span class="s1">opts.outerName = 'outer' + opts.uppercaseName;</span><span class="s3">\n  </span><span class="s1">opts.uppercaseOuterName = capitalize(opts.outerName);</span><span class="s3">\n  </span><span class="s1">fn$2[opts.name] = function dimImpl() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">var cy = _p.cy;</span><span class="s3">\n    </span><span class="s1">var styleEnabled = cy._private.styleEnabled;</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">if (styleEnabled) {</span><span class="s3">\n        </span><span class="s1">if (ele.isParent()) {</span><span class="s3">\n          </span><span class="s1">ele.updateCompoundBounds();</span><span class="s3">\n          </span><span class="s1">return _p[opts.autoName] || 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var d = ele.pstyle(opts.name);</span><span class="s3">\n        </span><span class="s1">switch (d.strValue) {</span><span class="s3">\n          </span><span class="s1">case 'label':</span><span class="s3">\n            </span><span class="s1">ele.recalculateRenderedStyle();</span><span class="s3">\n            </span><span class="s1">return _p.rstyle[opts.labelName] || 0;</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return d.pfValue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">var cy = _p.cy;</span><span class="s3">\n    </span><span class="s1">var styleEnabled = cy._private.styleEnabled;</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">if (styleEnabled) {</span><span class="s3">\n        </span><span class="s1">var dim = ele[opts.name]();</span><span class="s3">\n        </span><span class="s1">var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side</span><span class="s3">\n        </span><span class="s1">var padding = 2 * ele.padding();</span><span class="s3">\n        </span><span class="s1">return dim + border + padding;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">var d = ele[opts.name]();</span><span class="s3">\n      </span><span class="s1">return d * this.cy().zoom();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">var od = ele[opts.outerName]();</span><span class="s3">\n      </span><span class="s1">return od * this.cy().zoom();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">defineDimFns({</span><span class="s3">\n  </span><span class="s1">name: 'width'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">defineDimFns({</span><span class="s3">\n  </span><span class="s1">name: 'height'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$a.padding = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">if (ele.isParent()) {</span><span class="s3">\n    </span><span class="s1">ele.updateCompoundBounds();</span><span class="s3">\n    </span><span class="s1">if (_p.autoPadding !== undefined) {</span><span class="s3">\n      </span><span class="s1">return _p.autoPadding;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return ele.pstyle('padding').pfValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ele.pstyle('padding').pfValue;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$a.paddedHeight = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">return ele.height() + 2 * ele.padding();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$a.paddedWidth = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">return ele.width() + 2 * ele.padding();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var widthHeight = elesfn$a;</span><span class="s3">\n\n</span><span class="s1">var ifEdge = function ifEdge(ele, getValue) {</span><span class="s3">\n  </span><span class="s1">if (ele.isEdge() &amp;&amp; ele.takesUpSpace()) {</span><span class="s3">\n    </span><span class="s1">return getValue(ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {</span><span class="s3">\n  </span><span class="s1">if (ele.isEdge() &amp;&amp; ele.takesUpSpace()) {</span><span class="s3">\n    </span><span class="s1">var cy = ele.cy();</span><span class="s3">\n    </span><span class="s1">return modelToRenderedPosition$1(getPoint(ele), cy.zoom(), cy.pan());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {</span><span class="s3">\n  </span><span class="s1">if (ele.isEdge() &amp;&amp; ele.takesUpSpace()) {</span><span class="s3">\n    </span><span class="s1">var cy = ele.cy();</span><span class="s3">\n    </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">return getPoints(ele).map(function (p) {</span><span class="s3">\n      </span><span class="s1">return modelToRenderedPosition$1(p, zoom, pan);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var controlPoints = function controlPoints(ele) {</span><span class="s3">\n  </span><span class="s1">return ele.renderer().getControlPoints(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var segmentPoints = function segmentPoints(ele) {</span><span class="s3">\n  </span><span class="s1">return ele.renderer().getSegmentPoints(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sourceEndpoint = function sourceEndpoint(ele) {</span><span class="s3">\n  </span><span class="s1">return ele.renderer().getSourceEndpoint(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var targetEndpoint = function targetEndpoint(ele) {</span><span class="s3">\n  </span><span class="s1">return ele.renderer().getTargetEndpoint(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var midpoint = function midpoint(ele) {</span><span class="s3">\n  </span><span class="s1">return ele.renderer().getEdgeMidpoint(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var pts = {</span><span class="s3">\n  </span><span class="s1">controlPoints: {</span><span class="s3">\n    </span><span class="s1">get: controlPoints,</span><span class="s3">\n    </span><span class="s1">mult: true</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">segmentPoints: {</span><span class="s3">\n    </span><span class="s1">get: segmentPoints,</span><span class="s3">\n    </span><span class="s1">mult: true</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">sourceEndpoint: {</span><span class="s3">\n    </span><span class="s1">get: sourceEndpoint</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">targetEndpoint: {</span><span class="s3">\n    </span><span class="s1">get: targetEndpoint</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">midpoint: {</span><span class="s3">\n    </span><span class="s1">get: midpoint</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var renderedName = function renderedName(name) {</span><span class="s3">\n  </span><span class="s1">return 'rendered' + name[0].toUpperCase() + name.substr(1);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var edgePoints = Object.keys(pts).reduce(function (obj, name) {</span><span class="s3">\n  </span><span class="s1">var spec = pts[name];</span><span class="s3">\n  </span><span class="s1">var rName = renderedName(name);</span><span class="s3">\n  </span><span class="s1">obj[name] = function () {</span><span class="s3">\n    </span><span class="s1">return ifEdge(this, spec.get);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (spec.mult) {</span><span class="s3">\n    </span><span class="s1">obj[rName] = function () {</span><span class="s3">\n      </span><span class="s1">return ifEdgeRenderedPositions(this, spec.get);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">obj[rName] = function () {</span><span class="s3">\n      </span><span class="s1">return ifEdgeRenderedPosition(this, spec.get);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">}, {});</span><span class="s3">\n\n</span><span class="s1">var dimensions = extend({}, position, bounds, widthHeight, edgePoints);</span><span class="s3">\n\n</span><span class="s1">/*!</span><span class="s3">\n</span><span class="s1">Event object based on jQuery events, MIT license</span><span class="s3">\n\n</span><span class="s1">https://jquery.org/license/</span><span class="s3">\n</span><span class="s1">https://tldrlegal.com/license/mit-license</span><span class="s3">\n</span><span class="s1">https://github.com/jquery/jquery/blob/master/src/event.js</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var Event = function Event(src, props) {</span><span class="s3">\n  </span><span class="s1">this.recycle(src, props);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function returnFalse() {</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function returnTrue() {</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</span><span class="s3">\n</span><span class="s1">Event.prototype = {</span><span class="s3">\n  </span><span class="s1">instanceString: function instanceString() {</span><span class="s3">\n    </span><span class="s1">return 'event';</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">recycle: function recycle(src, props) {</span><span class="s3">\n    </span><span class="s1">this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;</span><span class="s3">\n    </span><span class="s1">if (src != null &amp;&amp; src.preventDefault) {</span><span class="s3">\n      </span><span class="s1">// Browser Event object</span><span class="s3">\n      </span><span class="s1">this.type = src.type;</span><span class="s3">\n\n      </span><span class="s1">// Events bubbling up the document may have been marked as prevented</span><span class="s3">\n      </span><span class="s1">// by a handler lower down the tree; reflect the correct value.</span><span class="s3">\n      </span><span class="s1">this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;</span><span class="s3">\n    </span><span class="s1">} else if (src != null &amp;&amp; src.type) {</span><span class="s3">\n      </span><span class="s1">// Plain object containing all event details</span><span class="s3">\n      </span><span class="s1">props = src;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Event string</span><span class="s3">\n      </span><span class="s1">this.type = src;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Put explicitly provided properties onto the event object</span><span class="s3">\n    </span><span class="s1">if (props != null) {</span><span class="s3">\n      </span><span class="s1">// more efficient to manually copy fields we use</span><span class="s3">\n      </span><span class="s1">this.originalEvent = props.originalEvent;</span><span class="s3">\n      </span><span class="s1">this.type = props.type != null ? props.type : this.type;</span><span class="s3">\n      </span><span class="s1">this.cy = props.cy;</span><span class="s3">\n      </span><span class="s1">this.target = props.target;</span><span class="s3">\n      </span><span class="s1">this.position = props.position;</span><span class="s3">\n      </span><span class="s1">this.renderedPosition = props.renderedPosition;</span><span class="s3">\n      </span><span class="s1">this.namespace = props.namespace;</span><span class="s3">\n      </span><span class="s1">this.layout = props.layout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.cy != null &amp;&amp; this.position != null &amp;&amp; this.renderedPosition == null) {</span><span class="s3">\n      </span><span class="s1">// create a rendered position based on the passed position</span><span class="s3">\n      </span><span class="s1">var pos = this.position;</span><span class="s3">\n      </span><span class="s1">var zoom = this.cy.zoom();</span><span class="s3">\n      </span><span class="s1">var pan = this.cy.pan();</span><span class="s3">\n      </span><span class="s1">this.renderedPosition = {</span><span class="s3">\n        </span><span class="s1">x: pos.x * zoom + pan.x,</span><span class="s3">\n        </span><span class="s1">y: pos.y * zoom + pan.y</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create a timestamp if incoming event doesn't have one</span><span class="s3">\n    </span><span class="s1">this.timeStamp = src &amp;&amp; src.timeStamp || Date.now();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">preventDefault: function preventDefault() {</span><span class="s3">\n    </span><span class="s1">this.isDefaultPrevented = returnTrue;</span><span class="s3">\n    </span><span class="s1">var e = this.originalEvent;</span><span class="s3">\n    </span><span class="s1">if (!e) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if preventDefault exists run it on the original event</span><span class="s3">\n    </span><span class="s1">if (e.preventDefault) {</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">stopPropagation: function stopPropagation() {</span><span class="s3">\n    </span><span class="s1">this.isPropagationStopped = returnTrue;</span><span class="s3">\n    </span><span class="s1">var e = this.originalEvent;</span><span class="s3">\n    </span><span class="s1">if (!e) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if stopPropagation exists run it on the original event</span><span class="s3">\n    </span><span class="s1">if (e.stopPropagation) {</span><span class="s3">\n      </span><span class="s1">e.stopPropagation();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">stopImmediatePropagation: function stopImmediatePropagation() {</span><span class="s3">\n    </span><span class="s1">this.isImmediatePropagationStopped = returnTrue;</span><span class="s3">\n    </span><span class="s1">this.stopPropagation();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isDefaultPrevented: returnFalse,</span><span class="s3">\n  </span><span class="s1">isPropagationStopped: returnFalse,</span><span class="s3">\n  </span><span class="s1">isImmediatePropagationStopped: returnFalse</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var eventRegex = /^([^.]+)(</span><span class="s3">\\</span><span class="s1">.(?:[^.]+))?$/; // regex for matching event strings (e.g. </span><span class="s3">\&quot;</span><span class="s1">click.namespace</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally</span><span class="s3">\n\n</span><span class="s1">var defaults$8 = {</span><span class="s3">\n  </span><span class="s1">qualifierCompare: function qualifierCompare(q1, q2) {</span><span class="s3">\n    </span><span class="s1">return q1 === q2;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">eventMatches: function eventMatches(/*context, listener, eventObj*/</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">addEventFields: function addEventFields(/*context, evt*/</span><span class="s3">\n  </span><span class="s1">) {},</span><span class="s3">\n  </span><span class="s1">callbackContext: function callbackContext(context /*, listener, eventObj*/) {</span><span class="s3">\n    </span><span class="s1">return context;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">beforeEmit: function beforeEmit(/* context, listener, eventObj */</span><span class="s3">\n  </span><span class="s1">) {},</span><span class="s3">\n  </span><span class="s1">afterEmit: function afterEmit(/* context, listener, eventObj */</span><span class="s3">\n  </span><span class="s1">) {},</span><span class="s3">\n  </span><span class="s1">bubble: function bubble(/*context*/</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">parent: function parent(/*context*/</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">context: null</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var defaultsKeys = Object.keys(defaults$8);</span><span class="s3">\n</span><span class="s1">var emptyOpts = {};</span><span class="s3">\n</span><span class="s1">function Emitter() {</span><span class="s3">\n  </span><span class="s1">var opts = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : emptyOpts;</span><span class="s3">\n  </span><span class="s1">var context = arguments.length &gt; 1 ? arguments[1] : undefined;</span><span class="s3">\n  </span><span class="s1">// micro-optimisation vs Object.assign() -- reduces Element instantiation time</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; defaultsKeys.length; i++) {</span><span class="s3">\n    </span><span class="s1">var key = defaultsKeys[i];</span><span class="s3">\n    </span><span class="s1">this[key] = opts[key] || defaults$8[key];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.context = context || this.context;</span><span class="s3">\n  </span><span class="s1">this.listeners = [];</span><span class="s3">\n  </span><span class="s1">this.emitting = 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var p = Emitter.prototype;</span><span class="s3">\n</span><span class="s1">var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {</span><span class="s3">\n  </span><span class="s1">if (fn$6(qualifier)) {</span><span class="s3">\n    </span><span class="s1">callback = qualifier;</span><span class="s3">\n    </span><span class="s1">qualifier = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (confOverrides) {</span><span class="s3">\n    </span><span class="s1">if (conf == null) {</span><span class="s3">\n      </span><span class="s1">conf = confOverrides;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">conf = extend({}, conf, confOverrides);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var eventList = array(events) ? events : events.split(/</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eventList.length; i++) {</span><span class="s3">\n    </span><span class="s1">var evt = eventList[i];</span><span class="s3">\n    </span><span class="s1">if (emptyString(evt)) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var match = evt.match(eventRegex); // type[.namespace]</span><span class="s3">\n\n    </span><span class="s1">if (match) {</span><span class="s3">\n      </span><span class="s1">var type = match[1];</span><span class="s3">\n      </span><span class="s1">var namespace = match[2] ? match[2] : null;</span><span class="s3">\n      </span><span class="s1">var ret = handler(self, evt, type, namespace, qualifier, callback, conf);</span><span class="s3">\n      </span><span class="s1">if (ret === false) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">} // allow exiting early</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var makeEventObj = function makeEventObj(self, obj) {</span><span class="s3">\n  </span><span class="s1">self.addEventFields(self.context, obj);</span><span class="s3">\n  </span><span class="s1">return new Event(obj.type, obj);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var forEachEventObj = function forEachEventObj(self, handler, events) {</span><span class="s3">\n  </span><span class="s1">if (event(events)) {</span><span class="s3">\n    </span><span class="s1">handler(self, events);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} else if (plainObject(events)) {</span><span class="s3">\n    </span><span class="s1">handler(self, makeEventObj(self, events));</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var eventList = array(events) ? events : events.split(/</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eventList.length; i++) {</span><span class="s3">\n    </span><span class="s1">var evt = eventList[i];</span><span class="s3">\n    </span><span class="s1">if (emptyString(evt)) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var match = evt.match(eventRegex); // type[.namespace]</span><span class="s3">\n\n    </span><span class="s1">if (match) {</span><span class="s3">\n      </span><span class="s1">var type = match[1];</span><span class="s3">\n      </span><span class="s1">var namespace = match[2] ? match[2] : null;</span><span class="s3">\n      </span><span class="s1">var eventObj = makeEventObj(self, {</span><span class="s3">\n        </span><span class="s1">type: type,</span><span class="s3">\n        </span><span class="s1">namespace: namespace,</span><span class="s3">\n        </span><span class="s1">target: self.context</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">handler(self, eventObj);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {</span><span class="s3">\n  </span><span class="s1">forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {</span><span class="s3">\n    </span><span class="s1">if (fn$6(callback)) {</span><span class="s3">\n      </span><span class="s1">self.listeners.push({</span><span class="s3">\n        </span><span class="s1">event: event,</span><span class="s3">\n        </span><span class="s1">// full event string</span><span class="s3">\n        </span><span class="s1">callback: callback,</span><span class="s3">\n        </span><span class="s1">// callback to run</span><span class="s3">\n        </span><span class="s1">type: type,</span><span class="s3">\n        </span><span class="s1">// the event type (e.g. 'click')</span><span class="s3">\n        </span><span class="s1">namespace: namespace,</span><span class="s3">\n        </span><span class="s1">// the event namespace (e.g. </span><span class="s3">\&quot;</span><span class="s1">.foo</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">qualifier: qualifier,</span><span class="s3">\n        </span><span class="s1">// a restriction on whether to match this emitter</span><span class="s3">\n        </span><span class="s1">conf: conf // additional configuration</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, events, qualifier, callback, conf, confOverrides);</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">p.one = function (events, qualifier, callback, conf) {</span><span class="s3">\n  </span><span class="s1">return this.on(events, qualifier, callback, conf, {</span><span class="s3">\n    </span><span class="s1">one: true</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">p.removeListener = p.off = function (events, qualifier, callback, conf) {</span><span class="s3">\n  </span><span class="s1">var _this = this;</span><span class="s3">\n  </span><span class="s1">if (this.emitting !== 0) {</span><span class="s3">\n    </span><span class="s1">this.listeners = copyArray(this.listeners);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var listeners = this.listeners;</span><span class="s3">\n  </span><span class="s1">var _loop = function _loop(i) {</span><span class="s3">\n    </span><span class="s1">var listener = listeners[i];</span><span class="s3">\n    </span><span class="s1">forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {</span><span class="s3">\n      </span><span class="s1">if ((listener.type === type || events === '*') &amp;&amp; (!namespace &amp;&amp; listener.namespace !== '.*' || listener.namespace === namespace) &amp;&amp; (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) &amp;&amp; (!callback || listener.callback === callback)) {</span><span class="s3">\n        </span><span class="s1">listeners.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, events, qualifier, callback, conf);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (var i = listeners.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">_loop(i);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">p.removeAllListeners = function () {</span><span class="s3">\n  </span><span class="s1">return this.removeListener('*');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">p.emit = p.trigger = function (events, extraParams, manualCallback) {</span><span class="s3">\n  </span><span class="s1">var listeners = this.listeners;</span><span class="s3">\n  </span><span class="s1">var numListenersBeforeEmit = listeners.length;</span><span class="s3">\n  </span><span class="s1">this.emitting++;</span><span class="s3">\n  </span><span class="s1">if (!array(extraParams)) {</span><span class="s3">\n    </span><span class="s1">extraParams = [extraParams];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">forEachEventObj(this, function (self, eventObj) {</span><span class="s3">\n    </span><span class="s1">if (manualCallback != null) {</span><span class="s3">\n      </span><span class="s1">listeners = [{</span><span class="s3">\n        </span><span class="s1">event: eventObj.event,</span><span class="s3">\n        </span><span class="s1">type: eventObj.type,</span><span class="s3">\n        </span><span class="s1">namespace: eventObj.namespace,</span><span class="s3">\n        </span><span class="s1">callback: manualCallback</span><span class="s3">\n      </span><span class="s1">}];</span><span class="s3">\n      </span><span class="s1">numListenersBeforeEmit = listeners.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _loop2 = function _loop2() {</span><span class="s3">\n      </span><span class="s1">var listener = listeners[i];</span><span class="s3">\n      </span><span class="s1">if (listener.type === eventObj.type &amp;&amp; (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) &amp;&amp; self.eventMatches(self.context, listener, eventObj)) {</span><span class="s3">\n        </span><span class="s1">var args = [eventObj];</span><span class="s3">\n        </span><span class="s1">if (extraParams != null) {</span><span class="s3">\n          </span><span class="s1">push(args, extraParams);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">self.beforeEmit(self.context, listener, eventObj);</span><span class="s3">\n        </span><span class="s1">if (listener.conf &amp;&amp; listener.conf.one) {</span><span class="s3">\n          </span><span class="s1">self.listeners = self.listeners.filter(function (l) {</span><span class="s3">\n            </span><span class="s1">return l !== listener;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var context = self.callbackContext(self.context, listener, eventObj);</span><span class="s3">\n        </span><span class="s1">var ret = listener.callback.apply(context, args);</span><span class="s3">\n        </span><span class="s1">self.afterEmit(self.context, listener, eventObj);</span><span class="s3">\n        </span><span class="s1">if (ret === false) {</span><span class="s3">\n          </span><span class="s1">eventObj.stopPropagation();</span><span class="s3">\n          </span><span class="s1">eventObj.preventDefault();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // if listener matches</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; numListenersBeforeEmit; i++) {</span><span class="s3">\n      </span><span class="s1">_loop2();</span><span class="s3">\n    </span><span class="s1">} // for listener</span><span class="s3">\n\n    </span><span class="s1">if (self.bubble(self.context) &amp;&amp; !eventObj.isPropagationStopped()) {</span><span class="s3">\n      </span><span class="s1">self.parent(self.context).emit(eventObj, extraParams);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, events);</span><span class="s3">\n  </span><span class="s1">this.emitting--;</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var emitterOptions$1 = {</span><span class="s3">\n  </span><span class="s1">qualifierCompare: function qualifierCompare(selector1, selector2) {</span><span class="s3">\n    </span><span class="s1">if (selector1 == null || selector2 == null) {</span><span class="s3">\n      </span><span class="s1">return selector1 == null &amp;&amp; selector2 == null;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return selector1.sameText(selector2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">eventMatches: function eventMatches(ele, listener, eventObj) {</span><span class="s3">\n    </span><span class="s1">var selector = listener.qualifier;</span><span class="s3">\n    </span><span class="s1">if (selector != null) {</span><span class="s3">\n      </span><span class="s1">return ele !== eventObj.target &amp;&amp; element(eventObj.target) &amp;&amp; selector.matches(eventObj.target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">addEventFields: function addEventFields(ele, evt) {</span><span class="s3">\n    </span><span class="s1">evt.cy = ele.cy();</span><span class="s3">\n    </span><span class="s1">evt.target = ele;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">callbackContext: function callbackContext(ele, listener, eventObj) {</span><span class="s3">\n    </span><span class="s1">return listener.qualifier != null ? eventObj.target : ele;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {</span><span class="s3">\n    </span><span class="s1">if (listener.conf &amp;&amp; listener.conf.once) {</span><span class="s3">\n      </span><span class="s1">listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">bubble: function bubble() {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">parent: function parent(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.isChild() ? ele.parent() : ele.cy();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var argSelector$1 = function argSelector(arg) {</span><span class="s3">\n  </span><span class="s1">if (string(arg)) {</span><span class="s3">\n    </span><span class="s1">return new Selector(arg);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return arg;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var elesfn$9 = {</span><span class="s3">\n  </span><span class="s1">createEmitter: function createEmitter() {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">var _p = ele._private;</span><span class="s3">\n      </span><span class="s1">if (!_p.emitter) {</span><span class="s3">\n        </span><span class="s1">_p.emitter = new Emitter(emitterOptions$1, ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">emitter: function emitter() {</span><span class="s3">\n    </span><span class="s1">return this._private.emitter;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">on: function on(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">var argSel = argSelector$1(selector);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">ele.emitter().on(events, argSel, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeListener: function removeListener(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">var argSel = argSelector$1(selector);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">ele.emitter().removeListener(events, argSel, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeAllListeners: function removeAllListeners() {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">ele.emitter().removeAllListeners();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">one: function one(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">var argSel = argSelector$1(selector);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">ele.emitter().one(events, argSel, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">once: function once(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">var argSel = argSelector$1(selector);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">ele.emitter().on(events, argSel, callback, {</span><span class="s3">\n        </span><span class="s1">once: true,</span><span class="s3">\n        </span><span class="s1">onceCollection: this</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">emit: function emit(events, extraParams) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">ele.emitter().emit(events, extraParams);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">emitAndNotify: function emitAndNotify(event, extraParams) {</span><span class="s3">\n    </span><span class="s1">// for internal use only</span><span class="s3">\n    </span><span class="s1">if (this.length === 0) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // empty collections don't need to notify anything</span><span class="s3">\n\n    </span><span class="s1">// notify renderer</span><span class="s3">\n    </span><span class="s1">this.cy().notify(event, this);</span><span class="s3">\n    </span><span class="s1">this.emit(event, extraParams);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">define.eventAliasesOn(elesfn$9);</span><span class="s3">\n\n</span><span class="s1">var elesfn$8 = {</span><span class="s3">\n  </span><span class="s1">nodes: function nodes(selector) {</span><span class="s3">\n    </span><span class="s1">return this.filter(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isNode();</span><span class="s3">\n    </span><span class="s1">}).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">edges: function edges(selector) {</span><span class="s3">\n    </span><span class="s1">return this.filter(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isEdge();</span><span class="s3">\n    </span><span class="s1">}).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// internal helper to get nodes and edges as separate collections with single iteration over elements</span><span class="s3">\n  </span><span class="s1">byGroup: function byGroup() {</span><span class="s3">\n    </span><span class="s1">var nodes = this.spawn();</span><span class="s3">\n    </span><span class="s1">var edges = this.spawn();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n        </span><span class="s1">nodes.push(ele);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">edges.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">nodes: nodes,</span><span class="s3">\n      </span><span class="s1">edges: edges</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">filter: function filter(_filter, thisArg) {</span><span class="s3">\n    </span><span class="s1">if (_filter === undefined) {</span><span class="s3">\n      </span><span class="s1">// check this first b/c it's the most common/performant case</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">} else if (string(_filter) || elementOrCollection(_filter)) {</span><span class="s3">\n      </span><span class="s1">return new Selector(_filter).filter(this);</span><span class="s3">\n    </span><span class="s1">} else if (fn$6(_filter)) {</span><span class="s3">\n      </span><span class="s1">var filterEles = this.spawn();</span><span class="s3">\n      </span><span class="s1">var eles = this;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = eles[i];</span><span class="s3">\n        </span><span class="s1">var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);</span><span class="s3">\n        </span><span class="s1">if (include) {</span><span class="s3">\n          </span><span class="s1">filterEles.push(ele);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return filterEles;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(); // if not handled by above, give 'em an empty collection</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">not: function not(toRemove) {</span><span class="s3">\n    </span><span class="s1">if (!toRemove) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (string(toRemove)) {</span><span class="s3">\n        </span><span class="s1">toRemove = this.filter(toRemove);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var elements = this.spawn();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n        </span><span class="s1">var element = this[i];</span><span class="s3">\n        </span><span class="s1">var remove = toRemove.has(element);</span><span class="s3">\n        </span><span class="s1">if (!remove) {</span><span class="s3">\n          </span><span class="s1">elements.push(element);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return elements;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">absoluteComplement: function absoluteComplement() {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">return cy.mutableElements().not(this);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">intersect: function intersect(other) {</span><span class="s3">\n    </span><span class="s1">// if a selector is specified, then filter by it instead</span><span class="s3">\n    </span><span class="s1">if (string(other)) {</span><span class="s3">\n      </span><span class="s1">var selector = other;</span><span class="s3">\n      </span><span class="s1">return this.filter(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var elements = this.spawn();</span><span class="s3">\n    </span><span class="s1">var col1 = this;</span><span class="s3">\n    </span><span class="s1">var col2 = other;</span><span class="s3">\n    </span><span class="s1">var col1Smaller = this.length &lt; other.length;</span><span class="s3">\n    </span><span class="s1">var colS = col1Smaller ? col1 : col2;</span><span class="s3">\n    </span><span class="s1">var colL = col1Smaller ? col2 : col1;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; colS.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = colS[i];</span><span class="s3">\n      </span><span class="s1">if (colL.has(ele)) {</span><span class="s3">\n        </span><span class="s1">elements.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elements;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">xor: function xor(other) {</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">if (string(other)) {</span><span class="s3">\n      </span><span class="s1">other = cy.$(other);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var elements = this.spawn();</span><span class="s3">\n    </span><span class="s1">var col1 = this;</span><span class="s3">\n    </span><span class="s1">var col2 = other;</span><span class="s3">\n    </span><span class="s1">var add = function add(col, other) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; col.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = col[i];</span><span class="s3">\n        </span><span class="s1">var id = ele._private.data.id;</span><span class="s3">\n        </span><span class="s1">var inOther = other.hasElementWithId(id);</span><span class="s3">\n        </span><span class="s1">if (!inOther) {</span><span class="s3">\n          </span><span class="s1">elements.push(ele);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">add(col1, col2);</span><span class="s3">\n    </span><span class="s1">add(col2, col1);</span><span class="s3">\n    </span><span class="s1">return elements;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">diff: function diff(other) {</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">if (string(other)) {</span><span class="s3">\n      </span><span class="s1">other = cy.$(other);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var left = this.spawn();</span><span class="s3">\n    </span><span class="s1">var right = this.spawn();</span><span class="s3">\n    </span><span class="s1">var both = this.spawn();</span><span class="s3">\n    </span><span class="s1">var col1 = this;</span><span class="s3">\n    </span><span class="s1">var col2 = other;</span><span class="s3">\n    </span><span class="s1">var add = function add(col, other, retEles) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; col.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = col[i];</span><span class="s3">\n        </span><span class="s1">var id = ele._private.data.id;</span><span class="s3">\n        </span><span class="s1">var inOther = other.hasElementWithId(id);</span><span class="s3">\n        </span><span class="s1">if (inOther) {</span><span class="s3">\n          </span><span class="s1">both.merge(ele);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">retEles.push(ele);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">add(col1, col2, left);</span><span class="s3">\n    </span><span class="s1">add(col2, col1, right);</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">left: left,</span><span class="s3">\n      </span><span class="s1">right: right,</span><span class="s3">\n      </span><span class="s1">both: both</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">add: function add(toAdd) {</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">if (!toAdd) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (string(toAdd)) {</span><span class="s3">\n      </span><span class="s1">var selector = toAdd;</span><span class="s3">\n      </span><span class="s1">toAdd = cy.mutableElements().filter(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var elements = this.spawnSelf();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; toAdd.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = toAdd[i];</span><span class="s3">\n      </span><span class="s1">var add = !this.has(ele);</span><span class="s3">\n      </span><span class="s1">if (add) {</span><span class="s3">\n        </span><span class="s1">elements.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elements;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// in place merge on calling collection</span><span class="s3">\n  </span><span class="s1">merge: function merge(toAdd) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var cy = _p.cy;</span><span class="s3">\n    </span><span class="s1">if (!toAdd) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (toAdd &amp;&amp; string(toAdd)) {</span><span class="s3">\n      </span><span class="s1">var selector = toAdd;</span><span class="s3">\n      </span><span class="s1">toAdd = cy.mutableElements().filter(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var map = _p.map;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; toAdd.length; i++) {</span><span class="s3">\n      </span><span class="s1">var toAddEle = toAdd[i];</span><span class="s3">\n      </span><span class="s1">var id = toAddEle._private.data.id;</span><span class="s3">\n      </span><span class="s1">var add = !map.has(id);</span><span class="s3">\n      </span><span class="s1">if (add) {</span><span class="s3">\n        </span><span class="s1">var index = this.length++;</span><span class="s3">\n        </span><span class="s1">this[index] = toAddEle;</span><span class="s3">\n        </span><span class="s1">map.set(id, {</span><span class="s3">\n          </span><span class="s1">ele: toAddEle,</span><span class="s3">\n          </span><span class="s1">index: index</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">unmergeAt: function unmergeAt(i) {</span><span class="s3">\n    </span><span class="s1">var ele = this[i];</span><span class="s3">\n    </span><span class="s1">var id = ele.id();</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var map = _p.map;</span><span class="s3">\n\n    </span><span class="s1">// remove ele</span><span class="s3">\n    </span><span class="s1">this[i] = undefined;</span><span class="s3">\n    </span><span class="s1">map[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](id);</span><span class="s3">\n    </span><span class="s1">var unmergedLastEle = i === this.length - 1;</span><span class="s3">\n\n    </span><span class="s1">// replace empty spot with last ele in collection</span><span class="s3">\n    </span><span class="s1">if (this.length &gt; 1 &amp;&amp; !unmergedLastEle) {</span><span class="s3">\n      </span><span class="s1">var lastEleI = this.length - 1;</span><span class="s3">\n      </span><span class="s1">var lastEle = this[lastEleI];</span><span class="s3">\n      </span><span class="s1">var lastEleId = lastEle._private.data.id;</span><span class="s3">\n      </span><span class="s1">this[lastEleI] = undefined;</span><span class="s3">\n      </span><span class="s1">this[i] = lastEle;</span><span class="s3">\n      </span><span class="s1">map.set(lastEleId, {</span><span class="s3">\n        </span><span class="s1">ele: lastEle,</span><span class="s3">\n        </span><span class="s1">index: i</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// the collection is now 1 ele smaller</span><span class="s3">\n    </span><span class="s1">this.length--;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// remove single ele in place in calling collection</span><span class="s3">\n  </span><span class="s1">unmergeOne: function unmergeOne(ele) {</span><span class="s3">\n    </span><span class="s1">ele = ele[0];</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var id = ele._private.data.id;</span><span class="s3">\n    </span><span class="s1">var map = _p.map;</span><span class="s3">\n    </span><span class="s1">var entry = map.get(id);</span><span class="s3">\n    </span><span class="s1">if (!entry) {</span><span class="s3">\n      </span><span class="s1">return this; // no need to remove</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var i = entry.index;</span><span class="s3">\n    </span><span class="s1">this.unmergeAt(i);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// remove eles in place on calling collection</span><span class="s3">\n  </span><span class="s1">unmerge: function unmerge(toRemove) {</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">if (!toRemove) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (toRemove &amp;&amp; string(toRemove)) {</span><span class="s3">\n      </span><span class="s1">var selector = toRemove;</span><span class="s3">\n      </span><span class="s1">toRemove = cy.mutableElements().filter(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; toRemove.length; i++) {</span><span class="s3">\n      </span><span class="s1">this.unmergeOne(toRemove[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">unmergeBy: function unmergeBy(toRmFn) {</span><span class="s3">\n    </span><span class="s1">for (var i = this.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">if (toRmFn(ele)) {</span><span class="s3">\n        </span><span class="s1">this.unmergeAt(i);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">map: function map(mapFn, thisArg) {</span><span class="s3">\n    </span><span class="s1">var arr = [];</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = eles[i];</span><span class="s3">\n      </span><span class="s1">var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);</span><span class="s3">\n      </span><span class="s1">arr.push(ret);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return arr;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">reduce: function reduce(fn, initialValue) {</span><span class="s3">\n    </span><span class="s1">var val = initialValue;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">val = fn(val, eles[i], i, eles);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return val;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">max: function max(valFn, thisArg) {</span><span class="s3">\n    </span><span class="s1">var max = -Infinity;</span><span class="s3">\n    </span><span class="s1">var maxEle;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = eles[i];</span><span class="s3">\n      </span><span class="s1">var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);</span><span class="s3">\n      </span><span class="s1">if (val &gt; max) {</span><span class="s3">\n        </span><span class="s1">max = val;</span><span class="s3">\n        </span><span class="s1">maxEle = ele;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">value: max,</span><span class="s3">\n      </span><span class="s1">ele: maxEle</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">min: function min(valFn, thisArg) {</span><span class="s3">\n    </span><span class="s1">var min = Infinity;</span><span class="s3">\n    </span><span class="s1">var minEle;</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = eles[i];</span><span class="s3">\n      </span><span class="s1">var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);</span><span class="s3">\n      </span><span class="s1">if (val &lt; min) {</span><span class="s3">\n        </span><span class="s1">min = val;</span><span class="s3">\n        </span><span class="s1">minEle = ele;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">value: min,</span><span class="s3">\n      </span><span class="s1">ele: minEle</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">var fn$1 = elesfn$8;</span><span class="s3">\n</span><span class="s1">fn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;</span><span class="s3">\n</span><span class="s1">fn$1['</span><span class="s3">\\\\</span><span class="s1">'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;</span><span class="s3">\n</span><span class="s1">fn$1['n'] = fn$1['&amp;'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;</span><span class="s3">\n</span><span class="s1">fn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;</span><span class="s3">\n</span><span class="s1">fn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;</span><span class="s3">\n</span><span class="s1">fn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;</span><span class="s3">\n\n</span><span class="s1">var elesfn$7 = {</span><span class="s3">\n  </span><span class="s1">isNode: function isNode() {</span><span class="s3">\n    </span><span class="s1">return this.group() === 'nodes';</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isEdge: function isEdge() {</span><span class="s3">\n    </span><span class="s1">return this.group() === 'edges';</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isLoop: function isLoop() {</span><span class="s3">\n    </span><span class="s1">return this.isEdge() &amp;&amp; this.source()[0] === this.target()[0];</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isSimple: function isSimple() {</span><span class="s3">\n    </span><span class="s1">return this.isEdge() &amp;&amp; this.source()[0] !== this.target()[0];</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">group: function group() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele._private.group;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),</span><span class="s3">\n </span><span class="s1">*  and z-index (low to high).  These styles affect how this applies:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the</span><span class="s3">\n </span><span class="s1">*      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from</span><span class="s3">\n </span><span class="s1">*      root to leaves of the compound graph.  The last drawn is `top`.</span><span class="s3">\n </span><span class="s1">*  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.</span><span class="s3">\n </span><span class="s1">*      `manual` ignores this convention and draws based on the `z-index` value setting.</span><span class="s3">\n </span><span class="s1">*  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher</span><span class="s3">\n </span><span class="s1">*      `z-index` will be drawn on top of an element with a lower `z-index`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var zIndexSort = function zIndexSort(a, b) {</span><span class="s3">\n  </span><span class="s1">var cy = a.cy();</span><span class="s3">\n  </span><span class="s1">var hasCompoundNodes = cy.hasCompoundNodes();</span><span class="s3">\n  </span><span class="s1">function getDepth(ele) {</span><span class="s3">\n    </span><span class="s1">var style = ele.pstyle('z-compound-depth');</span><span class="s3">\n    </span><span class="s1">if (style.value === 'auto') {</span><span class="s3">\n      </span><span class="s1">return hasCompoundNodes ? ele.zDepth() : 0;</span><span class="s3">\n    </span><span class="s1">} else if (style.value === 'bottom') {</span><span class="s3">\n      </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">} else if (style.value === 'top') {</span><span class="s3">\n      </span><span class="s1">return MAX_INT$1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// 'orphan'</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var depthDiff = getDepth(a) - getDepth(b);</span><span class="s3">\n  </span><span class="s1">if (depthDiff !== 0) {</span><span class="s3">\n    </span><span class="s1">return depthDiff;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function getEleDepth(ele) {</span><span class="s3">\n    </span><span class="s1">var style = ele.pstyle('z-index-compare');</span><span class="s3">\n    </span><span class="s1">if (style.value === 'auto') {</span><span class="s3">\n      </span><span class="s1">return ele.isNode() ? 1 : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// 'manual'</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var eleDiff = getEleDepth(a) - getEleDepth(b);</span><span class="s3">\n  </span><span class="s1">if (eleDiff !== 0) {</span><span class="s3">\n    </span><span class="s1">return eleDiff;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;</span><span class="s3">\n  </span><span class="s1">if (zDiff !== 0) {</span><span class="s3">\n    </span><span class="s1">return zDiff;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// compare indices in the core (order added to graph w/ last on top)</span><span class="s3">\n  </span><span class="s1">return a.poolIndex() - b.poolIndex();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var elesfn$6 = {</span><span class="s3">\n  </span><span class="s1">forEach: function forEach(fn, thisArg) {</span><span class="s3">\n    </span><span class="s1">if (fn$6(fn)) {</span><span class="s3">\n      </span><span class="s1">var N = this.length;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; N; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = this[i];</span><span class="s3">\n        </span><span class="s1">var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);</span><span class="s3">\n        </span><span class="s1">if (ret === false) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">} // exit each early on return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">toArray: function toArray() {</span><span class="s3">\n    </span><span class="s1">var array = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">array.push(this[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return array;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">slice: function slice(start, end) {</span><span class="s3">\n    </span><span class="s1">var array = [];</span><span class="s3">\n    </span><span class="s1">var thisSize = this.length;</span><span class="s3">\n    </span><span class="s1">if (end == null) {</span><span class="s3">\n      </span><span class="s1">end = thisSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (start == null) {</span><span class="s3">\n      </span><span class="s1">start = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (start &lt; 0) {</span><span class="s3">\n      </span><span class="s1">start = thisSize + start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end &lt; 0) {</span><span class="s3">\n      </span><span class="s1">end = thisSize + end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = start; i &gt;= 0 &amp;&amp; i &lt; end &amp;&amp; i &lt; thisSize; i++) {</span><span class="s3">\n      </span><span class="s1">array.push(this[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(array);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">size: function size() {</span><span class="s3">\n    </span><span class="s1">return this.length;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">eq: function eq(i) {</span><span class="s3">\n    </span><span class="s1">return this[i] || this.spawn();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">first: function first() {</span><span class="s3">\n    </span><span class="s1">return this[0] || this.spawn();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">last: function last() {</span><span class="s3">\n    </span><span class="s1">return this[this.length - 1] || this.spawn();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">empty: function empty() {</span><span class="s3">\n    </span><span class="s1">return this.length === 0;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">nonempty: function nonempty() {</span><span class="s3">\n    </span><span class="s1">return !this.empty();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">sort: function sort(sortFn) {</span><span class="s3">\n    </span><span class="s1">if (!fn$6(sortFn)) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var sorted = this.toArray().sort(sortFn);</span><span class="s3">\n    </span><span class="s1">return this.spawn(sorted);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">sortByZIndex: function sortByZIndex() {</span><span class="s3">\n    </span><span class="s1">return this.sort(zIndexSort);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">zDepth: function zDepth() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (!ele) {</span><span class="s3">\n      </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let cy = ele.cy();</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">var group = _p.group;</span><span class="s3">\n    </span><span class="s1">if (group === 'nodes') {</span><span class="s3">\n      </span><span class="s1">var depth = _p.data.parent ? ele.parents().size() : 0;</span><span class="s3">\n      </span><span class="s1">if (!ele.isParent()) {</span><span class="s3">\n        </span><span class="s1">return MAX_INT$1 - 1; // childless nodes always on top</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return depth;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var src = _p.source;</span><span class="s3">\n      </span><span class="s1">var tgt = _p.target;</span><span class="s3">\n      </span><span class="s1">var srcDepth = src.zDepth();</span><span class="s3">\n      </span><span class="s1">var tgtDepth = tgt.zDepth();</span><span class="s3">\n      </span><span class="s1">return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$6.each = elesfn$6.forEach;</span><span class="s3">\n</span><span class="s1">var defineSymbolIterator = function defineSymbolIterator() {</span><span class="s3">\n  </span><span class="s1">var typeofUndef = </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">var isIteratorSupported = (typeof Symbol === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: _typeof(Symbol)) != typeofUndef &amp;&amp; _typeof(Symbol.iterator) != typeofUndef;</span><span class="s3">\n  </span><span class="s1">if (isIteratorSupported) {</span><span class="s3">\n    </span><span class="s1">elesfn$6[Symbol.iterator] = function () {</span><span class="s3">\n      </span><span class="s1">var _this = this;</span><span class="s3">\n      </span><span class="s1">var entry = {</span><span class="s3">\n        </span><span class="s1">value: undefined,</span><span class="s3">\n        </span><span class="s1">done: false</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var i = 0;</span><span class="s3">\n      </span><span class="s1">var length = this.length;</span><span class="s3">\n      </span><span class="s1">return _defineProperty$1({</span><span class="s3">\n        </span><span class="s1">next: function next() {</span><span class="s3">\n          </span><span class="s1">if (i &lt; length) {</span><span class="s3">\n            </span><span class="s1">entry.value = _this[i++];</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">entry.value = undefined;</span><span class="s3">\n            </span><span class="s1">entry.done = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return entry;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, Symbol.iterator, function () {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">defineSymbolIterator();</span><span class="s3">\n\n</span><span class="s1">var getLayoutDimensionOptions = defaults$g({</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var elesfn$5 = {</span><span class="s3">\n  </span><span class="s1">// Calculates and returns node dimensions { x, y } based on options given</span><span class="s3">\n  </span><span class="s1">layoutDimensions: function layoutDimensions(options) {</span><span class="s3">\n    </span><span class="s1">options = getLayoutDimensionOptions(options);</span><span class="s3">\n    </span><span class="s1">var dims;</span><span class="s3">\n    </span><span class="s1">if (!this.takesUpSpace()) {</span><span class="s3">\n      </span><span class="s1">dims = {</span><span class="s3">\n        </span><span class="s1">w: 0,</span><span class="s3">\n        </span><span class="s1">h: 0</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else if (options.nodeDimensionsIncludeLabels) {</span><span class="s3">\n      </span><span class="s1">var bbDim = this.boundingBox();</span><span class="s3">\n      </span><span class="s1">dims = {</span><span class="s3">\n        </span><span class="s1">w: bbDim.w,</span><span class="s3">\n        </span><span class="s1">h: bbDim.h</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">dims = {</span><span class="s3">\n        </span><span class="s1">w: this.outerWidth(),</span><span class="s3">\n        </span><span class="s1">h: this.outerHeight()</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// sanitise the dimensions for external layouts (avoid division by zero)</span><span class="s3">\n    </span><span class="s1">if (dims.w === 0 || dims.h === 0) {</span><span class="s3">\n      </span><span class="s1">dims.w = dims.h = 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return dims;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// using standard layout options, apply position function (w/ or w/o animation)</span><span class="s3">\n  </span><span class="s1">layoutPositions: function layoutPositions(layout, options, fn) {</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes().filter(function (n) {</span><span class="s3">\n      </span><span class="s1">return !n.isParent();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var layoutEles = options.eles; // nodes &amp; edges</span><span class="s3">\n    </span><span class="s1">var getMemoizeKey = function getMemoizeKey(node) {</span><span class="s3">\n      </span><span class="s1">return node.id();</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function</span><span class="s3">\n\n    </span><span class="s1">layout.emit({</span><span class="s3">\n      </span><span class="s1">type: 'layoutstart',</span><span class="s3">\n      </span><span class="s1">layout: layout</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">layout.animations = [];</span><span class="s3">\n    </span><span class="s1">var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {</span><span class="s3">\n      </span><span class="s1">var center = {</span><span class="s3">\n        </span><span class="s1">x: nodesBb.x1 + nodesBb.w / 2,</span><span class="s3">\n        </span><span class="s1">y: nodesBb.y1 + nodesBb.h / 2</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var spacingVector = {</span><span class="s3">\n        </span><span class="s1">// scale from center of bounding box (not necessarily 0,0)</span><span class="s3">\n        </span><span class="s1">x: (pos.x - center.x) * spacing,</span><span class="s3">\n        </span><span class="s1">y: (pos.y - center.y) * spacing</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: center.x + spacingVector.x,</span><span class="s3">\n        </span><span class="s1">y: center.y + spacingVector.y</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var useSpacingFactor = options.spacingFactor &amp;&amp; options.spacingFactor !== 1;</span><span class="s3">\n    </span><span class="s1">var spacingBb = function spacingBb() {</span><span class="s3">\n      </span><span class="s1">if (!useSpacingFactor) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var bb = makeBoundingBox();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">var node = nodes[i];</span><span class="s3">\n        </span><span class="s1">var pos = fnMem(node, i);</span><span class="s3">\n        </span><span class="s1">expandBoundingBoxByPoint(bb, pos.x, pos.y);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return bb;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var bb = spacingBb();</span><span class="s3">\n    </span><span class="s1">var getFinalPos = memoize(function (node, i) {</span><span class="s3">\n      </span><span class="s1">var newPos = fnMem(node, i);</span><span class="s3">\n      </span><span class="s1">if (useSpacingFactor) {</span><span class="s3">\n        </span><span class="s1">var spacing = Math.abs(options.spacingFactor);</span><span class="s3">\n        </span><span class="s1">newPos = calculateSpacing(spacing, bb, newPos);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (options.transform != null) {</span><span class="s3">\n        </span><span class="s1">newPos = options.transform(node, newPos);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return newPos;</span><span class="s3">\n    </span><span class="s1">}, getMemoizeKey);</span><span class="s3">\n    </span><span class="s1">if (options.animate) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">var node = nodes[i];</span><span class="s3">\n        </span><span class="s1">var newPos = getFinalPos(node, i);</span><span class="s3">\n        </span><span class="s1">var animateNode = options.animateFilter == null || options.animateFilter(node, i);</span><span class="s3">\n        </span><span class="s1">if (animateNode) {</span><span class="s3">\n          </span><span class="s1">var ani = node.animation({</span><span class="s3">\n            </span><span class="s1">position: newPos,</span><span class="s3">\n            </span><span class="s1">duration: options.animationDuration,</span><span class="s3">\n            </span><span class="s1">easing: options.animationEasing</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">layout.animations.push(ani);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">node.position(newPos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (options.fit) {</span><span class="s3">\n        </span><span class="s1">var fitAni = cy.animation({</span><span class="s3">\n          </span><span class="s1">fit: {</span><span class="s3">\n            </span><span class="s1">boundingBox: layoutEles.boundingBoxAt(getFinalPos),</span><span class="s3">\n            </span><span class="s1">padding: options.padding</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">duration: options.animationDuration,</span><span class="s3">\n          </span><span class="s1">easing: options.animationEasing</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">layout.animations.push(fitAni);</span><span class="s3">\n      </span><span class="s1">} else if (options.zoom !== undefined &amp;&amp; options.pan !== undefined) {</span><span class="s3">\n        </span><span class="s1">var zoomPanAni = cy.animation({</span><span class="s3">\n          </span><span class="s1">zoom: options.zoom,</span><span class="s3">\n          </span><span class="s1">pan: options.pan,</span><span class="s3">\n          </span><span class="s1">duration: options.animationDuration,</span><span class="s3">\n          </span><span class="s1">easing: options.animationEasing</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">layout.animations.push(zoomPanAni);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">layout.animations.forEach(function (ani) {</span><span class="s3">\n        </span><span class="s1">return ani.play();</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">layout.one('layoutready', options.ready);</span><span class="s3">\n      </span><span class="s1">layout.emit({</span><span class="s3">\n        </span><span class="s1">type: 'layoutready',</span><span class="s3">\n        </span><span class="s1">layout: layout</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">Promise$1.all(layout.animations.map(function (ani) {</span><span class="s3">\n        </span><span class="s1">return ani.promise();</span><span class="s3">\n      </span><span class="s1">})).then(function () {</span><span class="s3">\n        </span><span class="s1">layout.one('layoutstop', options.stop);</span><span class="s3">\n        </span><span class="s1">layout.emit({</span><span class="s3">\n          </span><span class="s1">type: 'layoutstop',</span><span class="s3">\n          </span><span class="s1">layout: layout</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">nodes.positions(getFinalPos);</span><span class="s3">\n      </span><span class="s1">if (options.fit) {</span><span class="s3">\n        </span><span class="s1">cy.fit(options.eles, options.padding);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (options.zoom != null) {</span><span class="s3">\n        </span><span class="s1">cy.zoom(options.zoom);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (options.pan) {</span><span class="s3">\n        </span><span class="s1">cy.pan(options.pan);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">layout.one('layoutready', options.ready);</span><span class="s3">\n      </span><span class="s1">layout.emit({</span><span class="s3">\n        </span><span class="s1">type: 'layoutready',</span><span class="s3">\n        </span><span class="s1">layout: layout</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">layout.one('layoutstop', options.stop);</span><span class="s3">\n      </span><span class="s1">layout.emit({</span><span class="s3">\n        </span><span class="s1">type: 'layoutstop',</span><span class="s3">\n        </span><span class="s1">layout: layout</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">layout: function layout(options) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">return cy.makeLayout(extend({}, options, {</span><span class="s3">\n      </span><span class="s1">eles: this</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases:</span><span class="s3">\n</span><span class="s1">elesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;</span><span class="s3">\n\n</span><span class="s1">function styleCache(key, fn, ele) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var cache = _p.styleCache = _p.styleCache || [];</span><span class="s3">\n  </span><span class="s1">var val;</span><span class="s3">\n  </span><span class="s1">if ((val = cache[key]) != null) {</span><span class="s3">\n    </span><span class="s1">return val;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">val = cache[key] = fn(ele);</span><span class="s3">\n    </span><span class="s1">return val;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cacheStyleFunction(key, fn) {</span><span class="s3">\n  </span><span class="s1">key = hashString(key);</span><span class="s3">\n  </span><span class="s1">return function cachedStyleFunction(ele) {</span><span class="s3">\n    </span><span class="s1">return styleCache(key, fn, ele);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cachePrototypeStyleFunction(key, fn) {</span><span class="s3">\n  </span><span class="s1">key = hashString(key);</span><span class="s3">\n  </span><span class="s1">var selfFn = function selfFn(ele) {</span><span class="s3">\n    </span><span class="s1">return fn.call(ele);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return function cachedPrototypeStyleFunction() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return styleCache(key, selfFn, ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var elesfn$4 = {</span><span class="s3">\n  </span><span class="s1">recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var renderer = cy.renderer();</span><span class="s3">\n    </span><span class="s1">var styleEnabled = cy.styleEnabled();</span><span class="s3">\n    </span><span class="s1">if (renderer &amp;&amp; styleEnabled) {</span><span class="s3">\n      </span><span class="s1">renderer.recalculateRenderedStyle(this, useCache);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">dirtyStyleCache: function dirtyStyleCache() {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">var dirty = function dirty(ele) {</span><span class="s3">\n      </span><span class="s1">return ele._private.styleCache = null;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (cy.hasCompoundNodes()) {</span><span class="s3">\n      </span><span class="s1">var eles;</span><span class="s3">\n      </span><span class="s1">eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());</span><span class="s3">\n      </span><span class="s1">eles.merge(eles.connectedEdges());</span><span class="s3">\n      </span><span class="s1">eles.forEach(dirty);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.forEach(function (ele) {</span><span class="s3">\n        </span><span class="s1">dirty(ele);</span><span class="s3">\n        </span><span class="s1">ele.connectedEdges().forEach(dirty);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// fully updates (recalculates) the style for the elements</span><span class="s3">\n  </span><span class="s1">updateStyle: function updateStyle(notifyRenderer) {</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cy.batching()) {</span><span class="s3">\n      </span><span class="s1">var bEles = cy._private.batchStyleEles;</span><span class="s3">\n      </span><span class="s1">bEles.merge(this);</span><span class="s3">\n      </span><span class="s1">return this; // chaining and exit early when batching</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var hasCompounds = cy.hasCompoundNodes();</span><span class="s3">\n    </span><span class="s1">var updatedEles = this;</span><span class="s3">\n    </span><span class="s1">notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;</span><span class="s3">\n    </span><span class="s1">if (hasCompounds) {</span><span class="s3">\n      </span><span class="s1">// then add everything up and down for compound selector checks</span><span class="s3">\n      </span><span class="s1">updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let changedEles = style.apply( updatedEles );</span><span class="s3">\n    </span><span class="s1">var changedEles = updatedEles;</span><span class="s3">\n    </span><span class="s1">if (notifyRenderer) {</span><span class="s3">\n      </span><span class="s1">changedEles.emitAndNotify('style'); // let renderer know we changed style</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">changedEles.emit('style'); // just fire the event</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updatedEles.forEach(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele._private.styleDirty = true;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// private: clears dirty flag and recalculates style</span><span class="s3">\n  </span><span class="s1">cleanStyle: function cleanStyle() {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">if (ele._private.styleDirty) {</span><span class="s3">\n        </span><span class="s1">// n.b. this flag should be set before apply() to avoid potential infinite recursion</span><span class="s3">\n        </span><span class="s1">ele._private.styleDirty = false;</span><span class="s3">\n        </span><span class="s1">cy.style().apply(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// get the internal parsed style object for the specified property</span><span class="s3">\n  </span><span class="s1">parsedStyle: function parsedStyle(property) {</span><span class="s3">\n    </span><span class="s1">var includeNonDefault = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var cy = ele.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">// this.cleanStyle();</span><span class="s3">\n\n      </span><span class="s1">// Inline the important part of cleanStyle(), for raw performance</span><span class="s3">\n      </span><span class="s1">if (ele._private.styleDirty) {</span><span class="s3">\n        </span><span class="s1">// n.b. this flag should be set before apply() to avoid potential infinite recursion</span><span class="s3">\n        </span><span class="s1">ele._private.styleDirty = false;</span><span class="s3">\n        </span><span class="s1">cy.style().apply(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var overriddenStyle = ele._private.style[property];</span><span class="s3">\n      </span><span class="s1">if (overriddenStyle != null) {</span><span class="s3">\n        </span><span class="s1">return overriddenStyle;</span><span class="s3">\n      </span><span class="s1">} else if (includeNonDefault) {</span><span class="s3">\n        </span><span class="s1">return cy.style().getDefaultProperty(property);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">numericStyle: function numericStyle(property) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (!ele.cy().styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">var pstyle = ele.pstyle(property);</span><span class="s3">\n      </span><span class="s1">return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">numericStyleUnits: function numericStyleUnits(property) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (!ele.cy().styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.pstyle(property).units;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// get the specified css property as a rendered value (i.e. on-screen value)</span><span class="s3">\n  </span><span class="s1">// or get the whole rendered style if no property specified (NB doesn't allow setting)</span><span class="s3">\n  </span><span class="s1">renderedStyle: function renderedStyle(property) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">return cy.style().getRenderedStyle(ele, property);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// read the calculated css style of the element or override the style (via a bypass)</span><span class="s3">\n  </span><span class="s1">style: function style(name, value) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var updateTransitions = false;</span><span class="s3">\n    </span><span class="s1">var style = cy.style();</span><span class="s3">\n    </span><span class="s1">if (plainObject(name)) {</span><span class="s3">\n      </span><span class="s1">// then extend the bypass</span><span class="s3">\n      </span><span class="s1">var props = name;</span><span class="s3">\n      </span><span class="s1">style.applyBypass(this, props, updateTransitions);</span><span class="s3">\n      </span><span class="s1">this.emitAndNotify('style'); // let the renderer know we've updated style</span><span class="s3">\n    </span><span class="s1">} else if (string(name)) {</span><span class="s3">\n      </span><span class="s1">if (value === undefined) {</span><span class="s3">\n        </span><span class="s1">// then get the property from the style</span><span class="s3">\n        </span><span class="s1">var ele = this[0];</span><span class="s3">\n        </span><span class="s1">if (ele) {</span><span class="s3">\n          </span><span class="s1">return style.getStylePropertyValue(ele, name);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// empty collection =&gt; can't get any value</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// then set the bypass with the property value</span><span class="s3">\n        </span><span class="s1">style.applyBypass(this, name, value, updateTransitions);</span><span class="s3">\n        </span><span class="s1">this.emitAndNotify('style'); // let the renderer know we've updated style</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (name === undefined) {</span><span class="s3">\n      </span><span class="s1">var _ele = this[0];</span><span class="s3">\n      </span><span class="s1">if (_ele) {</span><span class="s3">\n        </span><span class="s1">return style.getRawStyle(_ele);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// empty collection =&gt; can't get any value</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeStyle: function removeStyle(names) {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var updateTransitions = false;</span><span class="s3">\n    </span><span class="s1">var style = cy.style();</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">if (names === undefined) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = eles[i];</span><span class="s3">\n        </span><span class="s1">style.removeAllBypasses(ele, updateTransitions);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">names = names.split(/</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; eles.length; _i++) {</span><span class="s3">\n        </span><span class="s1">var _ele2 = eles[_i];</span><span class="s3">\n        </span><span class="s1">style.removeBypasses(_ele2, names, updateTransitions);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.emitAndNotify('style'); // let the renderer know we've updated style</span><span class="s3">\n\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">show: function show() {</span><span class="s3">\n    </span><span class="s1">this.css('display', 'element');</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hide: function hide() {</span><span class="s3">\n    </span><span class="s1">this.css('display', 'none');</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">effectiveOpacity: function effectiveOpacity() {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var hasCompoundNodes = cy.hasCompoundNodes();</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">var _p = ele._private;</span><span class="s3">\n      </span><span class="s1">var parentOpacity = ele.pstyle('opacity').value;</span><span class="s3">\n      </span><span class="s1">if (!hasCompoundNodes) {</span><span class="s3">\n        </span><span class="s1">return parentOpacity;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var parents = !_p.data.parent ? null : ele.parents();</span><span class="s3">\n      </span><span class="s1">if (parents) {</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; parents.length; i++) {</span><span class="s3">\n          </span><span class="s1">var parent = parents[i];</span><span class="s3">\n          </span><span class="s1">var opacity = parent.pstyle('opacity').value;</span><span class="s3">\n          </span><span class="s1">parentOpacity = opacity * parentOpacity;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return parentOpacity;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">transparent: function transparent() {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var hasCompoundNodes = ele.cy().hasCompoundNodes();</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">if (!hasCompoundNodes) {</span><span class="s3">\n        </span><span class="s1">return ele.pstyle('opacity').value === 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return ele.effectiveOpacity() === 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">backgrounding: function backgrounding() {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">return ele._private.backgrounding ? true : false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function checkCompound(ele, parentOk) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var parents = _p.data.parent ? ele.parents() : null;</span><span class="s3">\n  </span><span class="s1">if (parents) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; parents.length; i++) {</span><span class="s3">\n      </span><span class="s1">var parent = parents[i];</span><span class="s3">\n      </span><span class="s1">if (!parentOk(parent)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defineDerivedStateFunction(specs) {</span><span class="s3">\n  </span><span class="s1">var ok = specs.ok;</span><span class="s3">\n  </span><span class="s1">var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;</span><span class="s3">\n  </span><span class="s1">var parentOk = specs.parentOk || specs.ok;</span><span class="s3">\n  </span><span class="s1">return function () {</span><span class="s3">\n    </span><span class="s1">var cy = this.cy();</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var hasCompoundNodes = cy.hasCompoundNodes();</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">var _p = ele._private;</span><span class="s3">\n      </span><span class="s1">if (!ok(ele)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n        </span><span class="s1">return !hasCompoundNodes || checkCompound(ele, parentOk);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var src = _p.source;</span><span class="s3">\n        </span><span class="s1">var tgt = _p.target;</span><span class="s3">\n        </span><span class="s1">return edgeOkViaNode(src) &amp;&amp; (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) &amp;&amp; (src === tgt || edgeOkViaNode(tgt) &amp;&amp; (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {</span><span class="s3">\n  </span><span class="s1">return ele.pstyle('display').value === 'element' &amp;&amp; ele.width() !== 0 &amp;&amp; (ele.isNode() ? ele.height() !== 0 : true);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({</span><span class="s3">\n  </span><span class="s1">ok: eleTakesUpSpace</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {</span><span class="s3">\n  </span><span class="s1">return ele.pstyle('events').value === 'yes' &amp;&amp; ele.pstyle('visibility').value === 'visible' &amp;&amp; eleTakesUpSpace(ele);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {</span><span class="s3">\n  </span><span class="s1">return parent.pstyle('visibility').value === 'visible' &amp;&amp; eleTakesUpSpace(parent);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({</span><span class="s3">\n  </span><span class="s1">ok: eleInteractive,</span><span class="s3">\n  </span><span class="s1">parentOk: parentInteractive,</span><span class="s3">\n  </span><span class="s1">edgeOkViaNode: eleTakesUpSpace</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">elesfn$4.noninteractive = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.interactive();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var eleVisible = cacheStyleFunction('eleVisible', function (ele) {</span><span class="s3">\n  </span><span class="s1">return ele.pstyle('visibility').value === 'visible' &amp;&amp; ele.pstyle('opacity').pfValue !== 0 &amp;&amp; eleTakesUpSpace(ele);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var edgeVisibleViaNode = eleTakesUpSpace;</span><span class="s3">\n</span><span class="s1">elesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({</span><span class="s3">\n  </span><span class="s1">ok: eleVisible,</span><span class="s3">\n  </span><span class="s1">edgeOkViaNode: edgeVisibleViaNode</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">elesfn$4.hidden = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">return !ele.visible();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {</span><span class="s3">\n  </span><span class="s1">if (!this.cy().styleEnabled()) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return !this.removed() &amp;&amp; this.pstyle('curve-style').value === 'bezier' &amp;&amp; this.takesUpSpace();</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$4.bypass = elesfn$4.css = elesfn$4.style;</span><span class="s3">\n</span><span class="s1">elesfn$4.renderedCss = elesfn$4.renderedStyle;</span><span class="s3">\n</span><span class="s1">elesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;</span><span class="s3">\n</span><span class="s1">elesfn$4.pstyle = elesfn$4.parsedStyle;</span><span class="s3">\n\n</span><span class="s1">var elesfn$3 = {};</span><span class="s3">\n</span><span class="s1">function defineSwitchFunction(params) {</span><span class="s3">\n  </span><span class="s1">return function () {</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">var changedEles = [];</span><span class="s3">\n\n    </span><span class="s1">// e.g. cy.nodes().select( data, handler )</span><span class="s3">\n    </span><span class="s1">if (args.length === 2) {</span><span class="s3">\n      </span><span class="s1">var data = args[0];</span><span class="s3">\n      </span><span class="s1">var handler = args[1];</span><span class="s3">\n      </span><span class="s1">this.on(params.event, data, handler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// e.g. cy.nodes().select( handler )</span><span class="s3">\n    </span><span class="s1">else if (args.length === 1 &amp;&amp; fn$6(args[0])) {</span><span class="s3">\n      </span><span class="s1">var _handler = args[0];</span><span class="s3">\n      </span><span class="s1">this.on(params.event, _handler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// e.g. cy.nodes().select()</span><span class="s3">\n    </span><span class="s1">// e.g. (private) cy.nodes().select(['tapselect'])</span><span class="s3">\n    </span><span class="s1">else if (args.length === 0 || args.length === 1 &amp;&amp; array(args[0])) {</span><span class="s3">\n      </span><span class="s1">var addlEvents = args.length === 1 ? args[0] : null;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = this[i];</span><span class="s3">\n        </span><span class="s1">var able = !params.ableField || ele._private[params.ableField];</span><span class="s3">\n        </span><span class="s1">var changed = ele._private[params.field] != params.value;</span><span class="s3">\n        </span><span class="s1">if (params.overrideAble) {</span><span class="s3">\n          </span><span class="s1">var overrideAble = params.overrideAble(ele);</span><span class="s3">\n          </span><span class="s1">if (overrideAble !== undefined) {</span><span class="s3">\n            </span><span class="s1">able = overrideAble;</span><span class="s3">\n            </span><span class="s1">if (!overrideAble) {</span><span class="s3">\n              </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">} // to save cycles assume not able for all on override</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (able) {</span><span class="s3">\n          </span><span class="s1">ele._private[params.field] = params.value;</span><span class="s3">\n          </span><span class="s1">if (changed) {</span><span class="s3">\n            </span><span class="s1">changedEles.push(ele);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var changedColl = this.spawn(changedEles);</span><span class="s3">\n      </span><span class="s1">changedColl.updateStyle(); // change of state =&gt; possible change of style</span><span class="s3">\n      </span><span class="s1">changedColl.emit(params.event);</span><span class="s3">\n      </span><span class="s1">if (addlEvents) {</span><span class="s3">\n        </span><span class="s1">changedColl.emit(addlEvents);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defineSwitchSet(params) {</span><span class="s3">\n  </span><span class="s1">elesfn$3[params.field] = function () {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">if (params.overrideField) {</span><span class="s3">\n        </span><span class="s1">var val = params.overrideField(ele);</span><span class="s3">\n        </span><span class="s1">if (val !== undefined) {</span><span class="s3">\n          </span><span class="s1">return val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ele._private[params.field];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">elesfn$3[params.on] = defineSwitchFunction({</span><span class="s3">\n    </span><span class="s1">event: params.on,</span><span class="s3">\n    </span><span class="s1">field: params.field,</span><span class="s3">\n    </span><span class="s1">ableField: params.ableField,</span><span class="s3">\n    </span><span class="s1">overrideAble: params.overrideAble,</span><span class="s3">\n    </span><span class="s1">value: true</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">elesfn$3[params.off] = defineSwitchFunction({</span><span class="s3">\n    </span><span class="s1">event: params.off,</span><span class="s3">\n    </span><span class="s1">field: params.field,</span><span class="s3">\n    </span><span class="s1">ableField: params.ableField,</span><span class="s3">\n    </span><span class="s1">overrideAble: params.overrideAble,</span><span class="s3">\n    </span><span class="s1">value: false</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">defineSwitchSet({</span><span class="s3">\n  </span><span class="s1">field: 'locked',</span><span class="s3">\n  </span><span class="s1">overrideField: function overrideField(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.cy().autolock() ? true : undefined;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">on: 'lock',</span><span class="s3">\n  </span><span class="s1">off: 'unlock'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">defineSwitchSet({</span><span class="s3">\n  </span><span class="s1">field: 'grabbable',</span><span class="s3">\n  </span><span class="s1">overrideField: function overrideField(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">on: 'grabify',</span><span class="s3">\n  </span><span class="s1">off: 'ungrabify'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">defineSwitchSet({</span><span class="s3">\n  </span><span class="s1">field: 'selected',</span><span class="s3">\n  </span><span class="s1">ableField: 'selectable',</span><span class="s3">\n  </span><span class="s1">overrideAble: function overrideAble(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.cy().autounselectify() ? false : undefined;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">on: 'select',</span><span class="s3">\n  </span><span class="s1">off: 'unselect'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">defineSwitchSet({</span><span class="s3">\n  </span><span class="s1">field: 'selectable',</span><span class="s3">\n  </span><span class="s1">overrideField: function overrideField(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.cy().autounselectify() ? false : undefined;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">on: 'selectify',</span><span class="s3">\n  </span><span class="s1">off: 'unselectify'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$3.deselect = elesfn$3.unselect;</span><span class="s3">\n</span><span class="s1">elesfn$3.grabbed = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">return ele._private.grabbed;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">defineSwitchSet({</span><span class="s3">\n  </span><span class="s1">field: 'active',</span><span class="s3">\n  </span><span class="s1">on: 'activate',</span><span class="s3">\n  </span><span class="s1">off: 'unactivate'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">defineSwitchSet({</span><span class="s3">\n  </span><span class="s1">field: 'pannable',</span><span class="s3">\n  </span><span class="s1">on: 'panify',</span><span class="s3">\n  </span><span class="s1">off: 'unpanify'</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$3.inactive = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">return !ele._private.active;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var elesfn$2 = {};</span><span class="s3">\n\n</span><span class="s1">// DAG functions</span><span class="s3">\n</span><span class="s1">////////////////</span><span class="s3">\n\n</span><span class="s1">var defineDagExtremity = function defineDagExtremity(params) {</span><span class="s3">\n  </span><span class="s1">return function dagExtremityImpl(selector) {</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var ret = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = eles[i];</span><span class="s3">\n      </span><span class="s1">if (!ele.isNode()) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var disqualified = false;</span><span class="s3">\n      </span><span class="s1">var edges = ele.connectedEdges();</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; edges.length; j++) {</span><span class="s3">\n        </span><span class="s1">var edge = edges[j];</span><span class="s3">\n        </span><span class="s1">var src = edge.source();</span><span class="s3">\n        </span><span class="s1">var tgt = edge.target();</span><span class="s3">\n        </span><span class="s1">if (params.noIncomingEdges &amp;&amp; tgt === ele &amp;&amp; src !== ele || params.noOutgoingEdges &amp;&amp; src === ele &amp;&amp; tgt !== ele) {</span><span class="s3">\n          </span><span class="s1">disqualified = true;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!disqualified) {</span><span class="s3">\n        </span><span class="s1">ret.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(ret, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var defineDagOneHop = function defineDagOneHop(params) {</span><span class="s3">\n  </span><span class="s1">return function (selector) {</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var oEles = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = eles[i];</span><span class="s3">\n      </span><span class="s1">if (!ele.isNode()) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var edges = ele.connectedEdges();</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; edges.length; j++) {</span><span class="s3">\n        </span><span class="s1">var edge = edges[j];</span><span class="s3">\n        </span><span class="s1">var src = edge.source();</span><span class="s3">\n        </span><span class="s1">var tgt = edge.target();</span><span class="s3">\n        </span><span class="s1">if (params.outgoing &amp;&amp; src === ele) {</span><span class="s3">\n          </span><span class="s1">oEles.push(edge);</span><span class="s3">\n          </span><span class="s1">oEles.push(tgt);</span><span class="s3">\n        </span><span class="s1">} else if (params.incoming &amp;&amp; tgt === ele) {</span><span class="s3">\n          </span><span class="s1">oEles.push(edge);</span><span class="s3">\n          </span><span class="s1">oEles.push(src);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(oEles, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var defineDagAllHops = function defineDagAllHops(params) {</span><span class="s3">\n  </span><span class="s1">return function (selector) {</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">var sEles = [];</span><span class="s3">\n    </span><span class="s1">var sElesIds = {};</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n      </span><span class="s1">var next = params.outgoing ? eles.outgoers() : eles.incomers();</span><span class="s3">\n      </span><span class="s1">if (next.length === 0) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">} // done if none left</span><span class="s3">\n\n      </span><span class="s1">var newNext = false;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; next.length; i++) {</span><span class="s3">\n        </span><span class="s1">var n = next[i];</span><span class="s3">\n        </span><span class="s1">var nid = n.id();</span><span class="s3">\n        </span><span class="s1">if (!sElesIds[nid]) {</span><span class="s3">\n          </span><span class="s1">sElesIds[nid] = true;</span><span class="s3">\n          </span><span class="s1">sEles.push(n);</span><span class="s3">\n          </span><span class="s1">newNext = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!newNext) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">} // done if touched all outgoers already</span><span class="s3">\n\n      </span><span class="s1">eles = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(sEles, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$2.clearTraversalCache = function () {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">this[i]._private.traversalCache = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">extend(elesfn$2, {</span><span class="s3">\n  </span><span class="s1">// get the root nodes in the DAG</span><span class="s3">\n  </span><span class="s1">roots: defineDagExtremity({</span><span class="s3">\n    </span><span class="s1">noIncomingEdges: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">// get the leaf nodes in the DAG</span><span class="s3">\n  </span><span class="s1">leaves: defineDagExtremity({</span><span class="s3">\n    </span><span class="s1">noOutgoingEdges: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">// normally called children in graph theory</span><span class="s3">\n  </span><span class="s1">// these nodes =edges=&gt; outgoing nodes</span><span class="s3">\n  </span><span class="s1">outgoers: cache(defineDagOneHop({</span><span class="s3">\n    </span><span class="s1">outgoing: true</span><span class="s3">\n  </span><span class="s1">}), 'outgoers'),</span><span class="s3">\n  </span><span class="s1">// aka DAG descendants</span><span class="s3">\n  </span><span class="s1">successors: defineDagAllHops({</span><span class="s3">\n    </span><span class="s1">outgoing: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">// normally called parents in graph theory</span><span class="s3">\n  </span><span class="s1">// these nodes &lt;=edges= incoming nodes</span><span class="s3">\n  </span><span class="s1">incomers: cache(defineDagOneHop({</span><span class="s3">\n    </span><span class="s1">incoming: true</span><span class="s3">\n  </span><span class="s1">}), 'incomers'),</span><span class="s3">\n  </span><span class="s1">// aka DAG ancestors</span><span class="s3">\n  </span><span class="s1">predecessors: defineDagAllHops({</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// Neighbourhood functions</span><span class="s3">\n</span><span class="s1">//////////////////////////</span><span class="s3">\n\n</span><span class="s1">extend(elesfn$2, {</span><span class="s3">\n  </span><span class="s1">neighborhood: cache(function (selector) {</span><span class="s3">\n    </span><span class="s1">var elements = [];</span><span class="s3">\n    </span><span class="s1">var nodes = this.nodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">// for all nodes</span><span class="s3">\n      </span><span class="s1">var node = nodes[i];</span><span class="s3">\n      </span><span class="s1">var connectedEdges = node.connectedEdges();</span><span class="s3">\n\n      </span><span class="s1">// for each connected edge, add the edge and the other node</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; connectedEdges.length; j++) {</span><span class="s3">\n        </span><span class="s1">var edge = connectedEdges[j];</span><span class="s3">\n        </span><span class="s1">var src = edge.source();</span><span class="s3">\n        </span><span class="s1">var tgt = edge.target();</span><span class="s3">\n        </span><span class="s1">var otherNode = node === src ? tgt : src;</span><span class="s3">\n\n        </span><span class="s1">// need check in case of loop</span><span class="s3">\n        </span><span class="s1">if (otherNode.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">elements.push(otherNode[0]); // add node 1 hop away</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// add connected edge</span><span class="s3">\n        </span><span class="s1">elements.push(edge[0]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(elements, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">}, 'neighborhood'),</span><span class="s3">\n  </span><span class="s1">closedNeighborhood: function closedNeighborhood(selector) {</span><span class="s3">\n    </span><span class="s1">return this.neighborhood().add(this).filter(selector);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">openNeighborhood: function openNeighborhood(selector) {</span><span class="s3">\n    </span><span class="s1">return this.neighborhood(selector);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">elesfn$2.neighbourhood = elesfn$2.neighborhood;</span><span class="s3">\n</span><span class="s1">elesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;</span><span class="s3">\n</span><span class="s1">elesfn$2.openNeighbourhood = elesfn$2.openNeighborhood;</span><span class="s3">\n\n</span><span class="s1">// Edge functions</span><span class="s3">\n</span><span class="s1">/////////////////</span><span class="s3">\n\n</span><span class="s1">extend(elesfn$2, {</span><span class="s3">\n  </span><span class="s1">source: cache(function sourceImpl(selector) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var src;</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">src = ele._private.source || ele.cy().collection();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return src &amp;&amp; selector ? src.filter(selector) : src;</span><span class="s3">\n  </span><span class="s1">}, 'source'),</span><span class="s3">\n  </span><span class="s1">target: cache(function targetImpl(selector) {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">var tgt;</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">tgt = ele._private.target || ele.cy().collection();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tgt &amp;&amp; selector ? tgt.filter(selector) : tgt;</span><span class="s3">\n  </span><span class="s1">}, 'target'),</span><span class="s3">\n  </span><span class="s1">sources: defineSourceFunction({</span><span class="s3">\n    </span><span class="s1">attr: 'source'</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">targets: defineSourceFunction({</span><span class="s3">\n    </span><span class="s1">attr: 'target'</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function defineSourceFunction(params) {</span><span class="s3">\n  </span><span class="s1">return function sourceImpl(selector) {</span><span class="s3">\n    </span><span class="s1">var sources = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ele = this[i];</span><span class="s3">\n      </span><span class="s1">var src = ele._private[params.attr];</span><span class="s3">\n      </span><span class="s1">if (src) {</span><span class="s3">\n        </span><span class="s1">sources.push(src);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(sources, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">extend(elesfn$2, {</span><span class="s3">\n  </span><span class="s1">edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),</span><span class="s3">\n  </span><span class="s1">edgesTo: cache(defineEdgesWithFunction({</span><span class="s3">\n    </span><span class="s1">thisIsSrc: true</span><span class="s3">\n  </span><span class="s1">}), 'edgesTo')</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function defineEdgesWithFunction(params) {</span><span class="s3">\n  </span><span class="s1">return function edgesWithImpl(otherNodes) {</span><span class="s3">\n    </span><span class="s1">var elements = [];</span><span class="s3">\n    </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n    </span><span class="s1">var p = params || {};</span><span class="s3">\n\n    </span><span class="s1">// get elements if a selector is specified</span><span class="s3">\n    </span><span class="s1">if (string(otherNodes)) {</span><span class="s3">\n      </span><span class="s1">otherNodes = cy.$(otherNodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var h = 0; h &lt; otherNodes.length; h++) {</span><span class="s3">\n      </span><span class="s1">var edges = otherNodes[h]._private.edges;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n        </span><span class="s1">var edge = edges[i];</span><span class="s3">\n        </span><span class="s1">var edgeData = edge._private.data;</span><span class="s3">\n        </span><span class="s1">var thisToOther = this.hasElementWithId(edgeData.source) &amp;&amp; otherNodes.hasElementWithId(edgeData.target);</span><span class="s3">\n        </span><span class="s1">var otherToThis = otherNodes.hasElementWithId(edgeData.source) &amp;&amp; this.hasElementWithId(edgeData.target);</span><span class="s3">\n        </span><span class="s1">var edgeConnectsThisAndOther = thisToOther || otherToThis;</span><span class="s3">\n        </span><span class="s1">if (!edgeConnectsThisAndOther) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (p.thisIsSrc || p.thisIsTgt) {</span><span class="s3">\n          </span><span class="s1">if (p.thisIsSrc &amp;&amp; !thisToOther) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (p.thisIsTgt &amp;&amp; !otherToThis) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">elements.push(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(elements, true);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">extend(elesfn$2, {</span><span class="s3">\n  </span><span class="s1">connectedEdges: cache(function (selector) {</span><span class="s3">\n    </span><span class="s1">var retEles = [];</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var node = eles[i];</span><span class="s3">\n      </span><span class="s1">if (!node.isNode()) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var edges = node._private.edges;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; edges.length; j++) {</span><span class="s3">\n        </span><span class="s1">var edge = edges[j];</span><span class="s3">\n        </span><span class="s1">retEles.push(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(retEles, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">}, 'connectedEdges'),</span><span class="s3">\n  </span><span class="s1">connectedNodes: cache(function (selector) {</span><span class="s3">\n    </span><span class="s1">var retEles = [];</span><span class="s3">\n    </span><span class="s1">var eles = this;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n      </span><span class="s1">var edge = eles[i];</span><span class="s3">\n      </span><span class="s1">if (!edge.isEdge()) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">retEles.push(edge.source()[0]);</span><span class="s3">\n      </span><span class="s1">retEles.push(edge.target()[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(retEles, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">}, 'connectedNodes'),</span><span class="s3">\n  </span><span class="s1">parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),</span><span class="s3">\n  </span><span class="s1">codirectedEdges: cache(defineParallelEdgesFunction({</span><span class="s3">\n    </span><span class="s1">codirected: true</span><span class="s3">\n  </span><span class="s1">}), 'codirectedEdges')</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function defineParallelEdgesFunction(params) {</span><span class="s3">\n  </span><span class="s1">var defaults = {</span><span class="s3">\n    </span><span class="s1">codirected: false</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">params = extend({}, defaults, params);</span><span class="s3">\n  </span><span class="s1">return function parallelEdgesImpl(selector) {</span><span class="s3">\n    </span><span class="s1">// micro-optimised for renderer</span><span class="s3">\n    </span><span class="s1">var elements = [];</span><span class="s3">\n    </span><span class="s1">var edges = this.edges();</span><span class="s3">\n    </span><span class="s1">var p = params;</span><span class="s3">\n\n    </span><span class="s1">// look at all the edges in the collection</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n      </span><span class="s1">var edge1 = edges[i];</span><span class="s3">\n      </span><span class="s1">var edge1_p = edge1._private;</span><span class="s3">\n      </span><span class="s1">var src1 = edge1_p.source;</span><span class="s3">\n      </span><span class="s1">var srcid1 = src1._private.data.id;</span><span class="s3">\n      </span><span class="s1">var tgtid1 = edge1_p.data.target;</span><span class="s3">\n      </span><span class="s1">var srcEdges1 = src1._private.edges;</span><span class="s3">\n\n      </span><span class="s1">// look at edges connected to the src node of this edge</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; srcEdges1.length; j++) {</span><span class="s3">\n        </span><span class="s1">var edge2 = srcEdges1[j];</span><span class="s3">\n        </span><span class="s1">var edge2data = edge2._private.data;</span><span class="s3">\n        </span><span class="s1">var tgtid2 = edge2data.target;</span><span class="s3">\n        </span><span class="s1">var srcid2 = edge2data.source;</span><span class="s3">\n        </span><span class="s1">var codirected = tgtid2 === tgtid1 &amp;&amp; srcid2 === srcid1;</span><span class="s3">\n        </span><span class="s1">var oppdirected = srcid1 === tgtid2 &amp;&amp; tgtid1 === srcid2;</span><span class="s3">\n        </span><span class="s1">if (p.codirected &amp;&amp; codirected || !p.codirected &amp;&amp; (codirected || oppdirected)) {</span><span class="s3">\n          </span><span class="s1">elements.push(edge2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.spawn(elements, true).filter(selector);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Misc functions</span><span class="s3">\n</span><span class="s1">/////////////////</span><span class="s3">\n\n</span><span class="s1">extend(elesfn$2, {</span><span class="s3">\n  </span><span class="s1">components: function components(root) {</span><span class="s3">\n    </span><span class="s1">var self = this;</span><span class="s3">\n    </span><span class="s1">var cy = self.cy();</span><span class="s3">\n    </span><span class="s1">var visited = cy.collection();</span><span class="s3">\n    </span><span class="s1">var unvisited = root == null ? self.nodes() : root.nodes();</span><span class="s3">\n    </span><span class="s1">var components = [];</span><span class="s3">\n    </span><span class="s1">if (root != null &amp;&amp; unvisited.empty()) {</span><span class="s3">\n      </span><span class="s1">// root may contain only edges</span><span class="s3">\n      </span><span class="s1">unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var visitInComponent = function visitInComponent(node, component) {</span><span class="s3">\n      </span><span class="s1">visited.merge(node);</span><span class="s3">\n      </span><span class="s1">unvisited.unmerge(node);</span><span class="s3">\n      </span><span class="s1">component.merge(node);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (unvisited.empty()) {</span><span class="s3">\n      </span><span class="s1">return self.spawn();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n      </span><span class="s1">// each iteration yields a component</span><span class="s3">\n      </span><span class="s1">var cmpt = cy.collection();</span><span class="s3">\n      </span><span class="s1">components.push(cmpt);</span><span class="s3">\n      </span><span class="s1">var root = unvisited[0];</span><span class="s3">\n      </span><span class="s1">visitInComponent(root, cmpt);</span><span class="s3">\n      </span><span class="s1">self.bfs({</span><span class="s3">\n        </span><span class="s1">directed: false,</span><span class="s3">\n        </span><span class="s1">roots: root,</span><span class="s3">\n        </span><span class="s1">visit: function visit(v) {</span><span class="s3">\n          </span><span class="s1">return visitInComponent(v, cmpt);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">cmpt.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">node.connectedEdges().forEach(function (e) {</span><span class="s3">\n          </span><span class="s1">// connectedEdges() usually cached</span><span class="s3">\n          </span><span class="s1">if (self.has(e) &amp;&amp; cmpt.has(e.source()) &amp;&amp; cmpt.has(e.target())) {</span><span class="s3">\n            </span><span class="s1">// has() is cheap</span><span class="s3">\n            </span><span class="s1">cmpt.merge(e); // forEach() only considers nodes -- sets N at call time</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">_loop();</span><span class="s3">\n    </span><span class="s1">} while (unvisited.length &gt; 0);</span><span class="s3">\n    </span><span class="s1">return components;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">component: function component() {</span><span class="s3">\n    </span><span class="s1">var ele = this[0];</span><span class="s3">\n    </span><span class="s1">return ele.cy().mutableElements().components(ele)[0];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">elesfn$2.componentsOf = elesfn$2.components;</span><span class="s3">\n\n</span><span class="s1">// represents a set of nodes, edges, or both together</span><span class="s3">\n</span><span class="s1">var Collection = function Collection(cy, elements) {</span><span class="s3">\n  </span><span class="s1">var unique = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;</span><span class="s3">\n  </span><span class="s1">var removed = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : false;</span><span class="s3">\n  </span><span class="s1">if (cy === undefined) {</span><span class="s3">\n    </span><span class="s1">error('A collection must have a reference to the core');</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var map = new Map$1();</span><span class="s3">\n  </span><span class="s1">var createdElements = false;</span><span class="s3">\n  </span><span class="s1">if (!elements) {</span><span class="s3">\n    </span><span class="s1">elements = [];</span><span class="s3">\n  </span><span class="s1">} else if (elements.length &gt; 0 &amp;&amp; plainObject(elements[0]) &amp;&amp; !element(elements[0])) {</span><span class="s3">\n    </span><span class="s1">createdElements = true;</span><span class="s3">\n\n    </span><span class="s1">// make elements from json and restore all at once later</span><span class="s3">\n    </span><span class="s1">var eles = [];</span><span class="s3">\n    </span><span class="s1">var elesIds = new Set$1();</span><span class="s3">\n    </span><span class="s1">for (var i = 0, l = elements.length; i &lt; l; i++) {</span><span class="s3">\n      </span><span class="s1">var json = elements[i];</span><span class="s3">\n      </span><span class="s1">if (json.data == null) {</span><span class="s3">\n        </span><span class="s1">json.data = {};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var _data = json.data;</span><span class="s3">\n\n      </span><span class="s1">// make sure newly created elements have valid ids</span><span class="s3">\n      </span><span class="s1">if (_data.id == null) {</span><span class="s3">\n        </span><span class="s1">_data.id = uuid();</span><span class="s3">\n      </span><span class="s1">} else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {</span><span class="s3">\n        </span><span class="s1">continue; // can't create element if prior id already exists</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var ele = new Element(cy, json, false);</span><span class="s3">\n      </span><span class="s1">eles.push(ele);</span><span class="s3">\n      </span><span class="s1">elesIds.add(_data.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">elements = eles;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.length = 0;</span><span class="s3">\n  </span><span class="s1">for (var _i = 0, _l = elements.length; _i &lt; _l; _i++) {</span><span class="s3">\n    </span><span class="s1">var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements</span><span class="s3">\n    </span><span class="s1">if (element$1 == null) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var id = element$1._private.data.id;</span><span class="s3">\n    </span><span class="s1">if (!unique || !map.has(id)) {</span><span class="s3">\n      </span><span class="s1">if (unique) {</span><span class="s3">\n        </span><span class="s1">map.set(id, {</span><span class="s3">\n          </span><span class="s1">index: this.length,</span><span class="s3">\n          </span><span class="s1">ele: element$1</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[this.length] = element$1;</span><span class="s3">\n      </span><span class="s1">this.length++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this._private = {</span><span class="s3">\n    </span><span class="s1">eles: this,</span><span class="s3">\n    </span><span class="s1">cy: cy,</span><span class="s3">\n    </span><span class="s1">get map() {</span><span class="s3">\n      </span><span class="s1">if (this.lazyMap == null) {</span><span class="s3">\n        </span><span class="s1">this.rebuildMap();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this.lazyMap;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set map(m) {</span><span class="s3">\n      </span><span class="s1">this.lazyMap = m;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">rebuildMap: function rebuildMap() {</span><span class="s3">\n      </span><span class="s1">var m = this.lazyMap = new Map$1();</span><span class="s3">\n      </span><span class="s1">var eles = this.eles;</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; eles.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">var _ele = eles[_i2];</span><span class="s3">\n        </span><span class="s1">m.set(_ele.id(), {</span><span class="s3">\n          </span><span class="s1">index: _i2,</span><span class="s3">\n          </span><span class="s1">ele: _ele</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (unique) {</span><span class="s3">\n    </span><span class="s1">this._private.map = map;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// restore the elements if we created them from json</span><span class="s3">\n  </span><span class="s1">if (createdElements &amp;&amp; !removed) {</span><span class="s3">\n    </span><span class="s1">this.restore();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Functions</span><span class="s3">\n</span><span class="s1">////////////////////////////////////////////////////////////////////////////////////////////////////</span><span class="s3">\n\n</span><span class="s1">// keep the prototypes in sync (an element has the same functions as a collection)</span><span class="s3">\n</span><span class="s1">// and use elefn and elesfn as shorthands to the prototypes</span><span class="s3">\n</span><span class="s1">var elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);</span><span class="s3">\n</span><span class="s1">elesfn$1.instanceString = function () {</span><span class="s3">\n  </span><span class="s1">return 'collection';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.spawn = function (eles, unique) {</span><span class="s3">\n  </span><span class="s1">return new Collection(this.cy(), eles, unique);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.spawnSelf = function () {</span><span class="s3">\n  </span><span class="s1">return this.spawn(this);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.cy = function () {</span><span class="s3">\n  </span><span class="s1">return this._private.cy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.renderer = function () {</span><span class="s3">\n  </span><span class="s1">return this._private.cy.renderer();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.element = function () {</span><span class="s3">\n  </span><span class="s1">return this[0];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.collection = function () {</span><span class="s3">\n  </span><span class="s1">if (collection(this)) {</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// an element</span><span class="s3">\n    </span><span class="s1">return new Collection(this._private.cy, [this]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.unique = function () {</span><span class="s3">\n  </span><span class="s1">return new Collection(this._private.cy, this, true);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.hasElementWithId = function (id) {</span><span class="s3">\n  </span><span class="s1">id = '' + id; // id must be string</span><span class="s3">\n\n  </span><span class="s1">return this._private.map.has(id);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.getElementById = function (id) {</span><span class="s3">\n  </span><span class="s1">id = '' + id; // id must be string</span><span class="s3">\n\n  </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n  </span><span class="s1">var entry = this._private.map.get(id);</span><span class="s3">\n  </span><span class="s1">return entry ? entry.ele : new Collection(cy); // get ele or empty collection</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.$id = elesfn$1.getElementById;</span><span class="s3">\n</span><span class="s1">elesfn$1.poolIndex = function () {</span><span class="s3">\n  </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n  </span><span class="s1">var eles = cy._private.elements;</span><span class="s3">\n  </span><span class="s1">var id = this[0]._private.data.id;</span><span class="s3">\n  </span><span class="s1">return eles._private.map.get(id).index;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.indexOf = function (ele) {</span><span class="s3">\n  </span><span class="s1">var id = ele[0]._private.data.id;</span><span class="s3">\n  </span><span class="s1">return this._private.map.get(id).index;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.indexOfId = function (id) {</span><span class="s3">\n  </span><span class="s1">id = '' + id; // id must be string</span><span class="s3">\n\n  </span><span class="s1">return this._private.map.get(id).index;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.json = function (obj) {</span><span class="s3">\n  </span><span class="s1">var ele = this.element();</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">if (ele == null &amp;&amp; obj) {</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">} // can't set to no eles</span><span class="s3">\n\n  </span><span class="s1">if (ele == null) {</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n  </span><span class="s1">} // can't get from no eles</span><span class="s3">\n\n  </span><span class="s1">var p = ele._private;</span><span class="s3">\n  </span><span class="s1">if (plainObject(obj)) {</span><span class="s3">\n    </span><span class="s1">// set</span><span class="s3">\n\n    </span><span class="s1">cy.startBatch();</span><span class="s3">\n    </span><span class="s1">if (obj.data) {</span><span class="s3">\n      </span><span class="s1">ele.data(obj.data);</span><span class="s3">\n      </span><span class="s1">var _data2 = p.data;</span><span class="s3">\n      </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n        </span><span class="s1">// source and target are immutable via data()</span><span class="s3">\n        </span><span class="s1">var move = false;</span><span class="s3">\n        </span><span class="s1">var spec = {};</span><span class="s3">\n        </span><span class="s1">var src = obj.data.source;</span><span class="s3">\n        </span><span class="s1">var tgt = obj.data.target;</span><span class="s3">\n        </span><span class="s1">if (src != null &amp;&amp; src != _data2.source) {</span><span class="s3">\n          </span><span class="s1">spec.source = '' + src; // id must be string</span><span class="s3">\n          </span><span class="s1">move = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (tgt != null &amp;&amp; tgt != _data2.target) {</span><span class="s3">\n          </span><span class="s1">spec.target = '' + tgt; // id must be string</span><span class="s3">\n          </span><span class="s1">move = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (move) {</span><span class="s3">\n          </span><span class="s1">ele = ele.move(spec);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// parent is immutable via data()</span><span class="s3">\n        </span><span class="s1">var newParentValSpecd = 'parent' in obj.data;</span><span class="s3">\n        </span><span class="s1">var parent = obj.data.parent;</span><span class="s3">\n        </span><span class="s1">if (newParentValSpecd &amp;&amp; (parent != null || _data2.parent != null) &amp;&amp; parent != _data2.parent) {</span><span class="s3">\n          </span><span class="s1">if (parent === undefined) {</span><span class="s3">\n            </span><span class="s1">// can't set undefined imperatively, so use null</span><span class="s3">\n            </span><span class="s1">parent = null;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (parent != null) {</span><span class="s3">\n            </span><span class="s1">parent = '' + parent; // id must be string</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">ele = ele.move({</span><span class="s3">\n            </span><span class="s1">parent: parent</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (obj.position) {</span><span class="s3">\n      </span><span class="s1">ele.position(obj.position);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// ignore group -- immutable</span><span class="s3">\n\n    </span><span class="s1">var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {</span><span class="s3">\n      </span><span class="s1">var obj_k = obj[k];</span><span class="s3">\n      </span><span class="s1">if (obj_k != null &amp;&amp; obj_k !== p[k]) {</span><span class="s3">\n        </span><span class="s1">if (obj_k) {</span><span class="s3">\n          </span><span class="s1">ele[trueFnName]();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">ele[falseFnName]();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">checkSwitch('removed', 'remove', 'restore');</span><span class="s3">\n    </span><span class="s1">checkSwitch('selected', 'select', 'unselect');</span><span class="s3">\n    </span><span class="s1">checkSwitch('selectable', 'selectify', 'unselectify');</span><span class="s3">\n    </span><span class="s1">checkSwitch('locked', 'lock', 'unlock');</span><span class="s3">\n    </span><span class="s1">checkSwitch('grabbable', 'grabify', 'ungrabify');</span><span class="s3">\n    </span><span class="s1">checkSwitch('pannable', 'panify', 'unpanify');</span><span class="s3">\n    </span><span class="s1">if (obj.classes != null) {</span><span class="s3">\n      </span><span class="s1">ele.classes(obj.classes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cy.endBatch();</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">} else if (obj === undefined) {</span><span class="s3">\n    </span><span class="s1">// get</span><span class="s3">\n\n    </span><span class="s1">var json = {</span><span class="s3">\n      </span><span class="s1">data: copy(p.data),</span><span class="s3">\n      </span><span class="s1">position: copy(p.position),</span><span class="s3">\n      </span><span class="s1">group: p.group,</span><span class="s3">\n      </span><span class="s1">removed: p.removed,</span><span class="s3">\n      </span><span class="s1">selected: p.selected,</span><span class="s3">\n      </span><span class="s1">selectable: p.selectable,</span><span class="s3">\n      </span><span class="s1">locked: p.locked,</span><span class="s3">\n      </span><span class="s1">grabbable: p.grabbable,</span><span class="s3">\n      </span><span class="s1">pannable: p.pannable,</span><span class="s3">\n      </span><span class="s1">classes: null</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">json.classes = '';</span><span class="s3">\n    </span><span class="s1">var i = 0;</span><span class="s3">\n    </span><span class="s1">p.classes.forEach(function (cls) {</span><span class="s3">\n      </span><span class="s1">return json.classes += i++ === 0 ? cls : ' ' + cls;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return json;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.jsons = function () {</span><span class="s3">\n  </span><span class="s1">var jsons = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = this[i];</span><span class="s3">\n    </span><span class="s1">var json = ele.json();</span><span class="s3">\n    </span><span class="s1">jsons.push(json);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return jsons;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.clone = function () {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy();</span><span class="s3">\n  </span><span class="s1">var elesArr = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = this[i];</span><span class="s3">\n    </span><span class="s1">var json = ele.json();</span><span class="s3">\n    </span><span class="s1">var clone = new Element(cy, json, false); // NB no restore</span><span class="s3">\n\n    </span><span class="s1">elesArr.push(clone);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new Collection(cy, elesArr);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.copy = elesfn$1.clone;</span><span class="s3">\n</span><span class="s1">elesfn$1.restore = function () {</span><span class="s3">\n  </span><span class="s1">var notifyRenderer = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;</span><span class="s3">\n  </span><span class="s1">var addToPool = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var cy = self.cy();</span><span class="s3">\n  </span><span class="s1">var cy_p = cy._private;</span><span class="s3">\n\n  </span><span class="s1">// create arrays of nodes and edges, since we need to</span><span class="s3">\n  </span><span class="s1">// restore the nodes first</span><span class="s3">\n  </span><span class="s1">var nodes = [];</span><span class="s3">\n  </span><span class="s1">var edges = [];</span><span class="s3">\n  </span><span class="s1">var elements;</span><span class="s3">\n  </span><span class="s1">for (var _i3 = 0, l = self.length; _i3 &lt; l; _i3++) {</span><span class="s3">\n    </span><span class="s1">var ele = self[_i3];</span><span class="s3">\n    </span><span class="s1">if (addToPool &amp;&amp; !ele.removed()) {</span><span class="s3">\n      </span><span class="s1">// don't need to handle this ele</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// keep nodes first in the array and edges after</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">// put to front of array if node</span><span class="s3">\n      </span><span class="s1">nodes.push(ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// put to end of array if edge</span><span class="s3">\n      </span><span class="s1">edges.push(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">elements = nodes.concat(edges);</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">var removeFromElements = function removeFromElements() {</span><span class="s3">\n    </span><span class="s1">elements.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">i--;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// now, restore each element</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; elements.length; i++) {</span><span class="s3">\n    </span><span class="s1">var _ele2 = elements[i];</span><span class="s3">\n    </span><span class="s1">var _private = _ele2._private;</span><span class="s3">\n    </span><span class="s1">var _data3 = _private.data;</span><span class="s3">\n\n    </span><span class="s1">// the traversal cache should start fresh when ele is added</span><span class="s3">\n    </span><span class="s1">_ele2.clearTraversalCache();</span><span class="s3">\n\n    </span><span class="s1">// set id and validate</span><span class="s3">\n    </span><span class="s1">if (!addToPool &amp;&amp; !_private.removed) ; else if (_data3.id === undefined) {</span><span class="s3">\n      </span><span class="s1">_data3.id = uuid();</span><span class="s3">\n    </span><span class="s1">} else if (number$1(_data3.id)) {</span><span class="s3">\n      </span><span class="s1">_data3.id = '' + _data3.id; // now it's a string</span><span class="s3">\n    </span><span class="s1">} else if (emptyString(_data3.id) || !string(_data3.id)) {</span><span class="s3">\n      </span><span class="s1">error('Can not create element with invalid string ID `' + _data3.id + '`');</span><span class="s3">\n\n      </span><span class="s1">// can't create element if it has empty string as id or non-string id</span><span class="s3">\n      </span><span class="s1">removeFromElements();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">} else if (cy.hasElementWithId(_data3.id)) {</span><span class="s3">\n      </span><span class="s1">error('Can not create second element with ID `' + _data3.id + '`');</span><span class="s3">\n\n      </span><span class="s1">// can't create element if one already has that id</span><span class="s3">\n      </span><span class="s1">removeFromElements();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var id = _data3.id; // id is finalised, now let's keep a ref</span><span class="s3">\n\n    </span><span class="s1">if (_ele2.isNode()) {</span><span class="s3">\n      </span><span class="s1">// extra checks for nodes</span><span class="s3">\n      </span><span class="s1">var pos = _private.position;</span><span class="s3">\n\n      </span><span class="s1">// make sure the nodes have a defined position</span><span class="s3">\n\n      </span><span class="s1">if (pos.x == null) {</span><span class="s3">\n        </span><span class="s1">pos.x = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (pos.y == null) {</span><span class="s3">\n        </span><span class="s1">pos.y = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (_ele2.isEdge()) {</span><span class="s3">\n      </span><span class="s1">// extra checks for edges</span><span class="s3">\n\n      </span><span class="s1">var edge = _ele2;</span><span class="s3">\n      </span><span class="s1">var fields = ['source', 'target'];</span><span class="s3">\n      </span><span class="s1">var fieldsLength = fields.length;</span><span class="s3">\n      </span><span class="s1">var badSourceOrTarget = false;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; fieldsLength; j++) {</span><span class="s3">\n        </span><span class="s1">var field = fields[j];</span><span class="s3">\n        </span><span class="s1">var val = _data3[field];</span><span class="s3">\n        </span><span class="s1">if (number$1(val)) {</span><span class="s3">\n          </span><span class="s1">val = _data3[field] = '' + _data3[field]; // now string</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (val == null || val === '') {</span><span class="s3">\n          </span><span class="s1">// can't create if source or target is not defined properly</span><span class="s3">\n          </span><span class="s1">error('Can not create edge `' + id + '` with unspecified ' + field);</span><span class="s3">\n          </span><span class="s1">badSourceOrTarget = true;</span><span class="s3">\n        </span><span class="s1">} else if (!cy.hasElementWithId(val)) {</span><span class="s3">\n          </span><span class="s1">// can't create edge if one of its nodes doesn't exist</span><span class="s3">\n          </span><span class="s1">error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');</span><span class="s3">\n          </span><span class="s1">badSourceOrTarget = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (badSourceOrTarget) {</span><span class="s3">\n        </span><span class="s1">removeFromElements();</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">} // can't create this</span><span class="s3">\n\n      </span><span class="s1">var src = cy.getElementById(_data3.source);</span><span class="s3">\n      </span><span class="s1">var tgt = cy.getElementById(_data3.target);</span><span class="s3">\n\n      </span><span class="s1">// only one edge in node if loop</span><span class="s3">\n      </span><span class="s1">if (src.same(tgt)) {</span><span class="s3">\n        </span><span class="s1">src._private.edges.push(edge);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">src._private.edges.push(edge);</span><span class="s3">\n        </span><span class="s1">tgt._private.edges.push(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">edge._private.source = src;</span><span class="s3">\n      </span><span class="s1">edge._private.target = tgt;</span><span class="s3">\n    </span><span class="s1">} // if is edge</span><span class="s3">\n\n    </span><span class="s1">// create mock ids / indexes maps for element so it can be used like collections</span><span class="s3">\n    </span><span class="s1">_private.map = new Map$1();</span><span class="s3">\n    </span><span class="s1">_private.map.set(id, {</span><span class="s3">\n      </span><span class="s1">ele: _ele2,</span><span class="s3">\n      </span><span class="s1">index: 0</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">_private.removed = false;</span><span class="s3">\n    </span><span class="s1">if (addToPool) {</span><span class="s3">\n      </span><span class="s1">cy.addToPool(_ele2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} // for each element</span><span class="s3">\n\n  </span><span class="s1">// do compound node sanity checks</span><span class="s3">\n  </span><span class="s1">for (var _i4 = 0; _i4 &lt; nodes.length; _i4++) {</span><span class="s3">\n    </span><span class="s1">// each node</span><span class="s3">\n    </span><span class="s1">var node = nodes[_i4];</span><span class="s3">\n    </span><span class="s1">var _data4 = node._private.data;</span><span class="s3">\n    </span><span class="s1">if (number$1(_data4.parent)) {</span><span class="s3">\n      </span><span class="s1">// then automake string</span><span class="s3">\n      </span><span class="s1">_data4.parent = '' + _data4.parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var parentId = _data4.parent;</span><span class="s3">\n    </span><span class="s1">var specifiedParent = parentId != null;</span><span class="s3">\n    </span><span class="s1">if (specifiedParent || node._private.parent) {</span><span class="s3">\n      </span><span class="s1">var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);</span><span class="s3">\n      </span><span class="s1">if (parent.empty()) {</span><span class="s3">\n        </span><span class="s1">// non-existant parent; just remove it</span><span class="s3">\n        </span><span class="s1">_data4.parent = undefined;</span><span class="s3">\n      </span><span class="s1">} else if (parent[0].removed()) {</span><span class="s3">\n        </span><span class="s1">warn('Node added with missing parent, reference to parent removed');</span><span class="s3">\n        </span><span class="s1">_data4.parent = undefined;</span><span class="s3">\n        </span><span class="s1">node._private.parent = null;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var selfAsParent = false;</span><span class="s3">\n        </span><span class="s1">var ancestor = parent;</span><span class="s3">\n        </span><span class="s1">while (!ancestor.empty()) {</span><span class="s3">\n          </span><span class="s1">if (node.same(ancestor)) {</span><span class="s3">\n            </span><span class="s1">// mark self as parent and remove from data</span><span class="s3">\n            </span><span class="s1">selfAsParent = true;</span><span class="s3">\n            </span><span class="s1">_data4.parent = undefined; // remove parent reference</span><span class="s3">\n\n            </span><span class="s1">// exit or we loop forever</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">ancestor = ancestor.parent();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!selfAsParent) {</span><span class="s3">\n          </span><span class="s1">// connect with children</span><span class="s3">\n          </span><span class="s1">parent[0]._private.children.push(node);</span><span class="s3">\n          </span><span class="s1">node._private.parent = parent[0];</span><span class="s3">\n\n          </span><span class="s1">// let the core know we have a compound graph</span><span class="s3">\n          </span><span class="s1">cy_p.hasCompoundNodes = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // else</span><span class="s3">\n    </span><span class="s1">} // if specified parent</span><span class="s3">\n  </span><span class="s1">} // for each node</span><span class="s3">\n\n  </span><span class="s1">if (elements.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var restored = elements.length === self.length ? self : new Collection(cy, elements);</span><span class="s3">\n    </span><span class="s1">for (var _i5 = 0; _i5 &lt; restored.length; _i5++) {</span><span class="s3">\n      </span><span class="s1">var _ele3 = restored[_i5];</span><span class="s3">\n      </span><span class="s1">if (_ele3.isNode()) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// adding an edge invalidates the traversal caches for the parallel edges</span><span class="s3">\n      </span><span class="s1">_ele3.parallelEdges().clearTraversalCache();</span><span class="s3">\n\n      </span><span class="s1">// adding an edge invalidates the traversal cache for the connected nodes</span><span class="s3">\n      </span><span class="s1">_ele3.source().clearTraversalCache();</span><span class="s3">\n      </span><span class="s1">_ele3.target().clearTraversalCache();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var toUpdateStyle;</span><span class="s3">\n    </span><span class="s1">if (cy_p.hasCompoundNodes) {</span><span class="s3">\n      </span><span class="s1">toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">toUpdateStyle = restored;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);</span><span class="s3">\n    </span><span class="s1">if (notifyRenderer) {</span><span class="s3">\n      </span><span class="s1">restored.emitAndNotify('add');</span><span class="s3">\n    </span><span class="s1">} else if (addToPool) {</span><span class="s3">\n      </span><span class="s1">restored.emit('add');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return self; // chainability</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.removed = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">return ele &amp;&amp; ele._private.removed;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.inside = function () {</span><span class="s3">\n  </span><span class="s1">var ele = this[0];</span><span class="s3">\n  </span><span class="s1">return ele &amp;&amp; !ele._private.removed;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.remove = function () {</span><span class="s3">\n  </span><span class="s1">var notifyRenderer = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;</span><span class="s3">\n  </span><span class="s1">var removeFromPool = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var elesToRemove = [];</span><span class="s3">\n  </span><span class="s1">var elesToRemoveIds = {};</span><span class="s3">\n  </span><span class="s1">var cy = self._private.cy;</span><span class="s3">\n\n  </span><span class="s1">// add connected edges</span><span class="s3">\n  </span><span class="s1">function addConnectedEdges(node) {</span><span class="s3">\n    </span><span class="s1">var edges = node._private.edges;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n      </span><span class="s1">add(edges[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add descendant nodes</span><span class="s3">\n  </span><span class="s1">function addChildren(node) {</span><span class="s3">\n    </span><span class="s1">var children = node._private.children;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n      </span><span class="s1">add(children[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function add(ele) {</span><span class="s3">\n    </span><span class="s1">var alreadyAdded = elesToRemoveIds[ele.id()];</span><span class="s3">\n    </span><span class="s1">if (removeFromPool &amp;&amp; ele.removed() || alreadyAdded) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">elesToRemoveIds[ele.id()] = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">elesToRemove.push(ele); // nodes are removed last</span><span class="s3">\n\n      </span><span class="s1">addConnectedEdges(ele);</span><span class="s3">\n      </span><span class="s1">addChildren(ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">elesToRemove.unshift(ele); // edges are removed first</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// make the list of elements to remove</span><span class="s3">\n  </span><span class="s1">// (may be removing more than specified due to connected edges etc)</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0, l = self.length; i &lt; l; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = self[i];</span><span class="s3">\n    </span><span class="s1">add(ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function removeEdgeRef(node, edge) {</span><span class="s3">\n    </span><span class="s1">var connectedEdges = node._private.edges;</span><span class="s3">\n    </span><span class="s1">removeFromArray(connectedEdges, edge);</span><span class="s3">\n\n    </span><span class="s1">// removing an edges invalidates the traversal cache for its nodes</span><span class="s3">\n    </span><span class="s1">node.clearTraversalCache();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function removeParallelRef(pllEdge) {</span><span class="s3">\n    </span><span class="s1">// removing an edge invalidates the traversal caches for the parallel edges</span><span class="s3">\n    </span><span class="s1">pllEdge.clearTraversalCache();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var alteredParents = [];</span><span class="s3">\n  </span><span class="s1">alteredParents.ids = {};</span><span class="s3">\n  </span><span class="s1">function removeChildRef(parent, ele) {</span><span class="s3">\n    </span><span class="s1">ele = ele[0];</span><span class="s3">\n    </span><span class="s1">parent = parent[0];</span><span class="s3">\n    </span><span class="s1">var children = parent._private.children;</span><span class="s3">\n    </span><span class="s1">var pid = parent.id();</span><span class="s3">\n    </span><span class="s1">removeFromArray(children, ele); // remove parent =&gt; child ref</span><span class="s3">\n\n    </span><span class="s1">ele._private.parent = null; // remove child =&gt; parent ref</span><span class="s3">\n\n    </span><span class="s1">if (!alteredParents.ids[pid]) {</span><span class="s3">\n      </span><span class="s1">alteredParents.ids[pid] = true;</span><span class="s3">\n      </span><span class="s1">alteredParents.push(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">self.dirtyCompoundBoundsCache();</span><span class="s3">\n  </span><span class="s1">if (removeFromPool) {</span><span class="s3">\n    </span><span class="s1">cy.removeFromPool(elesToRemove); // remove from core pool</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var _i6 = 0; _i6 &lt; elesToRemove.length; _i6++) {</span><span class="s3">\n    </span><span class="s1">var _ele4 = elesToRemove[_i6];</span><span class="s3">\n    </span><span class="s1">if (_ele4.isEdge()) {</span><span class="s3">\n      </span><span class="s1">// remove references to this edge in its connected nodes</span><span class="s3">\n      </span><span class="s1">var src = _ele4.source()[0];</span><span class="s3">\n      </span><span class="s1">var tgt = _ele4.target()[0];</span><span class="s3">\n      </span><span class="s1">removeEdgeRef(src, _ele4);</span><span class="s3">\n      </span><span class="s1">removeEdgeRef(tgt, _ele4);</span><span class="s3">\n      </span><span class="s1">var pllEdges = _ele4.parallelEdges();</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; pllEdges.length; j++) {</span><span class="s3">\n        </span><span class="s1">var pllEdge = pllEdges[j];</span><span class="s3">\n        </span><span class="s1">removeParallelRef(pllEdge);</span><span class="s3">\n        </span><span class="s1">if (pllEdge.isBundledBezier()) {</span><span class="s3">\n          </span><span class="s1">pllEdge.dirtyBoundingBoxCache();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// remove reference to parent</span><span class="s3">\n      </span><span class="s1">var parent = _ele4.parent();</span><span class="s3">\n      </span><span class="s1">if (parent.length !== 0) {</span><span class="s3">\n        </span><span class="s1">removeChildRef(parent, _ele4);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (removeFromPool) {</span><span class="s3">\n      </span><span class="s1">// mark as removed</span><span class="s3">\n      </span><span class="s1">_ele4._private.removed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check to see if we have a compound graph or not</span><span class="s3">\n  </span><span class="s1">var elesStillInside = cy._private.elements;</span><span class="s3">\n  </span><span class="s1">cy._private.hasCompoundNodes = false;</span><span class="s3">\n  </span><span class="s1">for (var _i7 = 0; _i7 &lt; elesStillInside.length; _i7++) {</span><span class="s3">\n    </span><span class="s1">var _ele5 = elesStillInside[_i7];</span><span class="s3">\n    </span><span class="s1">if (_ele5.isParent()) {</span><span class="s3">\n      </span><span class="s1">cy._private.hasCompoundNodes = true;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var removedElements = new Collection(this.cy(), elesToRemove);</span><span class="s3">\n  </span><span class="s1">if (removedElements.size() &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// must manually notify since trigger won't do this automatically once removed</span><span class="s3">\n\n    </span><span class="s1">if (notifyRenderer) {</span><span class="s3">\n      </span><span class="s1">removedElements.emitAndNotify('remove');</span><span class="s3">\n    </span><span class="s1">} else if (removeFromPool) {</span><span class="s3">\n      </span><span class="s1">removedElements.emit('remove');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// the parents who were modified by the removal need their style updated</span><span class="s3">\n  </span><span class="s1">for (var _i8 = 0; _i8 &lt; alteredParents.length; _i8++) {</span><span class="s3">\n    </span><span class="s1">var _ele6 = alteredParents[_i8];</span><span class="s3">\n    </span><span class="s1">if (!removeFromPool || !_ele6.removed()) {</span><span class="s3">\n      </span><span class="s1">_ele6.updateStyle();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return removedElements;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">elesfn$1.move = function (struct) {</span><span class="s3">\n  </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n  </span><span class="s1">var eles = this;</span><span class="s3">\n\n  </span><span class="s1">// just clean up refs, caches, etc. in the same way as when removing and then restoring</span><span class="s3">\n  </span><span class="s1">// (our calls to remove/restore do not remove from the graph or make events)</span><span class="s3">\n  </span><span class="s1">var notifyRenderer = false;</span><span class="s3">\n  </span><span class="s1">var modifyPool = false;</span><span class="s3">\n  </span><span class="s1">var toString = function toString(id) {</span><span class="s3">\n    </span><span class="s1">return id == null ? id : '' + id;</span><span class="s3">\n  </span><span class="s1">}; // id must be string</span><span class="s3">\n\n  </span><span class="s1">if (struct.source !== undefined || struct.target !== undefined) {</span><span class="s3">\n    </span><span class="s1">var srcId = toString(struct.source);</span><span class="s3">\n    </span><span class="s1">var tgtId = toString(struct.target);</span><span class="s3">\n    </span><span class="s1">var srcExists = srcId != null &amp;&amp; cy.hasElementWithId(srcId);</span><span class="s3">\n    </span><span class="s1">var tgtExists = tgtId != null &amp;&amp; cy.hasElementWithId(tgtId);</span><span class="s3">\n    </span><span class="s1">if (srcExists || tgtExists) {</span><span class="s3">\n      </span><span class="s1">cy.batch(function () {</span><span class="s3">\n        </span><span class="s1">// avoid duplicate style updates</span><span class="s3">\n        </span><span class="s1">eles.remove(notifyRenderer, modifyPool); // clean up refs etc.</span><span class="s3">\n        </span><span class="s1">eles.emitAndNotify('moveout');</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n          </span><span class="s1">var ele = eles[i];</span><span class="s3">\n          </span><span class="s1">var _data5 = ele._private.data;</span><span class="s3">\n          </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n            </span><span class="s1">if (srcExists) {</span><span class="s3">\n              </span><span class="s1">_data5.source = srcId;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (tgtExists) {</span><span class="s3">\n              </span><span class="s1">_data5.target = tgtId;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">eles.emitAndNotify('move');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (struct.parent !== undefined) {</span><span class="s3">\n    </span><span class="s1">// move node to new parent</span><span class="s3">\n    </span><span class="s1">var parentId = toString(struct.parent);</span><span class="s3">\n    </span><span class="s1">var parentExists = parentId === null || cy.hasElementWithId(parentId);</span><span class="s3">\n    </span><span class="s1">if (parentExists) {</span><span class="s3">\n      </span><span class="s1">var pidToAssign = parentId === null ? undefined : parentId;</span><span class="s3">\n      </span><span class="s1">cy.batch(function () {</span><span class="s3">\n        </span><span class="s1">// avoid duplicate style updates</span><span class="s3">\n        </span><span class="s1">var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.</span><span class="s3">\n        </span><span class="s1">updated.emitAndNotify('moveout');</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n          </span><span class="s1">var ele = eles[i];</span><span class="s3">\n          </span><span class="s1">var _data6 = ele._private.data;</span><span class="s3">\n          </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n            </span><span class="s1">_data6.parent = pidToAssign;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">eles.emitAndNotify('move');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">[elesfn$j, elesfn$i, elesfn$h, elesfn$g, elesfn$f, data, elesfn$d, dimensions, elesfn$9, elesfn$8, elesfn$7, elesfn$6, elesfn$5, elesfn$4, elesfn$3, elesfn$2].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(elesfn$1, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var corefn$9 = {</span><span class="s3">\n  </span><span class="s1">add: function add(opts) {</span><span class="s3">\n    </span><span class="s1">var elements;</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n\n    </span><span class="s1">// add the elements</span><span class="s3">\n    </span><span class="s1">if (elementOrCollection(opts)) {</span><span class="s3">\n      </span><span class="s1">var eles = opts;</span><span class="s3">\n      </span><span class="s1">if (eles._private.cy === cy) {</span><span class="s3">\n        </span><span class="s1">// same instance =&gt; just restore</span><span class="s3">\n        </span><span class="s1">elements = eles.restore();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// otherwise, copy from json</span><span class="s3">\n        </span><span class="s1">var jsons = [];</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n          </span><span class="s1">var ele = eles[i];</span><span class="s3">\n          </span><span class="s1">jsons.push(ele.json());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">elements = new Collection(cy, jsons);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// specify an array of options</span><span class="s3">\n    </span><span class="s1">else if (array(opts)) {</span><span class="s3">\n      </span><span class="s1">var _jsons = opts;</span><span class="s3">\n      </span><span class="s1">elements = new Collection(cy, _jsons);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// specify via opts.nodes and opts.edges</span><span class="s3">\n    </span><span class="s1">else if (plainObject(opts) &amp;&amp; (array(opts.nodes) || array(opts.edges))) {</span><span class="s3">\n      </span><span class="s1">var elesByGroup = opts;</span><span class="s3">\n      </span><span class="s1">var _jsons2 = [];</span><span class="s3">\n      </span><span class="s1">var grs = ['nodes', 'edges'];</span><span class="s3">\n      </span><span class="s1">for (var _i = 0, il = grs.length; _i &lt; il; _i++) {</span><span class="s3">\n        </span><span class="s1">var group = grs[_i];</span><span class="s3">\n        </span><span class="s1">var elesArray = elesByGroup[group];</span><span class="s3">\n        </span><span class="s1">if (array(elesArray)) {</span><span class="s3">\n          </span><span class="s1">for (var j = 0, jl = elesArray.length; j &lt; jl; j++) {</span><span class="s3">\n            </span><span class="s1">var json = extend({</span><span class="s3">\n              </span><span class="s1">group: group</span><span class="s3">\n            </span><span class="s1">}, elesArray[j]);</span><span class="s3">\n            </span><span class="s1">_jsons2.push(json);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">elements = new Collection(cy, _jsons2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// specify options for one element</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">var _json = opts;</span><span class="s3">\n      </span><span class="s1">elements = new Element(cy, _json).collection();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elements;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">remove: function remove(collection) {</span><span class="s3">\n    </span><span class="s1">if (elementOrCollection(collection)) ; else if (string(collection)) {</span><span class="s3">\n      </span><span class="s1">var selector = collection;</span><span class="s3">\n      </span><span class="s1">collection = this.$(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return collection.remove();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* global Float32Array */</span><span class="s3">\n\n</span><span class="s1">/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */</span><span class="s3">\n</span><span class="s1">function generateCubicBezier(mX1, mY1, mX2, mY2) {</span><span class="s3">\n  </span><span class="s1">var NEWTON_ITERATIONS = 4,</span><span class="s3">\n    </span><span class="s1">NEWTON_MIN_SLOPE = 0.001,</span><span class="s3">\n    </span><span class="s1">SUBDIVISION_PRECISION = 0.0000001,</span><span class="s3">\n    </span><span class="s1">SUBDIVISION_MAX_ITERATIONS = 10,</span><span class="s3">\n    </span><span class="s1">kSplineTableSize = 11,</span><span class="s3">\n    </span><span class="s1">kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),</span><span class="s3">\n    </span><span class="s1">float32ArraySupported = typeof Float32Array !== 'undefined';</span><span class="s3">\n\n  </span><span class="s1">/* Must contain four arguments. */</span><span class="s3">\n  </span><span class="s1">if (arguments.length !== 4) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* Arguments must be numbers. */</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; 4; ++i) {</span><span class="s3">\n    </span><span class="s1">if (typeof arguments[i] !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| isNaN(arguments[i]) || !isFinite(arguments[i])) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* X values must be in the [0, 1] range. */</span><span class="s3">\n  </span><span class="s1">mX1 = Math.min(mX1, 1);</span><span class="s3">\n  </span><span class="s1">mX2 = Math.min(mX2, 1);</span><span class="s3">\n  </span><span class="s1">mX1 = Math.max(mX1, 0);</span><span class="s3">\n  </span><span class="s1">mX2 = Math.max(mX2, 0);</span><span class="s3">\n  </span><span class="s1">var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);</span><span class="s3">\n  </span><span class="s1">function A(aA1, aA2) {</span><span class="s3">\n    </span><span class="s1">return 1.0 - 3.0 * aA2 + 3.0 * aA1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function B(aA1, aA2) {</span><span class="s3">\n    </span><span class="s1">return 3.0 * aA2 - 6.0 * aA1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function C(aA1) {</span><span class="s3">\n    </span><span class="s1">return 3.0 * aA1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function calcBezier(aT, aA1, aA2) {</span><span class="s3">\n    </span><span class="s1">return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function getSlope(aT, aA1, aA2) {</span><span class="s3">\n    </span><span class="s1">return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function newtonRaphsonIterate(aX, aGuessT) {</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; NEWTON_ITERATIONS; ++_i) {</span><span class="s3">\n      </span><span class="s1">var currentSlope = getSlope(aGuessT, mX1, mX2);</span><span class="s3">\n      </span><span class="s1">if (currentSlope === 0.0) {</span><span class="s3">\n        </span><span class="s1">return aGuessT;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var currentX = calcBezier(aGuessT, mX1, mX2) - aX;</span><span class="s3">\n      </span><span class="s1">aGuessT -= currentX / currentSlope;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return aGuessT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function calcSampleValues() {</span><span class="s3">\n    </span><span class="s1">for (var _i2 = 0; _i2 &lt; kSplineTableSize; ++_i2) {</span><span class="s3">\n      </span><span class="s1">mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function binarySubdivide(aX, aA, aB) {</span><span class="s3">\n    </span><span class="s1">var currentX,</span><span class="s3">\n      </span><span class="s1">currentT,</span><span class="s3">\n      </span><span class="s1">i = 0;</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">currentT = aA + (aB - aA) / 2.0;</span><span class="s3">\n      </span><span class="s1">currentX = calcBezier(currentT, mX1, mX2) - aX;</span><span class="s3">\n      </span><span class="s1">if (currentX &gt; 0.0) {</span><span class="s3">\n        </span><span class="s1">aB = currentT;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">aA = currentT;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while (Math.abs(currentX) &gt; SUBDIVISION_PRECISION &amp;&amp; ++i &lt; SUBDIVISION_MAX_ITERATIONS);</span><span class="s3">\n    </span><span class="s1">return currentT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function getTForX(aX) {</span><span class="s3">\n    </span><span class="s1">var intervalStart = 0.0,</span><span class="s3">\n      </span><span class="s1">currentSample = 1,</span><span class="s3">\n      </span><span class="s1">lastSample = kSplineTableSize - 1;</span><span class="s3">\n    </span><span class="s1">for (; currentSample !== lastSample &amp;&amp; mSampleValues[currentSample] &lt;= aX; ++currentSample) {</span><span class="s3">\n      </span><span class="s1">intervalStart += kSampleStepSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">--currentSample;</span><span class="s3">\n    </span><span class="s1">var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),</span><span class="s3">\n      </span><span class="s1">guessForT = intervalStart + dist * kSampleStepSize,</span><span class="s3">\n      </span><span class="s1">initialSlope = getSlope(guessForT, mX1, mX2);</span><span class="s3">\n    </span><span class="s1">if (initialSlope &gt;= NEWTON_MIN_SLOPE) {</span><span class="s3">\n      </span><span class="s1">return newtonRaphsonIterate(aX, guessForT);</span><span class="s3">\n    </span><span class="s1">} else if (initialSlope === 0.0) {</span><span class="s3">\n      </span><span class="s1">return guessForT;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var _precomputed = false;</span><span class="s3">\n  </span><span class="s1">function precompute() {</span><span class="s3">\n    </span><span class="s1">_precomputed = true;</span><span class="s3">\n    </span><span class="s1">if (mX1 !== mY1 || mX2 !== mY2) {</span><span class="s3">\n      </span><span class="s1">calcSampleValues();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var f = function f(aX) {</span><span class="s3">\n    </span><span class="s1">if (!_precomputed) {</span><span class="s3">\n      </span><span class="s1">precompute();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (mX1 === mY1 &amp;&amp; mX2 === mY2) {</span><span class="s3">\n      </span><span class="s1">return aX;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (aX === 0) {</span><span class="s3">\n      </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (aX === 1) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return calcBezier(getTForX(aX), mY1, mY2);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">f.getControlPoints = function () {</span><span class="s3">\n    </span><span class="s1">return [{</span><span class="s3">\n      </span><span class="s1">x: mX1,</span><span class="s3">\n      </span><span class="s1">y: mY1</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">x: mX2,</span><span class="s3">\n      </span><span class="s1">y: mY2</span><span class="s3">\n    </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var str = </span><span class="s3">\&quot;</span><span class="s1">generateBezier(</span><span class="s3">\&quot; </span><span class="s1">+ [mX1, mY1, mX2, mY2] + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">f.toString = function () {</span><span class="s3">\n    </span><span class="s1">return str;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return f;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */</span><span class="s3">\n</span><span class="s1">/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass</span><span class="s3">\n   </span><span class="s1">then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */</span><span class="s3">\n</span><span class="s1">var generateSpringRK4 = function () {</span><span class="s3">\n  </span><span class="s1">function springAccelerationForState(state) {</span><span class="s3">\n    </span><span class="s1">return -state.tension * state.x - state.friction * state.v;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function springEvaluateStateWithDerivative(initialState, dt, derivative) {</span><span class="s3">\n    </span><span class="s1">var state = {</span><span class="s3">\n      </span><span class="s1">x: initialState.x + derivative.dx * dt,</span><span class="s3">\n      </span><span class="s1">v: initialState.v + derivative.dv * dt,</span><span class="s3">\n      </span><span class="s1">tension: initialState.tension,</span><span class="s3">\n      </span><span class="s1">friction: initialState.friction</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">dx: state.v,</span><span class="s3">\n      </span><span class="s1">dv: springAccelerationForState(state)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function springIntegrateState(state, dt) {</span><span class="s3">\n    </span><span class="s1">var a = {</span><span class="s3">\n        </span><span class="s1">dx: state.v,</span><span class="s3">\n        </span><span class="s1">dv: springAccelerationForState(state)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">b = springEvaluateStateWithDerivative(state, dt * 0.5, a),</span><span class="s3">\n      </span><span class="s1">c = springEvaluateStateWithDerivative(state, dt * 0.5, b),</span><span class="s3">\n      </span><span class="s1">d = springEvaluateStateWithDerivative(state, dt, c),</span><span class="s3">\n      </span><span class="s1">dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),</span><span class="s3">\n      </span><span class="s1">dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);</span><span class="s3">\n    </span><span class="s1">state.x = state.x + dxdt * dt;</span><span class="s3">\n    </span><span class="s1">state.v = state.v + dvdt * dt;</span><span class="s3">\n    </span><span class="s1">return state;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function springRK4Factory(tension, friction, duration) {</span><span class="s3">\n    </span><span class="s1">var initState = {</span><span class="s3">\n        </span><span class="s1">x: -1,</span><span class="s3">\n        </span><span class="s1">v: 0,</span><span class="s3">\n        </span><span class="s1">tension: null,</span><span class="s3">\n        </span><span class="s1">friction: null</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">path = [0],</span><span class="s3">\n      </span><span class="s1">time_lapsed = 0,</span><span class="s3">\n      </span><span class="s1">tolerance = 1 / 10000,</span><span class="s3">\n      </span><span class="s1">DT = 16 / 1000,</span><span class="s3">\n      </span><span class="s1">have_duration,</span><span class="s3">\n      </span><span class="s1">dt,</span><span class="s3">\n      </span><span class="s1">last_state;</span><span class="s3">\n    </span><span class="s1">tension = parseFloat(tension) || 500;</span><span class="s3">\n    </span><span class="s1">friction = parseFloat(friction) || 20;</span><span class="s3">\n    </span><span class="s1">duration = duration || null;</span><span class="s3">\n    </span><span class="s1">initState.tension = tension;</span><span class="s3">\n    </span><span class="s1">initState.friction = friction;</span><span class="s3">\n    </span><span class="s1">have_duration = duration !== null;</span><span class="s3">\n\n    </span><span class="s1">/* Calculate the actual time it takes for this animation to complete with the provided conditions. */</span><span class="s3">\n    </span><span class="s1">if (have_duration) {</span><span class="s3">\n      </span><span class="s1">/* Run the simulation without a duration. */</span><span class="s3">\n      </span><span class="s1">time_lapsed = springRK4Factory(tension, friction);</span><span class="s3">\n      </span><span class="s1">/* Compute the adjusted time delta. */</span><span class="s3">\n      </span><span class="s1">dt = time_lapsed / duration * DT;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">dt = DT;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n      </span><span class="s1">/* Next/step function .*/</span><span class="s3">\n      </span><span class="s1">last_state = springIntegrateState(last_state || initState, dt);</span><span class="s3">\n      </span><span class="s1">/* Store the position. */</span><span class="s3">\n      </span><span class="s1">path.push(1 + last_state.x);</span><span class="s3">\n      </span><span class="s1">time_lapsed += 16;</span><span class="s3">\n      </span><span class="s1">/* If the change threshold is reached, break. */</span><span class="s3">\n      </span><span class="s1">if (!(Math.abs(last_state.x) &gt; tolerance &amp;&amp; Math.abs(last_state.v) &gt; tolerance)) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the</span><span class="s3">\n       </span><span class="s1">computed path and returns a snapshot of the position according to a given percentComplete. */</span><span class="s3">\n    </span><span class="s1">return !have_duration ? time_lapsed : function (percentComplete) {</span><span class="s3">\n      </span><span class="s1">return path[percentComplete * (path.length - 1) | 0];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">var cubicBezier = function cubicBezier(t1, p1, t2, p2) {</span><span class="s3">\n  </span><span class="s1">var bezier = generateCubicBezier(t1, p1, t2, p2);</span><span class="s3">\n  </span><span class="s1">return function (start, end, percent) {</span><span class="s3">\n    </span><span class="s1">return start + (end - start) * bezier(percent);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var easings = {</span><span class="s3">\n  </span><span class="s1">'linear': function linear(start, end, percent) {</span><span class="s3">\n    </span><span class="s1">return start + (end - start) * percent;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// default easings</span><span class="s3">\n  </span><span class="s1">'ease': cubicBezier(0.25, 0.1, 0.25, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in': cubicBezier(0.42, 0, 1, 1),</span><span class="s3">\n  </span><span class="s1">'ease-out': cubicBezier(0, 0, 0.58, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),</span><span class="s3">\n  </span><span class="s1">// sine</span><span class="s3">\n  </span><span class="s1">'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),</span><span class="s3">\n  </span><span class="s1">'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),</span><span class="s3">\n  </span><span class="s1">// quad</span><span class="s3">\n  </span><span class="s1">'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),</span><span class="s3">\n  </span><span class="s1">'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),</span><span class="s3">\n  </span><span class="s1">// cubic</span><span class="s3">\n  </span><span class="s1">'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),</span><span class="s3">\n  </span><span class="s1">'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),</span><span class="s3">\n  </span><span class="s1">// quart</span><span class="s3">\n  </span><span class="s1">'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),</span><span class="s3">\n  </span><span class="s1">'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),</span><span class="s3">\n  </span><span class="s1">// quint</span><span class="s3">\n  </span><span class="s1">'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),</span><span class="s3">\n  </span><span class="s1">'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),</span><span class="s3">\n  </span><span class="s1">// expo</span><span class="s3">\n  </span><span class="s1">'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),</span><span class="s3">\n  </span><span class="s1">'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-expo': cubicBezier(1, 0, 0, 1),</span><span class="s3">\n  </span><span class="s1">// circ</span><span class="s3">\n  </span><span class="s1">'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),</span><span class="s3">\n  </span><span class="s1">'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),</span><span class="s3">\n  </span><span class="s1">'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),</span><span class="s3">\n  </span><span class="s1">// user param easings...</span><span class="s3">\n\n  </span><span class="s1">'spring': function spring(tension, friction, duration) {</span><span class="s3">\n    </span><span class="s1">if (duration === 0) {</span><span class="s3">\n      </span><span class="s1">// can't get a spring w/ duration 0</span><span class="s3">\n      </span><span class="s1">return easings.linear; // duration 0 =&gt; jump to end so impl doesn't matter</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var spring = generateSpringRK4(tension, friction, duration);</span><span class="s3">\n    </span><span class="s1">return function (start, end, percent) {</span><span class="s3">\n      </span><span class="s1">return start + (end - start) * spring(percent);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">'cubic-bezier': cubicBezier</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function getEasedValue(type, start, end, percent, easingFn) {</span><span class="s3">\n  </span><span class="s1">if (percent === 1) {</span><span class="s3">\n    </span><span class="s1">return end;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (start === end) {</span><span class="s3">\n    </span><span class="s1">return end;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var val = easingFn(start, end, percent);</span><span class="s3">\n  </span><span class="s1">if (type == null) {</span><span class="s3">\n    </span><span class="s1">return val;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type.roundValue || type.color) {</span><span class="s3">\n    </span><span class="s1">val = Math.round(val);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type.min !== undefined) {</span><span class="s3">\n    </span><span class="s1">val = Math.max(val, type.min);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type.max !== undefined) {</span><span class="s3">\n    </span><span class="s1">val = Math.min(val, type.max);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return val;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getValue(prop, spec) {</span><span class="s3">\n  </span><span class="s1">if (prop.pfValue != null || prop.value != null) {</span><span class="s3">\n    </span><span class="s1">if (prop.pfValue != null &amp;&amp; (spec == null || spec.type.units !== '%')) {</span><span class="s3">\n      </span><span class="s1">return prop.pfValue;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return prop.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return prop;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ease(startProp, endProp, percent, easingFn, propSpec) {</span><span class="s3">\n  </span><span class="s1">var type = propSpec != null ? propSpec.type : null;</span><span class="s3">\n  </span><span class="s1">if (percent &lt; 0) {</span><span class="s3">\n    </span><span class="s1">percent = 0;</span><span class="s3">\n  </span><span class="s1">} else if (percent &gt; 1) {</span><span class="s3">\n    </span><span class="s1">percent = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var start = getValue(startProp, propSpec);</span><span class="s3">\n  </span><span class="s1">var end = getValue(endProp, propSpec);</span><span class="s3">\n  </span><span class="s1">if (number$1(start) &amp;&amp; number$1(end)) {</span><span class="s3">\n    </span><span class="s1">return getEasedValue(type, start, end, percent, easingFn);</span><span class="s3">\n  </span><span class="s1">} else if (array(start) &amp;&amp; array(end)) {</span><span class="s3">\n    </span><span class="s1">var easedArr = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; end.length; i++) {</span><span class="s3">\n      </span><span class="s1">var si = start[i];</span><span class="s3">\n      </span><span class="s1">var ei = end[i];</span><span class="s3">\n      </span><span class="s1">if (si != null &amp;&amp; ei != null) {</span><span class="s3">\n        </span><span class="s1">var val = getEasedValue(type, si, ei, percent, easingFn);</span><span class="s3">\n        </span><span class="s1">easedArr.push(val);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">easedArr.push(ei);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return easedArr;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function step$1(self, ani, now, isCore) {</span><span class="s3">\n  </span><span class="s1">var isEles = !isCore;</span><span class="s3">\n  </span><span class="s1">var _p = self._private;</span><span class="s3">\n  </span><span class="s1">var ani_p = ani._private;</span><span class="s3">\n  </span><span class="s1">var pEasing = ani_p.easing;</span><span class="s3">\n  </span><span class="s1">var startTime = ani_p.startTime;</span><span class="s3">\n  </span><span class="s1">var cy = isCore ? self : self.cy();</span><span class="s3">\n  </span><span class="s1">var style = cy.style();</span><span class="s3">\n  </span><span class="s1">if (!ani_p.easingImpl) {</span><span class="s3">\n    </span><span class="s1">if (pEasing == null) {</span><span class="s3">\n      </span><span class="s1">// use default</span><span class="s3">\n      </span><span class="s1">ani_p.easingImpl = easings['linear'];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// then define w/ name</span><span class="s3">\n      </span><span class="s1">var easingVals;</span><span class="s3">\n      </span><span class="s1">if (string(pEasing)) {</span><span class="s3">\n        </span><span class="s1">var easingProp = style.parse('transition-timing-function', pEasing);</span><span class="s3">\n        </span><span class="s1">easingVals = easingProp.value;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// then assume preparsed array</span><span class="s3">\n        </span><span class="s1">easingVals = pEasing;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var name, args;</span><span class="s3">\n      </span><span class="s1">if (string(easingVals)) {</span><span class="s3">\n        </span><span class="s1">name = easingVals;</span><span class="s3">\n        </span><span class="s1">args = [];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">name = easingVals[1];</span><span class="s3">\n        </span><span class="s1">args = easingVals.slice(2).map(function (n) {</span><span class="s3">\n          </span><span class="s1">return +n;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (args.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// create with args</span><span class="s3">\n        </span><span class="s1">if (name === 'spring') {</span><span class="s3">\n          </span><span class="s1">args.push(ani_p.duration); // need duration to generate spring</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">ani_p.easingImpl = easings[name].apply(null, args);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// static impl by name</span><span class="s3">\n        </span><span class="s1">ani_p.easingImpl = easings[name];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var easing = ani_p.easingImpl;</span><span class="s3">\n  </span><span class="s1">var percent;</span><span class="s3">\n  </span><span class="s1">if (ani_p.duration === 0) {</span><span class="s3">\n    </span><span class="s1">percent = 1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">percent = (now - startTime) / ani_p.duration;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ani_p.applying) {</span><span class="s3">\n    </span><span class="s1">percent = ani_p.progress;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (percent &lt; 0) {</span><span class="s3">\n    </span><span class="s1">percent = 0;</span><span class="s3">\n  </span><span class="s1">} else if (percent &gt; 1) {</span><span class="s3">\n    </span><span class="s1">percent = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ani_p.delay == null) {</span><span class="s3">\n    </span><span class="s1">// then update</span><span class="s3">\n\n    </span><span class="s1">var startPos = ani_p.startPosition;</span><span class="s3">\n    </span><span class="s1">var endPos = ani_p.position;</span><span class="s3">\n    </span><span class="s1">if (endPos &amp;&amp; isEles &amp;&amp; !self.locked()) {</span><span class="s3">\n      </span><span class="s1">var newPos = {};</span><span class="s3">\n      </span><span class="s1">if (valid(startPos.x, endPos.x)) {</span><span class="s3">\n        </span><span class="s1">newPos.x = ease(startPos.x, endPos.x, percent, easing);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (valid(startPos.y, endPos.y)) {</span><span class="s3">\n        </span><span class="s1">newPos.y = ease(startPos.y, endPos.y, percent, easing);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">self.position(newPos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var startPan = ani_p.startPan;</span><span class="s3">\n    </span><span class="s1">var endPan = ani_p.pan;</span><span class="s3">\n    </span><span class="s1">var pan = _p.pan;</span><span class="s3">\n    </span><span class="s1">var animatingPan = endPan != null &amp;&amp; isCore;</span><span class="s3">\n    </span><span class="s1">if (animatingPan) {</span><span class="s3">\n      </span><span class="s1">if (valid(startPan.x, endPan.x)) {</span><span class="s3">\n        </span><span class="s1">pan.x = ease(startPan.x, endPan.x, percent, easing);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (valid(startPan.y, endPan.y)) {</span><span class="s3">\n        </span><span class="s1">pan.y = ease(startPan.y, endPan.y, percent, easing);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">self.emit('pan');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var startZoom = ani_p.startZoom;</span><span class="s3">\n    </span><span class="s1">var endZoom = ani_p.zoom;</span><span class="s3">\n    </span><span class="s1">var animatingZoom = endZoom != null &amp;&amp; isCore;</span><span class="s3">\n    </span><span class="s1">if (animatingZoom) {</span><span class="s3">\n      </span><span class="s1">if (valid(startZoom, endZoom)) {</span><span class="s3">\n        </span><span class="s1">_p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">self.emit('zoom');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (animatingPan || animatingZoom) {</span><span class="s3">\n      </span><span class="s1">self.emit('viewport');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var props = ani_p.style;</span><span class="s3">\n    </span><span class="s1">if (props &amp;&amp; props.length &gt; 0 &amp;&amp; isEles) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; props.length; i++) {</span><span class="s3">\n        </span><span class="s1">var prop = props[i];</span><span class="s3">\n        </span><span class="s1">var _name = prop.name;</span><span class="s3">\n        </span><span class="s1">var end = prop;</span><span class="s3">\n        </span><span class="s1">var start = ani_p.startStyle[_name];</span><span class="s3">\n        </span><span class="s1">var propSpec = style.properties[start.name];</span><span class="s3">\n        </span><span class="s1">var easedVal = ease(start, end, percent, easing, propSpec);</span><span class="s3">\n        </span><span class="s1">style.overrideBypass(self, _name, easedVal);</span><span class="s3">\n      </span><span class="s1">} // for props</span><span class="s3">\n\n      </span><span class="s1">self.emit('style');</span><span class="s3">\n    </span><span class="s1">} // if</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">ani_p.progress = percent;</span><span class="s3">\n  </span><span class="s1">return percent;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function valid(start, end) {</span><span class="s3">\n  </span><span class="s1">if (start == null || end == null) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (number$1(start) &amp;&amp; number$1(end)) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} else if (start &amp;&amp; end) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function startAnimation(self, ani, now, isCore) {</span><span class="s3">\n  </span><span class="s1">var ani_p = ani._private;</span><span class="s3">\n  </span><span class="s1">ani_p.started = true;</span><span class="s3">\n  </span><span class="s1">ani_p.startTime = now - ani_p.progress * ani_p.duration;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stepAll(now, cy) {</span><span class="s3">\n  </span><span class="s1">var eles = cy._private.aniEles;</span><span class="s3">\n  </span><span class="s1">var doneEles = [];</span><span class="s3">\n  </span><span class="s1">function stepOne(ele, isCore) {</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">var current = _p.animation.current;</span><span class="s3">\n    </span><span class="s1">var queue = _p.animation.queue;</span><span class="s3">\n    </span><span class="s1">var ranAnis = false;</span><span class="s3">\n\n    </span><span class="s1">// if nothing currently animating, get something from the queue</span><span class="s3">\n    </span><span class="s1">if (current.length === 0) {</span><span class="s3">\n      </span><span class="s1">var next = queue.shift();</span><span class="s3">\n      </span><span class="s1">if (next) {</span><span class="s3">\n        </span><span class="s1">current.push(next);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var callbacks = function callbacks(_callbacks) {</span><span class="s3">\n      </span><span class="s1">for (var j = _callbacks.length - 1; j &gt;= 0; j--) {</span><span class="s3">\n        </span><span class="s1">var cb = _callbacks[j];</span><span class="s3">\n        </span><span class="s1">cb();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_callbacks.splice(0, _callbacks.length);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// step and remove if done</span><span class="s3">\n    </span><span class="s1">for (var i = current.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">var ani = current[i];</span><span class="s3">\n      </span><span class="s1">var ani_p = ani._private;</span><span class="s3">\n      </span><span class="s1">if (ani_p.stopped) {</span><span class="s3">\n        </span><span class="s1">current.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">ani_p.hooked = false;</span><span class="s3">\n        </span><span class="s1">ani_p.playing = false;</span><span class="s3">\n        </span><span class="s1">ani_p.started = false;</span><span class="s3">\n        </span><span class="s1">callbacks(ani_p.frames);</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!ani_p.playing &amp;&amp; !ani_p.applying) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// an apply() while playing shouldn't do anything</span><span class="s3">\n      </span><span class="s1">if (ani_p.playing &amp;&amp; ani_p.applying) {</span><span class="s3">\n        </span><span class="s1">ani_p.applying = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!ani_p.started) {</span><span class="s3">\n        </span><span class="s1">startAnimation(ele, ani, now);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">step$1(ele, ani, now, isCore);</span><span class="s3">\n      </span><span class="s1">if (ani_p.applying) {</span><span class="s3">\n        </span><span class="s1">ani_p.applying = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">callbacks(ani_p.frames);</span><span class="s3">\n      </span><span class="s1">if (ani_p.step != null) {</span><span class="s3">\n        </span><span class="s1">ani_p.step(now);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (ani.completed()) {</span><span class="s3">\n        </span><span class="s1">current.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">ani_p.hooked = false;</span><span class="s3">\n        </span><span class="s1">ani_p.playing = false;</span><span class="s3">\n        </span><span class="s1">ani_p.started = false;</span><span class="s3">\n        </span><span class="s1">callbacks(ani_p.completes);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ranAnis = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!isCore &amp;&amp; current.length === 0 &amp;&amp; queue.length === 0) {</span><span class="s3">\n      </span><span class="s1">doneEles.push(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ranAnis;</span><span class="s3">\n  </span><span class="s1">} // stepElement</span><span class="s3">\n\n  </span><span class="s1">// handle all eles</span><span class="s3">\n  </span><span class="s1">var ranEleAni = false;</span><span class="s3">\n  </span><span class="s1">for (var e = 0; e &lt; eles.length; e++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[e];</span><span class="s3">\n    </span><span class="s1">var handledThisEle = stepOne(ele);</span><span class="s3">\n    </span><span class="s1">ranEleAni = ranEleAni || handledThisEle;</span><span class="s3">\n  </span><span class="s1">} // each element</span><span class="s3">\n\n  </span><span class="s1">var ranCoreAni = stepOne(cy, true);</span><span class="s3">\n\n  </span><span class="s1">// notify renderer</span><span class="s3">\n  </span><span class="s1">if (ranEleAni || ranCoreAni) {</span><span class="s3">\n    </span><span class="s1">if (eles.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">cy.notify('draw', eles);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cy.notify('draw');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// remove elements from list of currently animating if its queues are empty</span><span class="s3">\n  </span><span class="s1">eles.unmerge(doneEles);</span><span class="s3">\n  </span><span class="s1">cy.emit('step');</span><span class="s3">\n</span><span class="s1">} // stepAll</span><span class="s3">\n\n</span><span class="s1">var corefn$8 = {</span><span class="s3">\n  </span><span class="s1">// pull in animation functions</span><span class="s3">\n  </span><span class="s1">animate: define.animate(),</span><span class="s3">\n  </span><span class="s1">animation: define.animation(),</span><span class="s3">\n  </span><span class="s1">animated: define.animated(),</span><span class="s3">\n  </span><span class="s1">clearQueue: define.clearQueue(),</span><span class="s3">\n  </span><span class="s1">delay: define.delay(),</span><span class="s3">\n  </span><span class="s1">delayAnimation: define.delayAnimation(),</span><span class="s3">\n  </span><span class="s1">stop: define.stop(),</span><span class="s3">\n  </span><span class="s1">addToAnimationPool: function addToAnimationPool(eles) {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // save cycles when no style used</span><span class="s3">\n\n    </span><span class="s1">cy._private.aniEles.merge(eles);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">stopAnimationLoop: function stopAnimationLoop() {</span><span class="s3">\n    </span><span class="s1">this._private.animationsRunning = false;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">startAnimationLoop: function startAnimationLoop() {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">cy._private.animationsRunning = true;</span><span class="s3">\n    </span><span class="s1">if (!cy.styleEnabled()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // save cycles when no style used</span><span class="s3">\n\n    </span><span class="s1">// NB the animation loop will exec in headless environments if style enabled</span><span class="s3">\n    </span><span class="s1">// and explicit cy.destroy() is necessary to stop the loop</span><span class="s3">\n\n    </span><span class="s1">function headlessStep() {</span><span class="s3">\n      </span><span class="s1">if (!cy._private.animationsRunning) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">requestAnimationFrame(function animationStep(now) {</span><span class="s3">\n        </span><span class="s1">stepAll(now, cy);</span><span class="s3">\n        </span><span class="s1">headlessStep();</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var renderer = cy.renderer();</span><span class="s3">\n    </span><span class="s1">if (renderer &amp;&amp; renderer.beforeRender) {</span><span class="s3">\n      </span><span class="s1">// let the renderer schedule animations</span><span class="s3">\n      </span><span class="s1">renderer.beforeRender(function rendererAnimationStep(willDraw, now) {</span><span class="s3">\n        </span><span class="s1">stepAll(now, cy);</span><span class="s3">\n      </span><span class="s1">}, renderer.beforeRenderPriorities.animations);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// manage the animation loop ourselves</span><span class="s3">\n      </span><span class="s1">headlessStep(); // first call</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var emitterOptions = {</span><span class="s3">\n  </span><span class="s1">qualifierCompare: function qualifierCompare(selector1, selector2) {</span><span class="s3">\n    </span><span class="s1">if (selector1 == null || selector2 == null) {</span><span class="s3">\n      </span><span class="s1">return selector1 == null &amp;&amp; selector2 == null;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return selector1.sameText(selector2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">eventMatches: function eventMatches(cy, listener, eventObj) {</span><span class="s3">\n    </span><span class="s1">var selector = listener.qualifier;</span><span class="s3">\n    </span><span class="s1">if (selector != null) {</span><span class="s3">\n      </span><span class="s1">return cy !== eventObj.target &amp;&amp; element(eventObj.target) &amp;&amp; selector.matches(eventObj.target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">addEventFields: function addEventFields(cy, evt) {</span><span class="s3">\n    </span><span class="s1">evt.cy = cy;</span><span class="s3">\n    </span><span class="s1">evt.target = cy;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">callbackContext: function callbackContext(cy, listener, eventObj) {</span><span class="s3">\n    </span><span class="s1">return listener.qualifier != null ? eventObj.target : cy;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var argSelector = function argSelector(arg) {</span><span class="s3">\n  </span><span class="s1">if (string(arg)) {</span><span class="s3">\n    </span><span class="s1">return new Selector(arg);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return arg;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var elesfn = {</span><span class="s3">\n  </span><span class="s1">createEmitter: function createEmitter() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (!_p.emitter) {</span><span class="s3">\n      </span><span class="s1">_p.emitter = new Emitter(emitterOptions, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">emitter: function emitter() {</span><span class="s3">\n    </span><span class="s1">return this._private.emitter;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">on: function on(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">this.emitter().on(events, argSelector(selector), callback);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeListener: function removeListener(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">this.emitter().removeListener(events, argSelector(selector), callback);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeAllListeners: function removeAllListeners() {</span><span class="s3">\n    </span><span class="s1">this.emitter().removeAllListeners();</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">one: function one(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">this.emitter().one(events, argSelector(selector), callback);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">once: function once(events, selector, callback) {</span><span class="s3">\n    </span><span class="s1">this.emitter().one(events, argSelector(selector), callback);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">emit: function emit(events, extraParams) {</span><span class="s3">\n    </span><span class="s1">this.emitter().emit(events, extraParams);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">emitAndNotify: function emitAndNotify(event, eles) {</span><span class="s3">\n    </span><span class="s1">this.emit(event);</span><span class="s3">\n    </span><span class="s1">this.notify(event, eles);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">define.eventAliasesOn(elesfn);</span><span class="s3">\n\n</span><span class="s1">var corefn$7 = {</span><span class="s3">\n  </span><span class="s1">png: function png(options) {</span><span class="s3">\n    </span><span class="s1">var renderer = this._private.renderer;</span><span class="s3">\n    </span><span class="s1">options = options || {};</span><span class="s3">\n    </span><span class="s1">return renderer.png(options);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">jpg: function jpg(options) {</span><span class="s3">\n    </span><span class="s1">var renderer = this._private.renderer;</span><span class="s3">\n    </span><span class="s1">options = options || {};</span><span class="s3">\n    </span><span class="s1">options.bg = options.bg || '#fff';</span><span class="s3">\n    </span><span class="s1">return renderer.jpg(options);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">corefn$7.jpeg = corefn$7.jpg;</span><span class="s3">\n\n</span><span class="s1">var corefn$6 = {</span><span class="s3">\n  </span><span class="s1">layout: function layout(options) {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">if (options == null) {</span><span class="s3">\n      </span><span class="s1">error('Layout options must be specified to make a layout');</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (options.name == null) {</span><span class="s3">\n      </span><span class="s1">error('A `name` must be specified to make a layout');</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var name = options.name;</span><span class="s3">\n    </span><span class="s1">var Layout = cy.extension('layout', name);</span><span class="s3">\n    </span><span class="s1">if (Layout == null) {</span><span class="s3">\n      </span><span class="s1">error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var eles;</span><span class="s3">\n    </span><span class="s1">if (string(options.eles)) {</span><span class="s3">\n      </span><span class="s1">eles = cy.$(options.eles);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">eles = options.eles != null ? options.eles : cy.$();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var layout = new Layout(extend({}, options, {</span><span class="s3">\n      </span><span class="s1">cy: cy,</span><span class="s3">\n      </span><span class="s1">eles: eles</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return layout;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">corefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;</span><span class="s3">\n\n</span><span class="s1">var corefn$5 = {</span><span class="s3">\n  </span><span class="s1">notify: function notify(eventName, eventEles) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (this.batching()) {</span><span class="s3">\n      </span><span class="s1">_p.batchNotifications = _p.batchNotifications || {};</span><span class="s3">\n      </span><span class="s1">var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();</span><span class="s3">\n      </span><span class="s1">if (eventEles != null) {</span><span class="s3">\n        </span><span class="s1">eles.merge(eventEles);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return; // notifications are disabled during batching</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!_p.notificationsEnabled) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // exit on disabled</span><span class="s3">\n\n    </span><span class="s1">var renderer = this.renderer();</span><span class="s3">\n\n    </span><span class="s1">// exit if destroy() called on core or renderer in between frames #1499 #1528</span><span class="s3">\n    </span><span class="s1">if (this.destroyed() || !renderer) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">renderer.notify(eventName, eventEles);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">notifications: function notifications(bool) {</span><span class="s3">\n    </span><span class="s1">var p = this._private;</span><span class="s3">\n    </span><span class="s1">if (bool === undefined) {</span><span class="s3">\n      </span><span class="s1">return p.notificationsEnabled;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">p.notificationsEnabled = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">noNotifications: function noNotifications(callback) {</span><span class="s3">\n    </span><span class="s1">this.notifications(false);</span><span class="s3">\n    </span><span class="s1">callback();</span><span class="s3">\n    </span><span class="s1">this.notifications(true);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">batching: function batching() {</span><span class="s3">\n    </span><span class="s1">return this._private.batchCount &gt; 0;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">startBatch: function startBatch() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (_p.batchCount == null) {</span><span class="s3">\n      </span><span class="s1">_p.batchCount = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (_p.batchCount === 0) {</span><span class="s3">\n      </span><span class="s1">_p.batchStyleEles = this.collection();</span><span class="s3">\n      </span><span class="s1">_p.batchNotifications = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.batchCount++;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">endBatch: function endBatch() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (_p.batchCount === 0) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.batchCount--;</span><span class="s3">\n    </span><span class="s1">if (_p.batchCount === 0) {</span><span class="s3">\n      </span><span class="s1">// update style for dirty eles</span><span class="s3">\n      </span><span class="s1">_p.batchStyleEles.updateStyle();</span><span class="s3">\n      </span><span class="s1">var renderer = this.renderer();</span><span class="s3">\n\n      </span><span class="s1">// notify the renderer of queued eles and event types</span><span class="s3">\n      </span><span class="s1">Object.keys(_p.batchNotifications).forEach(function (eventName) {</span><span class="s3">\n        </span><span class="s1">var eles = _p.batchNotifications[eventName];</span><span class="s3">\n        </span><span class="s1">if (eles.empty()) {</span><span class="s3">\n          </span><span class="s1">renderer.notify(eventName);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">renderer.notify(eventName, eles);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">batch: function batch(callback) {</span><span class="s3">\n    </span><span class="s1">this.startBatch();</span><span class="s3">\n    </span><span class="s1">callback();</span><span class="s3">\n    </span><span class="s1">this.endBatch();</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// for backwards compatibility</span><span class="s3">\n  </span><span class="s1">batchData: function batchData(map) {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">return this.batch(function () {</span><span class="s3">\n      </span><span class="s1">var ids = Object.keys(map);</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; ids.length; i++) {</span><span class="s3">\n        </span><span class="s1">var id = ids[i];</span><span class="s3">\n        </span><span class="s1">var data = map[id];</span><span class="s3">\n        </span><span class="s1">var ele = cy.getElementById(id);</span><span class="s3">\n        </span><span class="s1">ele.data(data);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var rendererDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">hideEdgesOnViewport: false,</span><span class="s3">\n  </span><span class="s1">textureOnViewport: false,</span><span class="s3">\n  </span><span class="s1">motionBlur: false,</span><span class="s3">\n  </span><span class="s1">motionBlurOpacity: 0.05,</span><span class="s3">\n  </span><span class="s1">pixelRatio: undefined,</span><span class="s3">\n  </span><span class="s1">desktopTapThreshold: 4,</span><span class="s3">\n  </span><span class="s1">touchTapThreshold: 8,</span><span class="s3">\n  </span><span class="s1">wheelSensitivity: 1,</span><span class="s3">\n  </span><span class="s1">debug: false,</span><span class="s3">\n  </span><span class="s1">showFps: false,</span><span class="s3">\n  </span><span class="s1">// webgl options</span><span class="s3">\n  </span><span class="s1">webgl: false,</span><span class="s3">\n  </span><span class="s1">webglDebug: false,</span><span class="s3">\n  </span><span class="s1">webglDebugShowAtlases: false,</span><span class="s3">\n  </span><span class="s1">// defaults good for mobile</span><span class="s3">\n  </span><span class="s1">webglTexSize: 2048,</span><span class="s3">\n  </span><span class="s1">webglTexRows: 36,</span><span class="s3">\n  </span><span class="s1">webglTexRowsNodes: 18,</span><span class="s3">\n  </span><span class="s1">webglBatchSize: 2048,</span><span class="s3">\n  </span><span class="s1">webglTexPerBatch: 14,</span><span class="s3">\n  </span><span class="s1">webglBgColor: [255, 255, 255]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var corefn$4 = {</span><span class="s3">\n  </span><span class="s1">renderTo: function renderTo(context, zoom, pan, pxRatio) {</span><span class="s3">\n    </span><span class="s1">var r = this._private.renderer;</span><span class="s3">\n    </span><span class="s1">r.renderTo(context, zoom, pan, pxRatio);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">renderer: function renderer() {</span><span class="s3">\n    </span><span class="s1">return this._private.renderer;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">forceRender: function forceRender() {</span><span class="s3">\n    </span><span class="s1">this.notify('draw');</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">resize: function resize() {</span><span class="s3">\n    </span><span class="s1">this.invalidateSize();</span><span class="s3">\n    </span><span class="s1">this.emitAndNotify('resize');</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">initRenderer: function initRenderer(options) {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">var RendererProto = cy.extension('renderer', options.name);</span><span class="s3">\n    </span><span class="s1">if (RendererProto == null) {</span><span class="s3">\n      </span><span class="s1">error(</span><span class="s3">\&quot;</span><span class="s1">Can not initialise: No such renderer `</span><span class="s3">\&quot;</span><span class="s1">.concat(options.name, </span><span class="s3">\&quot;</span><span class="s1">` found. Did you forget to import it and `cytoscape.use()` it?</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (options.wheelSensitivity !== undefined) {</span><span class="s3">\n      </span><span class="s1">warn(</span><span class="s3">\&quot;</span><span class="s1">You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var rOpts = rendererDefaults(options);</span><span class="s3">\n    </span><span class="s1">rOpts.cy = cy;</span><span class="s3">\n    </span><span class="s1">cy._private.renderer = new RendererProto(rOpts);</span><span class="s3">\n    </span><span class="s1">this.notify('init');</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">destroyRenderer: function destroyRenderer() {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">cy.notify('destroy'); // destroy the renderer</span><span class="s3">\n\n    </span><span class="s1">var domEle = cy.container();</span><span class="s3">\n    </span><span class="s1">if (domEle) {</span><span class="s3">\n      </span><span class="s1">domEle._cyreg = null;</span><span class="s3">\n      </span><span class="s1">while (domEle.childNodes.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">domEle.removeChild(domEle.childNodes[0]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cy._private.renderer = null; // to be extra safe, remove the ref</span><span class="s3">\n    </span><span class="s1">cy.mutableElements().forEach(function (ele) {</span><span class="s3">\n      </span><span class="s1">var _p = ele._private;</span><span class="s3">\n      </span><span class="s1">_p.rscratch = {};</span><span class="s3">\n      </span><span class="s1">_p.rstyle = {};</span><span class="s3">\n      </span><span class="s1">_p.animation.current = [];</span><span class="s3">\n      </span><span class="s1">_p.animation.queue = [];</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">onRender: function onRender(fn) {</span><span class="s3">\n    </span><span class="s1">return this.on('render', fn);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">offRender: function offRender(fn) {</span><span class="s3">\n    </span><span class="s1">return this.off('render', fn);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">corefn$4.invalidateDimensions = corefn$4.resize;</span><span class="s3">\n\n</span><span class="s1">var corefn$3 = {</span><span class="s3">\n  </span><span class="s1">// get a collection</span><span class="s3">\n  </span><span class="s1">// - empty collection on no args</span><span class="s3">\n  </span><span class="s1">// - collection of elements in the graph on selector arg</span><span class="s3">\n  </span><span class="s1">// - guarantee a returned collection when elements or collection specified</span><span class="s3">\n  </span><span class="s1">collection: function collection(eles, opts) {</span><span class="s3">\n    </span><span class="s1">if (string(eles)) {</span><span class="s3">\n      </span><span class="s1">return this.$(eles);</span><span class="s3">\n    </span><span class="s1">} else if (elementOrCollection(eles)) {</span><span class="s3">\n      </span><span class="s1">return eles.collection();</span><span class="s3">\n    </span><span class="s1">} else if (array(eles)) {</span><span class="s3">\n      </span><span class="s1">if (!opts) {</span><span class="s3">\n        </span><span class="s1">opts = {};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return new Collection(this, eles, opts.unique, opts.removed);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new Collection(this);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">nodes: function nodes(selector) {</span><span class="s3">\n    </span><span class="s1">var nodes = this.$(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isNode();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (selector) {</span><span class="s3">\n      </span><span class="s1">return nodes.filter(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return nodes;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">edges: function edges(selector) {</span><span class="s3">\n    </span><span class="s1">var edges = this.$(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.isEdge();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (selector) {</span><span class="s3">\n      </span><span class="s1">return edges.filter(selector);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return edges;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// search the graph like jQuery</span><span class="s3">\n  </span><span class="s1">$: function $(selector) {</span><span class="s3">\n    </span><span class="s1">var eles = this._private.elements;</span><span class="s3">\n    </span><span class="s1">if (selector) {</span><span class="s3">\n      </span><span class="s1">return eles.filter(selector);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return eles.spawnSelf();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">mutableElements: function mutableElements() {</span><span class="s3">\n    </span><span class="s1">return this._private.elements;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">corefn$3.elements = corefn$3.filter = corefn$3.$;</span><span class="s3">\n\n</span><span class="s1">var styfn$8 = {};</span><span class="s3">\n\n</span><span class="s1">// keys for style blocks, e.g. ttfftt</span><span class="s3">\n</span><span class="s1">var TRUE = 't';</span><span class="s3">\n</span><span class="s1">var FALSE = 'f';</span><span class="s3">\n\n</span><span class="s1">// (potentially expensive calculation)</span><span class="s3">\n</span><span class="s1">// apply the style to the element based on</span><span class="s3">\n</span><span class="s1">// - its bypass</span><span class="s3">\n</span><span class="s1">// - what selectors match it</span><span class="s3">\n</span><span class="s1">styfn$8.apply = function (eles) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var _p = self._private;</span><span class="s3">\n  </span><span class="s1">var cy = _p.cy;</span><span class="s3">\n  </span><span class="s1">var updatedEles = cy.collection();</span><span class="s3">\n  </span><span class="s1">for (var ie = 0; ie &lt; eles.length; ie++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[ie];</span><span class="s3">\n    </span><span class="s1">var cxtMeta = self.getContextMeta(ele);</span><span class="s3">\n    </span><span class="s1">if (cxtMeta.empty) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var cxtStyle = self.getContextStyle(cxtMeta);</span><span class="s3">\n    </span><span class="s1">var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);</span><span class="s3">\n    </span><span class="s1">if (ele._private.appliedInitStyle) {</span><span class="s3">\n      </span><span class="s1">self.updateTransitions(ele, app.diffProps);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">ele._private.appliedInitStyle = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var hintsDiff = self.updateStyleHints(ele);</span><span class="s3">\n    </span><span class="s1">if (hintsDiff) {</span><span class="s3">\n      </span><span class="s1">updatedEles.push(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} // for elements</span><span class="s3">\n\n  </span><span class="s1">return updatedEles;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.getPropertiesDiff = function (oldCxtKey, newCxtKey) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var cache = self._private.propDiffs = self._private.propDiffs || {};</span><span class="s3">\n  </span><span class="s1">var dualCxtKey = oldCxtKey + '-' + newCxtKey;</span><span class="s3">\n  </span><span class="s1">var cachedVal = cache[dualCxtKey];</span><span class="s3">\n  </span><span class="s1">if (cachedVal) {</span><span class="s3">\n    </span><span class="s1">return cachedVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var diffProps = [];</span><span class="s3">\n  </span><span class="s1">var addedProp = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; self.length; i++) {</span><span class="s3">\n    </span><span class="s1">var cxt = self[i];</span><span class="s3">\n    </span><span class="s1">var oldHasCxt = oldCxtKey[i] === TRUE;</span><span class="s3">\n    </span><span class="s1">var newHasCxt = newCxtKey[i] === TRUE;</span><span class="s3">\n    </span><span class="s1">var cxtHasDiffed = oldHasCxt !== newHasCxt;</span><span class="s3">\n    </span><span class="s1">var cxtHasMappedProps = cxt.mappedProperties.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">if (cxtHasDiffed || newHasCxt &amp;&amp; cxtHasMappedProps) {</span><span class="s3">\n      </span><span class="s1">var props = undefined;</span><span class="s3">\n      </span><span class="s1">if (cxtHasDiffed &amp;&amp; cxtHasMappedProps) {</span><span class="s3">\n        </span><span class="s1">props = cxt.properties; // suffices b/c mappedProperties is a subset of properties</span><span class="s3">\n      </span><span class="s1">} else if (cxtHasDiffed) {</span><span class="s3">\n        </span><span class="s1">props = cxt.properties; // need to check them all</span><span class="s3">\n      </span><span class="s1">} else if (cxtHasMappedProps) {</span><span class="s3">\n        </span><span class="s1">props = cxt.mappedProperties; // only need to check mapped</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; props.length; j++) {</span><span class="s3">\n        </span><span class="s1">var prop = props[j];</span><span class="s3">\n        </span><span class="s1">var name = prop.name;</span><span class="s3">\n\n        </span><span class="s1">// if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter</span><span class="s3">\n        </span><span class="s1">// (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result</span><span class="s3">\n        </span><span class="s1">// is cached)</span><span class="s3">\n        </span><span class="s1">var laterCxtOverrides = false;</span><span class="s3">\n        </span><span class="s1">for (var k = i + 1; k &lt; self.length; k++) {</span><span class="s3">\n          </span><span class="s1">var laterCxt = self[k];</span><span class="s3">\n          </span><span class="s1">var hasLaterCxt = newCxtKey[k] === TRUE;</span><span class="s3">\n          </span><span class="s1">if (!hasLaterCxt) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">} // can't override unless the context is active</span><span class="s3">\n\n          </span><span class="s1">laterCxtOverrides = laterCxt.properties[prop.name] != null;</span><span class="s3">\n          </span><span class="s1">if (laterCxtOverrides) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">} // exit early as long as one later context overrides</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!addedProp[name] &amp;&amp; !laterCxtOverrides) {</span><span class="s3">\n          </span><span class="s1">addedProp[name] = true;</span><span class="s3">\n          </span><span class="s1">diffProps.push(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // for props</span><span class="s3">\n    </span><span class="s1">} // if</span><span class="s3">\n  </span><span class="s1">} // for contexts</span><span class="s3">\n\n  </span><span class="s1">cache[dualCxtKey] = diffProps;</span><span class="s3">\n  </span><span class="s1">return diffProps;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.getContextMeta = function (ele) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var cxtKey = '';</span><span class="s3">\n  </span><span class="s1">var diffProps;</span><span class="s3">\n  </span><span class="s1">var prevKey = ele._private.styleCxtKey || '';</span><span class="s3">\n\n  </span><span class="s1">// get the cxt key</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; self.length; i++) {</span><span class="s3">\n    </span><span class="s1">var context = self[i];</span><span class="s3">\n    </span><span class="s1">var contextSelectorMatches = context.selector &amp;&amp; context.selector.matches(ele); // NB: context.selector may be null for 'core'</span><span class="s3">\n\n    </span><span class="s1">if (contextSelectorMatches) {</span><span class="s3">\n      </span><span class="s1">cxtKey += TRUE;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cxtKey += FALSE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} // for context</span><span class="s3">\n\n  </span><span class="s1">diffProps = self.getPropertiesDiff(prevKey, cxtKey);</span><span class="s3">\n  </span><span class="s1">ele._private.styleCxtKey = cxtKey;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">key: cxtKey,</span><span class="s3">\n    </span><span class="s1">diffPropNames: diffProps,</span><span class="s3">\n    </span><span class="s1">empty: diffProps.length === 0</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// gets a computed ele style object based on matched contexts</span><span class="s3">\n</span><span class="s1">styfn$8.getContextStyle = function (cxtMeta) {</span><span class="s3">\n  </span><span class="s1">var cxtKey = cxtMeta.key;</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};</span><span class="s3">\n\n  </span><span class="s1">// if already computed style, returned cached copy</span><span class="s3">\n  </span><span class="s1">if (cxtStyles[cxtKey]) {</span><span class="s3">\n    </span><span class="s1">return cxtStyles[cxtKey];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var style = {</span><span class="s3">\n    </span><span class="s1">_private: {</span><span class="s3">\n      </span><span class="s1">key: cxtKey</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; self.length; i++) {</span><span class="s3">\n    </span><span class="s1">var cxt = self[i];</span><span class="s3">\n    </span><span class="s1">var hasCxt = cxtKey[i] === TRUE;</span><span class="s3">\n    </span><span class="s1">if (!hasCxt) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; cxt.properties.length; j++) {</span><span class="s3">\n      </span><span class="s1">var prop = cxt.properties[j];</span><span class="s3">\n      </span><span class="s1">style[prop.name] = prop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">cxtStyles[cxtKey] = style;</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.applyContextStyle = function (cxtMeta, cxtStyle, ele) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var diffProps = cxtMeta.diffPropNames;</span><span class="s3">\n  </span><span class="s1">var retDiffProps = {};</span><span class="s3">\n  </span><span class="s1">var types = self.types;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; diffProps.length; i++) {</span><span class="s3">\n    </span><span class="s1">var diffPropName = diffProps[i];</span><span class="s3">\n    </span><span class="s1">var cxtProp = cxtStyle[diffPropName];</span><span class="s3">\n    </span><span class="s1">var eleProp = ele.pstyle(diffPropName);</span><span class="s3">\n    </span><span class="s1">if (!cxtProp) {</span><span class="s3">\n      </span><span class="s1">// no context prop means delete</span><span class="s3">\n      </span><span class="s1">if (!eleProp) {</span><span class="s3">\n        </span><span class="s1">continue; // no existing prop means nothing needs to be removed</span><span class="s3">\n        </span><span class="s1">// nb affects initial application on mapped values like control-point-distances</span><span class="s3">\n      </span><span class="s1">} else if (eleProp.bypass) {</span><span class="s3">\n        </span><span class="s1">cxtProp = {</span><span class="s3">\n          </span><span class="s1">name: diffPropName,</span><span class="s3">\n          </span><span class="s1">deleteBypassed: true</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cxtProp = {</span><span class="s3">\n          </span><span class="s1">name: diffPropName,</span><span class="s3">\n          \&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">: true</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// save cycles when the context prop doesn't need to be applied</span><span class="s3">\n    </span><span class="s1">if (eleProp === cxtProp) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// save cycles when a mapped context prop doesn't need to be applied</span><span class="s3">\n    </span><span class="s1">if (cxtProp.mapped === types.fn // context prop is function mapper</span><span class="s3">\n    </span><span class="s1">&amp;&amp; eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)</span><span class="s3">\n    </span><span class="s1">&amp;&amp; eleProp.mapping != null // ele prop is a concrete value from from a mapper</span><span class="s3">\n    </span><span class="s1">&amp;&amp; eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)</span><span class="s3">\n      </span><span class="s1">var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy</span><span class="s3">\n      </span><span class="s1">var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss</span><span class="s3">\n\n      </span><span class="s1">if (fnValue === mapping.prevFnValue) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var retDiffProp = retDiffProps[diffPropName] = {</span><span class="s3">\n      </span><span class="s1">prev: eleProp</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">self.applyParsedProperty(ele, cxtProp);</span><span class="s3">\n    </span><span class="s1">retDiffProp.next = ele.pstyle(diffPropName);</span><span class="s3">\n    </span><span class="s1">if (retDiffProp.next &amp;&amp; retDiffProp.next.bypass) {</span><span class="s3">\n      </span><span class="s1">retDiffProp.next = retDiffProp.next.bypassed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">diffProps: retDiffProps</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.updateStyleHints = function (ele) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var propNames = self.propertyGroupNames;</span><span class="s3">\n  </span><span class="s1">var propGrKeys = self.propertyGroupKeys;</span><span class="s3">\n  </span><span class="s1">var propHash = function propHash(ele, propNames, seedKey) {</span><span class="s3">\n    </span><span class="s1">return self.getPropertiesHash(ele, propNames, seedKey);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var oldStyleKey = _p.styleKey;</span><span class="s3">\n  </span><span class="s1">if (ele.removed()) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var isNode = _p.group === 'nodes';</span><span class="s3">\n\n  </span><span class="s1">// get the style key hashes per prop group</span><span class="s3">\n  </span><span class="s1">// but lazily -- only use non-default prop values to reduce the number of hashes</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">var overriddenStyles = ele._private.style;</span><span class="s3">\n  </span><span class="s1">propNames = Object.keys(overriddenStyles);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; propGrKeys.length; i++) {</span><span class="s3">\n    </span><span class="s1">var grKey = propGrKeys[i];</span><span class="s3">\n    </span><span class="s1">_p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var updateGrKey1 = function updateGrKey1(val, grKey) {</span><span class="s3">\n    </span><span class="s1">return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var updateGrKey2 = function updateGrKey2(val, grKey) {</span><span class="s3">\n    </span><span class="s1">return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var updateGrKey = function updateGrKey(val, grKey) {</span><span class="s3">\n    </span><span class="s1">updateGrKey1(val, grKey);</span><span class="s3">\n    </span><span class="s1">updateGrKey2(val, grKey);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; strVal.length; j++) {</span><span class="s3">\n      </span><span class="s1">var ch = strVal.charCodeAt(j);</span><span class="s3">\n      </span><span class="s1">updateGrKey1(ch, grKey);</span><span class="s3">\n      </span><span class="s1">updateGrKey2(ch, grKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// - hashing works on 32 bit ints b/c we use bitwise ops</span><span class="s3">\n  </span><span class="s1">// - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)</span><span class="s3">\n  </span><span class="s1">// - raise up small numbers so more significant digits are seen by hashing</span><span class="s3">\n  </span><span class="s1">// - make small numbers larger than a normal value to avoid collisions</span><span class="s3">\n  </span><span class="s1">// - works in practice and it's relatively cheap</span><span class="s3">\n  </span><span class="s1">var N = 2000000000;</span><span class="s3">\n  </span><span class="s1">var cleanNum = function cleanNum(val) {</span><span class="s3">\n    </span><span class="s1">return -128 &lt; val &amp;&amp; val &lt; 128 &amp;&amp; Math.floor(val) !== val ? N - (val * 1024 | 0) : val;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; propNames.length; _i++) {</span><span class="s3">\n    </span><span class="s1">var name = propNames[_i];</span><span class="s3">\n    </span><span class="s1">var parsedProp = overriddenStyles[name];</span><span class="s3">\n    </span><span class="s1">if (parsedProp == null) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var propInfo = this.properties[name];</span><span class="s3">\n    </span><span class="s1">var type = propInfo.type;</span><span class="s3">\n    </span><span class="s1">var _grKey = propInfo.groupKey;</span><span class="s3">\n    </span><span class="s1">var normalizedNumberVal = undefined;</span><span class="s3">\n    </span><span class="s1">if (propInfo.hashOverride != null) {</span><span class="s3">\n      </span><span class="s1">normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);</span><span class="s3">\n    </span><span class="s1">} else if (parsedProp.pfValue != null) {</span><span class="s3">\n      </span><span class="s1">normalizedNumberVal = parsedProp.pfValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// might not be a number if it allows enums</span><span class="s3">\n    </span><span class="s1">var numberVal = propInfo.enums == null ? parsedProp.value : null;</span><span class="s3">\n    </span><span class="s1">var haveNormNum = normalizedNumberVal != null;</span><span class="s3">\n    </span><span class="s1">var haveUnitedNum = numberVal != null;</span><span class="s3">\n    </span><span class="s1">var haveNum = haveNormNum || haveUnitedNum;</span><span class="s3">\n    </span><span class="s1">var units = parsedProp.units;</span><span class="s3">\n\n    </span><span class="s1">// numbers are cheaper to hash than strings</span><span class="s3">\n    </span><span class="s1">// 1 hash op vs n hash ops (for length n string)</span><span class="s3">\n    </span><span class="s1">if (type.number &amp;&amp; haveNum &amp;&amp; !type.multiple) {</span><span class="s3">\n      </span><span class="s1">var v = haveNormNum ? normalizedNumberVal : numberVal;</span><span class="s3">\n      </span><span class="s1">updateGrKey(cleanNum(v), _grKey);</span><span class="s3">\n      </span><span class="s1">if (!haveNormNum &amp;&amp; units != null) {</span><span class="s3">\n        </span><span class="s1">updateGrKeyWStr(units, _grKey);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">updateGrKeyWStr(parsedProp.strValue, _grKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// overall style key</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; propGrKeys.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var _grKey2 = propGrKeys[_i2];</span><span class="s3">\n    </span><span class="s1">var grHash = _p.styleKeys[_grKey2];</span><span class="s3">\n    </span><span class="s1">hash[0] = hashInt(grHash[0], hash[0]);</span><span class="s3">\n    </span><span class="s1">hash[1] = hashIntAlt(grHash[1], hash[1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">_p.styleKey = combineHashes(hash[0], hash[1]);</span><span class="s3">\n\n  </span><span class="s1">// label dims</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">var sk = _p.styleKeys;</span><span class="s3">\n  </span><span class="s1">_p.labelDimsKey = combineHashesArray(sk.labelDimensions);</span><span class="s3">\n  </span><span class="s1">var labelKeys = propHash(ele, ['label'], sk.labelDimensions);</span><span class="s3">\n  </span><span class="s1">_p.labelKey = combineHashesArray(labelKeys);</span><span class="s3">\n  </span><span class="s1">_p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));</span><span class="s3">\n  </span><span class="s1">if (!isNode) {</span><span class="s3">\n    </span><span class="s1">var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);</span><span class="s3">\n    </span><span class="s1">_p.sourceLabelKey = combineHashesArray(sourceLabelKeys);</span><span class="s3">\n    </span><span class="s1">_p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));</span><span class="s3">\n    </span><span class="s1">var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);</span><span class="s3">\n    </span><span class="s1">_p.targetLabelKey = combineHashesArray(targetLabelKeys);</span><span class="s3">\n    </span><span class="s1">_p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// node</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">if (isNode) {</span><span class="s3">\n    </span><span class="s1">var _p$styleKeys = _p.styleKeys,</span><span class="s3">\n      </span><span class="s1">nodeBody = _p$styleKeys.nodeBody,</span><span class="s3">\n      </span><span class="s1">nodeBorder = _p$styleKeys.nodeBorder,</span><span class="s3">\n      </span><span class="s1">nodeOutline = _p$styleKeys.nodeOutline,</span><span class="s3">\n      </span><span class="s1">backgroundImage = _p$styleKeys.backgroundImage,</span><span class="s3">\n      </span><span class="s1">compound = _p$styleKeys.compound,</span><span class="s3">\n      </span><span class="s1">pie = _p$styleKeys.pie;</span><span class="s3">\n    </span><span class="s1">var nodeKeys = [nodeBody, nodeBorder, nodeOutline, backgroundImage, compound, pie].filter(function (k) {</span><span class="s3">\n      </span><span class="s1">return k != null;</span><span class="s3">\n    </span><span class="s1">}).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);</span><span class="s3">\n    </span><span class="s1">_p.nodeKey = combineHashesArray(nodeKeys);</span><span class="s3">\n    </span><span class="s1">_p.hasPie = pie != null &amp;&amp; pie[0] !== DEFAULT_HASH_SEED &amp;&amp; pie[1] !== DEFAULT_HASH_SEED_ALT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return oldStyleKey !== _p.styleKey;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.clearStyleHints = function (ele) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">_p.styleCxtKey = '';</span><span class="s3">\n  </span><span class="s1">_p.styleKeys = {};</span><span class="s3">\n  </span><span class="s1">_p.styleKey = null;</span><span class="s3">\n  </span><span class="s1">_p.labelKey = null;</span><span class="s3">\n  </span><span class="s1">_p.labelStyleKey = null;</span><span class="s3">\n  </span><span class="s1">_p.sourceLabelKey = null;</span><span class="s3">\n  </span><span class="s1">_p.sourceLabelStyleKey = null;</span><span class="s3">\n  </span><span class="s1">_p.targetLabelKey = null;</span><span class="s3">\n  </span><span class="s1">_p.targetLabelStyleKey = null;</span><span class="s3">\n  </span><span class="s1">_p.nodeKey = null;</span><span class="s3">\n  </span><span class="s1">_p.hasPie = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// apply a property to the style (for internal use)</span><span class="s3">\n</span><span class="s1">// returns whether application was successful</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// now, this function flattens the property, and here's how:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// for parsedProp:{ bypass: true, deleteBypass: true }</span><span class="s3">\n</span><span class="s1">// no property is generated, instead the bypass property in the</span><span class="s3">\n</span><span class="s1">// element's style is replaced by what's pointed to by the `bypassed`</span><span class="s3">\n</span><span class="s1">// field in the bypass property (i.e. restoring the property the</span><span class="s3">\n</span><span class="s1">// bypass was overriding)</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// for parsedProp:{ mapped: truthy }</span><span class="s3">\n</span><span class="s1">// the generated flattenedProp:{ mapping: prop }</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// for parsedProp:{ bypass: true }</span><span class="s3">\n</span><span class="s1">// the generated flattenedProp:{ bypassed: parsedProp }</span><span class="s3">\n</span><span class="s1">styfn$8.applyParsedProperty = function (ele, parsedProp) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var prop = parsedProp;</span><span class="s3">\n  </span><span class="s1">var style = ele._private.style;</span><span class="s3">\n  </span><span class="s1">var flatProp;</span><span class="s3">\n  </span><span class="s1">var types = self.types;</span><span class="s3">\n  </span><span class="s1">var type = self.properties[prop.name].type;</span><span class="s3">\n  </span><span class="s1">var propIsBypass = prop.bypass;</span><span class="s3">\n  </span><span class="s1">var origProp = style[prop.name];</span><span class="s3">\n  </span><span class="s1">var origPropIsBypass = origProp &amp;&amp; origProp.bypass;</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var flatPropMapping = 'mapping';</span><span class="s3">\n  </span><span class="s1">var getVal = function getVal(p) {</span><span class="s3">\n    </span><span class="s1">if (p == null) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">} else if (p.pfValue != null) {</span><span class="s3">\n      </span><span class="s1">return p.pfValue;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return p.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var checkTriggers = function checkTriggers() {</span><span class="s3">\n    </span><span class="s1">var fromVal = getVal(origProp);</span><span class="s3">\n    </span><span class="s1">var toVal = getVal(prop);</span><span class="s3">\n    </span><span class="s1">self.checkTriggers(ele, prop.name, fromVal, toVal);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// edge sanity checks to prevent the client from making serious mistakes</span><span class="s3">\n  </span><span class="s1">if (parsedProp.name === 'curve-style' &amp;&amp; ele.isEdge() &amp;&amp; (</span><span class="s3">\n  </span><span class="s1">// loops must be bundled beziers</span><span class="s3">\n  </span><span class="s1">parsedProp.value !== 'bezier' &amp;&amp; ele.isLoop() ||</span><span class="s3">\n  </span><span class="s1">// edges connected to compound nodes can not be haystacks</span><span class="s3">\n  </span><span class="s1">parsedProp.value === 'haystack' &amp;&amp; (ele.source().isParent() || ele.target().isParent()))) {</span><span class="s3">\n    </span><span class="s1">prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (prop[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">]) {</span><span class="s3">\n    </span><span class="s1">// delete the property and use the default value on falsey value</span><span class="s3">\n    </span><span class="s1">style[prop.name] = undefined;</span><span class="s3">\n    </span><span class="s1">checkTriggers();</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (prop.deleteBypassed) {</span><span class="s3">\n    </span><span class="s1">// delete the property that the</span><span class="s3">\n    </span><span class="s1">if (!origProp) {</span><span class="s3">\n      </span><span class="s1">checkTriggers();</span><span class="s3">\n      </span><span class="s1">return true; // can't delete if no prop</span><span class="s3">\n    </span><span class="s1">} else if (origProp.bypass) {</span><span class="s3">\n      </span><span class="s1">// delete bypassed</span><span class="s3">\n      </span><span class="s1">origProp.bypassed = undefined;</span><span class="s3">\n      </span><span class="s1">checkTriggers();</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return false; // we're unsuccessful deleting the bypassed</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check if we need to delete the current bypass</span><span class="s3">\n  </span><span class="s1">if (prop.deleteBypass) {</span><span class="s3">\n    </span><span class="s1">// then this property is just here to indicate we need to delete</span><span class="s3">\n    </span><span class="s1">if (!origProp) {</span><span class="s3">\n      </span><span class="s1">checkTriggers();</span><span class="s3">\n      </span><span class="s1">return true; // property is already not defined</span><span class="s3">\n    </span><span class="s1">} else if (origProp.bypass) {</span><span class="s3">\n      </span><span class="s1">// then replace the bypass property with the original</span><span class="s3">\n      </span><span class="s1">// because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)</span><span class="s3">\n      </span><span class="s1">style[prop.name] = origProp.bypassed;</span><span class="s3">\n      </span><span class="s1">checkTriggers();</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return false; // we're unsuccessful deleting the bypass</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var printMappingErr = function printMappingErr() {</span><span class="s3">\n    </span><span class="s1">warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// put the property in the style objects</span><span class="s3">\n  </span><span class="s1">switch (prop.mapped) {</span><span class="s3">\n    </span><span class="s1">// flatten the property if mapped</span><span class="s3">\n    </span><span class="s1">case types.mapData:</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">// flatten the field (e.g. data.foo.bar)</span><span class="s3">\n        </span><span class="s1">var fields = prop.field.split('.');</span><span class="s3">\n        </span><span class="s1">var fieldVal = _p.data;</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; fields.length &amp;&amp; fieldVal; i++) {</span><span class="s3">\n          </span><span class="s1">var field = fields[i];</span><span class="s3">\n          </span><span class="s1">fieldVal = fieldVal[field];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (fieldVal == null) {</span><span class="s3">\n          </span><span class="s1">printMappingErr();</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var percent;</span><span class="s3">\n        </span><span class="s1">if (!number$1(fieldVal)) {</span><span class="s3">\n          </span><span class="s1">// then don't apply and fall back on the existing style</span><span class="s3">\n          </span><span class="s1">warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var fieldWidth = prop.fieldMax - prop.fieldMin;</span><span class="s3">\n          </span><span class="s1">if (fieldWidth === 0) {</span><span class="s3">\n            </span><span class="s1">// safety check -- not strictly necessary as no props of zero range should be passed here</span><span class="s3">\n            </span><span class="s1">percent = 0;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">percent = (fieldVal - prop.fieldMin) / fieldWidth;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// make sure to bound percent value</span><span class="s3">\n        </span><span class="s1">if (percent &lt; 0) {</span><span class="s3">\n          </span><span class="s1">percent = 0;</span><span class="s3">\n        </span><span class="s1">} else if (percent &gt; 1) {</span><span class="s3">\n          </span><span class="s1">percent = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (type.color) {</span><span class="s3">\n          </span><span class="s1">var r1 = prop.valueMin[0];</span><span class="s3">\n          </span><span class="s1">var r2 = prop.valueMax[0];</span><span class="s3">\n          </span><span class="s1">var g1 = prop.valueMin[1];</span><span class="s3">\n          </span><span class="s1">var g2 = prop.valueMax[1];</span><span class="s3">\n          </span><span class="s1">var b1 = prop.valueMin[2];</span><span class="s3">\n          </span><span class="s1">var b2 = prop.valueMax[2];</span><span class="s3">\n          </span><span class="s1">var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];</span><span class="s3">\n          </span><span class="s1">var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];</span><span class="s3">\n          </span><span class="s1">var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];</span><span class="s3">\n          </span><span class="s1">flatProp = {</span><span class="s3">\n            </span><span class="s1">// colours are simple, so just create the flat property instead of expensive string parsing</span><span class="s3">\n            </span><span class="s1">bypass: prop.bypass,</span><span class="s3">\n            </span><span class="s1">// we're a bypass if the mapping property is a bypass</span><span class="s3">\n            </span><span class="s1">name: prop.name,</span><span class="s3">\n            </span><span class="s1">value: clr,</span><span class="s3">\n            </span><span class="s1">strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">} else if (type.number) {</span><span class="s3">\n          </span><span class="s1">var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;</span><span class="s3">\n          </span><span class="s1">flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return false; // can only map to colours and numbers</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!flatProp) {</span><span class="s3">\n          </span><span class="s1">// if we can't flatten the property, then don't apply the property and fall back on the existing style</span><span class="s3">\n          </span><span class="s1">printMappingErr();</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">flatProp.mapping = prop; // keep a reference to the mapping</span><span class="s3">\n        </span><span class="s1">prop = flatProp; // the flattened (mapped) property is the one we want</span><span class="s3">\n\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// direct mapping</span><span class="s3">\n    </span><span class="s1">case types.data:</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">// flatten the field (e.g. data.foo.bar)</span><span class="s3">\n        </span><span class="s1">var _fields = prop.field.split('.');</span><span class="s3">\n        </span><span class="s1">var _fieldVal = _p.data;</span><span class="s3">\n        </span><span class="s1">for (var _i3 = 0; _i3 &lt; _fields.length &amp;&amp; _fieldVal; _i3++) {</span><span class="s3">\n          </span><span class="s1">var _field = _fields[_i3];</span><span class="s3">\n          </span><span class="s1">_fieldVal = _fieldVal[_field];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (_fieldVal != null) {</span><span class="s3">\n          </span><span class="s1">flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!flatProp) {</span><span class="s3">\n          </span><span class="s1">// if we can't flatten the property, then don't apply and fall back on the existing style</span><span class="s3">\n          </span><span class="s1">printMappingErr();</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">flatProp.mapping = prop; // keep a reference to the mapping</span><span class="s3">\n        </span><span class="s1">prop = flatProp; // the flattened (mapped) property is the one we want</span><span class="s3">\n\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case types.fn:</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">var fn = prop.value;</span><span class="s3">\n        </span><span class="s1">var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function</span><span class="s3">\n\n        </span><span class="s1">prop.prevFnValue = fnRetVal;</span><span class="s3">\n        </span><span class="s1">if (fnRetVal == null) {</span><span class="s3">\n          </span><span class="s1">warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);</span><span class="s3">\n        </span><span class="s1">if (!flatProp) {</span><span class="s3">\n          </span><span class="s1">warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">flatProp.mapping = copy(prop); // keep a reference to the mapping</span><span class="s3">\n        </span><span class="s1">prop = flatProp; // the flattened (mapped) property is the one we want</span><span class="s3">\n\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case undefined:</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">// just set the property</span><span class="s3">\n\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">// not a valid mapping</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the property is a bypass property, then link the resultant property to the original one</span><span class="s3">\n  </span><span class="s1">if (propIsBypass) {</span><span class="s3">\n    </span><span class="s1">if (origPropIsBypass) {</span><span class="s3">\n      </span><span class="s1">// then this bypass overrides the existing one</span><span class="s3">\n      </span><span class="s1">prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// then link the orig prop to the new bypass</span><span class="s3">\n      </span><span class="s1">prop.bypassed = origProp;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">style[prop.name] = prop; // and set</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// prop is not bypass</span><span class="s3">\n    </span><span class="s1">if (origPropIsBypass) {</span><span class="s3">\n      </span><span class="s1">// then keep the orig prop (since it's a bypass) and link to the new prop</span><span class="s3">\n      </span><span class="s1">origProp.bypassed = prop;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// then just replace the old prop with the new one</span><span class="s3">\n      </span><span class="s1">style[prop.name] = prop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">checkTriggers();</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.cleanElements = function (eles, keepBypasses) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">this.clearStyleHints(ele);</span><span class="s3">\n    </span><span class="s1">ele.dirtyCompoundBoundsCache();</span><span class="s3">\n    </span><span class="s1">ele.dirtyBoundingBoxCache();</span><span class="s3">\n    </span><span class="s1">if (!keepBypasses) {</span><span class="s3">\n      </span><span class="s1">ele._private.style = {};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var style = ele._private.style;</span><span class="s3">\n      </span><span class="s1">var propNames = Object.keys(style);</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; propNames.length; j++) {</span><span class="s3">\n        </span><span class="s1">var propName = propNames[j];</span><span class="s3">\n        </span><span class="s1">var eleProp = style[propName];</span><span class="s3">\n        </span><span class="s1">if (eleProp != null) {</span><span class="s3">\n          </span><span class="s1">if (eleProp.bypass) {</span><span class="s3">\n            </span><span class="s1">eleProp.bypassed = null;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">style[propName] = null;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// updates the visual style for all elements (useful for manual style modification after init)</span><span class="s3">\n</span><span class="s1">styfn$8.update = function () {</span><span class="s3">\n  </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n  </span><span class="s1">var eles = cy.mutableElements();</span><span class="s3">\n  </span><span class="s1">eles.updateStyle();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// diffProps : { name =&gt; { prev, next } }</span><span class="s3">\n</span><span class="s1">styfn$8.updateTransitions = function (ele, diffProps) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var props = ele.pstyle('transition-property').value;</span><span class="s3">\n  </span><span class="s1">var duration = ele.pstyle('transition-duration').pfValue;</span><span class="s3">\n  </span><span class="s1">var delay = ele.pstyle('transition-delay').pfValue;</span><span class="s3">\n  </span><span class="s1">if (props.length &gt; 0 &amp;&amp; duration &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var style = {};</span><span class="s3">\n\n    </span><span class="s1">// build up the style to animate towards</span><span class="s3">\n    </span><span class="s1">var anyPrev = false;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; props.length; i++) {</span><span class="s3">\n      </span><span class="s1">var prop = props[i];</span><span class="s3">\n      </span><span class="s1">var styProp = ele.pstyle(prop);</span><span class="s3">\n      </span><span class="s1">var diffProp = diffProps[prop];</span><span class="s3">\n      </span><span class="s1">if (!diffProp) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var prevProp = diffProp.prev;</span><span class="s3">\n      </span><span class="s1">var fromProp = prevProp;</span><span class="s3">\n      </span><span class="s1">var toProp = diffProp.next != null ? diffProp.next : styProp;</span><span class="s3">\n      </span><span class="s1">var diff = false;</span><span class="s3">\n      </span><span class="s1">var initVal = undefined;</span><span class="s3">\n      </span><span class="s1">var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)</span><span class="s3">\n\n      </span><span class="s1">if (!fromProp) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// consider px values</span><span class="s3">\n      </span><span class="s1">if (number$1(fromProp.pfValue) &amp;&amp; number$1(toProp.pfValue)) {</span><span class="s3">\n        </span><span class="s1">diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy</span><span class="s3">\n        </span><span class="s1">initVal = fromProp.pfValue + initDt * diff;</span><span class="s3">\n\n        </span><span class="s1">// consider numerical values</span><span class="s3">\n      </span><span class="s1">} else if (number$1(fromProp.value) &amp;&amp; number$1(toProp.value)) {</span><span class="s3">\n        </span><span class="s1">diff = toProp.value - fromProp.value; // nonzero is truthy</span><span class="s3">\n        </span><span class="s1">initVal = fromProp.value + initDt * diff;</span><span class="s3">\n\n        </span><span class="s1">// consider colour values</span><span class="s3">\n      </span><span class="s1">} else if (array(fromProp.value) &amp;&amp; array(toProp.value)) {</span><span class="s3">\n        </span><span class="s1">diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];</span><span class="s3">\n        </span><span class="s1">initVal = fromProp.strValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// the previous value is good for an animation only if it's different</span><span class="s3">\n      </span><span class="s1">if (diff) {</span><span class="s3">\n        </span><span class="s1">style[prop] = toProp.strValue; // to val</span><span class="s3">\n        </span><span class="s1">this.applyBypass(ele, prop, initVal); // from val</span><span class="s3">\n        </span><span class="s1">anyPrev = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} // end if props allow ani</span><span class="s3">\n\n    </span><span class="s1">// can't transition if there's nothing previous to transition from</span><span class="s3">\n    </span><span class="s1">if (!anyPrev) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.transitioning = true;</span><span class="s3">\n    </span><span class="s1">new Promise$1(function (resolve) {</span><span class="s3">\n      </span><span class="s1">if (delay &gt; 0) {</span><span class="s3">\n        </span><span class="s1">ele.delayAnimation(delay).play().promise().then(resolve);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">resolve();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}).then(function () {</span><span class="s3">\n      </span><span class="s1">return ele.animation({</span><span class="s3">\n        </span><span class="s1">style: style,</span><span class="s3">\n        </span><span class="s1">duration: duration,</span><span class="s3">\n        </span><span class="s1">easing: ele.pstyle('transition-timing-function').value,</span><span class="s3">\n        </span><span class="s1">queue: false</span><span class="s3">\n      </span><span class="s1">}).play().promise();</span><span class="s3">\n    </span><span class="s1">}).then(function () {</span><span class="s3">\n      </span><span class="s1">// if( !isBypass ){</span><span class="s3">\n      </span><span class="s1">self.removeBypasses(ele, props);</span><span class="s3">\n      </span><span class="s1">ele.emitAndNotify('style');</span><span class="s3">\n      </span><span class="s1">// }</span><span class="s3">\n\n      </span><span class="s1">_p.transitioning = false;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (_p.transitioning) {</span><span class="s3">\n    </span><span class="s1">this.removeBypasses(ele, props);</span><span class="s3">\n    </span><span class="s1">ele.emitAndNotify('style');</span><span class="s3">\n    </span><span class="s1">_p.transitioning = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {</span><span class="s3">\n  </span><span class="s1">var prop = this.properties[name];</span><span class="s3">\n  </span><span class="s1">var triggerCheck = getTrigger(prop);</span><span class="s3">\n  </span><span class="s1">if (ele.removed()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (triggerCheck != null &amp;&amp; triggerCheck(fromValue, toValue, ele)) {</span><span class="s3">\n    </span><span class="s1">onTrigger(prop);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.checkZOrderTrigger = function (ele, name, fromValue, toValue) {</span><span class="s3">\n  </span><span class="s1">var _this = this;</span><span class="s3">\n  </span><span class="s1">this.checkTrigger(ele, name, fromValue, toValue, function (prop) {</span><span class="s3">\n    </span><span class="s1">return prop.triggersZOrder;</span><span class="s3">\n  </span><span class="s1">}, function () {</span><span class="s3">\n    </span><span class="s1">_this._private.cy.notify('zorder', ele);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.checkBoundsTrigger = function (ele, name, fromValue, toValue) {</span><span class="s3">\n  </span><span class="s1">this.checkTrigger(ele, name, fromValue, toValue, function (prop) {</span><span class="s3">\n    </span><span class="s1">return prop.triggersBounds;</span><span class="s3">\n  </span><span class="s1">}, function (prop) {</span><span class="s3">\n    </span><span class="s1">ele.dirtyCompoundBoundsCache();</span><span class="s3">\n    </span><span class="s1">ele.dirtyBoundingBoxCache();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.checkConnectedEdgesBoundsTrigger = function (ele, name, fromValue, toValue) {</span><span class="s3">\n  </span><span class="s1">this.checkTrigger(ele, name, fromValue, toValue, function (prop) {</span><span class="s3">\n    </span><span class="s1">return prop.triggersBoundsOfConnectedEdges;</span><span class="s3">\n  </span><span class="s1">}, function (prop) {</span><span class="s3">\n    </span><span class="s1">ele.connectedEdges().forEach(function (edge) {</span><span class="s3">\n      </span><span class="s1">edge.dirtyBoundingBoxCache();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.checkParallelEdgesBoundsTrigger = function (ele, name, fromValue, toValue) {</span><span class="s3">\n  </span><span class="s1">this.checkTrigger(ele, name, fromValue, toValue, function (prop) {</span><span class="s3">\n    </span><span class="s1">return prop.triggersBoundsOfParallelEdges;</span><span class="s3">\n  </span><span class="s1">}, function (prop) {</span><span class="s3">\n    </span><span class="s1">ele.parallelEdges().forEach(function (pllEdge) {</span><span class="s3">\n      </span><span class="s1">pllEdge.dirtyBoundingBoxCache();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$8.checkTriggers = function (ele, name, fromValue, toValue) {</span><span class="s3">\n  </span><span class="s1">ele.dirtyStyleCache();</span><span class="s3">\n  </span><span class="s1">this.checkZOrderTrigger(ele, name, fromValue, toValue);</span><span class="s3">\n  </span><span class="s1">this.checkBoundsTrigger(ele, name, fromValue, toValue);</span><span class="s3">\n  </span><span class="s1">this.checkConnectedEdgesBoundsTrigger(ele, name, fromValue, toValue);</span><span class="s3">\n  </span><span class="s1">this.checkParallelEdgesBoundsTrigger(ele, name, fromValue, toValue);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var styfn$7 = {};</span><span class="s3">\n\n</span><span class="s1">// bypasses are applied to an existing style on an element, and just tacked on temporarily</span><span class="s3">\n</span><span class="s1">// returns true iff application was successful for at least 1 specified property</span><span class="s3">\n</span><span class="s1">styfn$7.applyBypass = function (eles, name, value, updateTransitions) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var props = [];</span><span class="s3">\n  </span><span class="s1">var isBypass = true;</span><span class="s3">\n\n  </span><span class="s1">// put all the properties (can specify one or many) in an array after parsing them</span><span class="s3">\n  </span><span class="s1">if (name === '*' || name === '**') {</span><span class="s3">\n    </span><span class="s1">// apply to all property names</span><span class="s3">\n\n    </span><span class="s1">if (value !== undefined) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; self.properties.length; i++) {</span><span class="s3">\n        </span><span class="s1">var prop = self.properties[i];</span><span class="s3">\n        </span><span class="s1">var _name = prop.name;</span><span class="s3">\n        </span><span class="s1">var parsedProp = this.parse(_name, value, true);</span><span class="s3">\n        </span><span class="s1">if (parsedProp) {</span><span class="s3">\n          </span><span class="s1">props.push(parsedProp);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (string(name)) {</span><span class="s3">\n    </span><span class="s1">// then parse the single property</span><span class="s3">\n    </span><span class="s1">var _parsedProp = this.parse(name, value, true);</span><span class="s3">\n    </span><span class="s1">if (_parsedProp) {</span><span class="s3">\n      </span><span class="s1">props.push(_parsedProp);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (plainObject(name)) {</span><span class="s3">\n    </span><span class="s1">// then parse each property</span><span class="s3">\n    </span><span class="s1">var specifiedProps = name;</span><span class="s3">\n    </span><span class="s1">updateTransitions = value;</span><span class="s3">\n    </span><span class="s1">var names = Object.keys(specifiedProps);</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; names.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var _name2 = names[_i];</span><span class="s3">\n      </span><span class="s1">var _value = specifiedProps[_name2];</span><span class="s3">\n      </span><span class="s1">if (_value === undefined) {</span><span class="s3">\n        </span><span class="s1">// try camel case name too</span><span class="s3">\n        </span><span class="s1">_value = specifiedProps[dash2camel(_name2)];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (_value !== undefined) {</span><span class="s3">\n        </span><span class="s1">var _parsedProp2 = this.parse(_name2, _value, true);</span><span class="s3">\n        </span><span class="s1">if (_parsedProp2) {</span><span class="s3">\n          </span><span class="s1">props.push(_parsedProp2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// can't do anything without well defined properties</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we've failed if there are no valid properties</span><span class="s3">\n  </span><span class="s1">if (props.length === 0) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// now, apply the bypass properties on the elements</span><span class="s3">\n  </span><span class="s1">var ret = false; // return true if at least one succesful bypass applied</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; eles.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">// for each ele</span><span class="s3">\n    </span><span class="s1">var ele = eles[_i2];</span><span class="s3">\n    </span><span class="s1">var diffProps = {};</span><span class="s3">\n    </span><span class="s1">var diffProp = undefined;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; props.length; j++) {</span><span class="s3">\n      </span><span class="s1">// for each prop</span><span class="s3">\n      </span><span class="s1">var _prop = props[j];</span><span class="s3">\n      </span><span class="s1">if (updateTransitions) {</span><span class="s3">\n        </span><span class="s1">var prevProp = ele.pstyle(_prop.name);</span><span class="s3">\n        </span><span class="s1">diffProp = diffProps[_prop.name] = {</span><span class="s3">\n          </span><span class="s1">prev: prevProp</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ret = this.applyParsedProperty(ele, copy(_prop)) || ret;</span><span class="s3">\n      </span><span class="s1">if (updateTransitions) {</span><span class="s3">\n        </span><span class="s1">diffProp.next = ele.pstyle(_prop.name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} // for props</span><span class="s3">\n\n    </span><span class="s1">if (ret) {</span><span class="s3">\n      </span><span class="s1">this.updateStyleHints(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (updateTransitions) {</span><span class="s3">\n      </span><span class="s1">this.updateTransitions(ele, diffProps, isBypass);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} // for eles</span><span class="s3">\n\n  </span><span class="s1">return ret;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// only useful in specific cases like animation</span><span class="s3">\n</span><span class="s1">styfn$7.overrideBypass = function (eles, name, value) {</span><span class="s3">\n  </span><span class="s1">name = camel2dash(name);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">var prop = ele._private.style[name];</span><span class="s3">\n    </span><span class="s1">var type = this.properties[name].type;</span><span class="s3">\n    </span><span class="s1">var isColor = type.color;</span><span class="s3">\n    </span><span class="s1">var isMulti = type.mutiple;</span><span class="s3">\n    </span><span class="s1">var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;</span><span class="s3">\n    </span><span class="s1">if (!prop || !prop.bypass) {</span><span class="s3">\n      </span><span class="s1">// need a bypass if one doesn't exist</span><span class="s3">\n      </span><span class="s1">this.applyBypass(ele, name, value);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">prop.value = value;</span><span class="s3">\n      </span><span class="s1">if (prop.pfValue != null) {</span><span class="s3">\n        </span><span class="s1">prop.pfValue = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isColor) {</span><span class="s3">\n        </span><span class="s1">prop.strValue = 'rgb(' + value.join(',') + ')';</span><span class="s3">\n      </span><span class="s1">} else if (isMulti) {</span><span class="s3">\n        </span><span class="s1">prop.strValue = value.join(' ');</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">prop.strValue = '' + value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.updateStyleHints(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.checkTriggers(ele, name, oldValue, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$7.removeAllBypasses = function (eles, updateTransitions) {</span><span class="s3">\n  </span><span class="s1">return this.removeBypasses(eles, this.propertyNames, updateTransitions);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$7.removeBypasses = function (eles, props, updateTransitions) {</span><span class="s3">\n  </span><span class="s1">var isBypass = true;</span><span class="s3">\n  </span><span class="s1">for (var j = 0; j &lt; eles.length; j++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[j];</span><span class="s3">\n    </span><span class="s1">var diffProps = {};</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; props.length; i++) {</span><span class="s3">\n      </span><span class="s1">var name = props[i];</span><span class="s3">\n      </span><span class="s1">var prop = this.properties[name];</span><span class="s3">\n      </span><span class="s1">var prevProp = ele.pstyle(prop.name);</span><span class="s3">\n      </span><span class="s1">if (!prevProp || !prevProp.bypass) {</span><span class="s3">\n        </span><span class="s1">// if a bypass doesn't exist for the prop, nothing needs to be removed</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var value = ''; // empty =&gt; remove bypass</span><span class="s3">\n      </span><span class="s1">var parsedProp = this.parse(name, value, true);</span><span class="s3">\n      </span><span class="s1">var diffProp = diffProps[prop.name] = {</span><span class="s3">\n        </span><span class="s1">prev: prevProp</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">this.applyParsedProperty(ele, parsedProp);</span><span class="s3">\n      </span><span class="s1">diffProp.next = ele.pstyle(prop.name);</span><span class="s3">\n    </span><span class="s1">} // for props</span><span class="s3">\n\n    </span><span class="s1">this.updateStyleHints(ele);</span><span class="s3">\n    </span><span class="s1">if (updateTransitions) {</span><span class="s3">\n      </span><span class="s1">this.updateTransitions(ele, diffProps, isBypass);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} // for eles</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var styfn$6 = {};</span><span class="s3">\n\n</span><span class="s1">// gets what an em size corresponds to in pixels relative to a dom element</span><span class="s3">\n</span><span class="s1">styfn$6.getEmSizeInPixels = function () {</span><span class="s3">\n  </span><span class="s1">var px = this.containerCss('font-size');</span><span class="s3">\n  </span><span class="s1">if (px != null) {</span><span class="s3">\n    </span><span class="s1">return parseFloat(px);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 1; // for headless</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// gets css property from the core container</span><span class="s3">\n</span><span class="s1">styfn$6.containerCss = function (propName) {</span><span class="s3">\n  </span><span class="s1">var cy = this._private.cy;</span><span class="s3">\n  </span><span class="s1">var domElement = cy.container();</span><span class="s3">\n  </span><span class="s1">var containerWindow = cy.window();</span><span class="s3">\n  </span><span class="s1">if (containerWindow &amp;&amp; domElement &amp;&amp; containerWindow.getComputedStyle) {</span><span class="s3">\n    </span><span class="s1">return containerWindow.getComputedStyle(domElement).getPropertyValue(propName);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var styfn$5 = {};</span><span class="s3">\n\n</span><span class="s1">// gets the rendered style for an element</span><span class="s3">\n</span><span class="s1">styfn$5.getRenderedStyle = function (ele, prop) {</span><span class="s3">\n  </span><span class="s1">if (prop) {</span><span class="s3">\n    </span><span class="s1">return this.getStylePropertyValue(ele, prop, true);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return this.getRawStyle(ele, true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// gets the raw style for an element</span><span class="s3">\n</span><span class="s1">styfn$5.getRawStyle = function (ele, isRenderedVal) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">ele = ele[0]; // insure it's an element</span><span class="s3">\n\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">var rstyle = {};</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; self.properties.length; i++) {</span><span class="s3">\n      </span><span class="s1">var prop = self.properties[i];</span><span class="s3">\n      </span><span class="s1">var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);</span><span class="s3">\n      </span><span class="s1">if (val != null) {</span><span class="s3">\n        </span><span class="s1">rstyle[prop.name] = val;</span><span class="s3">\n        </span><span class="s1">rstyle[dash2camel(prop.name)] = val;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rstyle;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$5.getIndexedStyle = function (ele, property, subproperty, index) {</span><span class="s3">\n  </span><span class="s1">var pstyle = ele.pstyle(property)[subproperty][index];</span><span class="s3">\n  </span><span class="s1">return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$5.getStylePropertyValue = function (ele, propName, isRenderedVal) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">ele = ele[0]; // insure it's an element</span><span class="s3">\n\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">var prop = self.properties[propName];</span><span class="s3">\n    </span><span class="s1">if (prop.alias) {</span><span class="s3">\n      </span><span class="s1">prop = prop.pointsTo;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var type = prop.type;</span><span class="s3">\n    </span><span class="s1">var styleProp = ele.pstyle(prop.name);</span><span class="s3">\n    </span><span class="s1">if (styleProp) {</span><span class="s3">\n      </span><span class="s1">var value = styleProp.value,</span><span class="s3">\n        </span><span class="s1">units = styleProp.units,</span><span class="s3">\n        </span><span class="s1">strValue = styleProp.strValue;</span><span class="s3">\n      </span><span class="s1">if (isRenderedVal &amp;&amp; type.number &amp;&amp; value != null &amp;&amp; number$1(value)) {</span><span class="s3">\n        </span><span class="s1">var zoom = ele.cy().zoom();</span><span class="s3">\n        </span><span class="s1">var getRenderedValue = function getRenderedValue(val) {</span><span class="s3">\n          </span><span class="s1">return val * zoom;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var getValueStringWithUnits = function getValueStringWithUnits(val, units) {</span><span class="s3">\n          </span><span class="s1">return getRenderedValue(val) + units;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var isArrayValue = array(value);</span><span class="s3">\n        </span><span class="s1">var haveUnits = isArrayValue ? units.every(function (u) {</span><span class="s3">\n          </span><span class="s1">return u != null;</span><span class="s3">\n        </span><span class="s1">}) : units != null;</span><span class="s3">\n        </span><span class="s1">if (haveUnits) {</span><span class="s3">\n          </span><span class="s1">if (isArrayValue) {</span><span class="s3">\n            </span><span class="s1">return value.map(function (v, i) {</span><span class="s3">\n              </span><span class="s1">return getValueStringWithUnits(v, units[i]);</span><span class="s3">\n            </span><span class="s1">}).join(' ');</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">return getValueStringWithUnits(value, units);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (isArrayValue) {</span><span class="s3">\n            </span><span class="s1">return value.map(function (v) {</span><span class="s3">\n              </span><span class="s1">return string(v) ? v : '' + getRenderedValue(v);</span><span class="s3">\n            </span><span class="s1">}).join(' ');</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">return '' + getRenderedValue(value);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (strValue != null) {</span><span class="s3">\n        </span><span class="s1">return strValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$5.getAnimationStartStyle = function (ele, aniProps) {</span><span class="s3">\n  </span><span class="s1">var rstyle = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; aniProps.length; i++) {</span><span class="s3">\n    </span><span class="s1">var aniProp = aniProps[i];</span><span class="s3">\n    </span><span class="s1">var name = aniProp.name;</span><span class="s3">\n    </span><span class="s1">var styleProp = ele.pstyle(name);</span><span class="s3">\n    </span><span class="s1">if (styleProp !== undefined) {</span><span class="s3">\n      </span><span class="s1">// then make a prop of it</span><span class="s3">\n      </span><span class="s1">if (plainObject(styleProp)) {</span><span class="s3">\n        </span><span class="s1">styleProp = this.parse(name, styleProp.strValue);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">styleProp = this.parse(name, styleProp);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (styleProp) {</span><span class="s3">\n      </span><span class="s1">rstyle[name] = styleProp;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return rstyle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$5.getPropsList = function (propsObj) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var rstyle = [];</span><span class="s3">\n  </span><span class="s1">var style = propsObj;</span><span class="s3">\n  </span><span class="s1">var props = self.properties;</span><span class="s3">\n  </span><span class="s1">if (style) {</span><span class="s3">\n    </span><span class="s1">var names = Object.keys(style);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; names.length; i++) {</span><span class="s3">\n      </span><span class="s1">var name = names[i];</span><span class="s3">\n      </span><span class="s1">var val = style[name];</span><span class="s3">\n      </span><span class="s1">var prop = props[name] || props[camel2dash(name)];</span><span class="s3">\n      </span><span class="s1">var styleProp = this.parse(prop.name, val);</span><span class="s3">\n      </span><span class="s1">if (styleProp) {</span><span class="s3">\n        </span><span class="s1">rstyle.push(styleProp);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return rstyle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$5.getNonDefaultPropertiesHash = function (ele, propNames, seed) {</span><span class="s3">\n  </span><span class="s1">var hash = seed.slice();</span><span class="s3">\n  </span><span class="s1">var name, val, strVal, chVal;</span><span class="s3">\n  </span><span class="s1">var i, j;</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; propNames.length; i++) {</span><span class="s3">\n    </span><span class="s1">name = propNames[i];</span><span class="s3">\n    </span><span class="s1">val = ele.pstyle(name, false);</span><span class="s3">\n    </span><span class="s1">if (val == null) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">} else if (val.pfValue != null) {</span><span class="s3">\n      </span><span class="s1">hash[0] = hashInt(chVal, hash[0]);</span><span class="s3">\n      </span><span class="s1">hash[1] = hashIntAlt(chVal, hash[1]);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">strVal = val.strValue;</span><span class="s3">\n      </span><span class="s1">for (j = 0; j &lt; strVal.length; j++) {</span><span class="s3">\n        </span><span class="s1">chVal = strVal.charCodeAt(j);</span><span class="s3">\n        </span><span class="s1">hash[0] = hashInt(chVal, hash[0]);</span><span class="s3">\n        </span><span class="s1">hash[1] = hashIntAlt(chVal, hash[1]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return hash;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;</span><span class="s3">\n\n</span><span class="s1">var styfn$4 = {};</span><span class="s3">\n</span><span class="s1">styfn$4.appendFromJson = function (json) {</span><span class="s3">\n  </span><span class="s1">var style = this;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; json.length; i++) {</span><span class="s3">\n    </span><span class="s1">var context = json[i];</span><span class="s3">\n    </span><span class="s1">var selector = context.selector;</span><span class="s3">\n    </span><span class="s1">var props = context.style || context.css;</span><span class="s3">\n    </span><span class="s1">var names = Object.keys(props);</span><span class="s3">\n    </span><span class="s1">style.selector(selector); // apply selector</span><span class="s3">\n\n    </span><span class="s1">for (var j = 0; j &lt; names.length; j++) {</span><span class="s3">\n      </span><span class="s1">var name = names[j];</span><span class="s3">\n      </span><span class="s1">var value = props[name];</span><span class="s3">\n      </span><span class="s1">style.css(name, value); // apply property</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// accessible cy.style() function</span><span class="s3">\n</span><span class="s1">styfn$4.fromJson = function (json) {</span><span class="s3">\n  </span><span class="s1">var style = this;</span><span class="s3">\n  </span><span class="s1">style.resetToDefault();</span><span class="s3">\n  </span><span class="s1">style.appendFromJson(json);</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get json from cy.style() api</span><span class="s3">\n</span><span class="s1">styfn$4.json = function () {</span><span class="s3">\n  </span><span class="s1">var json = [];</span><span class="s3">\n  </span><span class="s1">for (var i = this.defaultLength; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var cxt = this[i];</span><span class="s3">\n    </span><span class="s1">var selector = cxt.selector;</span><span class="s3">\n    </span><span class="s1">var props = cxt.properties;</span><span class="s3">\n    </span><span class="s1">var css = {};</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; props.length; j++) {</span><span class="s3">\n      </span><span class="s1">var prop = props[j];</span><span class="s3">\n      </span><span class="s1">css[prop.name] = prop.strValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">json.push({</span><span class="s3">\n      </span><span class="s1">selector: !selector ? 'core' : selector.toString(),</span><span class="s3">\n      </span><span class="s1">style: css</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return json;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var styfn$3 = {};</span><span class="s3">\n</span><span class="s1">styfn$3.appendFromString = function (string) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var style = this;</span><span class="s3">\n  </span><span class="s1">var remaining = '' + string;</span><span class="s3">\n  </span><span class="s1">var selAndBlockStr;</span><span class="s3">\n  </span><span class="s1">var blockRem;</span><span class="s3">\n  </span><span class="s1">var propAndValStr;</span><span class="s3">\n\n  </span><span class="s1">// remove comments from the style string</span><span class="s3">\n  </span><span class="s1">remaining = remaining.replace(/[/][*](</span><span class="s3">\\</span><span class="s1">s|.)+?[*][/]/g, '');</span><span class="s3">\n  </span><span class="s1">function removeSelAndBlockFromRemaining() {</span><span class="s3">\n    </span><span class="s1">// remove the parsed selector and block from the remaining text to parse</span><span class="s3">\n    </span><span class="s1">if (remaining.length &gt; selAndBlockStr.length) {</span><span class="s3">\n      </span><span class="s1">remaining = remaining.substr(selAndBlockStr.length);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">remaining = '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function removePropAndValFromRem() {</span><span class="s3">\n    </span><span class="s1">// remove the parsed property and value from the remaining block text to parse</span><span class="s3">\n    </span><span class="s1">if (blockRem.length &gt; propAndValStr.length) {</span><span class="s3">\n      </span><span class="s1">blockRem = blockRem.substr(propAndValStr.length);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">blockRem = '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (;;) {</span><span class="s3">\n    </span><span class="s1">var nothingLeftToParse = remaining.match(/^</span><span class="s3">\\</span><span class="s1">s*$/);</span><span class="s3">\n    </span><span class="s1">if (nothingLeftToParse) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var selAndBlock = remaining.match(/^</span><span class="s3">\\</span><span class="s1">s*((?:.|</span><span class="s3">\\</span><span class="s1">s)+?)</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">{((?:.|</span><span class="s3">\\</span><span class="s1">s)+?)</span><span class="s3">\\</span><span class="s1">}/);</span><span class="s3">\n    </span><span class="s1">if (!selAndBlock) {</span><span class="s3">\n      </span><span class="s1">warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">selAndBlockStr = selAndBlock[0];</span><span class="s3">\n\n    </span><span class="s1">// parse the selector</span><span class="s3">\n    </span><span class="s1">var selectorStr = selAndBlock[1];</span><span class="s3">\n    </span><span class="s1">if (selectorStr !== 'core') {</span><span class="s3">\n      </span><span class="s1">var selector = new Selector(selectorStr);</span><span class="s3">\n      </span><span class="s1">if (selector.invalid) {</span><span class="s3">\n        </span><span class="s1">warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);</span><span class="s3">\n\n        </span><span class="s1">// skip this selector and block</span><span class="s3">\n        </span><span class="s1">removeSelAndBlockFromRemaining();</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// parse the block of properties and values</span><span class="s3">\n    </span><span class="s1">var blockStr = selAndBlock[2];</span><span class="s3">\n    </span><span class="s1">var invalidBlock = false;</span><span class="s3">\n    </span><span class="s1">blockRem = blockStr;</span><span class="s3">\n    </span><span class="s1">var props = [];</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n      </span><span class="s1">var _nothingLeftToParse = blockRem.match(/^</span><span class="s3">\\</span><span class="s1">s*$/);</span><span class="s3">\n      </span><span class="s1">if (_nothingLeftToParse) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var propAndVal = blockRem.match(/^</span><span class="s3">\\</span><span class="s1">s*(.+?)</span><span class="s3">\\</span><span class="s1">s*:</span><span class="s3">\\</span><span class="s1">s*(.+?)(?:</span><span class="s3">\\</span><span class="s1">s*;|</span><span class="s3">\\</span><span class="s1">s*$)/);</span><span class="s3">\n      </span><span class="s1">if (!propAndVal) {</span><span class="s3">\n        </span><span class="s1">warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);</span><span class="s3">\n        </span><span class="s1">invalidBlock = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">propAndValStr = propAndVal[0];</span><span class="s3">\n      </span><span class="s1">var propStr = propAndVal[1];</span><span class="s3">\n      </span><span class="s1">var valStr = propAndVal[2];</span><span class="s3">\n      </span><span class="s1">var prop = self.properties[propStr];</span><span class="s3">\n      </span><span class="s1">if (!prop) {</span><span class="s3">\n        </span><span class="s1">warn('Skipping property: Invalid property name in: ' + propAndValStr);</span><span class="s3">\n\n        </span><span class="s1">// skip this property in the block</span><span class="s3">\n        </span><span class="s1">removePropAndValFromRem();</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var parsedProp = style.parse(propStr, valStr);</span><span class="s3">\n      </span><span class="s1">if (!parsedProp) {</span><span class="s3">\n        </span><span class="s1">warn('Skipping property: Invalid property definition in: ' + propAndValStr);</span><span class="s3">\n\n        </span><span class="s1">// skip this property in the block</span><span class="s3">\n        </span><span class="s1">removePropAndValFromRem();</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">props.push({</span><span class="s3">\n        </span><span class="s1">name: propStr,</span><span class="s3">\n        </span><span class="s1">val: valStr</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">removePropAndValFromRem();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (invalidBlock) {</span><span class="s3">\n      </span><span class="s1">removeSelAndBlockFromRemaining();</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// put the parsed block in the style</span><span class="s3">\n    </span><span class="s1">style.selector(selectorStr);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; props.length; i++) {</span><span class="s3">\n      </span><span class="s1">var _prop = props[i];</span><span class="s3">\n      </span><span class="s1">style.css(_prop.name, _prop.val);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeSelAndBlockFromRemaining();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$3.fromString = function (string) {</span><span class="s3">\n  </span><span class="s1">var style = this;</span><span class="s3">\n  </span><span class="s1">style.resetToDefault();</span><span class="s3">\n  </span><span class="s1">style.appendFromString(string);</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var styfn$2 = {};</span><span class="s3">\n</span><span class="s1">(function () {</span><span class="s3">\n  </span><span class="s1">var number$1 = number;</span><span class="s3">\n  </span><span class="s1">var rgba = rgbaNoBackRefs;</span><span class="s3">\n  </span><span class="s1">var hsla = hslaNoBackRefs;</span><span class="s3">\n  </span><span class="s1">var hex3$1 = hex3;</span><span class="s3">\n  </span><span class="s1">var hex6$1 = hex6;</span><span class="s3">\n  </span><span class="s1">var data = function data(prefix) {</span><span class="s3">\n    </span><span class="s1">return '^' + prefix + '</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">s*([</span><span class="s3">\\\\</span><span class="s1">w</span><span class="s3">\\\\</span><span class="s1">.]+)</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">)$';</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var mapData = function mapData(prefix) {</span><span class="s3">\n    </span><span class="s1">var mapArg = number$1 + '|</span><span class="s3">\\\\</span><span class="s1">w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;</span><span class="s3">\n    </span><span class="s1">return '^' + prefix + '</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">(([</span><span class="s3">\\\\</span><span class="s1">w</span><span class="s3">\\\\</span><span class="s1">.]+)</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + mapArg + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">s*(' + mapArg + ')</span><span class="s3">\\\\</span><span class="s1">)$';</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var urlRegexes = ['^url</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">s*[</span><span class="s3">\\</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">]?(.+?)[</span><span class="s3">\\</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">]?</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">)$', '^(none)$', '^(.+)$'];</span><span class="s3">\n\n  </span><span class="s1">// each visual style property has a type and needs to be validated according to it</span><span class="s3">\n  </span><span class="s1">styfn$2.types = {</span><span class="s3">\n    </span><span class="s1">time: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">units: 's|ms',</span><span class="s3">\n      </span><span class="s1">implicitUnits: 'ms'</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">percent: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">max: 100,</span><span class="s3">\n      </span><span class="s1">units: '%',</span><span class="s3">\n      </span><span class="s1">implicitUnits: '%'</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">percentages: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">max: 100,</span><span class="s3">\n      </span><span class="s1">units: '%',</span><span class="s3">\n      </span><span class="s1">implicitUnits: '%',</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">zeroOneNumber: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">max: 1,</span><span class="s3">\n      </span><span class="s1">unitless: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">zeroOneNumbers: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">max: 1,</span><span class="s3">\n      </span><span class="s1">unitless: true,</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nOneOneNumber: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: -1,</span><span class="s3">\n      </span><span class="s1">max: 1,</span><span class="s3">\n      </span><span class="s1">unitless: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nonNegativeInt: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">integer: true,</span><span class="s3">\n      </span><span class="s1">unitless: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nonNegativeNumber: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">unitless: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">position: {</span><span class="s3">\n      </span><span class="s1">enums: ['parent', 'origin']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nodeSize: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">enums: ['label']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">number: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">unitless: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">numbers: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">unitless: true,</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">positiveNumber: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">unitless: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">strictMin: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">size: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bidirectionalSize: {</span><span class="s3">\n      </span><span class="s1">number: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// allows negative</span><span class="s3">\n    </span><span class="s1">bidirectionalSizeMaybePercent: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">allowPercent: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// allows negative</span><span class="s3">\n    </span><span class="s1">bidirectionalSizes: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// allows negative</span><span class="s3">\n    </span><span class="s1">sizeMaybePercent: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">allowPercent: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">axisDirection: {</span><span class="s3">\n      </span><span class="s1">enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">paddingRelativeTo: {</span><span class="s3">\n      </span><span class="s1">enums: ['width', 'height', 'average', 'min', 'max']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgWH: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">allowPercent: true,</span><span class="s3">\n      </span><span class="s1">enums: ['auto'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgPos: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">allowPercent: true,</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgRelativeTo: {</span><span class="s3">\n      </span><span class="s1">enums: ['inner', 'include-padding'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgRepeat: {</span><span class="s3">\n      </span><span class="s1">enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgFit: {</span><span class="s3">\n      </span><span class="s1">enums: ['none', 'contain', 'cover'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgCrossOrigin: {</span><span class="s3">\n      </span><span class="s1">enums: ['anonymous', 'use-credentials', 'null'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgClip: {</span><span class="s3">\n      </span><span class="s1">enums: ['none', 'node'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bgContainment: {</span><span class="s3">\n      </span><span class="s1">enums: ['inside', 'over'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">color: {</span><span class="s3">\n      </span><span class="s1">color: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">colors: {</span><span class="s3">\n      </span><span class="s1">color: true,</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fill: {</span><span class="s3">\n      </span><span class="s1">enums: ['solid', 'linear-gradient', 'radial-gradient']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bool: {</span><span class="s3">\n      </span><span class="s1">enums: ['yes', 'no']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">bools: {</span><span class="s3">\n      </span><span class="s1">enums: ['yes', 'no'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">lineStyle: {</span><span class="s3">\n      </span><span class="s1">enums: ['solid', 'dotted', 'dashed']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">lineCap: {</span><span class="s3">\n      </span><span class="s1">enums: ['butt', 'round', 'square']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">linePosition: {</span><span class="s3">\n      </span><span class="s1">enums: ['center', 'inside', 'outside']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">lineJoin: {</span><span class="s3">\n      </span><span class="s1">enums: ['round', 'bevel', 'miter']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">borderStyle: {</span><span class="s3">\n      </span><span class="s1">enums: ['solid', 'dotted', 'dashed', 'double']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">curveStyle: {</span><span class="s3">\n      </span><span class="s1">enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'straight-triangle', 'taxi', 'round-segments', 'round-taxi']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">radiusType: {</span><span class="s3">\n      </span><span class="s1">enums: ['arc-radius', 'influence-radius'],</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fontFamily: {</span><span class="s3">\n      </span><span class="s1">regex: '^([</span><span class="s3">\\\\</span><span class="s1">w- </span><span class="s3">\\\\\&quot;</span><span class="s1">]+(?:</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*[</span><span class="s3">\\\\</span><span class="s1">w- </span><span class="s3">\\\\\&quot;</span><span class="s1">]+)*)$'</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fontStyle: {</span><span class="s3">\n      </span><span class="s1">enums: ['italic', 'normal', 'oblique']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fontWeight: {</span><span class="s3">\n      </span><span class="s1">enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">textDecoration: {</span><span class="s3">\n      </span><span class="s1">enums: ['none', 'underline', 'overline', 'line-through']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">textTransform: {</span><span class="s3">\n      </span><span class="s1">enums: ['none', 'uppercase', 'lowercase']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">textWrap: {</span><span class="s3">\n      </span><span class="s1">enums: ['none', 'wrap', 'ellipsis']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">textOverflowWrap: {</span><span class="s3">\n      </span><span class="s1">enums: ['whitespace', 'anywhere']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">textBackgroundShape: {</span><span class="s3">\n      </span><span class="s1">enums: ['rectangle', 'roundrectangle', 'round-rectangle']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nodeShape: {</span><span class="s3">\n      </span><span class="s1">enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'right-rhomboid', 'polygon']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">overlayShape: {</span><span class="s3">\n      </span><span class="s1">enums: ['roundrectangle', 'round-rectangle', 'ellipse']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">cornerRadius: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">units: 'px|em',</span><span class="s3">\n      </span><span class="s1">implicitUnits: 'px',</span><span class="s3">\n      </span><span class="s1">enums: ['auto']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">compoundIncludeLabels: {</span><span class="s3">\n      </span><span class="s1">enums: ['include', 'exclude']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">arrowShape: {</span><span class="s3">\n      </span><span class="s1">enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">arrowFill: {</span><span class="s3">\n      </span><span class="s1">enums: ['filled', 'hollow']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">arrowWidth: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">units: '%|px|em',</span><span class="s3">\n      </span><span class="s1">implicitUnits: 'px',</span><span class="s3">\n      </span><span class="s1">enums: ['match-line']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">display: {</span><span class="s3">\n      </span><span class="s1">enums: ['element', 'none']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">visibility: {</span><span class="s3">\n      </span><span class="s1">enums: ['hidden', 'visible']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">zCompoundDepth: {</span><span class="s3">\n      </span><span class="s1">enums: ['bottom', 'orphan', 'auto', 'top']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">zIndexCompare: {</span><span class="s3">\n      </span><span class="s1">enums: ['auto', 'manual']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">valign: {</span><span class="s3">\n      </span><span class="s1">enums: ['top', 'center', 'bottom']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">halign: {</span><span class="s3">\n      </span><span class="s1">enums: ['left', 'center', 'right']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">justification: {</span><span class="s3">\n      </span><span class="s1">enums: ['left', 'center', 'right', 'auto']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">text: {</span><span class="s3">\n      </span><span class="s1">string: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">data: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">regex: data('data')</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">layoutData: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">regex: data('layoutData')</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">scratch: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">regex: data('scratch')</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">mapData: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">regex: mapData('mapData')</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">mapLayoutData: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">regex: mapData('mapLayoutData')</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">mapScratch: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">regex: mapData('mapScratch')</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fn: {</span><span class="s3">\n      </span><span class="s1">mapping: true,</span><span class="s3">\n      </span><span class="s1">fn: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">url: {</span><span class="s3">\n      </span><span class="s1">regexes: urlRegexes,</span><span class="s3">\n      </span><span class="s1">singleRegexMatchValue: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">urls: {</span><span class="s3">\n      </span><span class="s1">regexes: urlRegexes,</span><span class="s3">\n      </span><span class="s1">singleRegexMatchValue: true,</span><span class="s3">\n      </span><span class="s1">multiple: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">propList: {</span><span class="s3">\n      </span><span class="s1">propList: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">angle: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">units: 'deg|rad',</span><span class="s3">\n      </span><span class="s1">implicitUnits: 'rad'</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">textRotation: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">units: 'deg|rad',</span><span class="s3">\n      </span><span class="s1">implicitUnits: 'rad',</span><span class="s3">\n      </span><span class="s1">enums: ['none', 'autorotate']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">polygonPointList: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">multiple: true,</span><span class="s3">\n      </span><span class="s1">evenMultiple: true,</span><span class="s3">\n      </span><span class="s1">min: -1,</span><span class="s3">\n      </span><span class="s1">max: 1,</span><span class="s3">\n      </span><span class="s1">unitless: true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">edgeDistances: {</span><span class="s3">\n      </span><span class="s1">enums: ['intersection', 'node-position', 'endpoints']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">edgeEndpoint: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">multiple: true,</span><span class="s3">\n      </span><span class="s1">units: '%|px|em|deg|rad',</span><span class="s3">\n      </span><span class="s1">implicitUnits: 'px',</span><span class="s3">\n      </span><span class="s1">enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],</span><span class="s3">\n      </span><span class="s1">singleEnum: true,</span><span class="s3">\n      </span><span class="s1">validate: function validate(valArr, unitsArr) {</span><span class="s3">\n        </span><span class="s1">switch (valArr.length) {</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">// can be % or px only</span><span class="s3">\n            </span><span class="s1">return unitsArr[0] !== 'deg' &amp;&amp; unitsArr[0] !== 'rad' &amp;&amp; unitsArr[1] !== 'deg' &amp;&amp; unitsArr[1] !== 'rad';</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">// can be enum, deg, or rad only</span><span class="s3">\n            </span><span class="s1">return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">easing: {</span><span class="s3">\n      </span><span class="s1">regexes: ['^(spring)</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">)$', '^(cubic-bezier)</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*,</span><span class="s3">\\\\</span><span class="s1">s*(' + number$1 + ')</span><span class="s3">\\\\</span><span class="s1">s*</span><span class="s3">\\\\</span><span class="s1">)$'],</span><span class="s3">\n      </span><span class="s1">enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">gradientDirection: {</span><span class="s3">\n      </span><span class="s1">enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top' // different order</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">boundsExpansion: {</span><span class="s3">\n      </span><span class="s1">number: true,</span><span class="s3">\n      </span><span class="s1">multiple: true,</span><span class="s3">\n      </span><span class="s1">min: 0,</span><span class="s3">\n      </span><span class="s1">validate: function validate(valArr) {</span><span class="s3">\n        </span><span class="s1">var length = valArr.length;</span><span class="s3">\n        </span><span class="s1">return length === 1 || length === 2 || length === 4;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var diff = {</span><span class="s3">\n    </span><span class="s1">zeroNonZero: function zeroNonZero(val1, val2) {</span><span class="s3">\n      </span><span class="s1">if ((val1 == null || val2 == null) &amp;&amp; val1 !== val2) {</span><span class="s3">\n        </span><span class="s1">return true; // null cases could represent any value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (val1 == 0 &amp;&amp; val2 != 0) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">} else if (val1 != 0 &amp;&amp; val2 == 0) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">any: function any(val1, val2) {</span><span class="s3">\n      </span><span class="s1">return val1 != val2;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">emptyNonEmpty: function emptyNonEmpty(str1, str2) {</span><span class="s3">\n      </span><span class="s1">var empty1 = emptyString(str1);</span><span class="s3">\n      </span><span class="s1">var empty2 = emptyString(str2);</span><span class="s3">\n      </span><span class="s1">return empty1 &amp;&amp; !empty2 || !empty1 &amp;&amp; empty2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// define visual style properties</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// - n.b. adding a new group of props may require updates to updateStyleHints()</span><span class="s3">\n  </span><span class="s1">// - adding new props to an existing group gets handled automatically</span><span class="s3">\n\n  </span><span class="s1">var t = styfn$2.types;</span><span class="s3">\n  </span><span class="s1">var mainLabel = [{</span><span class="s3">\n    </span><span class="s1">name: 'label',</span><span class="s3">\n    </span><span class="s1">type: t.text,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.emptyNonEmpty</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-rotation',</span><span class="s3">\n    </span><span class="s1">type: t.textRotation,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-margin-x',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-margin-y',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var sourceLabel = [{</span><span class="s3">\n    </span><span class="s1">name: 'source-label',</span><span class="s3">\n    </span><span class="s1">type: t.text,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'source-text-rotation',</span><span class="s3">\n    </span><span class="s1">type: t.textRotation,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'source-text-margin-x',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'source-text-margin-y',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'source-text-offset',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var targetLabel = [{</span><span class="s3">\n    </span><span class="s1">name: 'target-label',</span><span class="s3">\n    </span><span class="s1">type: t.text,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'target-text-rotation',</span><span class="s3">\n    </span><span class="s1">type: t.textRotation,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'target-text-margin-x',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'target-text-margin-y',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'target-text-offset',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var labelDimensions = [{</span><span class="s3">\n    </span><span class="s1">name: 'font-family',</span><span class="s3">\n    </span><span class="s1">type: t.fontFamily,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'font-style',</span><span class="s3">\n    </span><span class="s1">type: t.fontStyle,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'font-weight',</span><span class="s3">\n    </span><span class="s1">type: t.fontWeight,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'font-size',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-transform',</span><span class="s3">\n    </span><span class="s1">type: t.textTransform,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-wrap',</span><span class="s3">\n    </span><span class="s1">type: t.textWrap,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-overflow-wrap',</span><span class="s3">\n    </span><span class="s1">type: t.textOverflowWrap,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-max-width',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-outline-width',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-height',</span><span class="s3">\n    </span><span class="s1">type: t.positiveNumber,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var commonLabel = [{</span><span class="s3">\n    </span><span class="s1">name: 'text-valign',</span><span class="s3">\n    </span><span class="s1">type: t.valign,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-halign',</span><span class="s3">\n    </span><span class="s1">type: t.halign,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-outline-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-outline-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-background-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-background-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-background-padding',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-border-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-border-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-border-width',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-border-style',</span><span class="s3">\n    </span><span class="s1">type: t.borderStyle,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-background-shape',</span><span class="s3">\n    </span><span class="s1">type: t.textBackgroundShape,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-justification',</span><span class="s3">\n    </span><span class="s1">type: t.justification</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var behavior = [{</span><span class="s3">\n    </span><span class="s1">name: 'events',</span><span class="s3">\n    </span><span class="s1">type: t.bool,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-events',</span><span class="s3">\n    </span><span class="s1">type: t.bool,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var visibility = [{</span><span class="s3">\n    </span><span class="s1">name: 'display',</span><span class="s3">\n    </span><span class="s1">type: t.display,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any,</span><span class="s3">\n    </span><span class="s1">triggersBoundsOfConnectedEdges: diff.any,</span><span class="s3">\n    </span><span class="s1">triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue, ele) {</span><span class="s3">\n      </span><span class="s1">if (fromValue === toValue) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// only if edge is bundled bezier (so as not to affect performance of other edges)</span><span class="s3">\n      </span><span class="s1">return ele.pstyle('curve-style').value === 'bezier';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'visibility',</span><span class="s3">\n    </span><span class="s1">type: t.visibility,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.zeroNonZero</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'text-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-zoomed-font-size',</span><span class="s3">\n    </span><span class="s1">type: t.size</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'z-compound-depth',</span><span class="s3">\n    </span><span class="s1">type: t.zCompoundDepth,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'z-index-compare',</span><span class="s3">\n    </span><span class="s1">type: t.zIndexCompare,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'z-index',</span><span class="s3">\n    </span><span class="s1">type: t.number,</span><span class="s3">\n    </span><span class="s1">triggersZOrder: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var overlay = [{</span><span class="s3">\n    </span><span class="s1">name: 'overlay-padding',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'overlay-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'overlay-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.zeroNonZero</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'overlay-shape',</span><span class="s3">\n    </span><span class="s1">type: t.overlayShape,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'overlay-corner-radius',</span><span class="s3">\n    </span><span class="s1">type: t.cornerRadius</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var underlay = [{</span><span class="s3">\n    </span><span class="s1">name: 'underlay-padding',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'underlay-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'underlay-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.zeroNonZero</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'underlay-shape',</span><span class="s3">\n    </span><span class="s1">type: t.overlayShape,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'underlay-corner-radius',</span><span class="s3">\n    </span><span class="s1">type: t.cornerRadius</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var transition = [{</span><span class="s3">\n    </span><span class="s1">name: 'transition-property',</span><span class="s3">\n    </span><span class="s1">type: t.propList</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'transition-duration',</span><span class="s3">\n    </span><span class="s1">type: t.time</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'transition-delay',</span><span class="s3">\n    </span><span class="s1">type: t.time</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'transition-timing-function',</span><span class="s3">\n    </span><span class="s1">type: t.easing</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {</span><span class="s3">\n    </span><span class="s1">if (parsedProp.value === 'label') {</span><span class="s3">\n      </span><span class="s1">return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return parsedProp.pfValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var nodeBody = [{</span><span class="s3">\n    </span><span class="s1">name: 'height',</span><span class="s3">\n    </span><span class="s1">type: t.nodeSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any,</span><span class="s3">\n    </span><span class="s1">hashOverride: nodeSizeHashOverride</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'width',</span><span class="s3">\n    </span><span class="s1">type: t.nodeSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any,</span><span class="s3">\n    </span><span class="s1">hashOverride: nodeSizeHashOverride</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'shape',</span><span class="s3">\n    </span><span class="s1">type: t.nodeShape,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'shape-polygon-points',</span><span class="s3">\n    </span><span class="s1">type: t.polygonPointList,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'corner-radius',</span><span class="s3">\n    </span><span class="s1">type: t.cornerRadius</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-fill',</span><span class="s3">\n    </span><span class="s1">type: t.fill</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-blacken',</span><span class="s3">\n    </span><span class="s1">type: t.nOneOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-gradient-stop-colors',</span><span class="s3">\n    </span><span class="s1">type: t.colors</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-gradient-stop-positions',</span><span class="s3">\n    </span><span class="s1">type: t.percentages</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-gradient-direction',</span><span class="s3">\n    </span><span class="s1">type: t.gradientDirection</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'padding',</span><span class="s3">\n    </span><span class="s1">type: t.sizeMaybePercent,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'padding-relative-to',</span><span class="s3">\n    </span><span class="s1">type: t.paddingRelativeTo,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'bounds-expansion',</span><span class="s3">\n    </span><span class="s1">type: t.boundsExpansion,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var nodeBorder = [{</span><span class="s3">\n    </span><span class="s1">name: 'border-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-width',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-style',</span><span class="s3">\n    </span><span class="s1">type: t.borderStyle</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-cap',</span><span class="s3">\n    </span><span class="s1">type: t.lineCap</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-join',</span><span class="s3">\n    </span><span class="s1">type: t.lineJoin</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-dash-pattern',</span><span class="s3">\n    </span><span class="s1">type: t.numbers</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-dash-offset',</span><span class="s3">\n    </span><span class="s1">type: t.number</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'border-position',</span><span class="s3">\n    </span><span class="s1">type: t.linePosition</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var nodeOutline = [{</span><span class="s3">\n    </span><span class="s1">name: 'outline-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'outline-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'outline-width',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'outline-style',</span><span class="s3">\n    </span><span class="s1">type: t.borderStyle</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'outline-offset',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var backgroundImage = [{</span><span class="s3">\n    </span><span class="s1">name: 'background-image',</span><span class="s3">\n    </span><span class="s1">type: t.urls</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-image-crossorigin',</span><span class="s3">\n    </span><span class="s1">type: t.bgCrossOrigin</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-image-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumbers</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-image-containment',</span><span class="s3">\n    </span><span class="s1">type: t.bgContainment</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-image-smoothing',</span><span class="s3">\n    </span><span class="s1">type: t.bools</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-position-x',</span><span class="s3">\n    </span><span class="s1">type: t.bgPos</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-position-y',</span><span class="s3">\n    </span><span class="s1">type: t.bgPos</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-width-relative-to',</span><span class="s3">\n    </span><span class="s1">type: t.bgRelativeTo</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-height-relative-to',</span><span class="s3">\n    </span><span class="s1">type: t.bgRelativeTo</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-repeat',</span><span class="s3">\n    </span><span class="s1">type: t.bgRepeat</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-fit',</span><span class="s3">\n    </span><span class="s1">type: t.bgFit</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-clip',</span><span class="s3">\n    </span><span class="s1">type: t.bgClip</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-width',</span><span class="s3">\n    </span><span class="s1">type: t.bgWH</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-height',</span><span class="s3">\n    </span><span class="s1">type: t.bgWH</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-offset-x',</span><span class="s3">\n    </span><span class="s1">type: t.bgPos</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'background-offset-y',</span><span class="s3">\n    </span><span class="s1">type: t.bgPos</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var compound = [{</span><span class="s3">\n    </span><span class="s1">name: 'position',</span><span class="s3">\n    </span><span class="s1">type: t.position,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'compound-sizing-wrt-labels',</span><span class="s3">\n    </span><span class="s1">type: t.compoundIncludeLabels,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-width',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-width-bias-left',</span><span class="s3">\n    </span><span class="s1">type: t.sizeMaybePercent,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-width-bias-right',</span><span class="s3">\n    </span><span class="s1">type: t.sizeMaybePercent,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-height',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-height-bias-top',</span><span class="s3">\n    </span><span class="s1">type: t.sizeMaybePercent,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'min-height-bias-bottom',</span><span class="s3">\n    </span><span class="s1">type: t.sizeMaybePercent,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var edgeLine = [{</span><span class="s3">\n    </span><span class="s1">name: 'line-style',</span><span class="s3">\n    </span><span class="s1">type: t.lineStyle</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-fill',</span><span class="s3">\n    </span><span class="s1">type: t.fill</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-cap',</span><span class="s3">\n    </span><span class="s1">type: t.lineCap</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-dash-pattern',</span><span class="s3">\n    </span><span class="s1">type: t.numbers</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-dash-offset',</span><span class="s3">\n    </span><span class="s1">type: t.number</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-outline-width',</span><span class="s3">\n    </span><span class="s1">type: t.size</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-outline-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-gradient-stop-colors',</span><span class="s3">\n    </span><span class="s1">type: t.colors</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'line-gradient-stop-positions',</span><span class="s3">\n    </span><span class="s1">type: t.percentages</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'curve-style',</span><span class="s3">\n    </span><span class="s1">type: t.curveStyle,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any,</span><span class="s3">\n    </span><span class="s1">triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue) {</span><span class="s3">\n      </span><span class="s1">if (fromValue === toValue) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} // must have diff</span><span class="s3">\n\n      </span><span class="s1">return fromValue === 'bezier' ||</span><span class="s3">\n      </span><span class="s1">// remove from bundle</span><span class="s3">\n      </span><span class="s1">toValue === 'bezier'; // add to bundle</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'haystack-radius',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'source-endpoint',</span><span class="s3">\n    </span><span class="s1">type: t.edgeEndpoint,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'target-endpoint',</span><span class="s3">\n    </span><span class="s1">type: t.edgeEndpoint,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'control-point-step-size',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'control-point-distances',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSizes,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'control-point-weights',</span><span class="s3">\n    </span><span class="s1">type: t.numbers,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'segment-distances',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSizes,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'segment-weights',</span><span class="s3">\n    </span><span class="s1">type: t.numbers,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'segment-radii',</span><span class="s3">\n    </span><span class="s1">type: t.numbers,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'radius-type',</span><span class="s3">\n    </span><span class="s1">type: t.radiusType,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'taxi-turn',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSizeMaybePercent,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'taxi-turn-min-distance',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'taxi-direction',</span><span class="s3">\n    </span><span class="s1">type: t.axisDirection,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'taxi-radius',</span><span class="s3">\n    </span><span class="s1">type: t.number,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'edge-distances',</span><span class="s3">\n    </span><span class="s1">type: t.edgeDistances,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-scale',</span><span class="s3">\n    </span><span class="s1">type: t.positiveNumber,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'loop-direction',</span><span class="s3">\n    </span><span class="s1">type: t.angle,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'loop-sweep',</span><span class="s3">\n    </span><span class="s1">type: t.angle,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'source-distance-from-node',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'target-distance-from-node',</span><span class="s3">\n    </span><span class="s1">type: t.size,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var ghost = [{</span><span class="s3">\n    </span><span class="s1">name: 'ghost',</span><span class="s3">\n    </span><span class="s1">type: t.bool,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'ghost-offset-x',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'ghost-offset-y',</span><span class="s3">\n    </span><span class="s1">type: t.bidirectionalSize,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'ghost-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">var core = [{</span><span class="s3">\n    </span><span class="s1">name: 'selection-box-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'selection-box-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'selection-box-border-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'selection-box-border-width',</span><span class="s3">\n    </span><span class="s1">type: t.size</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'active-bg-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'active-bg-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'active-bg-size',</span><span class="s3">\n    </span><span class="s1">type: t.size</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'outside-texture-bg-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'outside-texture-bg-opacity',</span><span class="s3">\n    </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n\n  </span><span class="s1">// pie backgrounds for nodes</span><span class="s3">\n  </span><span class="s1">var pie = [];</span><span class="s3">\n  </span><span class="s1">styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)</span><span class="s3">\n  </span><span class="s1">pie.push({</span><span class="s3">\n    </span><span class="s1">name: 'pie-size',</span><span class="s3">\n    </span><span class="s1">type: t.sizeMaybePercent</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">for (var i = 1; i &lt;= styfn$2.pieBackgroundN; i++) {</span><span class="s3">\n    </span><span class="s1">pie.push({</span><span class="s3">\n      </span><span class="s1">name: 'pie-' + i + '-background-color',</span><span class="s3">\n      </span><span class="s1">type: t.color</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">pie.push({</span><span class="s3">\n      </span><span class="s1">name: 'pie-' + i + '-background-size',</span><span class="s3">\n      </span><span class="s1">type: t.percent</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">pie.push({</span><span class="s3">\n      </span><span class="s1">name: 'pie-' + i + '-background-opacity',</span><span class="s3">\n      </span><span class="s1">type: t.zeroOneNumber</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// edge arrows</span><span class="s3">\n  </span><span class="s1">var edgeArrow = [];</span><span class="s3">\n  </span><span class="s1">var arrowPrefixes = styfn$2.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];</span><span class="s3">\n  </span><span class="s1">[{</span><span class="s3">\n    </span><span class="s1">name: 'arrow-shape',</span><span class="s3">\n    </span><span class="s1">type: t.arrowShape,</span><span class="s3">\n    </span><span class="s1">triggersBounds: diff.any</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-color',</span><span class="s3">\n    </span><span class="s1">type: t.color</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-fill',</span><span class="s3">\n    </span><span class="s1">type: t.arrowFill</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-width',</span><span class="s3">\n    </span><span class="s1">type: t.arrowWidth</span><span class="s3">\n  </span><span class="s1">}].forEach(function (prop) {</span><span class="s3">\n    </span><span class="s1">arrowPrefixes.forEach(function (prefix) {</span><span class="s3">\n      </span><span class="s1">var name = prefix + '-' + prop.name;</span><span class="s3">\n      </span><span class="s1">var type = prop.type,</span><span class="s3">\n        </span><span class="s1">triggersBounds = prop.triggersBounds;</span><span class="s3">\n      </span><span class="s1">edgeArrow.push({</span><span class="s3">\n        </span><span class="s1">name: name,</span><span class="s3">\n        </span><span class="s1">type: type,</span><span class="s3">\n        </span><span class="s1">triggersBounds: triggersBounds</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}, {});</span><span class="s3">\n  </span><span class="s1">var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, nodeOutline, backgroundImage, pie, compound, edgeLine, edgeArrow, core);</span><span class="s3">\n  </span><span class="s1">var propGroups = styfn$2.propertyGroups = {</span><span class="s3">\n    </span><span class="s1">// common to all eles</span><span class="s3">\n    </span><span class="s1">behavior: behavior,</span><span class="s3">\n    </span><span class="s1">transition: transition,</span><span class="s3">\n    </span><span class="s1">visibility: visibility,</span><span class="s3">\n    </span><span class="s1">overlay: overlay,</span><span class="s3">\n    </span><span class="s1">underlay: underlay,</span><span class="s3">\n    </span><span class="s1">ghost: ghost,</span><span class="s3">\n    </span><span class="s1">// labels</span><span class="s3">\n    </span><span class="s1">commonLabel: commonLabel,</span><span class="s3">\n    </span><span class="s1">labelDimensions: labelDimensions,</span><span class="s3">\n    </span><span class="s1">mainLabel: mainLabel,</span><span class="s3">\n    </span><span class="s1">sourceLabel: sourceLabel,</span><span class="s3">\n    </span><span class="s1">targetLabel: targetLabel,</span><span class="s3">\n    </span><span class="s1">// node props</span><span class="s3">\n    </span><span class="s1">nodeBody: nodeBody,</span><span class="s3">\n    </span><span class="s1">nodeBorder: nodeBorder,</span><span class="s3">\n    </span><span class="s1">nodeOutline: nodeOutline,</span><span class="s3">\n    </span><span class="s1">backgroundImage: backgroundImage,</span><span class="s3">\n    </span><span class="s1">pie: pie,</span><span class="s3">\n    </span><span class="s1">compound: compound,</span><span class="s3">\n    </span><span class="s1">// edge props</span><span class="s3">\n    </span><span class="s1">edgeLine: edgeLine,</span><span class="s3">\n    </span><span class="s1">edgeArrow: edgeArrow,</span><span class="s3">\n    </span><span class="s1">core: core</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var propGroupNames = styfn$2.propertyGroupNames = {};</span><span class="s3">\n  </span><span class="s1">var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);</span><span class="s3">\n  </span><span class="s1">propGroupKeys.forEach(function (key) {</span><span class="s3">\n    </span><span class="s1">propGroupNames[key] = propGroups[key].map(function (prop) {</span><span class="s3">\n      </span><span class="s1">return prop.name;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">propGroups[key].forEach(function (prop) {</span><span class="s3">\n      </span><span class="s1">return prop.groupKey = key;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// define aliases</span><span class="s3">\n  </span><span class="s1">var aliases = styfn$2.aliases = [{</span><span class="s3">\n    </span><span class="s1">name: 'content',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'label'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'control-point-distance',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'control-point-distances'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'control-point-weight',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'control-point-weights'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'segment-distance',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'segment-distances'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'segment-weight',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'segment-weights'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'segment-radius',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'segment-radii'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'edge-text-rotation',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'text-rotation'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'padding-left',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'padding'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'padding-right',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'padding'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'padding-top',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'padding'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'padding-bottom',</span><span class="s3">\n    </span><span class="s1">pointsTo: 'padding'</span><span class="s3">\n  </span><span class="s1">}];</span><span class="s3">\n\n  </span><span class="s1">// list of property names</span><span class="s3">\n  </span><span class="s1">styfn$2.propertyNames = props.map(function (p) {</span><span class="s3">\n    </span><span class="s1">return p.name;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// allow access of properties by name ( e.g. style.properties.height )</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; props.length; _i++) {</span><span class="s3">\n    </span><span class="s1">var prop = props[_i];</span><span class="s3">\n    </span><span class="s1">props[prop.name] = prop; // allow lookup by name</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// map aliases</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; aliases.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var alias = aliases[_i2];</span><span class="s3">\n    </span><span class="s1">var pointsToProp = props[alias.pointsTo];</span><span class="s3">\n    </span><span class="s1">var aliasProp = {</span><span class="s3">\n      </span><span class="s1">name: alias.name,</span><span class="s3">\n      </span><span class="s1">alias: true,</span><span class="s3">\n      </span><span class="s1">pointsTo: pointsToProp</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// add alias prop for parsing</span><span class="s3">\n    </span><span class="s1">props.push(aliasProp);</span><span class="s3">\n    </span><span class="s1">props[alias.name] = aliasProp; // allow lookup by name</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})();</span><span class="s3">\n</span><span class="s1">styfn$2.getDefaultProperty = function (name) {</span><span class="s3">\n  </span><span class="s1">return this.getDefaultProperties()[name];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$2.getDefaultProperties = function () {</span><span class="s3">\n  </span><span class="s1">var _p = this._private;</span><span class="s3">\n  </span><span class="s1">if (_p.defaultProperties != null) {</span><span class="s3">\n    </span><span class="s1">return _p.defaultProperties;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var rawProps = extend({</span><span class="s3">\n    </span><span class="s1">// core props</span><span class="s3">\n    </span><span class="s1">'selection-box-color': '#ddd',</span><span class="s3">\n    </span><span class="s1">'selection-box-opacity': 0.65,</span><span class="s3">\n    </span><span class="s1">'selection-box-border-color': '#aaa',</span><span class="s3">\n    </span><span class="s1">'selection-box-border-width': 1,</span><span class="s3">\n    </span><span class="s1">'active-bg-color': 'black',</span><span class="s3">\n    </span><span class="s1">'active-bg-opacity': 0.15,</span><span class="s3">\n    </span><span class="s1">'active-bg-size': 30,</span><span class="s3">\n    </span><span class="s1">'outside-texture-bg-color': '#000',</span><span class="s3">\n    </span><span class="s1">'outside-texture-bg-opacity': 0.125,</span><span class="s3">\n    </span><span class="s1">// common node/edge props</span><span class="s3">\n    </span><span class="s1">'events': 'yes',</span><span class="s3">\n    </span><span class="s1">'text-events': 'no',</span><span class="s3">\n    </span><span class="s1">'text-valign': 'top',</span><span class="s3">\n    </span><span class="s1">'text-halign': 'center',</span><span class="s3">\n    </span><span class="s1">'text-justification': 'auto',</span><span class="s3">\n    </span><span class="s1">'line-height': 1,</span><span class="s3">\n    </span><span class="s1">'color': '#000',</span><span class="s3">\n    </span><span class="s1">'text-outline-color': '#000',</span><span class="s3">\n    </span><span class="s1">'text-outline-width': 0,</span><span class="s3">\n    </span><span class="s1">'text-outline-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'text-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'text-decoration': 'none',</span><span class="s3">\n    </span><span class="s1">'text-transform': 'none',</span><span class="s3">\n    </span><span class="s1">'text-wrap': 'none',</span><span class="s3">\n    </span><span class="s1">'text-overflow-wrap': 'whitespace',</span><span class="s3">\n    </span><span class="s1">'text-max-width': 9999,</span><span class="s3">\n    </span><span class="s1">'text-background-color': '#000',</span><span class="s3">\n    </span><span class="s1">'text-background-opacity': 0,</span><span class="s3">\n    </span><span class="s1">'text-background-shape': 'rectangle',</span><span class="s3">\n    </span><span class="s1">'text-background-padding': 0,</span><span class="s3">\n    </span><span class="s1">'text-border-opacity': 0,</span><span class="s3">\n    </span><span class="s1">'text-border-width': 0,</span><span class="s3">\n    </span><span class="s1">'text-border-style': 'solid',</span><span class="s3">\n    </span><span class="s1">'text-border-color': '#000',</span><span class="s3">\n    </span><span class="s1">'font-family': 'Helvetica Neue, Helvetica, sans-serif',</span><span class="s3">\n    </span><span class="s1">'font-style': 'normal',</span><span class="s3">\n    </span><span class="s1">'font-weight': 'normal',</span><span class="s3">\n    </span><span class="s1">'font-size': 16,</span><span class="s3">\n    </span><span class="s1">'min-zoomed-font-size': 0,</span><span class="s3">\n    </span><span class="s1">'text-rotation': 'none',</span><span class="s3">\n    </span><span class="s1">'source-text-rotation': 'none',</span><span class="s3">\n    </span><span class="s1">'target-text-rotation': 'none',</span><span class="s3">\n    </span><span class="s1">'visibility': 'visible',</span><span class="s3">\n    </span><span class="s1">'display': 'element',</span><span class="s3">\n    </span><span class="s1">'opacity': 1,</span><span class="s3">\n    </span><span class="s1">'z-compound-depth': 'auto',</span><span class="s3">\n    </span><span class="s1">'z-index-compare': 'auto',</span><span class="s3">\n    </span><span class="s1">'z-index': 0,</span><span class="s3">\n    </span><span class="s1">'label': '',</span><span class="s3">\n    </span><span class="s1">'text-margin-x': 0,</span><span class="s3">\n    </span><span class="s1">'text-margin-y': 0,</span><span class="s3">\n    </span><span class="s1">'source-label': '',</span><span class="s3">\n    </span><span class="s1">'source-text-offset': 0,</span><span class="s3">\n    </span><span class="s1">'source-text-margin-x': 0,</span><span class="s3">\n    </span><span class="s1">'source-text-margin-y': 0,</span><span class="s3">\n    </span><span class="s1">'target-label': '',</span><span class="s3">\n    </span><span class="s1">'target-text-offset': 0,</span><span class="s3">\n    </span><span class="s1">'target-text-margin-x': 0,</span><span class="s3">\n    </span><span class="s1">'target-text-margin-y': 0,</span><span class="s3">\n    </span><span class="s1">'overlay-opacity': 0,</span><span class="s3">\n    </span><span class="s1">'overlay-color': '#000',</span><span class="s3">\n    </span><span class="s1">'overlay-padding': 10,</span><span class="s3">\n    </span><span class="s1">'overlay-shape': 'round-rectangle',</span><span class="s3">\n    </span><span class="s1">'overlay-corner-radius': 'auto',</span><span class="s3">\n    </span><span class="s1">'underlay-opacity': 0,</span><span class="s3">\n    </span><span class="s1">'underlay-color': '#000',</span><span class="s3">\n    </span><span class="s1">'underlay-padding': 10,</span><span class="s3">\n    </span><span class="s1">'underlay-shape': 'round-rectangle',</span><span class="s3">\n    </span><span class="s1">'underlay-corner-radius': 'auto',</span><span class="s3">\n    </span><span class="s1">'transition-property': 'none',</span><span class="s3">\n    </span><span class="s1">'transition-duration': 0,</span><span class="s3">\n    </span><span class="s1">'transition-delay': 0,</span><span class="s3">\n    </span><span class="s1">'transition-timing-function': 'linear',</span><span class="s3">\n    </span><span class="s1">// node props</span><span class="s3">\n    </span><span class="s1">'background-blacken': 0,</span><span class="s3">\n    </span><span class="s1">'background-color': '#999',</span><span class="s3">\n    </span><span class="s1">'background-fill': 'solid',</span><span class="s3">\n    </span><span class="s1">'background-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'background-image': 'none',</span><span class="s3">\n    </span><span class="s1">'background-image-crossorigin': 'anonymous',</span><span class="s3">\n    </span><span class="s1">'background-image-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'background-image-containment': 'inside',</span><span class="s3">\n    </span><span class="s1">'background-image-smoothing': 'yes',</span><span class="s3">\n    </span><span class="s1">'background-position-x': '50%',</span><span class="s3">\n    </span><span class="s1">'background-position-y': '50%',</span><span class="s3">\n    </span><span class="s1">'background-offset-x': 0,</span><span class="s3">\n    </span><span class="s1">'background-offset-y': 0,</span><span class="s3">\n    </span><span class="s1">'background-width-relative-to': 'include-padding',</span><span class="s3">\n    </span><span class="s1">'background-height-relative-to': 'include-padding',</span><span class="s3">\n    </span><span class="s1">'background-repeat': 'no-repeat',</span><span class="s3">\n    </span><span class="s1">'background-fit': 'none',</span><span class="s3">\n    </span><span class="s1">'background-clip': 'node',</span><span class="s3">\n    </span><span class="s1">'background-width': 'auto',</span><span class="s3">\n    </span><span class="s1">'background-height': 'auto',</span><span class="s3">\n    </span><span class="s1">'border-color': '#000',</span><span class="s3">\n    </span><span class="s1">'border-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'border-width': 0,</span><span class="s3">\n    </span><span class="s1">'border-style': 'solid',</span><span class="s3">\n    </span><span class="s1">'border-dash-pattern': [4, 2],</span><span class="s3">\n    </span><span class="s1">'border-dash-offset': 0,</span><span class="s3">\n    </span><span class="s1">'border-cap': 'butt',</span><span class="s3">\n    </span><span class="s1">'border-join': 'miter',</span><span class="s3">\n    </span><span class="s1">'border-position': 'center',</span><span class="s3">\n    </span><span class="s1">'outline-color': '#999',</span><span class="s3">\n    </span><span class="s1">'outline-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'outline-width': 0,</span><span class="s3">\n    </span><span class="s1">'outline-offset': 0,</span><span class="s3">\n    </span><span class="s1">'outline-style': 'solid',</span><span class="s3">\n    </span><span class="s1">'height': 30,</span><span class="s3">\n    </span><span class="s1">'width': 30,</span><span class="s3">\n    </span><span class="s1">'shape': 'ellipse',</span><span class="s3">\n    </span><span class="s1">'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',</span><span class="s3">\n    </span><span class="s1">'corner-radius': 'auto',</span><span class="s3">\n    </span><span class="s1">'bounds-expansion': 0,</span><span class="s3">\n    </span><span class="s1">// node gradient</span><span class="s3">\n    </span><span class="s1">'background-gradient-direction': 'to-bottom',</span><span class="s3">\n    </span><span class="s1">'background-gradient-stop-colors': '#999',</span><span class="s3">\n    </span><span class="s1">'background-gradient-stop-positions': '0%',</span><span class="s3">\n    </span><span class="s1">// ghost props</span><span class="s3">\n    </span><span class="s1">'ghost': 'no',</span><span class="s3">\n    </span><span class="s1">'ghost-offset-y': 0,</span><span class="s3">\n    </span><span class="s1">'ghost-offset-x': 0,</span><span class="s3">\n    </span><span class="s1">'ghost-opacity': 0,</span><span class="s3">\n    </span><span class="s1">// compound props</span><span class="s3">\n    </span><span class="s1">'padding': 0,</span><span class="s3">\n    </span><span class="s1">'padding-relative-to': 'width',</span><span class="s3">\n    </span><span class="s1">'position': 'origin',</span><span class="s3">\n    </span><span class="s1">'compound-sizing-wrt-labels': 'include',</span><span class="s3">\n    </span><span class="s1">'min-width': 0,</span><span class="s3">\n    </span><span class="s1">'min-width-bias-left': 0,</span><span class="s3">\n    </span><span class="s1">'min-width-bias-right': 0,</span><span class="s3">\n    </span><span class="s1">'min-height': 0,</span><span class="s3">\n    </span><span class="s1">'min-height-bias-top': 0,</span><span class="s3">\n    </span><span class="s1">'min-height-bias-bottom': 0</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">// node pie bg</span><span class="s3">\n    </span><span class="s1">'pie-size': '100%'</span><span class="s3">\n  </span><span class="s1">}, [{</span><span class="s3">\n    </span><span class="s1">name: 'pie-{{i}}-background-color',</span><span class="s3">\n    </span><span class="s1">value: 'black'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'pie-{{i}}-background-size',</span><span class="s3">\n    </span><span class="s1">value: '0%'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'pie-{{i}}-background-opacity',</span><span class="s3">\n    </span><span class="s1">value: 1</span><span class="s3">\n  </span><span class="s1">}].reduce(function (css, prop) {</span><span class="s3">\n    </span><span class="s1">for (var i = 1; i &lt;= styfn$2.pieBackgroundN; i++) {</span><span class="s3">\n      </span><span class="s1">var name = prop.name.replace('{{i}}', i);</span><span class="s3">\n      </span><span class="s1">var val = prop.value;</span><span class="s3">\n      </span><span class="s1">css[name] = val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return css;</span><span class="s3">\n  </span><span class="s1">}, {}), {</span><span class="s3">\n    </span><span class="s1">// edge props</span><span class="s3">\n    </span><span class="s1">'line-style': 'solid',</span><span class="s3">\n    </span><span class="s1">'line-color': '#999',</span><span class="s3">\n    </span><span class="s1">'line-fill': 'solid',</span><span class="s3">\n    </span><span class="s1">'line-cap': 'butt',</span><span class="s3">\n    </span><span class="s1">'line-opacity': 1,</span><span class="s3">\n    </span><span class="s1">'line-outline-width': 0,</span><span class="s3">\n    </span><span class="s1">'line-outline-color': '#000',</span><span class="s3">\n    </span><span class="s1">'line-gradient-stop-colors': '#999',</span><span class="s3">\n    </span><span class="s1">'line-gradient-stop-positions': '0%',</span><span class="s3">\n    </span><span class="s1">'control-point-step-size': 40,</span><span class="s3">\n    </span><span class="s1">'control-point-weights': 0.5,</span><span class="s3">\n    </span><span class="s1">'segment-weights': 0.5,</span><span class="s3">\n    </span><span class="s1">'segment-distances': 20,</span><span class="s3">\n    </span><span class="s1">'segment-radii': 15,</span><span class="s3">\n    </span><span class="s1">'radius-type': 'arc-radius',</span><span class="s3">\n    </span><span class="s1">'taxi-turn': '50%',</span><span class="s3">\n    </span><span class="s1">'taxi-radius': 15,</span><span class="s3">\n    </span><span class="s1">'taxi-turn-min-distance': 10,</span><span class="s3">\n    </span><span class="s1">'taxi-direction': 'auto',</span><span class="s3">\n    </span><span class="s1">'edge-distances': 'intersection',</span><span class="s3">\n    </span><span class="s1">'curve-style': 'haystack',</span><span class="s3">\n    </span><span class="s1">'haystack-radius': 0,</span><span class="s3">\n    </span><span class="s1">'arrow-scale': 1,</span><span class="s3">\n    </span><span class="s1">'loop-direction': '-45deg',</span><span class="s3">\n    </span><span class="s1">'loop-sweep': '-90deg',</span><span class="s3">\n    </span><span class="s1">'source-distance-from-node': 0,</span><span class="s3">\n    </span><span class="s1">'target-distance-from-node': 0,</span><span class="s3">\n    </span><span class="s1">'source-endpoint': 'outside-to-node',</span><span class="s3">\n    </span><span class="s1">'target-endpoint': 'outside-to-node',</span><span class="s3">\n    </span><span class="s1">'line-dash-pattern': [6, 3],</span><span class="s3">\n    </span><span class="s1">'line-dash-offset': 0</span><span class="s3">\n  </span><span class="s1">}, [{</span><span class="s3">\n    </span><span class="s1">name: 'arrow-shape',</span><span class="s3">\n    </span><span class="s1">value: 'none'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-color',</span><span class="s3">\n    </span><span class="s1">value: '#999'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-fill',</span><span class="s3">\n    </span><span class="s1">value: 'filled'</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">name: 'arrow-width',</span><span class="s3">\n    </span><span class="s1">value: 1</span><span class="s3">\n  </span><span class="s1">}].reduce(function (css, prop) {</span><span class="s3">\n    </span><span class="s1">styfn$2.arrowPrefixes.forEach(function (prefix) {</span><span class="s3">\n      </span><span class="s1">var name = prefix + '-' + prop.name;</span><span class="s3">\n      </span><span class="s1">var val = prop.value;</span><span class="s3">\n      </span><span class="s1">css[name] = val;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return css;</span><span class="s3">\n  </span><span class="s1">}, {}));</span><span class="s3">\n  </span><span class="s1">var parsedProps = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.properties.length; i++) {</span><span class="s3">\n    </span><span class="s1">var prop = this.properties[i];</span><span class="s3">\n    </span><span class="s1">if (prop.pointsTo) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var name = prop.name;</span><span class="s3">\n    </span><span class="s1">var val = rawProps[name];</span><span class="s3">\n    </span><span class="s1">var parsedProp = this.parse(name, val);</span><span class="s3">\n    </span><span class="s1">parsedProps[name] = parsedProp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">_p.defaultProperties = parsedProps;</span><span class="s3">\n  </span><span class="s1">return _p.defaultProperties;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$2.addDefaultStylesheet = function () {</span><span class="s3">\n  </span><span class="s1">this.selector(':parent').css({</span><span class="s3">\n    </span><span class="s1">'shape': 'rectangle',</span><span class="s3">\n    </span><span class="s1">'padding': 10,</span><span class="s3">\n    </span><span class="s1">'background-color': '#eee',</span><span class="s3">\n    </span><span class="s1">'border-color': '#ccc',</span><span class="s3">\n    </span><span class="s1">'border-width': 1</span><span class="s3">\n  </span><span class="s1">}).selector('edge').css({</span><span class="s3">\n    </span><span class="s1">'width': 3</span><span class="s3">\n  </span><span class="s1">}).selector(':loop').css({</span><span class="s3">\n    </span><span class="s1">'curve-style': 'bezier'</span><span class="s3">\n  </span><span class="s1">}).selector('edge:compound').css({</span><span class="s3">\n    </span><span class="s1">'curve-style': 'bezier',</span><span class="s3">\n    </span><span class="s1">'source-endpoint': 'outside-to-line',</span><span class="s3">\n    </span><span class="s1">'target-endpoint': 'outside-to-line'</span><span class="s3">\n  </span><span class="s1">}).selector(':selected').css({</span><span class="s3">\n    </span><span class="s1">'background-color': '#0169D9',</span><span class="s3">\n    </span><span class="s1">'line-color': '#0169D9',</span><span class="s3">\n    </span><span class="s1">'source-arrow-color': '#0169D9',</span><span class="s3">\n    </span><span class="s1">'target-arrow-color': '#0169D9',</span><span class="s3">\n    </span><span class="s1">'mid-source-arrow-color': '#0169D9',</span><span class="s3">\n    </span><span class="s1">'mid-target-arrow-color': '#0169D9'</span><span class="s3">\n  </span><span class="s1">}).selector(':parent:selected').css({</span><span class="s3">\n    </span><span class="s1">'background-color': '#CCE1F9',</span><span class="s3">\n    </span><span class="s1">'border-color': '#aec8e5'</span><span class="s3">\n  </span><span class="s1">}).selector(':active').css({</span><span class="s3">\n    </span><span class="s1">'overlay-color': 'black',</span><span class="s3">\n    </span><span class="s1">'overlay-padding': 10,</span><span class="s3">\n    </span><span class="s1">'overlay-opacity': 0.25</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">this.defaultLength = this.length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var styfn$1 = {};</span><span class="s3">\n\n</span><span class="s1">// a caching layer for property parsing</span><span class="s3">\n</span><span class="s1">styfn$1.parse = function (name, value, propIsBypass, propIsFlat) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n\n  </span><span class="s1">// function values can't be cached in all cases, and there isn't much benefit of caching them anyway</span><span class="s3">\n  </span><span class="s1">if (fn$6(value)) {</span><span class="s3">\n    </span><span class="s1">return self.parseImplWarn(name, value, propIsBypass, propIsFlat);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;</span><span class="s3">\n  </span><span class="s1">var bypassKey = propIsBypass ? 't' : 'f';</span><span class="s3">\n  </span><span class="s1">var valueKey = '' + value;</span><span class="s3">\n  </span><span class="s1">var argHash = hashStrings(name, valueKey, bypassKey, flatKey);</span><span class="s3">\n  </span><span class="s1">var propCache = self.propCache = self.propCache || [];</span><span class="s3">\n  </span><span class="s1">var ret;</span><span class="s3">\n  </span><span class="s1">if (!(ret = propCache[argHash])) {</span><span class="s3">\n    </span><span class="s1">ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden</span><span class="s3">\n  </span><span class="s1">// - mappings can't be shared b/c mappings are per-element</span><span class="s3">\n  </span><span class="s1">if (propIsBypass || propIsFlat === 'mapping') {</span><span class="s3">\n    </span><span class="s1">// need a copy since props are mutated later in their lifecycles</span><span class="s3">\n    </span><span class="s1">ret = copy(ret);</span><span class="s3">\n    </span><span class="s1">if (ret) {</span><span class="s3">\n      </span><span class="s1">ret.value = copy(ret.value); // because it could be an array, e.g. colour</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ret;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn$1.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {</span><span class="s3">\n  </span><span class="s1">var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);</span><span class="s3">\n  </span><span class="s1">if (!prop &amp;&amp; value != null) {</span><span class="s3">\n    </span><span class="s1">warn(</span><span class="s3">\&quot;</span><span class="s1">The style property `</span><span class="s3">\&quot;</span><span class="s1">.concat(name, </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">).concat(value, </span><span class="s3">\&quot;</span><span class="s1">` is invalid</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (prop &amp;&amp; (prop.name === 'width' || prop.name === 'height') &amp;&amp; value === 'label') {</span><span class="s3">\n    </span><span class="s1">warn('The style value of `label` is deprecated for `' + prop.name + '`');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return prop;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// parse a property; return null on invalid; return parsed property otherwise</span><span class="s3">\n</span><span class="s1">// fields :</span><span class="s3">\n</span><span class="s1">// - name : the name of the property</span><span class="s3">\n</span><span class="s1">// - value : the parsed, native-typed value of the property</span><span class="s3">\n</span><span class="s1">// - strValue : a string value that represents the property value in valid css</span><span class="s3">\n</span><span class="s1">// - bypass : true iff the property is a bypass property</span><span class="s3">\n</span><span class="s1">styfn$1.parseImpl = function (name, value, propIsBypass, propIsFlat) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')</span><span class="s3">\n\n  </span><span class="s1">var property = self.properties[name];</span><span class="s3">\n  </span><span class="s1">var passedValue = value;</span><span class="s3">\n  </span><span class="s1">var types = self.types;</span><span class="s3">\n  </span><span class="s1">if (!property) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">} // return null on property of unknown name</span><span class="s3">\n  </span><span class="s1">if (value === undefined) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">} // can't assign undefined</span><span class="s3">\n\n  </span><span class="s1">// the property may be an alias</span><span class="s3">\n  </span><span class="s1">if (property.alias) {</span><span class="s3">\n    </span><span class="s1">property = property.pointsTo;</span><span class="s3">\n    </span><span class="s1">name = property.name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var valueIsString = string(value);</span><span class="s3">\n  </span><span class="s1">if (valueIsString) {</span><span class="s3">\n    </span><span class="s1">// trim the value to make parsing easier</span><span class="s3">\n    </span><span class="s1">value = value.trim();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var type = property.type;</span><span class="s3">\n  </span><span class="s1">if (!type) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">} // no type, no luck</span><span class="s3">\n\n  </span><span class="s1">// check if bypass is null or empty string (i.e. indication to delete bypass property)</span><span class="s3">\n  </span><span class="s1">if (propIsBypass &amp;&amp; (value === '' || value === null)) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: value,</span><span class="s3">\n      </span><span class="s1">bypass: true,</span><span class="s3">\n      </span><span class="s1">deleteBypass: true</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check if value is a function used as a mapper</span><span class="s3">\n  </span><span class="s1">if (fn$6(value)) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: value,</span><span class="s3">\n      </span><span class="s1">strValue: 'fn',</span><span class="s3">\n      </span><span class="s1">mapped: types.fn,</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check if value is mapped</span><span class="s3">\n  </span><span class="s1">var data, mapData;</span><span class="s3">\n  </span><span class="s1">if (!valueIsString || propIsFlat || value.length &lt; 7 || value[1] !== 'a') ; else if (value.length &gt;= 7 &amp;&amp; value[0] === 'd' &amp;&amp; (data = new RegExp(types.data.regex).exec(value))) {</span><span class="s3">\n    </span><span class="s1">if (propIsBypass) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} // mappers not allowed in bypass</span><span class="s3">\n\n    </span><span class="s1">var mapped = types.data;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">strValue: '' + value,</span><span class="s3">\n      </span><span class="s1">mapped: mapped,</span><span class="s3">\n      </span><span class="s1">field: data[1],</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (value.length &gt;= 10 &amp;&amp; value[0] === 'm' &amp;&amp; (mapData = new RegExp(types.mapData.regex).exec(value))) {</span><span class="s3">\n    </span><span class="s1">if (propIsBypass) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} // mappers not allowed in bypass</span><span class="s3">\n    </span><span class="s1">if (type.multiple) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} // impossible to map to num</span><span class="s3">\n\n    </span><span class="s1">var _mapped = types.mapData;</span><span class="s3">\n\n    </span><span class="s1">// we can map only if the type is a colour or a number</span><span class="s3">\n    </span><span class="s1">if (!(type.color || type.number)) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var valueMin = this.parse(name, mapData[4]); // parse to validate</span><span class="s3">\n    </span><span class="s1">if (!valueMin || valueMin.mapped) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} // can't be invalid or mapped</span><span class="s3">\n\n    </span><span class="s1">var valueMax = this.parse(name, mapData[5]); // parse to validate</span><span class="s3">\n    </span><span class="s1">if (!valueMax || valueMax.mapped) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} // can't be invalid or mapped</span><span class="s3">\n\n    </span><span class="s1">// check if valueMin and valueMax are the same</span><span class="s3">\n    </span><span class="s1">if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {</span><span class="s3">\n      </span><span class="s1">warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');</span><span class="s3">\n      </span><span class="s1">return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range</span><span class="s3">\n    </span><span class="s1">} else if (type.color) {</span><span class="s3">\n      </span><span class="s1">var c1 = valueMin.value;</span><span class="s3">\n      </span><span class="s1">var c2 = valueMax.value;</span><span class="s3">\n      </span><span class="s1">var same = c1[0] === c2[0] // red</span><span class="s3">\n      </span><span class="s1">&amp;&amp; c1[1] === c2[1] // green</span><span class="s3">\n      </span><span class="s1">&amp;&amp; c1[2] === c2[2] // blue</span><span class="s3">\n      </span><span class="s1">&amp;&amp; (</span><span class="s3">\n      </span><span class="s1">// optional alpha</span><span class="s3">\n      </span><span class="s1">c1[3] === c2[3] // same alpha outright</span><span class="s3">\n      </span><span class="s1">|| (c1[3] == null || c1[3] === 1 // full opacity for colour 1?</span><span class="s3">\n      </span><span class="s1">) &amp;&amp; (c2[3] == null || c2[3] === 1) // full opacity for colour 2?</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (same) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} // can't make a mapper without a range</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: mapData,</span><span class="s3">\n      </span><span class="s1">strValue: '' + value,</span><span class="s3">\n      </span><span class="s1">mapped: _mapped,</span><span class="s3">\n      </span><span class="s1">field: mapData[1],</span><span class="s3">\n      </span><span class="s1">fieldMin: parseFloat(mapData[2]),</span><span class="s3">\n      </span><span class="s1">// min &amp; max are numeric</span><span class="s3">\n      </span><span class="s1">fieldMax: parseFloat(mapData[3]),</span><span class="s3">\n      </span><span class="s1">valueMin: valueMin.value,</span><span class="s3">\n      </span><span class="s1">valueMax: valueMax.value,</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type.multiple &amp;&amp; propIsFlat !== 'multiple') {</span><span class="s3">\n    </span><span class="s1">var vals;</span><span class="s3">\n    </span><span class="s1">if (valueIsString) {</span><span class="s3">\n      </span><span class="s1">vals = value.split(/</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n    </span><span class="s1">} else if (array(value)) {</span><span class="s3">\n      </span><span class="s1">vals = value;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">vals = [value];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type.evenMultiple &amp;&amp; vals.length % 2 !== 0) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var valArr = [];</span><span class="s3">\n    </span><span class="s1">var unitsArr = [];</span><span class="s3">\n    </span><span class="s1">var pfValArr = [];</span><span class="s3">\n    </span><span class="s1">var strVal = '';</span><span class="s3">\n    </span><span class="s1">var hasEnum = false;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; vals.length; i++) {</span><span class="s3">\n      </span><span class="s1">var p = self.parse(name, vals[i], propIsBypass, 'multiple');</span><span class="s3">\n      </span><span class="s1">hasEnum = hasEnum || string(p.value);</span><span class="s3">\n      </span><span class="s1">valArr.push(p.value);</span><span class="s3">\n      </span><span class="s1">pfValArr.push(p.pfValue != null ? p.pfValue : p.value);</span><span class="s3">\n      </span><span class="s1">unitsArr.push(p.units);</span><span class="s3">\n      </span><span class="s1">strVal += (i &gt; 0 ? ' ' : '') + p.strValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type.validate &amp;&amp; !type.validate(valArr, unitsArr)) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type.singleEnum &amp;&amp; hasEnum) {</span><span class="s3">\n      </span><span class="s1">if (valArr.length === 1 &amp;&amp; string(valArr[0])) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: name,</span><span class="s3">\n          </span><span class="s1">value: valArr[0],</span><span class="s3">\n          </span><span class="s1">strValue: valArr[0],</span><span class="s3">\n          </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: valArr,</span><span class="s3">\n      </span><span class="s1">pfValue: pfValArr,</span><span class="s3">\n      </span><span class="s1">strValue: strVal,</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass,</span><span class="s3">\n      </span><span class="s1">units: unitsArr</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// several types also allow enums</span><span class="s3">\n  </span><span class="s1">var checkEnums = function checkEnums() {</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; type.enums.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var en = type.enums[_i];</span><span class="s3">\n      </span><span class="s1">if (en === value) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: name,</span><span class="s3">\n          </span><span class="s1">value: value,</span><span class="s3">\n          </span><span class="s1">strValue: '' + value,</span><span class="s3">\n          </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// check the type and return the appropriate object</span><span class="s3">\n  </span><span class="s1">if (type.number) {</span><span class="s3">\n    </span><span class="s1">var units;</span><span class="s3">\n    </span><span class="s1">var implicitUnits = 'px'; // not set =&gt; px</span><span class="s3">\n\n    </span><span class="s1">if (type.units) {</span><span class="s3">\n      </span><span class="s1">// use specified units if set</span><span class="s3">\n      </span><span class="s1">units = type.units;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type.implicitUnits) {</span><span class="s3">\n      </span><span class="s1">implicitUnits = type.implicitUnits;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!type.unitless) {</span><span class="s3">\n      </span><span class="s1">if (valueIsString) {</span><span class="s3">\n        </span><span class="s1">var unitsRegex = 'px|em' + (type.allowPercent ? '|</span><span class="s3">\\\\</span><span class="s1">%' : '');</span><span class="s3">\n        </span><span class="s1">if (units) {</span><span class="s3">\n          </span><span class="s1">unitsRegex = units;</span><span class="s3">\n        </span><span class="s1">} // only allow explicit units if so set</span><span class="s3">\n        </span><span class="s1">var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');</span><span class="s3">\n        </span><span class="s1">if (match) {</span><span class="s3">\n          </span><span class="s1">value = match[1];</span><span class="s3">\n          </span><span class="s1">units = match[2] || implicitUnits;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (!units || type.implicitUnits) {</span><span class="s3">\n        </span><span class="s1">units = implicitUnits; // implicitly px if unspecified</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">value = parseFloat(value);</span><span class="s3">\n\n    </span><span class="s1">// if not a number and enums not allowed, then the value is invalid</span><span class="s3">\n    </span><span class="s1">if (isNaN(value) &amp;&amp; type.enums === undefined) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// check if this number type also accepts special keywords in place of numbers</span><span class="s3">\n    </span><span class="s1">// (i.e. `left`, `auto`, etc)</span><span class="s3">\n    </span><span class="s1">if (isNaN(value) &amp;&amp; type.enums !== undefined) {</span><span class="s3">\n      </span><span class="s1">value = passedValue;</span><span class="s3">\n      </span><span class="s1">return checkEnums();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// check if value must be an integer</span><span class="s3">\n    </span><span class="s1">if (type.integer &amp;&amp; !integer(value)) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// check value is within range</span><span class="s3">\n    </span><span class="s1">if (type.min !== undefined &amp;&amp; (value &lt; type.min || type.strictMin &amp;&amp; value === type.min) || type.max !== undefined &amp;&amp; (value &gt; type.max || type.strictMax &amp;&amp; value === type.max)) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ret = {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: value,</span><span class="s3">\n      </span><span class="s1">strValue: '' + value + (units ? units : ''),</span><span class="s3">\n      </span><span class="s1">units: units,</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// normalise value in pixels</span><span class="s3">\n    </span><span class="s1">if (type.unitless || units !== 'px' &amp;&amp; units !== 'em') {</span><span class="s3">\n      </span><span class="s1">ret.pfValue = value;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// normalise value in ms</span><span class="s3">\n    </span><span class="s1">if (units === 'ms' || units === 's') {</span><span class="s3">\n      </span><span class="s1">ret.pfValue = units === 'ms' ? value : 1000 * value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// normalise value in rad</span><span class="s3">\n    </span><span class="s1">if (units === 'deg' || units === 'rad') {</span><span class="s3">\n      </span><span class="s1">ret.pfValue = units === 'rad' ? value : deg2rad(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// normalize value in %</span><span class="s3">\n    </span><span class="s1">if (units === '%') {</span><span class="s3">\n      </span><span class="s1">ret.pfValue = value / 100;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">} else if (type.propList) {</span><span class="s3">\n    </span><span class="s1">var props = [];</span><span class="s3">\n    </span><span class="s1">var propsStr = '' + value;</span><span class="s3">\n    </span><span class="s1">if (propsStr === 'none') ; else {</span><span class="s3">\n      </span><span class="s1">// go over each prop</span><span class="s3">\n\n      </span><span class="s1">var propsSplit = propsStr.split(/</span><span class="s3">\\</span><span class="s1">s*,</span><span class="s3">\\</span><span class="s1">s*|</span><span class="s3">\\</span><span class="s1">s+/);</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; propsSplit.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">var propName = propsSplit[_i2].trim();</span><span class="s3">\n        </span><span class="s1">if (self.properties[propName]) {</span><span class="s3">\n          </span><span class="s1">props.push(propName);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">warn('`' + propName + '` is not a valid property name');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (props.length === 0) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: props,</span><span class="s3">\n      </span><span class="s1">strValue: props.length === 0 ? 'none' : props.join(' '),</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (type.color) {</span><span class="s3">\n    </span><span class="s1">var tuple = color2tuple(value);</span><span class="s3">\n    </span><span class="s1">if (!tuple) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: tuple,</span><span class="s3">\n      </span><span class="s1">pfValue: tuple,</span><span class="s3">\n      </span><span class="s1">strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',</span><span class="s3">\n      </span><span class="s1">// n.b. no spaces b/c of multiple support</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (type.regex || type.regexes) {</span><span class="s3">\n    </span><span class="s1">// first check enums</span><span class="s3">\n    </span><span class="s1">if (type.enums) {</span><span class="s3">\n      </span><span class="s1">var enumProp = checkEnums();</span><span class="s3">\n      </span><span class="s1">if (enumProp) {</span><span class="s3">\n        </span><span class="s1">return enumProp;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var regexes = type.regexes ? type.regexes : [type.regex];</span><span class="s3">\n    </span><span class="s1">for (var _i3 = 0; _i3 &lt; regexes.length; _i3++) {</span><span class="s3">\n      </span><span class="s1">var regex = new RegExp(regexes[_i3]); // make a regex from the type string</span><span class="s3">\n      </span><span class="s1">var m = regex.exec(value);</span><span class="s3">\n      </span><span class="s1">if (m) {</span><span class="s3">\n        </span><span class="s1">// regex matches</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: name,</span><span class="s3">\n          </span><span class="s1">value: type.singleRegexMatchValue ? m[1] : m,</span><span class="s3">\n          </span><span class="s1">strValue: '' + value,</span><span class="s3">\n          </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null; // didn't match any</span><span class="s3">\n  </span><span class="s1">} else if (type.string) {</span><span class="s3">\n    </span><span class="s1">// just return</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: '' + value,</span><span class="s3">\n      </span><span class="s1">strValue: '' + value,</span><span class="s3">\n      </span><span class="s1">bypass: propIsBypass</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (type.enums) {</span><span class="s3">\n    </span><span class="s1">// check enums last because it's a combo type in others</span><span class="s3">\n    </span><span class="s1">return checkEnums();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return null; // not a type we can handle</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var _Style = function Style(cy) {</span><span class="s3">\n  </span><span class="s1">if (!(this instanceof _Style)) {</span><span class="s3">\n    </span><span class="s1">return new _Style(cy);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!core(cy)) {</span><span class="s3">\n    </span><span class="s1">error('A style must have a core reference');</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this._private = {</span><span class="s3">\n    </span><span class="s1">cy: cy,</span><span class="s3">\n    </span><span class="s1">coreStyle: {}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">this.length = 0;</span><span class="s3">\n  </span><span class="s1">this.resetToDefault();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var styfn = _Style.prototype;</span><span class="s3">\n</span><span class="s1">styfn.instanceString = function () {</span><span class="s3">\n  </span><span class="s1">return 'style';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// remove all contexts</span><span class="s3">\n</span><span class="s1">styfn.clear = function () {</span><span class="s3">\n  </span><span class="s1">var _p = this._private;</span><span class="s3">\n  </span><span class="s1">var cy = _p.cy;</span><span class="s3">\n  </span><span class="s1">var eles = cy.elements();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">this[i] = undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.length = 0;</span><span class="s3">\n  </span><span class="s1">_p.contextStyles = {};</span><span class="s3">\n  </span><span class="s1">_p.propDiffs = {};</span><span class="s3">\n  </span><span class="s1">this.cleanElements(eles, true);</span><span class="s3">\n  </span><span class="s1">eles.forEach(function (ele) {</span><span class="s3">\n    </span><span class="s1">var ele_p = ele[0]._private;</span><span class="s3">\n    </span><span class="s1">ele_p.styleDirty = true;</span><span class="s3">\n    </span><span class="s1">ele_p.appliedInitStyle = false;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn.resetToDefault = function () {</span><span class="s3">\n  </span><span class="s1">this.clear();</span><span class="s3">\n  </span><span class="s1">this.addDefaultStylesheet();</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// builds a style object for the 'core' selector</span><span class="s3">\n</span><span class="s1">styfn.core = function (propName) {</span><span class="s3">\n  </span><span class="s1">return this._private.coreStyle[propName] || this.getDefaultProperty(propName);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// create a new context from the specified selector string and switch to that context</span><span class="s3">\n</span><span class="s1">styfn.selector = function (selectorStr) {</span><span class="s3">\n  </span><span class="s1">// 'core' is a special case and does not need a selector</span><span class="s3">\n  </span><span class="s1">var selector = selectorStr === 'core' ? null : new Selector(selectorStr);</span><span class="s3">\n  </span><span class="s1">var i = this.length++; // new context means new index</span><span class="s3">\n  </span><span class="s1">this[i] = {</span><span class="s3">\n    </span><span class="s1">selector: selector,</span><span class="s3">\n    </span><span class="s1">properties: [],</span><span class="s3">\n    </span><span class="s1">mappedProperties: [],</span><span class="s3">\n    </span><span class="s1">index: i</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// add one or many css rules to the current context</span><span class="s3">\n</span><span class="s1">styfn.css = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var args = arguments;</span><span class="s3">\n  </span><span class="s1">if (args.length === 1) {</span><span class="s3">\n    </span><span class="s1">var map = args[0];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; self.properties.length; i++) {</span><span class="s3">\n      </span><span class="s1">var prop = self.properties[i];</span><span class="s3">\n      </span><span class="s1">var mapVal = map[prop.name];</span><span class="s3">\n      </span><span class="s1">if (mapVal === undefined) {</span><span class="s3">\n        </span><span class="s1">mapVal = map[dash2camel(prop.name)];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (mapVal !== undefined) {</span><span class="s3">\n        </span><span class="s1">this.cssRule(prop.name, mapVal);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (args.length === 2) {</span><span class="s3">\n    </span><span class="s1">this.cssRule(args[0], args[1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// do nothing if args are invalid</span><span class="s3">\n\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn.style = styfn.css;</span><span class="s3">\n\n</span><span class="s1">// add a single css rule to the current context</span><span class="s3">\n</span><span class="s1">styfn.cssRule = function (name, value) {</span><span class="s3">\n  </span><span class="s1">// name-value pair</span><span class="s3">\n  </span><span class="s1">var property = this.parse(name, value);</span><span class="s3">\n\n  </span><span class="s1">// add property to current context if valid</span><span class="s3">\n  </span><span class="s1">if (property) {</span><span class="s3">\n    </span><span class="s1">var i = this.length - 1;</span><span class="s3">\n    </span><span class="s1">this[i].properties.push(property);</span><span class="s3">\n    </span><span class="s1">this[i].properties[property.name] = property; // allow access by name as well</span><span class="s3">\n\n    </span><span class="s1">if (property.name.match(/pie-(</span><span class="s3">\\</span><span class="s1">d+)-background-size/) &amp;&amp; property.value) {</span><span class="s3">\n      </span><span class="s1">this._private.hasPie = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (property.mapped) {</span><span class="s3">\n      </span><span class="s1">this[i].mappedProperties.push(property);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// add to core style if necessary</span><span class="s3">\n    </span><span class="s1">var currentSelectorIsCore = !this[i].selector;</span><span class="s3">\n    </span><span class="s1">if (currentSelectorIsCore) {</span><span class="s3">\n      </span><span class="s1">this._private.coreStyle[property.name] = property;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">styfn.append = function (style) {</span><span class="s3">\n  </span><span class="s1">if (stylesheet(style)) {</span><span class="s3">\n    </span><span class="s1">style.appendToStyle(this);</span><span class="s3">\n  </span><span class="s1">} else if (array(style)) {</span><span class="s3">\n    </span><span class="s1">this.appendFromJson(style);</span><span class="s3">\n  </span><span class="s1">} else if (string(style)) {</span><span class="s3">\n    </span><span class="s1">this.appendFromString(style);</span><span class="s3">\n  </span><span class="s1">} // you probably wouldn't want to append a Style, since you'd duplicate the default parts</span><span class="s3">\n\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// static function</span><span class="s3">\n</span><span class="s1">_Style.fromJson = function (cy, json) {</span><span class="s3">\n  </span><span class="s1">var style = new _Style(cy);</span><span class="s3">\n  </span><span class="s1">style.fromJson(json);</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">_Style.fromString = function (cy, string) {</span><span class="s3">\n  </span><span class="s1">return new _Style(cy).fromString(string);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">[styfn$8, styfn$7, styfn$6, styfn$5, styfn$4, styfn$3, styfn$2, styfn$1].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(styfn, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">_Style.types = styfn.types;</span><span class="s3">\n</span><span class="s1">_Style.properties = styfn.properties;</span><span class="s3">\n</span><span class="s1">_Style.propertyGroups = styfn.propertyGroups;</span><span class="s3">\n</span><span class="s1">_Style.propertyGroupNames = styfn.propertyGroupNames;</span><span class="s3">\n</span><span class="s1">_Style.propertyGroupKeys = styfn.propertyGroupKeys;</span><span class="s3">\n\n</span><span class="s1">var corefn$2 = {</span><span class="s3">\n  </span><span class="s1">style: function style(newStyle) {</span><span class="s3">\n    </span><span class="s1">if (newStyle) {</span><span class="s3">\n      </span><span class="s1">var s = this.setStyle(newStyle);</span><span class="s3">\n      </span><span class="s1">s.update();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this._private.style;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">setStyle: function setStyle(style) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (stylesheet(style)) {</span><span class="s3">\n      </span><span class="s1">_p.style = style.generateStyle(this);</span><span class="s3">\n    </span><span class="s1">} else if (array(style)) {</span><span class="s3">\n      </span><span class="s1">_p.style = _Style.fromJson(this, style);</span><span class="s3">\n    </span><span class="s1">} else if (string(style)) {</span><span class="s3">\n      </span><span class="s1">_p.style = _Style.fromString(this, style);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">_p.style = _Style(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _p.style;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// e.g. cy.data() changed =&gt; recalc ele mappers</span><span class="s3">\n  </span><span class="s1">updateStyle: function updateStyle() {</span><span class="s3">\n    </span><span class="s1">this.mutableElements().updateStyle(); // just send to all eles</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defaultSelectionType = 'single';</span><span class="s3">\n</span><span class="s1">var corefn$1 = {</span><span class="s3">\n  </span><span class="s1">autolock: function autolock(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.autolock = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.autolock;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">autoungrabify: function autoungrabify(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.autoungrabify = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.autoungrabify;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">autounselectify: function autounselectify(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.autounselectify = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.autounselectify;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">selectionType: function selectionType(selType) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (_p.selectionType == null) {</span><span class="s3">\n      </span><span class="s1">_p.selectionType = defaultSelectionType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (selType !== undefined) {</span><span class="s3">\n      </span><span class="s1">if (selType === 'additive' || selType === 'single') {</span><span class="s3">\n        </span><span class="s1">_p.selectionType = selType;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return _p.selectionType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">panningEnabled: function panningEnabled(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.panningEnabled = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.panningEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">userPanningEnabled: function userPanningEnabled(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.userPanningEnabled = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.userPanningEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">zoomingEnabled: function zoomingEnabled(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.zoomingEnabled = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.zoomingEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">userZoomingEnabled: function userZoomingEnabled(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.userZoomingEnabled = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.userZoomingEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">boxSelectionEnabled: function boxSelectionEnabled(bool) {</span><span class="s3">\n    </span><span class="s1">if (bool !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._private.boxSelectionEnabled = bool ? true : false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this._private.boxSelectionEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">pan: function pan() {</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">var pan = this._private.pan;</span><span class="s3">\n    </span><span class="s1">var dim, val, dims, x, y;</span><span class="s3">\n    </span><span class="s1">switch (args.length) {</span><span class="s3">\n      </span><span class="s1">case 0:</span><span class="s3">\n        </span><span class="s1">// .pan()</span><span class="s3">\n        </span><span class="s1">return pan;</span><span class="s3">\n      </span><span class="s1">case 1:</span><span class="s3">\n        </span><span class="s1">if (string(args[0])) {</span><span class="s3">\n          </span><span class="s1">// .pan('x')</span><span class="s3">\n          </span><span class="s1">dim = args[0];</span><span class="s3">\n          </span><span class="s1">return pan[dim];</span><span class="s3">\n        </span><span class="s1">} else if (plainObject(args[0])) {</span><span class="s3">\n          </span><span class="s1">// .pan({ x: 0, y: 100 })</span><span class="s3">\n          </span><span class="s1">if (!this._private.panningEnabled) {</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">dims = args[0];</span><span class="s3">\n          </span><span class="s1">x = dims.x;</span><span class="s3">\n          </span><span class="s1">y = dims.y;</span><span class="s3">\n          </span><span class="s1">if (number$1(x)) {</span><span class="s3">\n            </span><span class="s1">pan.x = x;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (number$1(y)) {</span><span class="s3">\n            </span><span class="s1">pan.y = y;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.emit('pan viewport');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 2:</span><span class="s3">\n        </span><span class="s1">// .pan('x', 100)</span><span class="s3">\n        </span><span class="s1">if (!this._private.panningEnabled) {</span><span class="s3">\n          </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">dim = args[0];</span><span class="s3">\n        </span><span class="s1">val = args[1];</span><span class="s3">\n        </span><span class="s1">if ((dim === 'x' || dim === 'y') &amp;&amp; number$1(val)) {</span><span class="s3">\n          </span><span class="s1">pan[dim] = val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.emit('pan viewport');</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">// invalid</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.notify('viewport');</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">panBy: function panBy(arg0, arg1) {</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">var pan = this._private.pan;</span><span class="s3">\n    </span><span class="s1">var dim, val, dims, x, y;</span><span class="s3">\n    </span><span class="s1">if (!this._private.panningEnabled) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">switch (args.length) {</span><span class="s3">\n      </span><span class="s1">case 1:</span><span class="s3">\n        </span><span class="s1">if (plainObject(arg0)) {</span><span class="s3">\n          </span><span class="s1">// .panBy({ x: 0, y: 100 })</span><span class="s3">\n          </span><span class="s1">dims = args[0];</span><span class="s3">\n          </span><span class="s1">x = dims.x;</span><span class="s3">\n          </span><span class="s1">y = dims.y;</span><span class="s3">\n          </span><span class="s1">if (number$1(x)) {</span><span class="s3">\n            </span><span class="s1">pan.x += x;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (number$1(y)) {</span><span class="s3">\n            </span><span class="s1">pan.y += y;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.emit('pan viewport');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 2:</span><span class="s3">\n        </span><span class="s1">// .panBy('x', 100)</span><span class="s3">\n        </span><span class="s1">dim = arg0;</span><span class="s3">\n        </span><span class="s1">val = arg1;</span><span class="s3">\n        </span><span class="s1">if ((dim === 'x' || dim === 'y') &amp;&amp; number$1(val)) {</span><span class="s3">\n          </span><span class="s1">pan[dim] += val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.emit('pan viewport');</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">// invalid</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.notify('viewport');</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">gc: function gc() {</span><span class="s3">\n    </span><span class="s1">this.notify('gc');</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">fit: function fit(elements, padding) {</span><span class="s3">\n    </span><span class="s1">var viewportState = this.getFitViewport(elements, padding);</span><span class="s3">\n    </span><span class="s1">if (viewportState) {</span><span class="s3">\n      </span><span class="s1">var _p = this._private;</span><span class="s3">\n      </span><span class="s1">_p.zoom = viewportState.zoom;</span><span class="s3">\n      </span><span class="s1">_p.pan = viewportState.pan;</span><span class="s3">\n      </span><span class="s1">this.emit('pan zoom viewport');</span><span class="s3">\n      </span><span class="s1">this.notify('viewport');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">getFitViewport: function getFitViewport(elements, padding) {</span><span class="s3">\n    </span><span class="s1">if (number$1(elements) &amp;&amp; padding === undefined) {</span><span class="s3">\n      </span><span class="s1">// elements is optional</span><span class="s3">\n      </span><span class="s1">padding = elements;</span><span class="s3">\n      </span><span class="s1">elements = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!this._private.panningEnabled || !this._private.zoomingEnabled) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var bb;</span><span class="s3">\n    </span><span class="s1">if (string(elements)) {</span><span class="s3">\n      </span><span class="s1">var sel = elements;</span><span class="s3">\n      </span><span class="s1">elements = this.$(sel);</span><span class="s3">\n    </span><span class="s1">} else if (boundingBox(elements)) {</span><span class="s3">\n      </span><span class="s1">// assume bb</span><span class="s3">\n      </span><span class="s1">var bbe = elements;</span><span class="s3">\n      </span><span class="s1">bb = {</span><span class="s3">\n        </span><span class="s1">x1: bbe.x1,</span><span class="s3">\n        </span><span class="s1">y1: bbe.y1,</span><span class="s3">\n        </span><span class="s1">x2: bbe.x2,</span><span class="s3">\n        </span><span class="s1">y2: bbe.y2</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">bb.w = bb.x2 - bb.x1;</span><span class="s3">\n      </span><span class="s1">bb.h = bb.y2 - bb.y1;</span><span class="s3">\n    </span><span class="s1">} else if (!elementOrCollection(elements)) {</span><span class="s3">\n      </span><span class="s1">elements = this.mutableElements();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (elementOrCollection(elements) &amp;&amp; elements.empty()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // can't fit to nothing</span><span class="s3">\n\n    </span><span class="s1">bb = bb || elements.boundingBox();</span><span class="s3">\n    </span><span class="s1">var w = this.width();</span><span class="s3">\n    </span><span class="s1">var h = this.height();</span><span class="s3">\n    </span><span class="s1">var zoom;</span><span class="s3">\n    </span><span class="s1">padding = number$1(padding) ? padding : 0;</span><span class="s3">\n    </span><span class="s1">if (!isNaN(w) &amp;&amp; !isNaN(h) &amp;&amp; w &gt; 0 &amp;&amp; h &gt; 0 &amp;&amp; !isNaN(bb.w) &amp;&amp; !isNaN(bb.h) &amp;&amp; bb.w &gt; 0 &amp;&amp; bb.h &gt; 0) {</span><span class="s3">\n      </span><span class="s1">zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);</span><span class="s3">\n\n      </span><span class="s1">// crop zoom</span><span class="s3">\n      </span><span class="s1">zoom = zoom &gt; this._private.maxZoom ? this._private.maxZoom : zoom;</span><span class="s3">\n      </span><span class="s1">zoom = zoom &lt; this._private.minZoom ? this._private.minZoom : zoom;</span><span class="s3">\n      </span><span class="s1">var pan = {</span><span class="s3">\n        </span><span class="s1">// now pan to middle</span><span class="s3">\n        </span><span class="s1">x: (w - zoom * (bb.x1 + bb.x2)) / 2,</span><span class="s3">\n        </span><span class="s1">y: (h - zoom * (bb.y1 + bb.y2)) / 2</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">zoom: zoom,</span><span class="s3">\n        </span><span class="s1">pan: pan</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">zoomRange: function zoomRange(min, max) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">if (max == null) {</span><span class="s3">\n      </span><span class="s1">var opts = min;</span><span class="s3">\n      </span><span class="s1">min = opts.min;</span><span class="s3">\n      </span><span class="s1">max = opts.max;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (number$1(min) &amp;&amp; number$1(max) &amp;&amp; min &lt;= max) {</span><span class="s3">\n      </span><span class="s1">_p.minZoom = min;</span><span class="s3">\n      </span><span class="s1">_p.maxZoom = max;</span><span class="s3">\n    </span><span class="s1">} else if (number$1(min) &amp;&amp; max === undefined &amp;&amp; min &lt;= _p.maxZoom) {</span><span class="s3">\n      </span><span class="s1">_p.minZoom = min;</span><span class="s3">\n    </span><span class="s1">} else if (number$1(max) &amp;&amp; min === undefined &amp;&amp; max &gt;= _p.minZoom) {</span><span class="s3">\n      </span><span class="s1">_p.maxZoom = max;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">minZoom: function minZoom(zoom) {</span><span class="s3">\n    </span><span class="s1">if (zoom === undefined) {</span><span class="s3">\n      </span><span class="s1">return this._private.minZoom;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this.zoomRange({</span><span class="s3">\n        </span><span class="s1">min: zoom</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">maxZoom: function maxZoom(zoom) {</span><span class="s3">\n    </span><span class="s1">if (zoom === undefined) {</span><span class="s3">\n      </span><span class="s1">return this._private.maxZoom;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this.zoomRange({</span><span class="s3">\n        </span><span class="s1">max: zoom</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">getZoomedViewport: function getZoomedViewport(params) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var currentPan = _p.pan;</span><span class="s3">\n    </span><span class="s1">var currentZoom = _p.zoom;</span><span class="s3">\n    </span><span class="s1">var pos; // in rendered px</span><span class="s3">\n    </span><span class="s1">var zoom;</span><span class="s3">\n    </span><span class="s1">var bail = false;</span><span class="s3">\n    </span><span class="s1">if (!_p.zoomingEnabled) {</span><span class="s3">\n      </span><span class="s1">// zooming disabled</span><span class="s3">\n      </span><span class="s1">bail = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (number$1(params)) {</span><span class="s3">\n      </span><span class="s1">// then set the zoom</span><span class="s3">\n      </span><span class="s1">zoom = params;</span><span class="s3">\n    </span><span class="s1">} else if (plainObject(params)) {</span><span class="s3">\n      </span><span class="s1">// then zoom about a point</span><span class="s3">\n      </span><span class="s1">zoom = params.level;</span><span class="s3">\n      </span><span class="s1">if (params.position != null) {</span><span class="s3">\n        </span><span class="s1">pos = modelToRenderedPosition$1(params.position, currentZoom, currentPan);</span><span class="s3">\n      </span><span class="s1">} else if (params.renderedPosition != null) {</span><span class="s3">\n        </span><span class="s1">pos = params.renderedPosition;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (pos != null &amp;&amp; !_p.panningEnabled) {</span><span class="s3">\n        </span><span class="s1">// panning disabled</span><span class="s3">\n        </span><span class="s1">bail = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// crop zoom</span><span class="s3">\n    </span><span class="s1">zoom = zoom &gt; _p.maxZoom ? _p.maxZoom : zoom;</span><span class="s3">\n    </span><span class="s1">zoom = zoom &lt; _p.minZoom ? _p.minZoom : zoom;</span><span class="s3">\n\n    </span><span class="s1">// can't zoom with invalid params</span><span class="s3">\n    </span><span class="s1">if (bail || !number$1(zoom) || zoom === currentZoom || pos != null &amp;&amp; (!number$1(pos.x) || !number$1(pos.y))) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (pos != null) {</span><span class="s3">\n      </span><span class="s1">// set zoom about position</span><span class="s3">\n      </span><span class="s1">var pan1 = currentPan;</span><span class="s3">\n      </span><span class="s1">var zoom1 = currentZoom;</span><span class="s3">\n      </span><span class="s1">var zoom2 = zoom;</span><span class="s3">\n      </span><span class="s1">var pan2 = {</span><span class="s3">\n        </span><span class="s1">x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,</span><span class="s3">\n        </span><span class="s1">y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">zoomed: true,</span><span class="s3">\n        </span><span class="s1">panned: true,</span><span class="s3">\n        </span><span class="s1">zoom: zoom2,</span><span class="s3">\n        </span><span class="s1">pan: pan2</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// just set the zoom</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">zoomed: true,</span><span class="s3">\n        </span><span class="s1">panned: false,</span><span class="s3">\n        </span><span class="s1">zoom: zoom,</span><span class="s3">\n        </span><span class="s1">pan: currentPan</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">zoom: function zoom(params) {</span><span class="s3">\n    </span><span class="s1">if (params === undefined) {</span><span class="s3">\n      </span><span class="s1">// get</span><span class="s3">\n      </span><span class="s1">return this._private.zoom;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// set</span><span class="s3">\n      </span><span class="s1">var vp = this.getZoomedViewport(params);</span><span class="s3">\n      </span><span class="s1">var _p = this._private;</span><span class="s3">\n      </span><span class="s1">if (vp == null || !vp.zoomed) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_p.zoom = vp.zoom;</span><span class="s3">\n      </span><span class="s1">if (vp.panned) {</span><span class="s3">\n        </span><span class="s1">_p.pan.x = vp.pan.x;</span><span class="s3">\n        </span><span class="s1">_p.pan.y = vp.pan.y;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');</span><span class="s3">\n      </span><span class="s1">this.notify('viewport');</span><span class="s3">\n      </span><span class="s1">return this; // chaining</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">viewport: function viewport(opts) {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var zoomDefd = true;</span><span class="s3">\n    </span><span class="s1">var panDefd = true;</span><span class="s3">\n    </span><span class="s1">var events = []; // to trigger</span><span class="s3">\n    </span><span class="s1">var zoomFailed = false;</span><span class="s3">\n    </span><span class="s1">var panFailed = false;</span><span class="s3">\n    </span><span class="s1">if (!opts) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!number$1(opts.zoom)) {</span><span class="s3">\n      </span><span class="s1">zoomDefd = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!plainObject(opts.pan)) {</span><span class="s3">\n      </span><span class="s1">panDefd = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!zoomDefd &amp;&amp; !panDefd) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (zoomDefd) {</span><span class="s3">\n      </span><span class="s1">var z = opts.zoom;</span><span class="s3">\n      </span><span class="s1">if (z &lt; _p.minZoom || z &gt; _p.maxZoom || !_p.zoomingEnabled) {</span><span class="s3">\n        </span><span class="s1">zoomFailed = true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">_p.zoom = z;</span><span class="s3">\n        </span><span class="s1">events.push('zoom');</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (panDefd &amp;&amp; (!zoomFailed || !opts.cancelOnFailedZoom) &amp;&amp; _p.panningEnabled) {</span><span class="s3">\n      </span><span class="s1">var p = opts.pan;</span><span class="s3">\n      </span><span class="s1">if (number$1(p.x)) {</span><span class="s3">\n        </span><span class="s1">_p.pan.x = p.x;</span><span class="s3">\n        </span><span class="s1">panFailed = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (number$1(p.y)) {</span><span class="s3">\n        </span><span class="s1">_p.pan.y = p.y;</span><span class="s3">\n        </span><span class="s1">panFailed = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!panFailed) {</span><span class="s3">\n        </span><span class="s1">events.push('pan');</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (events.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">events.push('viewport');</span><span class="s3">\n      </span><span class="s1">this.emit(events.join(' '));</span><span class="s3">\n      </span><span class="s1">this.notify('viewport');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">center: function center(elements) {</span><span class="s3">\n    </span><span class="s1">var pan = this.getCenterPan(elements);</span><span class="s3">\n    </span><span class="s1">if (pan) {</span><span class="s3">\n      </span><span class="s1">this._private.pan = pan;</span><span class="s3">\n      </span><span class="s1">this.emit('pan viewport');</span><span class="s3">\n      </span><span class="s1">this.notify('viewport');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">getCenterPan: function getCenterPan(elements, zoom) {</span><span class="s3">\n    </span><span class="s1">if (!this._private.panningEnabled) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (string(elements)) {</span><span class="s3">\n      </span><span class="s1">var selector = elements;</span><span class="s3">\n      </span><span class="s1">elements = this.mutableElements().filter(selector);</span><span class="s3">\n    </span><span class="s1">} else if (!elementOrCollection(elements)) {</span><span class="s3">\n      </span><span class="s1">elements = this.mutableElements();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (elements.length === 0) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // can't centre pan to nothing</span><span class="s3">\n\n    </span><span class="s1">var bb = elements.boundingBox();</span><span class="s3">\n    </span><span class="s1">var w = this.width();</span><span class="s3">\n    </span><span class="s1">var h = this.height();</span><span class="s3">\n    </span><span class="s1">zoom = zoom === undefined ? this._private.zoom : zoom;</span><span class="s3">\n    </span><span class="s1">var pan = {</span><span class="s3">\n      </span><span class="s1">// middle</span><span class="s3">\n      </span><span class="s1">x: (w - zoom * (bb.x1 + bb.x2)) / 2,</span><span class="s3">\n      </span><span class="s1">y: (h - zoom * (bb.y1 + bb.y2)) / 2</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return pan;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">reset: function reset() {</span><span class="s3">\n    </span><span class="s1">if (!this._private.panningEnabled || !this._private.zoomingEnabled) {</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.viewport({</span><span class="s3">\n      </span><span class="s1">pan: {</span><span class="s3">\n        </span><span class="s1">x: 0,</span><span class="s3">\n        </span><span class="s1">y: 0</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">zoom: 1</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">invalidateSize: function invalidateSize() {</span><span class="s3">\n    </span><span class="s1">this._private.sizeCache = null;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">size: function size() {</span><span class="s3">\n    </span><span class="s1">var _p = this._private;</span><span class="s3">\n    </span><span class="s1">var container = _p.container;</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">return _p.sizeCache = _p.sizeCache || (container ? function () {</span><span class="s3">\n      </span><span class="s1">var style = cy.window().getComputedStyle(container);</span><span class="s3">\n      </span><span class="s1">var val = function val(name) {</span><span class="s3">\n        </span><span class="s1">return parseFloat(style.getPropertyValue(name));</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">width: container.clientWidth - val('padding-left') - val('padding-right'),</span><span class="s3">\n        </span><span class="s1">height: container.clientHeight - val('padding-top') - val('padding-bottom')</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}() : {</span><span class="s3">\n      </span><span class="s1">// fallback if no container (not 0 b/c can be used for dividing etc)</span><span class="s3">\n      </span><span class="s1">width: 1,</span><span class="s3">\n      </span><span class="s1">height: 1</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">width: function width() {</span><span class="s3">\n    </span><span class="s1">return this.size().width;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">height: function height() {</span><span class="s3">\n    </span><span class="s1">return this.size().height;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">extent: function extent() {</span><span class="s3">\n    </span><span class="s1">var pan = this._private.pan;</span><span class="s3">\n    </span><span class="s1">var zoom = this._private.zoom;</span><span class="s3">\n    </span><span class="s1">var rb = this.renderedExtent();</span><span class="s3">\n    </span><span class="s1">var b = {</span><span class="s3">\n      </span><span class="s1">x1: (rb.x1 - pan.x) / zoom,</span><span class="s3">\n      </span><span class="s1">x2: (rb.x2 - pan.x) / zoom,</span><span class="s3">\n      </span><span class="s1">y1: (rb.y1 - pan.y) / zoom,</span><span class="s3">\n      </span><span class="s1">y2: (rb.y2 - pan.y) / zoom</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">b.w = b.x2 - b.x1;</span><span class="s3">\n    </span><span class="s1">b.h = b.y2 - b.y1;</span><span class="s3">\n    </span><span class="s1">return b;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">renderedExtent: function renderedExtent() {</span><span class="s3">\n    </span><span class="s1">var width = this.width();</span><span class="s3">\n    </span><span class="s1">var height = this.height();</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x1: 0,</span><span class="s3">\n      </span><span class="s1">y1: 0,</span><span class="s3">\n      </span><span class="s1">x2: width,</span><span class="s3">\n      </span><span class="s1">y2: height,</span><span class="s3">\n      </span><span class="s1">w: width,</span><span class="s3">\n      </span><span class="s1">h: height</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">multiClickDebounceTime: function multiClickDebounceTime(_int) {</span><span class="s3">\n    </span><span class="s1">if (_int) this._private.multiClickDebounceTime = _int;else return this._private.multiClickDebounceTime;</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">corefn$1.centre = corefn$1.center;</span><span class="s3">\n\n</span><span class="s1">// backwards compatibility</span><span class="s3">\n</span><span class="s1">corefn$1.autolockNodes = corefn$1.autolock;</span><span class="s3">\n</span><span class="s1">corefn$1.autoungrabifyNodes = corefn$1.autoungrabify;</span><span class="s3">\n\n</span><span class="s1">var fn = {</span><span class="s3">\n  </span><span class="s1">data: define.data({</span><span class="s3">\n    </span><span class="s1">field: 'data',</span><span class="s3">\n    </span><span class="s1">bindingEvent: 'data',</span><span class="s3">\n    </span><span class="s1">allowBinding: true,</span><span class="s3">\n    </span><span class="s1">allowSetting: true,</span><span class="s3">\n    </span><span class="s1">settingEvent: 'data',</span><span class="s3">\n    </span><span class="s1">settingTriggersEvent: true,</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">allowGetting: true,</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">removeData: define.removeData({</span><span class="s3">\n    </span><span class="s1">field: 'data',</span><span class="s3">\n    </span><span class="s1">event: 'data',</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">triggerEvent: true,</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">scratch: define.data({</span><span class="s3">\n    </span><span class="s1">field: 'scratch',</span><span class="s3">\n    </span><span class="s1">bindingEvent: 'scratch',</span><span class="s3">\n    </span><span class="s1">allowBinding: true,</span><span class="s3">\n    </span><span class="s1">allowSetting: true,</span><span class="s3">\n    </span><span class="s1">settingEvent: 'scratch',</span><span class="s3">\n    </span><span class="s1">settingTriggersEvent: true,</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">allowGetting: true,</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">removeScratch: define.removeData({</span><span class="s3">\n    </span><span class="s1">field: 'scratch',</span><span class="s3">\n    </span><span class="s1">event: 'scratch',</span><span class="s3">\n    </span><span class="s1">triggerFnName: 'trigger',</span><span class="s3">\n    </span><span class="s1">triggerEvent: true,</span><span class="s3">\n    </span><span class="s1">updateStyle: true</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// aliases</span><span class="s3">\n</span><span class="s1">fn.attr = fn.data;</span><span class="s3">\n</span><span class="s1">fn.removeAttr = fn.removeData;</span><span class="s3">\n\n</span><span class="s1">var Core = function Core(opts) {</span><span class="s3">\n  </span><span class="s1">var cy = this;</span><span class="s3">\n  </span><span class="s1">opts = extend({}, opts);</span><span class="s3">\n  </span><span class="s1">var container = opts.container;</span><span class="s3">\n\n  </span><span class="s1">// allow for passing a wrapped jquery object</span><span class="s3">\n  </span><span class="s1">// e.g. cytoscape({ container: $('#cy') })</span><span class="s3">\n  </span><span class="s1">if (container &amp;&amp; !htmlElement(container) &amp;&amp; htmlElement(container[0])) {</span><span class="s3">\n    </span><span class="s1">container = container[0];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery</span><span class="s3">\n  </span><span class="s1">reg = reg || {};</span><span class="s3">\n  </span><span class="s1">if (reg &amp;&amp; reg.cy) {</span><span class="s3">\n    </span><span class="s1">reg.cy.destroy();</span><span class="s3">\n    </span><span class="s1">reg = {}; // old instance =&gt; replace reg completely</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var readies = reg.readies = reg.readies || [];</span><span class="s3">\n  </span><span class="s1">if (container) {</span><span class="s3">\n    </span><span class="s1">container._cyreg = reg;</span><span class="s3">\n  </span><span class="s1">} // make sure container assoc'd reg points to this cy</span><span class="s3">\n  </span><span class="s1">reg.cy = cy;</span><span class="s3">\n  </span><span class="s1">var head = _window !== undefined &amp;&amp; container !== undefined &amp;&amp; !opts.headless;</span><span class="s3">\n  </span><span class="s1">var options = opts;</span><span class="s3">\n  </span><span class="s1">options.layout = extend({</span><span class="s3">\n    </span><span class="s1">name: head ? 'grid' : 'null'</span><span class="s3">\n  </span><span class="s1">}, options.layout);</span><span class="s3">\n  </span><span class="s1">options.renderer = extend({</span><span class="s3">\n    </span><span class="s1">name: head ? 'canvas' : 'null'</span><span class="s3">\n  </span><span class="s1">}, options.renderer);</span><span class="s3">\n  </span><span class="s1">var defVal = function defVal(def, val, altVal) {</span><span class="s3">\n    </span><span class="s1">if (val !== undefined) {</span><span class="s3">\n      </span><span class="s1">return val;</span><span class="s3">\n    </span><span class="s1">} else if (altVal !== undefined) {</span><span class="s3">\n      </span><span class="s1">return altVal;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return def;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var _p = this._private = {</span><span class="s3">\n    </span><span class="s1">container: container,</span><span class="s3">\n    </span><span class="s1">// html dom ele container</span><span class="s3">\n    </span><span class="s1">ready: false,</span><span class="s3">\n    </span><span class="s1">// whether ready has been triggered</span><span class="s3">\n    </span><span class="s1">options: options,</span><span class="s3">\n    </span><span class="s1">// cached options</span><span class="s3">\n    </span><span class="s1">elements: new Collection(this),</span><span class="s3">\n    </span><span class="s1">// elements in the graph</span><span class="s3">\n    </span><span class="s1">listeners: [],</span><span class="s3">\n    </span><span class="s1">// list of listeners</span><span class="s3">\n    </span><span class="s1">aniEles: new Collection(this),</span><span class="s3">\n    </span><span class="s1">// elements being animated</span><span class="s3">\n    </span><span class="s1">data: options.data || {},</span><span class="s3">\n    </span><span class="s1">// data for the core</span><span class="s3">\n    </span><span class="s1">scratch: {},</span><span class="s3">\n    </span><span class="s1">// scratch object for core</span><span class="s3">\n    </span><span class="s1">layout: null,</span><span class="s3">\n    </span><span class="s1">renderer: null,</span><span class="s3">\n    </span><span class="s1">destroyed: false,</span><span class="s3">\n    </span><span class="s1">// whether destroy was called</span><span class="s3">\n    </span><span class="s1">notificationsEnabled: true,</span><span class="s3">\n    </span><span class="s1">// whether notifications are sent to the renderer</span><span class="s3">\n    </span><span class="s1">minZoom: 1e-50,</span><span class="s3">\n    </span><span class="s1">maxZoom: 1e50,</span><span class="s3">\n    </span><span class="s1">zoomingEnabled: defVal(true, options.zoomingEnabled),</span><span class="s3">\n    </span><span class="s1">userZoomingEnabled: defVal(true, options.userZoomingEnabled),</span><span class="s3">\n    </span><span class="s1">panningEnabled: defVal(true, options.panningEnabled),</span><span class="s3">\n    </span><span class="s1">userPanningEnabled: defVal(true, options.userPanningEnabled),</span><span class="s3">\n    </span><span class="s1">boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),</span><span class="s3">\n    </span><span class="s1">autolock: defVal(false, options.autolock, options.autolockNodes),</span><span class="s3">\n    </span><span class="s1">autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),</span><span class="s3">\n    </span><span class="s1">autounselectify: defVal(false, options.autounselectify),</span><span class="s3">\n    </span><span class="s1">styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,</span><span class="s3">\n    </span><span class="s1">zoom: number$1(options.zoom) ? options.zoom : 1,</span><span class="s3">\n    </span><span class="s1">pan: {</span><span class="s3">\n      </span><span class="s1">x: plainObject(options.pan) &amp;&amp; number$1(options.pan.x) ? options.pan.x : 0,</span><span class="s3">\n      </span><span class="s1">y: plainObject(options.pan) &amp;&amp; number$1(options.pan.y) ? options.pan.y : 0</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">animation: {</span><span class="s3">\n      </span><span class="s1">// object for currently-running animations</span><span class="s3">\n      </span><span class="s1">current: [],</span><span class="s3">\n      </span><span class="s1">queue: []</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">hasCompoundNodes: false,</span><span class="s3">\n    </span><span class="s1">multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">this.createEmitter();</span><span class="s3">\n\n  </span><span class="s1">// set selection type</span><span class="s3">\n  </span><span class="s1">this.selectionType(options.selectionType);</span><span class="s3">\n\n  </span><span class="s1">// init zoom bounds</span><span class="s3">\n  </span><span class="s1">this.zoomRange({</span><span class="s3">\n    </span><span class="s1">min: options.minZoom,</span><span class="s3">\n    </span><span class="s1">max: options.maxZoom</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var loadExtData = function loadExtData(extData, next) {</span><span class="s3">\n    </span><span class="s1">var anyIsPromise = extData.some(promise);</span><span class="s3">\n    </span><span class="s1">if (anyIsPromise) {</span><span class="s3">\n      </span><span class="s1">return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">next(extData); // exec synchronously for convenience</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// start with the default stylesheet so we have something before loading an external stylesheet</span><span class="s3">\n  </span><span class="s1">if (_p.styleEnabled) {</span><span class="s3">\n    </span><span class="s1">cy.setStyle([]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// create the renderer</span><span class="s3">\n  </span><span class="s1">var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options</span><span class="s3">\n  </span><span class="s1">cy.initRenderer(rendererOptions);</span><span class="s3">\n  </span><span class="s1">var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {</span><span class="s3">\n    </span><span class="s1">cy.notifications(false);</span><span class="s3">\n\n    </span><span class="s1">// remove old elements</span><span class="s3">\n    </span><span class="s1">var oldEles = cy.mutableElements();</span><span class="s3">\n    </span><span class="s1">if (oldEles.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">oldEles.remove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (elements != null) {</span><span class="s3">\n      </span><span class="s1">if (plainObject(elements) || array(elements)) {</span><span class="s3">\n        </span><span class="s1">cy.add(elements);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cy.one('layoutready', function (e) {</span><span class="s3">\n      </span><span class="s1">cy.notifications(true);</span><span class="s3">\n      </span><span class="s1">cy.emit(e); // we missed this event by turning notifications off, so pass it on</span><span class="s3">\n\n      </span><span class="s1">cy.one('load', onload);</span><span class="s3">\n      </span><span class="s1">cy.emitAndNotify('load');</span><span class="s3">\n    </span><span class="s1">}).one('layoutstop', function () {</span><span class="s3">\n      </span><span class="s1">cy.one('done', ondone);</span><span class="s3">\n      </span><span class="s1">cy.emit('done');</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var layoutOpts = extend({}, cy._private.options.layout);</span><span class="s3">\n    </span><span class="s1">layoutOpts.eles = cy.elements();</span><span class="s3">\n    </span><span class="s1">cy.layout(layoutOpts).run();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">loadExtData([options.style, options.elements], function (thens) {</span><span class="s3">\n    </span><span class="s1">var initStyle = thens[0];</span><span class="s3">\n    </span><span class="s1">var initEles = thens[1];</span><span class="s3">\n\n    </span><span class="s1">// init style</span><span class="s3">\n    </span><span class="s1">if (_p.styleEnabled) {</span><span class="s3">\n      </span><span class="s1">cy.style().append(initStyle);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// initial load</span><span class="s3">\n    </span><span class="s1">setElesAndLayout(initEles, function () {</span><span class="s3">\n      </span><span class="s1">// onready</span><span class="s3">\n      </span><span class="s1">cy.startAnimationLoop();</span><span class="s3">\n      </span><span class="s1">_p.ready = true;</span><span class="s3">\n\n      </span><span class="s1">// if a ready callback is specified as an option, the bind it</span><span class="s3">\n      </span><span class="s1">if (fn$6(options.ready)) {</span><span class="s3">\n        </span><span class="s1">cy.on('ready', options.ready);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// bind all the ready handlers registered before creating this instance</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; readies.length; i++) {</span><span class="s3">\n        </span><span class="s1">var fn = readies[i];</span><span class="s3">\n        </span><span class="s1">cy.on('ready', fn);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (reg) {</span><span class="s3">\n        </span><span class="s1">reg.readies = [];</span><span class="s3">\n      </span><span class="s1">} // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc</span><span class="s3">\n\n      </span><span class="s1">cy.emit('ready');</span><span class="s3">\n    </span><span class="s1">}, options.done);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var corefn = Core.prototype; // short alias</span><span class="s3">\n\n</span><span class="s1">extend(corefn, {</span><span class="s3">\n  </span><span class="s1">instanceString: function instanceString() {</span><span class="s3">\n    </span><span class="s1">return 'core';</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isReady: function isReady() {</span><span class="s3">\n    </span><span class="s1">return this._private.ready;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">destroyed: function destroyed() {</span><span class="s3">\n    </span><span class="s1">return this._private.destroyed;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ready: function ready(fn) {</span><span class="s3">\n    </span><span class="s1">if (this.isReady()) {</span><span class="s3">\n      </span><span class="s1">this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.on('ready', fn);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">destroy: function destroy() {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">if (cy.destroyed()) return;</span><span class="s3">\n    </span><span class="s1">cy.stopAnimationLoop();</span><span class="s3">\n    </span><span class="s1">cy.destroyRenderer();</span><span class="s3">\n    </span><span class="s1">this.emit('destroy');</span><span class="s3">\n    </span><span class="s1">cy._private.destroyed = true;</span><span class="s3">\n    </span><span class="s1">return cy;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hasElementWithId: function hasElementWithId(id) {</span><span class="s3">\n    </span><span class="s1">return this._private.elements.hasElementWithId(id);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">getElementById: function getElementById(id) {</span><span class="s3">\n    </span><span class="s1">return this._private.elements.getElementById(id);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hasCompoundNodes: function hasCompoundNodes() {</span><span class="s3">\n    </span><span class="s1">return this._private.hasCompoundNodes;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">headless: function headless() {</span><span class="s3">\n    </span><span class="s1">return this._private.renderer.isHeadless();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">styleEnabled: function styleEnabled() {</span><span class="s3">\n    </span><span class="s1">return this._private.styleEnabled;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">addToPool: function addToPool(eles) {</span><span class="s3">\n    </span><span class="s1">this._private.elements.merge(eles);</span><span class="s3">\n    </span><span class="s1">return this; // chaining</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">removeFromPool: function removeFromPool(eles) {</span><span class="s3">\n    </span><span class="s1">this._private.elements.unmerge(eles);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">container: function container() {</span><span class="s3">\n    </span><span class="s1">return this._private.container || null;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">window: function window() {</span><span class="s3">\n    </span><span class="s1">var container = this._private.container;</span><span class="s3">\n    </span><span class="s1">if (container == null) return _window;</span><span class="s3">\n    </span><span class="s1">var ownerDocument = this._private.container.ownerDocument;</span><span class="s3">\n    </span><span class="s1">if (ownerDocument === undefined || ownerDocument == null) {</span><span class="s3">\n      </span><span class="s1">return _window;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ownerDocument.defaultView || _window;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">mount: function mount(container) {</span><span class="s3">\n    </span><span class="s1">if (container == null) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">var _p = cy._private;</span><span class="s3">\n    </span><span class="s1">var options = _p.options;</span><span class="s3">\n    </span><span class="s1">if (!htmlElement(container) &amp;&amp; htmlElement(container[0])) {</span><span class="s3">\n      </span><span class="s1">container = container[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cy.stopAnimationLoop();</span><span class="s3">\n    </span><span class="s1">cy.destroyRenderer();</span><span class="s3">\n    </span><span class="s1">_p.container = container;</span><span class="s3">\n    </span><span class="s1">_p.styleEnabled = true;</span><span class="s3">\n    </span><span class="s1">cy.invalidateSize();</span><span class="s3">\n    </span><span class="s1">cy.initRenderer(extend({}, options, options.renderer, {</span><span class="s3">\n      </span><span class="s1">// allow custom renderer name to be re-used, otherwise use canvas</span><span class="s3">\n      </span><span class="s1">name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">cy.startAnimationLoop();</span><span class="s3">\n    </span><span class="s1">cy.style(options.style);</span><span class="s3">\n    </span><span class="s1">cy.emit('mount');</span><span class="s3">\n    </span><span class="s1">return cy;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">unmount: function unmount() {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">cy.stopAnimationLoop();</span><span class="s3">\n    </span><span class="s1">cy.destroyRenderer();</span><span class="s3">\n    </span><span class="s1">cy.initRenderer({</span><span class="s3">\n      </span><span class="s1">name: 'null'</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">cy.emit('unmount');</span><span class="s3">\n    </span><span class="s1">return cy;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">options: function options() {</span><span class="s3">\n    </span><span class="s1">return copy(this._private.options);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">json: function json(obj) {</span><span class="s3">\n    </span><span class="s1">var cy = this;</span><span class="s3">\n    </span><span class="s1">var _p = cy._private;</span><span class="s3">\n    </span><span class="s1">var eles = cy.mutableElements();</span><span class="s3">\n    </span><span class="s1">var getFreshRef = function getFreshRef(ele) {</span><span class="s3">\n      </span><span class="s1">return cy.getElementById(ele.id());</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (plainObject(obj)) {</span><span class="s3">\n      </span><span class="s1">// set</span><span class="s3">\n\n      </span><span class="s1">cy.startBatch();</span><span class="s3">\n      </span><span class="s1">if (obj.elements) {</span><span class="s3">\n        </span><span class="s1">var idInJson = {};</span><span class="s3">\n        </span><span class="s1">var updateEles = function updateEles(jsons, gr) {</span><span class="s3">\n          </span><span class="s1">var toAdd = [];</span><span class="s3">\n          </span><span class="s1">var toMod = [];</span><span class="s3">\n          </span><span class="s1">for (var i = 0; i &lt; jsons.length; i++) {</span><span class="s3">\n            </span><span class="s1">var json = jsons[i];</span><span class="s3">\n            </span><span class="s1">if (!json.data.id) {</span><span class="s3">\n              </span><span class="s1">warn('cy.json() cannot handle elements without an ID attribute');</span><span class="s3">\n              </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var id = '' + json.data.id; // id must be string</span><span class="s3">\n            </span><span class="s1">var ele = cy.getElementById(id);</span><span class="s3">\n            </span><span class="s1">idInJson[id] = true;</span><span class="s3">\n            </span><span class="s1">if (ele.length !== 0) {</span><span class="s3">\n              </span><span class="s1">// existing element should be updated</span><span class="s3">\n              </span><span class="s1">toMod.push({</span><span class="s3">\n                </span><span class="s1">ele: ele,</span><span class="s3">\n                </span><span class="s1">json: json</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// otherwise should be added</span><span class="s3">\n              </span><span class="s1">if (gr) {</span><span class="s3">\n                </span><span class="s1">json.group = gr;</span><span class="s3">\n                </span><span class="s1">toAdd.push(json);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">toAdd.push(json);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">cy.add(toAdd);</span><span class="s3">\n          </span><span class="s1">for (var _i = 0; _i &lt; toMod.length; _i++) {</span><span class="s3">\n            </span><span class="s1">var _toMod$_i = toMod[_i],</span><span class="s3">\n              </span><span class="s1">_ele = _toMod$_i.ele,</span><span class="s3">\n              </span><span class="s1">_json = _toMod$_i.json;</span><span class="s3">\n            </span><span class="s1">_ele.json(_json);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (array(obj.elements)) {</span><span class="s3">\n          </span><span class="s1">// elements: []</span><span class="s3">\n          </span><span class="s1">updateEles(obj.elements);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// elements: { nodes: [], edges: [] }</span><span class="s3">\n          </span><span class="s1">var grs = ['nodes', 'edges'];</span><span class="s3">\n          </span><span class="s1">for (var i = 0; i &lt; grs.length; i++) {</span><span class="s3">\n            </span><span class="s1">var gr = grs[i];</span><span class="s3">\n            </span><span class="s1">var elements = obj.elements[gr];</span><span class="s3">\n            </span><span class="s1">if (array(elements)) {</span><span class="s3">\n              </span><span class="s1">updateEles(elements, gr);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var parentsToRemove = cy.collection();</span><span class="s3">\n        </span><span class="s1">eles.filter(function (ele) {</span><span class="s3">\n          </span><span class="s1">return !idInJson[ele.id()];</span><span class="s3">\n        </span><span class="s1">}).forEach(function (ele) {</span><span class="s3">\n          </span><span class="s1">if (ele.isParent()) {</span><span class="s3">\n            </span><span class="s1">parentsToRemove.merge(ele);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">ele.remove();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">// so that children are not removed w/parent</span><span class="s3">\n        </span><span class="s1">parentsToRemove.forEach(function (ele) {</span><span class="s3">\n          </span><span class="s1">return ele.children().move({</span><span class="s3">\n            </span><span class="s1">parent: null</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">// intermediate parents may be moved by prior line, so make sure we remove by fresh refs</span><span class="s3">\n        </span><span class="s1">parentsToRemove.forEach(function (ele) {</span><span class="s3">\n          </span><span class="s1">return getFreshRef(ele).remove();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (obj.style) {</span><span class="s3">\n        </span><span class="s1">cy.style(obj.style);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (obj.zoom != null &amp;&amp; obj.zoom !== _p.zoom) {</span><span class="s3">\n        </span><span class="s1">cy.zoom(obj.zoom);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (obj.pan) {</span><span class="s3">\n        </span><span class="s1">if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {</span><span class="s3">\n          </span><span class="s1">cy.pan(obj.pan);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (obj.data) {</span><span class="s3">\n        </span><span class="s1">cy.data(obj.data);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify', 'multiClickDebounceTime'];</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; fields.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">var f = fields[_i2];</span><span class="s3">\n        </span><span class="s1">if (obj[f] != null) {</span><span class="s3">\n          </span><span class="s1">cy[f](obj[f]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cy.endBatch();</span><span class="s3">\n      </span><span class="s1">return this; // chaining</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// get</span><span class="s3">\n      </span><span class="s1">var flat = !!obj;</span><span class="s3">\n      </span><span class="s1">var json = {};</span><span class="s3">\n      </span><span class="s1">if (flat) {</span><span class="s3">\n        </span><span class="s1">json.elements = this.elements().map(function (ele) {</span><span class="s3">\n          </span><span class="s1">return ele.json();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">json.elements = {};</span><span class="s3">\n        </span><span class="s1">eles.forEach(function (ele) {</span><span class="s3">\n          </span><span class="s1">var group = ele.group();</span><span class="s3">\n          </span><span class="s1">if (!json.elements[group]) {</span><span class="s3">\n            </span><span class="s1">json.elements[group] = [];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">json.elements[group].push(ele.json());</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this._private.styleEnabled) {</span><span class="s3">\n        </span><span class="s1">json.style = cy.style().json();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">json.data = copy(cy.data());</span><span class="s3">\n      </span><span class="s1">var options = _p.options;</span><span class="s3">\n      </span><span class="s1">json.zoomingEnabled = _p.zoomingEnabled;</span><span class="s3">\n      </span><span class="s1">json.userZoomingEnabled = _p.userZoomingEnabled;</span><span class="s3">\n      </span><span class="s1">json.zoom = _p.zoom;</span><span class="s3">\n      </span><span class="s1">json.minZoom = _p.minZoom;</span><span class="s3">\n      </span><span class="s1">json.maxZoom = _p.maxZoom;</span><span class="s3">\n      </span><span class="s1">json.panningEnabled = _p.panningEnabled;</span><span class="s3">\n      </span><span class="s1">json.userPanningEnabled = _p.userPanningEnabled;</span><span class="s3">\n      </span><span class="s1">json.pan = copy(_p.pan);</span><span class="s3">\n      </span><span class="s1">json.boxSelectionEnabled = _p.boxSelectionEnabled;</span><span class="s3">\n      </span><span class="s1">json.renderer = copy(options.renderer);</span><span class="s3">\n      </span><span class="s1">json.hideEdgesOnViewport = options.hideEdgesOnViewport;</span><span class="s3">\n      </span><span class="s1">json.textureOnViewport = options.textureOnViewport;</span><span class="s3">\n      </span><span class="s1">json.wheelSensitivity = options.wheelSensitivity;</span><span class="s3">\n      </span><span class="s1">json.motionBlur = options.motionBlur;</span><span class="s3">\n      </span><span class="s1">json.multiClickDebounceTime = options.multiClickDebounceTime;</span><span class="s3">\n      </span><span class="s1">return json;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">corefn.$id = corefn.getElementById;</span><span class="s3">\n</span><span class="s1">[corefn$9, corefn$8, elesfn, corefn$7, corefn$6, corefn$5, corefn$4, corefn$3, corefn$2, corefn$1, fn].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(corefn, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable no-unused-vars */</span><span class="s3">\n</span><span class="s1">var defaults$7 = {</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// whether to fit the viewport to the graph</span><span class="s3">\n  </span><span class="s1">directed: false,</span><span class="s3">\n  </span><span class="s1">// whether the tree is directed downwards (or edges can point in any direction if false)</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// padding on fit</span><span class="s3">\n  </span><span class="s1">circle: false,</span><span class="s3">\n  </span><span class="s1">// put depths in concentric circles if true, put depths top down if false</span><span class="s3">\n  </span><span class="s1">grid: false,</span><span class="s3">\n  </span><span class="s1">// whether to create an even grid into which the DAG is placed (circle:false only)</span><span class="s3">\n  </span><span class="s1">spacingFactor: 1.75,</span><span class="s3">\n  </span><span class="s1">// positive spacing factor, larger =&gt; more space between nodes (N.B. n/a if causes overlap)</span><span class="s3">\n  </span><span class="s1">boundingBox: undefined,</span><span class="s3">\n  </span><span class="s1">// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }</span><span class="s3">\n  </span><span class="s1">avoidOverlap: true,</span><span class="s3">\n  </span><span class="s1">// prevents node overlap, may overflow boundingBox if not enough space</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// Excludes the label when calculating node bounding boxes for the layout algorithm</span><span class="s3">\n  </span><span class="s1">roots: undefined,</span><span class="s3">\n  </span><span class="s1">// the roots of the trees</span><span class="s3">\n  </span><span class="s1">depthSort: undefined,</span><span class="s3">\n  </span><span class="s1">// a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }</span><span class="s3">\n  </span><span class="s1">animate: false,</span><span class="s3">\n  </span><span class="s1">// whether to transition the node positions</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// duration of animation in ms if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// easing of animation if enabled,</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">ready: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutready</span><span class="s3">\n  </span><span class="s1">stop: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutstop</span><span class="s3">\n  </span><span class="s1">transform: function transform(node, position) {</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">} // transform a given node position. Useful for changing flow direction in discrete layouts</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var deprecatedOptionDefaults = {</span><span class="s3">\n  </span><span class="s1">maximal: false,</span><span class="s3">\n  </span><span class="s1">// whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also</span><span class="s3">\n  </span><span class="s1">acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* eslint-enable */</span><span class="s3">\n\n</span><span class="s1">var getInfo = function getInfo(ele) {</span><span class="s3">\n  </span><span class="s1">return ele.scratch('breadthfirst');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var setInfo = function setInfo(ele, obj) {</span><span class="s3">\n  </span><span class="s1">return ele.scratch('breadthfirst', obj);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function BreadthFirstLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">BreadthFirstLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var options = this.options;</span><span class="s3">\n  </span><span class="s1">var cy = options.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes().filter(function (n) {</span><span class="s3">\n    </span><span class="s1">return n.isChildless();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var graph = eles;</span><span class="s3">\n  </span><span class="s1">var directed = options.directed;</span><span class="s3">\n  </span><span class="s1">var maximal = options.acyclic || options.maximal || options.maximalAdjustments &gt; 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true</span><span class="s3">\n\n  </span><span class="s1">var hasBoundingBox = !!options.boundingBox;</span><span class="s3">\n  </span><span class="s1">var cyExtent = cy.extent();</span><span class="s3">\n  </span><span class="s1">var bb = makeBoundingBox(hasBoundingBox ? options.boundingBox : {</span><span class="s3">\n    </span><span class="s1">x1: cyExtent.x1,</span><span class="s3">\n    </span><span class="s1">y1: cyExtent.y1,</span><span class="s3">\n    </span><span class="s1">w: cyExtent.w,</span><span class="s3">\n    </span><span class="s1">h: cyExtent.h</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var roots;</span><span class="s3">\n  </span><span class="s1">if (elementOrCollection(options.roots)) {</span><span class="s3">\n    </span><span class="s1">roots = options.roots;</span><span class="s3">\n  </span><span class="s1">} else if (array(options.roots)) {</span><span class="s3">\n    </span><span class="s1">var rootsArray = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; options.roots.length; i++) {</span><span class="s3">\n      </span><span class="s1">var id = options.roots[i];</span><span class="s3">\n      </span><span class="s1">var ele = cy.getElementById(id);</span><span class="s3">\n      </span><span class="s1">rootsArray.push(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">roots = cy.collection(rootsArray);</span><span class="s3">\n  </span><span class="s1">} else if (string(options.roots)) {</span><span class="s3">\n    </span><span class="s1">roots = cy.$(options.roots);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (directed) {</span><span class="s3">\n      </span><span class="s1">roots = nodes.roots();</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var components = eles.components();</span><span class="s3">\n      </span><span class="s1">roots = cy.collection();</span><span class="s3">\n      </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n        </span><span class="s1">var comp = components[_i];</span><span class="s3">\n        </span><span class="s1">var maxDegree = comp.maxDegree(false);</span><span class="s3">\n        </span><span class="s1">var compRoots = comp.filter(function (ele) {</span><span class="s3">\n          </span><span class="s1">return ele.degree(false) === maxDegree;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">roots = roots.add(compRoots);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; components.length; _i++) {</span><span class="s3">\n        </span><span class="s1">_loop();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var depths = [];</span><span class="s3">\n  </span><span class="s1">var foundByBfs = {};</span><span class="s3">\n  </span><span class="s1">var addToDepth = function addToDepth(ele, d) {</span><span class="s3">\n    </span><span class="s1">if (depths[d] == null) {</span><span class="s3">\n      </span><span class="s1">depths[d] = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var i = depths[d].length;</span><span class="s3">\n    </span><span class="s1">depths[d].push(ele);</span><span class="s3">\n    </span><span class="s1">setInfo(ele, {</span><span class="s3">\n      </span><span class="s1">index: i,</span><span class="s3">\n      </span><span class="s1">depth: d</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var changeDepth = function changeDepth(ele, newDepth) {</span><span class="s3">\n    </span><span class="s1">var _getInfo = getInfo(ele),</span><span class="s3">\n      </span><span class="s1">depth = _getInfo.depth,</span><span class="s3">\n      </span><span class="s1">index = _getInfo.index;</span><span class="s3">\n    </span><span class="s1">depths[depth][index] = null;</span><span class="s3">\n\n    </span><span class="s1">// add only childless nodes</span><span class="s3">\n    </span><span class="s1">if (ele.isChildless()) addToDepth(ele, newDepth);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// find the depths of the nodes</span><span class="s3">\n  </span><span class="s1">graph.bfs({</span><span class="s3">\n    </span><span class="s1">roots: roots,</span><span class="s3">\n    </span><span class="s1">directed: options.directed,</span><span class="s3">\n    </span><span class="s1">visit: function visit(node, edge, pNode, i, depth) {</span><span class="s3">\n      </span><span class="s1">var ele = node[0];</span><span class="s3">\n      </span><span class="s1">var id = ele.id();</span><span class="s3">\n\n      </span><span class="s1">// add only childless nodes</span><span class="s3">\n      </span><span class="s1">if (ele.isChildless()) addToDepth(ele, depth);</span><span class="s3">\n      </span><span class="s1">foundByBfs[id] = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// check for nodes not found by bfs</span><span class="s3">\n  </span><span class="s1">var orphanNodes = [];</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; nodes.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var _ele = nodes[_i2];</span><span class="s3">\n    </span><span class="s1">if (foundByBfs[_ele.id()]) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">orphanNodes.push(_ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// assign the nodes a depth and index</span><span class="s3">\n  </span><span class="s1">var assignDepthsAt = function assignDepthsAt(i) {</span><span class="s3">\n    </span><span class="s1">var eles = depths[i];</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; eles.length; j++) {</span><span class="s3">\n      </span><span class="s1">var _ele2 = eles[j];</span><span class="s3">\n      </span><span class="s1">if (_ele2 == null) {</span><span class="s3">\n        </span><span class="s1">eles.splice(j, 1);</span><span class="s3">\n        </span><span class="s1">j--;</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">setInfo(_ele2, {</span><span class="s3">\n        </span><span class="s1">depth: i,</span><span class="s3">\n        </span><span class="s1">index: j</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var adjustMaximally = function adjustMaximally(ele, shifted) {</span><span class="s3">\n    </span><span class="s1">var eInfo = getInfo(ele);</span><span class="s3">\n    </span><span class="s1">var incomers = ele.incomers().filter(function (el) {</span><span class="s3">\n      </span><span class="s1">return el.isNode() &amp;&amp; eles.has(el);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var maxDepth = -1;</span><span class="s3">\n    </span><span class="s1">var id = ele.id();</span><span class="s3">\n    </span><span class="s1">for (var k = 0; k &lt; incomers.length; k++) {</span><span class="s3">\n      </span><span class="s1">var incmr = incomers[k];</span><span class="s3">\n      </span><span class="s1">var iInfo = getInfo(incmr);</span><span class="s3">\n      </span><span class="s1">maxDepth = Math.max(maxDepth, iInfo.depth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (eInfo.depth &lt;= maxDepth) {</span><span class="s3">\n      </span><span class="s1">if (!options.acyclic &amp;&amp; shifted[id]) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var newDepth = maxDepth + 1;</span><span class="s3">\n      </span><span class="s1">changeDepth(ele, newDepth);</span><span class="s3">\n      </span><span class="s1">shifted[id] = newDepth;</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// for the directed case, try to make the edges all go down (i.e. depth i =&gt; depth i + 1)</span><span class="s3">\n  </span><span class="s1">if (directed &amp;&amp; maximal) {</span><span class="s3">\n    </span><span class="s1">var Q = [];</span><span class="s3">\n    </span><span class="s1">var shifted = {};</span><span class="s3">\n    </span><span class="s1">var enqueue = function enqueue(n) {</span><span class="s3">\n      </span><span class="s1">return Q.push(n);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var dequeue = function dequeue() {</span><span class="s3">\n      </span><span class="s1">return Q.shift();</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">nodes.forEach(function (n) {</span><span class="s3">\n      </span><span class="s1">return Q.push(n);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">while (Q.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var _ele3 = dequeue();</span><span class="s3">\n      </span><span class="s1">var didShift = adjustMaximally(_ele3, shifted);</span><span class="s3">\n      </span><span class="s1">if (didShift) {</span><span class="s3">\n        </span><span class="s1">_ele3.outgoers().filter(function (el) {</span><span class="s3">\n          </span><span class="s1">return el.isNode() &amp;&amp; eles.has(el);</span><span class="s3">\n        </span><span class="s1">}).forEach(enqueue);</span><span class="s3">\n      </span><span class="s1">} else if (didShift === null) {</span><span class="s3">\n        </span><span class="s1">warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');</span><span class="s3">\n        </span><span class="s1">break; // exit on failure</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// find min distance we need to leave between nodes</span><span class="s3">\n  </span><span class="s1">var minDistance = 0;</span><span class="s3">\n  </span><span class="s1">if (options.avoidOverlap) {</span><span class="s3">\n    </span><span class="s1">for (var _i3 = 0; _i3 &lt; nodes.length; _i3++) {</span><span class="s3">\n      </span><span class="s1">var n = nodes[_i3];</span><span class="s3">\n      </span><span class="s1">var nbb = n.layoutDimensions(options);</span><span class="s3">\n      </span><span class="s1">var w = nbb.w;</span><span class="s3">\n      </span><span class="s1">var h = nbb.h;</span><span class="s3">\n      </span><span class="s1">minDistance = Math.max(minDistance, w, h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// get the weighted percent for an element based on its connectivity to other levels</span><span class="s3">\n  </span><span class="s1">var cachedWeightedPercent = {};</span><span class="s3">\n  </span><span class="s1">var getWeightedPercent = function getWeightedPercent(ele) {</span><span class="s3">\n    </span><span class="s1">if (cachedWeightedPercent[ele.id()]) {</span><span class="s3">\n      </span><span class="s1">return cachedWeightedPercent[ele.id()];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var eleDepth = getInfo(ele).depth;</span><span class="s3">\n    </span><span class="s1">var neighbors = ele.neighborhood();</span><span class="s3">\n    </span><span class="s1">var percent = 0;</span><span class="s3">\n    </span><span class="s1">var samples = 0;</span><span class="s3">\n    </span><span class="s1">for (var _i4 = 0; _i4 &lt; neighbors.length; _i4++) {</span><span class="s3">\n      </span><span class="s1">var neighbor = neighbors[_i4];</span><span class="s3">\n      </span><span class="s1">if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var bf = getInfo(neighbor);</span><span class="s3">\n      </span><span class="s1">if (bf == null) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var index = bf.index;</span><span class="s3">\n      </span><span class="s1">var depth = bf.depth;</span><span class="s3">\n\n      </span><span class="s1">// unassigned neighbours shouldn't affect the ordering</span><span class="s3">\n      </span><span class="s1">if (index == null || depth == null) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var nDepth = depths[depth].length;</span><span class="s3">\n      </span><span class="s1">if (depth &lt; eleDepth) {</span><span class="s3">\n        </span><span class="s1">// only get influenced by elements above</span><span class="s3">\n        </span><span class="s1">percent += index / nDepth;</span><span class="s3">\n        </span><span class="s1">samples++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">samples = Math.max(1, samples);</span><span class="s3">\n    </span><span class="s1">percent = percent / samples;</span><span class="s3">\n    </span><span class="s1">if (samples === 0) {</span><span class="s3">\n      </span><span class="s1">// put lone nodes at the start</span><span class="s3">\n      </span><span class="s1">percent = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cachedWeightedPercent[ele.id()] = percent;</span><span class="s3">\n    </span><span class="s1">return percent;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// rearrange the indices in each depth level based on connectivity</span><span class="s3">\n  </span><span class="s1">var sortFn = function sortFn(a, b) {</span><span class="s3">\n    </span><span class="s1">var apct = getWeightedPercent(a);</span><span class="s3">\n    </span><span class="s1">var bpct = getWeightedPercent(b);</span><span class="s3">\n    </span><span class="s1">var diff = apct - bpct;</span><span class="s3">\n    </span><span class="s1">if (diff === 0) {</span><span class="s3">\n      </span><span class="s1">return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return diff;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (options.depthSort !== undefined) {</span><span class="s3">\n    </span><span class="s1">sortFn = options.depthSort;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var depthsLen = depths.length;</span><span class="s3">\n\n  </span><span class="s1">// sort each level to make connected nodes closer</span><span class="s3">\n  </span><span class="s1">for (var _i5 = 0; _i5 &lt; depthsLen; _i5++) {</span><span class="s3">\n    </span><span class="s1">depths[_i5].sort(sortFn);</span><span class="s3">\n    </span><span class="s1">assignDepthsAt(_i5);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// assign orphan nodes to a new top-level depth</span><span class="s3">\n  </span><span class="s1">var orphanDepth = [];</span><span class="s3">\n  </span><span class="s1">for (var _i6 = 0; _i6 &lt; orphanNodes.length; _i6++) {</span><span class="s3">\n    </span><span class="s1">orphanDepth.push(orphanNodes[_i6]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var assignDepths = function assignDepths() {</span><span class="s3">\n    </span><span class="s1">for (var _i7 = 0; _i7 &lt; depthsLen; _i7++) {</span><span class="s3">\n      </span><span class="s1">assignDepthsAt(_i7);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// add a new top-level depth only when there are orphan nodes</span><span class="s3">\n  </span><span class="s1">if (orphanDepth.length) {</span><span class="s3">\n    </span><span class="s1">depths.unshift(orphanDepth);</span><span class="s3">\n    </span><span class="s1">depthsLen = depths.length;</span><span class="s3">\n    </span><span class="s1">assignDepths();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var biggestDepthSize = 0;</span><span class="s3">\n  </span><span class="s1">for (var _i8 = 0; _i8 &lt; depthsLen; _i8++) {</span><span class="s3">\n    </span><span class="s1">biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var center = {</span><span class="s3">\n    </span><span class="s1">x: bb.x1 + bb.w / 2,</span><span class="s3">\n    </span><span class="s1">y: bb.y1 + bb.h / 2</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// average node size</span><span class="s3">\n  </span><span class="s1">var aveNodeSize = nodes.reduce(function (acc, node) {</span><span class="s3">\n    </span><span class="s1">return function (box) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">w: acc.w === -1 ? box.w : (acc.w + box.w) / 2,</span><span class="s3">\n        </span><span class="s1">h: acc.h === -1 ? box.h : (acc.h + box.h) / 2</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}(node.boundingBox({</span><span class="s3">\n      </span><span class="s1">includeLabels: options.nodeDimensionsIncludeLabels</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">w: -1,</span><span class="s3">\n    </span><span class="s1">h: -1</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var distanceY = Math.max(</span><span class="s3">\n  </span><span class="s1">// only one depth</span><span class="s3">\n  </span><span class="s1">depthsLen === 1 ? 0 :</span><span class="s3">\n  </span><span class="s1">// inside a bounding box, no need for top &amp; bottom padding</span><span class="s3">\n  </span><span class="s1">hasBoundingBox ? (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen - 1) : (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen + 1), minDistance);</span><span class="s3">\n  </span><span class="s1">var maxDepthSize = depths.reduce(function (max, eles) {</span><span class="s3">\n    </span><span class="s1">return Math.max(max, eles.length);</span><span class="s3">\n  </span><span class="s1">}, 0);</span><span class="s3">\n  </span><span class="s1">var getPosition = function getPosition(ele) {</span><span class="s3">\n    </span><span class="s1">var _getInfo2 = getInfo(ele),</span><span class="s3">\n      </span><span class="s1">depth = _getInfo2.depth,</span><span class="s3">\n      </span><span class="s1">index = _getInfo2.index;</span><span class="s3">\n    </span><span class="s1">if (options.circle) {</span><span class="s3">\n      </span><span class="s1">var radiusStepSize = Math.min(bb.w / 2 / depthsLen, bb.h / 2 / depthsLen);</span><span class="s3">\n      </span><span class="s1">radiusStepSize = Math.max(radiusStepSize, minDistance);</span><span class="s3">\n      </span><span class="s1">var radius = radiusStepSize * depth + radiusStepSize - (depthsLen &gt; 0 &amp;&amp; depths[0].length &lt;= 3 ? radiusStepSize / 2 : 0);</span><span class="s3">\n      </span><span class="s1">var theta = 2 * Math.PI / depths[depth].length * index;</span><span class="s3">\n      </span><span class="s1">if (depth === 0 &amp;&amp; depths[0].length === 1) {</span><span class="s3">\n        </span><span class="s1">radius = 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: center.x + radius * Math.cos(theta),</span><span class="s3">\n        </span><span class="s1">y: center.y + radius * Math.sin(theta)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var depthSize = depths[depth].length;</span><span class="s3">\n      </span><span class="s1">var distanceX = Math.max(</span><span class="s3">\n      </span><span class="s1">// only one depth</span><span class="s3">\n      </span><span class="s1">depthSize === 1 ? 0 :</span><span class="s3">\n      </span><span class="s1">// inside a bounding box, no need for left &amp; right padding</span><span class="s3">\n      </span><span class="s1">hasBoundingBox ? (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) - 1) : (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);</span><span class="s3">\n      </span><span class="s1">var epos = {</span><span class="s3">\n        </span><span class="s1">x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,</span><span class="s3">\n        </span><span class="s1">y: center.y + (depth + 1 - (depthsLen + 1) / 2) * distanceY</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">return epos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">eles.nodes().layoutPositions(this, options, getPosition);</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defaults$6 = {</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// whether to fit the viewport to the graph</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// the padding on fit</span><span class="s3">\n  </span><span class="s1">boundingBox: undefined,</span><span class="s3">\n  </span><span class="s1">// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }</span><span class="s3">\n  </span><span class="s1">avoidOverlap: true,</span><span class="s3">\n  </span><span class="s1">// prevents node overlap, may overflow boundingBox and radius if not enough space</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// Excludes the label when calculating node bounding boxes for the layout algorithm</span><span class="s3">\n  </span><span class="s1">spacingFactor: undefined,</span><span class="s3">\n  </span><span class="s1">// Applies a multiplicative factor (&gt;0) to expand or compress the overall area that the nodes take up</span><span class="s3">\n  </span><span class="s1">radius: undefined,</span><span class="s3">\n  </span><span class="s1">// the radius of the circle</span><span class="s3">\n  </span><span class="s1">startAngle: 3 / 2 * Math.PI,</span><span class="s3">\n  </span><span class="s1">// where nodes start in radians</span><span class="s3">\n  </span><span class="s1">sweep: undefined,</span><span class="s3">\n  </span><span class="s1">// how many radians should be between the first and last node (defaults to full circle)</span><span class="s3">\n  </span><span class="s1">clockwise: true,</span><span class="s3">\n  </span><span class="s1">// whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)</span><span class="s3">\n  </span><span class="s1">sort: undefined,</span><span class="s3">\n  </span><span class="s1">// a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }</span><span class="s3">\n  </span><span class="s1">animate: false,</span><span class="s3">\n  </span><span class="s1">// whether to transition the node positions</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// duration of animation in ms if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// easing of animation if enabled</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">ready: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutready</span><span class="s3">\n  </span><span class="s1">stop: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutstop</span><span class="s3">\n  </span><span class="s1">transform: function transform(node, position) {</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">} // transform a given node position. Useful for changing flow direction in discrete layouts </span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function CircleLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$6, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">CircleLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var params = this.options;</span><span class="s3">\n  </span><span class="s1">var options = params;</span><span class="s3">\n  </span><span class="s1">var cy = params.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes().not(':parent');</span><span class="s3">\n  </span><span class="s1">if (options.sort) {</span><span class="s3">\n    </span><span class="s1">nodes = nodes.sort(options.sort);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {</span><span class="s3">\n    </span><span class="s1">x1: 0,</span><span class="s3">\n    </span><span class="s1">y1: 0,</span><span class="s3">\n    </span><span class="s1">w: cy.width(),</span><span class="s3">\n    </span><span class="s1">h: cy.height()</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var center = {</span><span class="s3">\n    </span><span class="s1">x: bb.x1 + bb.w / 2,</span><span class="s3">\n    </span><span class="s1">y: bb.y1 + bb.h / 2</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;</span><span class="s3">\n  </span><span class="s1">var dTheta = sweep / Math.max(1, nodes.length - 1);</span><span class="s3">\n  </span><span class="s1">var r;</span><span class="s3">\n  </span><span class="s1">var minDistance = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var n = nodes[i];</span><span class="s3">\n    </span><span class="s1">var nbb = n.layoutDimensions(options);</span><span class="s3">\n    </span><span class="s1">var w = nbb.w;</span><span class="s3">\n    </span><span class="s1">var h = nbb.h;</span><span class="s3">\n    </span><span class="s1">minDistance = Math.max(minDistance, w, h);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (number$1(options.radius)) {</span><span class="s3">\n    </span><span class="s1">r = options.radius;</span><span class="s3">\n  </span><span class="s1">} else if (nodes.length &lt;= 1) {</span><span class="s3">\n    </span><span class="s1">r = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r = Math.min(bb.h, bb.w) / 2 - minDistance;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// calculate the radius</span><span class="s3">\n  </span><span class="s1">if (nodes.length &gt; 1 &amp;&amp; options.avoidOverlap) {</span><span class="s3">\n    </span><span class="s1">// but only if more than one node (can't overlap)</span><span class="s3">\n    </span><span class="s1">minDistance *= 1.75; // just to have some nice spacing</span><span class="s3">\n\n    </span><span class="s1">var dcos = Math.cos(dTheta) - Math.cos(0);</span><span class="s3">\n    </span><span class="s1">var dsin = Math.sin(dTheta) - Math.sin(0);</span><span class="s3">\n    </span><span class="s1">var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping</span><span class="s3">\n    </span><span class="s1">r = Math.max(rMin, r);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var getPos = function getPos(ele, i) {</span><span class="s3">\n    </span><span class="s1">var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);</span><span class="s3">\n    </span><span class="s1">var rx = r * Math.cos(theta);</span><span class="s3">\n    </span><span class="s1">var ry = r * Math.sin(theta);</span><span class="s3">\n    </span><span class="s1">var pos = {</span><span class="s3">\n      </span><span class="s1">x: center.x + rx,</span><span class="s3">\n      </span><span class="s1">y: center.y + ry</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">eles.nodes().layoutPositions(this, options, getPos);</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defaults$5 = {</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// whether to fit the viewport to the graph</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// the padding on fit</span><span class="s3">\n  </span><span class="s1">startAngle: 3 / 2 * Math.PI,</span><span class="s3">\n  </span><span class="s1">// where nodes start in radians</span><span class="s3">\n  </span><span class="s1">sweep: undefined,</span><span class="s3">\n  </span><span class="s1">// how many radians should be between the first and last node (defaults to full circle)</span><span class="s3">\n  </span><span class="s1">clockwise: true,</span><span class="s3">\n  </span><span class="s1">// whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)</span><span class="s3">\n  </span><span class="s1">equidistant: false,</span><span class="s3">\n  </span><span class="s1">// whether levels have an equal radial distance betwen them, may cause bounding box overflow</span><span class="s3">\n  </span><span class="s1">minNodeSpacing: 10,</span><span class="s3">\n  </span><span class="s1">// min spacing between outside of nodes (used for radius adjustment)</span><span class="s3">\n  </span><span class="s1">boundingBox: undefined,</span><span class="s3">\n  </span><span class="s1">// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }</span><span class="s3">\n  </span><span class="s1">avoidOverlap: true,</span><span class="s3">\n  </span><span class="s1">// prevents node overlap, may overflow boundingBox if not enough space</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// Excludes the label when calculating node bounding boxes for the layout algorithm</span><span class="s3">\n  </span><span class="s1">height: undefined,</span><span class="s3">\n  </span><span class="s1">// height of layout area (overrides container height)</span><span class="s3">\n  </span><span class="s1">width: undefined,</span><span class="s3">\n  </span><span class="s1">// width of layout area (overrides container width)</span><span class="s3">\n  </span><span class="s1">spacingFactor: undefined,</span><span class="s3">\n  </span><span class="s1">// Applies a multiplicative factor (&gt;0) to expand or compress the overall area that the nodes take up</span><span class="s3">\n  </span><span class="s1">concentric: function concentric(node) {</span><span class="s3">\n    </span><span class="s1">// returns numeric value for each node, placing higher nodes in levels towards the centre</span><span class="s3">\n    </span><span class="s1">return node.degree();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">levelWidth: function levelWidth(nodes) {</span><span class="s3">\n    </span><span class="s1">// the variation of concentric values in each level</span><span class="s3">\n    </span><span class="s1">return nodes.maxDegree() / 4;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">animate: false,</span><span class="s3">\n  </span><span class="s1">// whether to transition the node positions</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// duration of animation in ms if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// easing of animation if enabled</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">ready: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutready</span><span class="s3">\n  </span><span class="s1">stop: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutstop</span><span class="s3">\n  </span><span class="s1">transform: function transform(node, position) {</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">} // transform a given node position. Useful for changing flow direction in discrete layouts</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function ConcentricLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$5, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">ConcentricLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var params = this.options;</span><span class="s3">\n  </span><span class="s1">var options = params;</span><span class="s3">\n  </span><span class="s1">var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;</span><span class="s3">\n  </span><span class="s1">var cy = params.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes().not(':parent');</span><span class="s3">\n  </span><span class="s1">var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {</span><span class="s3">\n    </span><span class="s1">x1: 0,</span><span class="s3">\n    </span><span class="s1">y1: 0,</span><span class="s3">\n    </span><span class="s1">w: cy.width(),</span><span class="s3">\n    </span><span class="s1">h: cy.height()</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var center = {</span><span class="s3">\n    </span><span class="s1">x: bb.x1 + bb.w / 2,</span><span class="s3">\n    </span><span class="s1">y: bb.y1 + bb.h / 2</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var nodeValues = []; // { node, value }</span><span class="s3">\n  </span><span class="s1">var maxNodeSize = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = nodes[i];</span><span class="s3">\n    </span><span class="s1">var value = undefined;</span><span class="s3">\n\n    </span><span class="s1">// calculate the node value</span><span class="s3">\n    </span><span class="s1">value = options.concentric(node);</span><span class="s3">\n    </span><span class="s1">nodeValues.push({</span><span class="s3">\n      </span><span class="s1">value: value,</span><span class="s3">\n      </span><span class="s1">node: node</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// for style mapping</span><span class="s3">\n    </span><span class="s1">node._private.scratch.concentric = value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// in case we used the `concentric` in style</span><span class="s3">\n  </span><span class="s1">nodes.updateStyle();</span><span class="s3">\n\n  </span><span class="s1">// calculate max size now based on potentially updated mappers</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; nodes.length; _i++) {</span><span class="s3">\n    </span><span class="s1">var _node = nodes[_i];</span><span class="s3">\n    </span><span class="s1">var nbb = _node.layoutDimensions(options);</span><span class="s3">\n    </span><span class="s1">maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// sort node values in descreasing order</span><span class="s3">\n  </span><span class="s1">nodeValues.sort(function (a, b) {</span><span class="s3">\n    </span><span class="s1">return b.value - a.value;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var levelWidth = options.levelWidth(nodes);</span><span class="s3">\n\n  </span><span class="s1">// put the values into levels</span><span class="s3">\n  </span><span class="s1">var levels = [[]];</span><span class="s3">\n  </span><span class="s1">var currentLevel = levels[0];</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; nodeValues.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var val = nodeValues[_i2];</span><span class="s3">\n    </span><span class="s1">if (currentLevel.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var diff = Math.abs(currentLevel[0].value - val.value);</span><span class="s3">\n      </span><span class="s1">if (diff &gt;= levelWidth) {</span><span class="s3">\n        </span><span class="s1">currentLevel = [];</span><span class="s3">\n        </span><span class="s1">levels.push(currentLevel);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currentLevel.push(val);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// create positions from levels</span><span class="s3">\n\n  </span><span class="s1">var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes</span><span class="s3">\n\n  </span><span class="s1">if (!options.avoidOverlap) {</span><span class="s3">\n    </span><span class="s1">// then strictly constrain to bb</span><span class="s3">\n    </span><span class="s1">var firstLvlHasMulti = levels.length &gt; 0 &amp;&amp; levels[0].length &gt; 1;</span><span class="s3">\n    </span><span class="s1">var maxR = Math.min(bb.w, bb.h) / 2 - minDist;</span><span class="s3">\n    </span><span class="s1">var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);</span><span class="s3">\n    </span><span class="s1">minDist = Math.min(minDist, rStep);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// find the metrics for each level</span><span class="s3">\n  </span><span class="s1">var r = 0;</span><span class="s3">\n  </span><span class="s1">for (var _i3 = 0; _i3 &lt; levels.length; _i3++) {</span><span class="s3">\n    </span><span class="s1">var level = levels[_i3];</span><span class="s3">\n    </span><span class="s1">var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;</span><span class="s3">\n    </span><span class="s1">var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);</span><span class="s3">\n\n    </span><span class="s1">// calculate the radius</span><span class="s3">\n    </span><span class="s1">if (level.length &gt; 1 &amp;&amp; options.avoidOverlap) {</span><span class="s3">\n      </span><span class="s1">// but only if more than one node (can't overlap)</span><span class="s3">\n      </span><span class="s1">var dcos = Math.cos(dTheta) - Math.cos(0);</span><span class="s3">\n      </span><span class="s1">var dsin = Math.sin(dTheta) - Math.sin(0);</span><span class="s3">\n      </span><span class="s1">var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping</span><span class="s3">\n\n      </span><span class="s1">r = Math.max(rMin, r);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">level.r = r;</span><span class="s3">\n    </span><span class="s1">r += minDist;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (options.equidistant) {</span><span class="s3">\n    </span><span class="s1">var rDeltaMax = 0;</span><span class="s3">\n    </span><span class="s1">var _r = 0;</span><span class="s3">\n    </span><span class="s1">for (var _i4 = 0; _i4 &lt; levels.length; _i4++) {</span><span class="s3">\n      </span><span class="s1">var _level = levels[_i4];</span><span class="s3">\n      </span><span class="s1">var rDelta = _level.r - _r;</span><span class="s3">\n      </span><span class="s1">rDeltaMax = Math.max(rDeltaMax, rDelta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_r = 0;</span><span class="s3">\n    </span><span class="s1">for (var _i5 = 0; _i5 &lt; levels.length; _i5++) {</span><span class="s3">\n      </span><span class="s1">var _level2 = levels[_i5];</span><span class="s3">\n      </span><span class="s1">if (_i5 === 0) {</span><span class="s3">\n        </span><span class="s1">_r = _level2.r;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_level2.r = _r;</span><span class="s3">\n      </span><span class="s1">_r += rDeltaMax;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// calculate the node positions</span><span class="s3">\n  </span><span class="s1">var pos = {}; // id =&gt; position</span><span class="s3">\n  </span><span class="s1">for (var _i6 = 0; _i6 &lt; levels.length; _i6++) {</span><span class="s3">\n    </span><span class="s1">var _level3 = levels[_i6];</span><span class="s3">\n    </span><span class="s1">var _dTheta = _level3.dTheta;</span><span class="s3">\n    </span><span class="s1">var _r2 = _level3.r;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; _level3.length; j++) {</span><span class="s3">\n      </span><span class="s1">var _val = _level3[j];</span><span class="s3">\n      </span><span class="s1">var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;</span><span class="s3">\n      </span><span class="s1">var p = {</span><span class="s3">\n        </span><span class="s1">x: center.x + _r2 * Math.cos(theta),</span><span class="s3">\n        </span><span class="s1">y: center.y + _r2 * Math.sin(theta)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">pos[_val.node.id()] = p;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// position the nodes</span><span class="s3">\n  </span><span class="s1">eles.nodes().layoutPositions(this, options, function (ele) {</span><span class="s3">\n    </span><span class="s1">var id = ele.id();</span><span class="s3">\n    </span><span class="s1">return pos[id];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n</span><span class="s1">The CoSE layout was written by Gerardo Huck.</span><span class="s3">\n</span><span class="s1">https://www.linkedin.com/in/gerardohuck/</span><span class="s3">\n\n</span><span class="s1">Based on the following article:</span><span class="s3">\n</span><span class="s1">http://dl.acm.org/citation.cfm?id=1498047</span><span class="s3">\n\n</span><span class="s1">Modifications tracked on Github.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var DEBUG;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief :  default layout options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var defaults$4 = {</span><span class="s3">\n  </span><span class="s1">// Called on `layoutready`</span><span class="s3">\n  </span><span class="s1">ready: function ready() {},</span><span class="s3">\n  </span><span class="s1">// Called on `layoutstop`</span><span class="s3">\n  </span><span class="s1">stop: function stop() {},</span><span class="s3">\n  </span><span class="s1">// Whether to animate while running the layout</span><span class="s3">\n  </span><span class="s1">// true : Animate continuously as the layout is running</span><span class="s3">\n  </span><span class="s1">// false : Just show the end result</span><span class="s3">\n  </span><span class="s1">// 'end' : Animate with the end result, from the initial positions to the end positions</span><span class="s3">\n  </span><span class="s1">animate: true,</span><span class="s3">\n  </span><span class="s1">// Easing of the animation for animate:'end'</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// The duration of the animation for animate:'end'</span><span class="s3">\n  </span><span class="s1">animationDuration: undefined,</span><span class="s3">\n  </span><span class="s1">// A function that determines whether the node should be animated</span><span class="s3">\n  </span><span class="s1">// All nodes animated by default on animate enabled</span><span class="s3">\n  </span><span class="s1">// Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// The layout animates only after this many milliseconds for animate:true</span><span class="s3">\n  </span><span class="s1">// (prevents flashing on fast runs)</span><span class="s3">\n  </span><span class="s1">animationThreshold: 250,</span><span class="s3">\n  </span><span class="s1">// Number of iterations between consecutive screen positions update</span><span class="s3">\n  </span><span class="s1">refresh: 20,</span><span class="s3">\n  </span><span class="s1">// Whether to fit the network view after when done</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// Padding on fit</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }</span><span class="s3">\n  </span><span class="s1">boundingBox: undefined,</span><span class="s3">\n  </span><span class="s1">// Excludes the label when calculating node bounding boxes for the layout algorithm</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// Randomize the initial positions of the nodes (true) or use existing positions (false)</span><span class="s3">\n  </span><span class="s1">randomize: false,</span><span class="s3">\n  </span><span class="s1">// Extra spacing between components in non-compound graphs</span><span class="s3">\n  </span><span class="s1">componentSpacing: 40,</span><span class="s3">\n  </span><span class="s1">// Node repulsion (non overlapping) multiplier</span><span class="s3">\n  </span><span class="s1">nodeRepulsion: function nodeRepulsion(node) {</span><span class="s3">\n    </span><span class="s1">return 2048;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Node repulsion (overlapping) multiplier</span><span class="s3">\n  </span><span class="s1">nodeOverlap: 4,</span><span class="s3">\n  </span><span class="s1">// Ideal edge (non nested) length</span><span class="s3">\n  </span><span class="s1">idealEdgeLength: function idealEdgeLength(edge) {</span><span class="s3">\n    </span><span class="s1">return 32;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Divisor to compute edge forces</span><span class="s3">\n  </span><span class="s1">edgeElasticity: function edgeElasticity(edge) {</span><span class="s3">\n    </span><span class="s1">return 32;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Nesting factor (multiplier) to compute ideal edge length for nested edges</span><span class="s3">\n  </span><span class="s1">nestingFactor: 1.2,</span><span class="s3">\n  </span><span class="s1">// Gravity force (constant)</span><span class="s3">\n  </span><span class="s1">gravity: 1,</span><span class="s3">\n  </span><span class="s1">// Maximum number of iterations to perform</span><span class="s3">\n  </span><span class="s1">numIter: 1000,</span><span class="s3">\n  </span><span class="s1">// Initial temperature (maximum node displacement)</span><span class="s3">\n  </span><span class="s1">initialTemp: 1000,</span><span class="s3">\n  </span><span class="s1">// Cooling factor (how the temperature is reduced between consecutive iterations</span><span class="s3">\n  </span><span class="s1">coolingFactor: 0.99,</span><span class="s3">\n  </span><span class="s1">// Lower temperature threshold (below this point the layout will end)</span><span class="s3">\n  </span><span class="s1">minTemp: 1.0</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief       : constructor</span><span class="s3">\n </span><span class="s1">* @arg options : object containing layout options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function CoseLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$4, options);</span><span class="s3">\n  </span><span class="s1">this.options.layout = this;</span><span class="s3">\n\n  </span><span class="s1">// Exclude any edge that has a source or target node that is not in the set of passed-in nodes</span><span class="s3">\n  </span><span class="s1">var nodes = this.options.eles.nodes();</span><span class="s3">\n  </span><span class="s1">var edges = this.options.eles.edges();</span><span class="s3">\n  </span><span class="s1">var notEdges = edges.filter(function (e) {</span><span class="s3">\n    </span><span class="s1">var sourceId = e.source().data('id');</span><span class="s3">\n    </span><span class="s1">var targetId = e.target().data('id');</span><span class="s3">\n    </span><span class="s1">var hasSource = nodes.some(function (n) {</span><span class="s3">\n      </span><span class="s1">return n.data('id') === sourceId;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var hasTarget = nodes.some(function (n) {</span><span class="s3">\n      </span><span class="s1">return n.data('id') === targetId;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return !hasSource || !hasTarget;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">this.options.eles = this.options.eles.not(notEdges);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : runs the layout</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoseLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var options = this.options;</span><span class="s3">\n  </span><span class="s1">var cy = options.cy;</span><span class="s3">\n  </span><span class="s1">var layout = this;</span><span class="s3">\n  </span><span class="s1">layout.stopped = false;</span><span class="s3">\n  </span><span class="s1">if (options.animate === true || options.animate === false) {</span><span class="s3">\n    </span><span class="s1">layout.emit({</span><span class="s3">\n      </span><span class="s1">type: 'layoutstart',</span><span class="s3">\n      </span><span class="s1">layout: layout</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Set DEBUG - Global variable</span><span class="s3">\n  </span><span class="s1">if (true === options.debug) {</span><span class="s3">\n    </span><span class="s1">DEBUG = true;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">DEBUG = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Initialize layout info</span><span class="s3">\n  </span><span class="s1">var layoutInfo = createLayoutInfo(cy, layout, options);</span><span class="s3">\n\n  </span><span class="s1">// Show LayoutInfo contents if debugging</span><span class="s3">\n  </span><span class="s1">if (DEBUG) {</span><span class="s3">\n    </span><span class="s1">printLayoutInfo(layoutInfo);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If required, randomize node positions</span><span class="s3">\n  </span><span class="s1">if (options.randomize) {</span><span class="s3">\n    </span><span class="s1">randomizePositions(layoutInfo);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var startTime = performanceNow();</span><span class="s3">\n  </span><span class="s1">var refresh = function refresh() {</span><span class="s3">\n    </span><span class="s1">refreshPositions(layoutInfo, cy, options);</span><span class="s3">\n\n    </span><span class="s1">// Fit the graph if necessary</span><span class="s3">\n    </span><span class="s1">if (true === options.fit) {</span><span class="s3">\n      </span><span class="s1">cy.fit(options.padding);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var mainLoop = function mainLoop(i) {</span><span class="s3">\n    </span><span class="s1">if (layout.stopped || i &gt;= options.numIter) {</span><span class="s3">\n      </span><span class="s1">// logDebug(</span><span class="s3">\&quot;</span><span class="s1">Layout manually stopped. Stopping computation in step </span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Do one step in the phisical simulation</span><span class="s3">\n    </span><span class="s1">step(layoutInfo, options);</span><span class="s3">\n\n    </span><span class="s1">// Update temperature</span><span class="s3">\n    </span><span class="s1">layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;</span><span class="s3">\n    </span><span class="s1">// logDebug(</span><span class="s3">\&quot;</span><span class="s1">New temperature: </span><span class="s3">\&quot; </span><span class="s1">+ layoutInfo.temperature);</span><span class="s3">\n\n    </span><span class="s1">if (layoutInfo.temperature &lt; options.minTemp) {</span><span class="s3">\n      </span><span class="s1">// logDebug(</span><span class="s3">\&quot;</span><span class="s1">Temperature drop below minimum threshold. Stopping computation in step </span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var done = function done() {</span><span class="s3">\n    </span><span class="s1">if (options.animate === true || options.animate === false) {</span><span class="s3">\n      </span><span class="s1">refresh();</span><span class="s3">\n\n      </span><span class="s1">// Layout has finished</span><span class="s3">\n      </span><span class="s1">layout.one('layoutstop', options.stop);</span><span class="s3">\n      </span><span class="s1">layout.emit({</span><span class="s3">\n        </span><span class="s1">type: 'layoutstop',</span><span class="s3">\n        </span><span class="s1">layout: layout</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var nodes = options.eles.nodes();</span><span class="s3">\n      </span><span class="s1">var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);</span><span class="s3">\n      </span><span class="s1">nodes.layoutPositions(layout, options, getScaledPos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var i = 0;</span><span class="s3">\n  </span><span class="s1">var loopRet = true;</span><span class="s3">\n  </span><span class="s1">if (options.animate === true) {</span><span class="s3">\n    </span><span class="s1">var _frame = function frame() {</span><span class="s3">\n      </span><span class="s1">var f = 0;</span><span class="s3">\n      </span><span class="s1">while (loopRet &amp;&amp; f &lt; options.refresh) {</span><span class="s3">\n        </span><span class="s1">loopRet = mainLoop(i);</span><span class="s3">\n        </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">f++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!loopRet) {</span><span class="s3">\n        </span><span class="s1">// it's done</span><span class="s3">\n        </span><span class="s1">separateComponents(layoutInfo, options);</span><span class="s3">\n        </span><span class="s1">done();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var now = performanceNow();</span><span class="s3">\n        </span><span class="s1">if (now - startTime &gt;= options.animationThreshold) {</span><span class="s3">\n          </span><span class="s1">refresh();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">requestAnimationFrame(_frame);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">_frame();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">while (loopRet) {</span><span class="s3">\n      </span><span class="s1">loopRet = mainLoop(i);</span><span class="s3">\n      </span><span class="s1">i++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">separateComponents(layoutInfo, options);</span><span class="s3">\n    </span><span class="s1">done();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : called on continuous layouts to stop them before they finish</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoseLayout.prototype.stop = function () {</span><span class="s3">\n  </span><span class="s1">this.stopped = true;</span><span class="s3">\n  </span><span class="s1">if (this.thread) {</span><span class="s3">\n    </span><span class="s1">this.thread.stop();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.emit('layoutstop');</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CoseLayout.prototype.destroy = function () {</span><span class="s3">\n  </span><span class="s1">if (this.thread) {</span><span class="s3">\n    </span><span class="s1">this.thread.stop();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief     : Creates an object which is contains all the data</span><span class="s3">\n </span><span class="s1">*              used in the layout process</span><span class="s3">\n </span><span class="s1">* @arg cy    : cytoscape.js object</span><span class="s3">\n </span><span class="s1">* @return    : layoutInfo object initialized</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var createLayoutInfo = function createLayoutInfo(cy, layout, options) {</span><span class="s3">\n  </span><span class="s1">// Shortcut</span><span class="s3">\n  </span><span class="s1">var edges = options.eles.edges();</span><span class="s3">\n  </span><span class="s1">var nodes = options.eles.nodes();</span><span class="s3">\n  </span><span class="s1">var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {</span><span class="s3">\n    </span><span class="s1">x1: 0,</span><span class="s3">\n    </span><span class="s1">y1: 0,</span><span class="s3">\n    </span><span class="s1">w: cy.width(),</span><span class="s3">\n    </span><span class="s1">h: cy.height()</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var layoutInfo = {</span><span class="s3">\n    </span><span class="s1">isCompound: cy.hasCompoundNodes(),</span><span class="s3">\n    </span><span class="s1">layoutNodes: [],</span><span class="s3">\n    </span><span class="s1">idToIndex: {},</span><span class="s3">\n    </span><span class="s1">nodeSize: nodes.size(),</span><span class="s3">\n    </span><span class="s1">graphSet: [],</span><span class="s3">\n    </span><span class="s1">indexToGraph: [],</span><span class="s3">\n    </span><span class="s1">layoutEdges: [],</span><span class="s3">\n    </span><span class="s1">edgeSize: edges.size(),</span><span class="s3">\n    </span><span class="s1">temperature: options.initialTemp,</span><span class="s3">\n    </span><span class="s1">clientWidth: bb.w,</span><span class="s3">\n    </span><span class="s1">clientHeight: bb.h,</span><span class="s3">\n    </span><span class="s1">boundingBox: bb</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var components = options.eles.components();</span><span class="s3">\n  </span><span class="s1">var id2cmptId = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; components.length; i++) {</span><span class="s3">\n    </span><span class="s1">var component = components[i];</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n      </span><span class="s1">var node = component[j];</span><span class="s3">\n      </span><span class="s1">id2cmptId[node.id()] = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Iterate over all nodes, creating layout nodes</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.nodeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var n = nodes[i];</span><span class="s3">\n    </span><span class="s1">var nbb = n.layoutDimensions(options);</span><span class="s3">\n    </span><span class="s1">var tempNode = {};</span><span class="s3">\n    </span><span class="s1">tempNode.isLocked = n.locked();</span><span class="s3">\n    </span><span class="s1">tempNode.id = n.data('id');</span><span class="s3">\n    </span><span class="s1">tempNode.parentId = n.data('parent');</span><span class="s3">\n    </span><span class="s1">tempNode.cmptId = id2cmptId[n.id()];</span><span class="s3">\n    </span><span class="s1">tempNode.children = [];</span><span class="s3">\n    </span><span class="s1">tempNode.positionX = n.position('x');</span><span class="s3">\n    </span><span class="s1">tempNode.positionY = n.position('y');</span><span class="s3">\n    </span><span class="s1">tempNode.offsetX = 0;</span><span class="s3">\n    </span><span class="s1">tempNode.offsetY = 0;</span><span class="s3">\n    </span><span class="s1">tempNode.height = nbb.w;</span><span class="s3">\n    </span><span class="s1">tempNode.width = nbb.h;</span><span class="s3">\n    </span><span class="s1">tempNode.maxX = tempNode.positionX + tempNode.width / 2;</span><span class="s3">\n    </span><span class="s1">tempNode.minX = tempNode.positionX - tempNode.width / 2;</span><span class="s3">\n    </span><span class="s1">tempNode.maxY = tempNode.positionY + tempNode.height / 2;</span><span class="s3">\n    </span><span class="s1">tempNode.minY = tempNode.positionY - tempNode.height / 2;</span><span class="s3">\n    </span><span class="s1">tempNode.padLeft = parseFloat(n.style('padding'));</span><span class="s3">\n    </span><span class="s1">tempNode.padRight = parseFloat(n.style('padding'));</span><span class="s3">\n    </span><span class="s1">tempNode.padTop = parseFloat(n.style('padding'));</span><span class="s3">\n    </span><span class="s1">tempNode.padBottom = parseFloat(n.style('padding'));</span><span class="s3">\n\n    </span><span class="s1">// forces</span><span class="s3">\n    </span><span class="s1">tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;</span><span class="s3">\n\n    </span><span class="s1">// Add new node</span><span class="s3">\n    </span><span class="s1">layoutInfo.layoutNodes.push(tempNode);</span><span class="s3">\n    </span><span class="s1">// Add entry to id-index map</span><span class="s3">\n    </span><span class="s1">layoutInfo.idToIndex[tempNode.id] = i;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Inline implementation of a queue, used for traversing the graph in BFS order</span><span class="s3">\n  </span><span class="s1">var queue = [];</span><span class="s3">\n  </span><span class="s1">var start = 0; // Points to the start the queue</span><span class="s3">\n  </span><span class="s1">var end = -1; // Points to the end of the queue</span><span class="s3">\n\n  </span><span class="s1">var tempGraph = [];</span><span class="s3">\n\n  </span><span class="s1">// Second pass to add child information and</span><span class="s3">\n  </span><span class="s1">// initialize queue for hierarchical traversal</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.nodeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var n = layoutInfo.layoutNodes[i];</span><span class="s3">\n    </span><span class="s1">var p_id = n.parentId;</span><span class="s3">\n    </span><span class="s1">// Check if node n has a parent node</span><span class="s3">\n    </span><span class="s1">if (null != p_id) {</span><span class="s3">\n      </span><span class="s1">// Add node Id to parent's list of children</span><span class="s3">\n      </span><span class="s1">layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// If a node doesn't have a parent, then it's in the root graph</span><span class="s3">\n      </span><span class="s1">queue[++end] = n.id;</span><span class="s3">\n      </span><span class="s1">tempGraph.push(n.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add root graph to graphSet</span><span class="s3">\n  </span><span class="s1">layoutInfo.graphSet.push(tempGraph);</span><span class="s3">\n\n  </span><span class="s1">// Traverse the graph, level by level,</span><span class="s3">\n  </span><span class="s1">while (start &lt;= end) {</span><span class="s3">\n    </span><span class="s1">// Get the node to visit and remove it from queue</span><span class="s3">\n    </span><span class="s1">var node_id = queue[start++];</span><span class="s3">\n    </span><span class="s1">var node_ix = layoutInfo.idToIndex[node_id];</span><span class="s3">\n    </span><span class="s1">var node = layoutInfo.layoutNodes[node_ix];</span><span class="s3">\n    </span><span class="s1">var children = node.children;</span><span class="s3">\n    </span><span class="s1">if (children.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">// Add children nodes as a new graph to graph set</span><span class="s3">\n      </span><span class="s1">layoutInfo.graphSet.push(children);</span><span class="s3">\n      </span><span class="s1">// Add children to que queue to be visited</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n        </span><span class="s1">queue[++end] = children[i];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create indexToGraph map</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.graphSet.length; i++) {</span><span class="s3">\n    </span><span class="s1">var graph = layoutInfo.graphSet[i];</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; graph.length; j++) {</span><span class="s3">\n      </span><span class="s1">var index = layoutInfo.idToIndex[graph[j]];</span><span class="s3">\n      </span><span class="s1">layoutInfo.indexToGraph[index] = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Iterate over all edges, creating Layout Edges</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.edgeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var e = edges[i];</span><span class="s3">\n    </span><span class="s1">var tempEdge = {};</span><span class="s3">\n    </span><span class="s1">tempEdge.id = e.data('id');</span><span class="s3">\n    </span><span class="s1">tempEdge.sourceId = e.data('source');</span><span class="s3">\n    </span><span class="s1">tempEdge.targetId = e.data('target');</span><span class="s3">\n\n    </span><span class="s1">// Compute ideal length</span><span class="s3">\n    </span><span class="s1">var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;</span><span class="s3">\n    </span><span class="s1">var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;</span><span class="s3">\n\n    </span><span class="s1">// Check if it's an inter graph edge</span><span class="s3">\n    </span><span class="s1">var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];</span><span class="s3">\n    </span><span class="s1">var targetIx = layoutInfo.idToIndex[tempEdge.targetId];</span><span class="s3">\n    </span><span class="s1">var sourceGraph = layoutInfo.indexToGraph[sourceIx];</span><span class="s3">\n    </span><span class="s1">var targetGraph = layoutInfo.indexToGraph[targetIx];</span><span class="s3">\n    </span><span class="s1">if (sourceGraph != targetGraph) {</span><span class="s3">\n      </span><span class="s1">// Find lowest common graph ancestor</span><span class="s3">\n      </span><span class="s1">var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);</span><span class="s3">\n\n      </span><span class="s1">// Compute sum of node depths, relative to lca graph</span><span class="s3">\n      </span><span class="s1">var lcaGraph = layoutInfo.graphSet[lca];</span><span class="s3">\n      </span><span class="s1">var depth = 0;</span><span class="s3">\n\n      </span><span class="s1">// Source depth</span><span class="s3">\n      </span><span class="s1">var tempNode = layoutInfo.layoutNodes[sourceIx];</span><span class="s3">\n      </span><span class="s1">while (-1 === lcaGraph.indexOf(tempNode.id)) {</span><span class="s3">\n        </span><span class="s1">tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];</span><span class="s3">\n        </span><span class="s1">depth++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Target depth</span><span class="s3">\n      </span><span class="s1">tempNode = layoutInfo.layoutNodes[targetIx];</span><span class="s3">\n      </span><span class="s1">while (-1 === lcaGraph.indexOf(tempNode.id)) {</span><span class="s3">\n        </span><span class="s1">tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];</span><span class="s3">\n        </span><span class="s1">depth++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +</span><span class="s3">\n      </span><span class="s1">//  </span><span class="s3">\&quot;</span><span class="s1">. Index: </span><span class="s3">\&quot; </span><span class="s1">+ lca + </span><span class="s3">\&quot; </span><span class="s1">Contents: </span><span class="s3">\&quot; </span><span class="s1">+ lcaGraph.toString() +</span><span class="s3">\n      </span><span class="s1">//  </span><span class="s3">\&quot;</span><span class="s1">. Depth: </span><span class="s3">\&quot; </span><span class="s1">+ depth);</span><span class="s3">\n\n      </span><span class="s1">// Update idealLength</span><span class="s3">\n      </span><span class="s1">idealLength *= depth * options.nestingFactor;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tempEdge.idealLength = idealLength;</span><span class="s3">\n    </span><span class="s1">tempEdge.elasticity = elasticity;</span><span class="s3">\n    </span><span class="s1">layoutInfo.layoutEdges.push(tempEdge);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Finally, return layoutInfo object</span><span class="s3">\n  </span><span class="s1">return layoutInfo;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : This function finds the index of the lowest common</span><span class="s3">\n </span><span class="s1">*          graph ancestor between 2 nodes in the subtree</span><span class="s3">\n </span><span class="s1">*          (from the graph hierarchy induced tree) whose</span><span class="s3">\n </span><span class="s1">*          root is graphIx</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @arg node1: node1's ID</span><span class="s3">\n </span><span class="s1">* @arg node2: node2's ID</span><span class="s3">\n </span><span class="s1">* @arg layoutInfo: layoutInfo object</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var findLCA = function findLCA(node1, node2, layoutInfo) {</span><span class="s3">\n  </span><span class="s1">// Find their common ancester, starting from the root graph</span><span class="s3">\n  </span><span class="s1">var res = _findLCA_aux(node1, node2, 0, layoutInfo);</span><span class="s3">\n  </span><span class="s1">if (2 &gt; res.count) {</span><span class="s3">\n    </span><span class="s1">// If aux function couldn't find the common ancester,</span><span class="s3">\n    </span><span class="s1">// then it is the root graph</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return res.graph;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief          : Auxiliary function used for LCA computation</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @arg node1      : node1's ID</span><span class="s3">\n </span><span class="s1">* @arg node2      : node2's ID</span><span class="s3">\n </span><span class="s1">* @arg graphIx    : subgraph index</span><span class="s3">\n </span><span class="s1">* @arg layoutInfo : layoutInfo object</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return         : object of the form {count: X, graph: Y}, where:</span><span class="s3">\n </span><span class="s1">*                   X is the number of ancestors (max: 2) found in</span><span class="s3">\n </span><span class="s1">*                   graphIx (and it's subgraphs),</span><span class="s3">\n </span><span class="s1">*                   Y is the graph index of the lowest graph containing</span><span class="s3">\n </span><span class="s1">*                   all X nodes</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var _findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {</span><span class="s3">\n  </span><span class="s1">var graph = layoutInfo.graphSet[graphIx];</span><span class="s3">\n  </span><span class="s1">// If both nodes belongs to graphIx</span><span class="s3">\n  </span><span class="s1">if (-1 &lt; graph.indexOf(node1) &amp;&amp; -1 &lt; graph.indexOf(node2)) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">count: 2,</span><span class="s3">\n      </span><span class="s1">graph: graphIx</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Make recursive calls for all subgraphs</span><span class="s3">\n  </span><span class="s1">var c = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; graph.length; i++) {</span><span class="s3">\n    </span><span class="s1">var nodeId = graph[i];</span><span class="s3">\n    </span><span class="s1">var nodeIx = layoutInfo.idToIndex[nodeId];</span><span class="s3">\n    </span><span class="s1">var children = layoutInfo.layoutNodes[nodeIx].children;</span><span class="s3">\n\n    </span><span class="s1">// If the node has no child, skip it</span><span class="s3">\n    </span><span class="s1">if (0 === children.length) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];</span><span class="s3">\n    </span><span class="s1">var result = _findLCA_aux(node1, node2, childGraphIx, layoutInfo);</span><span class="s3">\n    </span><span class="s1">if (0 === result.count) {</span><span class="s3">\n      </span><span class="s1">// Neither node1 nor node2 are present in this subgraph</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">} else if (1 === result.count) {</span><span class="s3">\n      </span><span class="s1">// One of (node1, node2) is present in this subgraph</span><span class="s3">\n      </span><span class="s1">c++;</span><span class="s3">\n      </span><span class="s1">if (2 === c) {</span><span class="s3">\n        </span><span class="s1">// We've already found both nodes, no need to keep searching</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Both nodes are present in this subgraph</span><span class="s3">\n      </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">count: c,</span><span class="s3">\n    </span><span class="s1">graph: graphIx</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief: printsLayoutInfo into js console</span><span class="s3">\n </span><span class="s1">*         Only used for debbuging</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var printLayoutInfo; </span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Randomizes the position of all nodes</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var randomizePositions = function randomizePositions(layoutInfo, cy) {</span><span class="s3">\n  </span><span class="s1">var width = layoutInfo.clientWidth;</span><span class="s3">\n  </span><span class="s1">var height = layoutInfo.clientHeight;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.nodeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var n = layoutInfo.layoutNodes[i];</span><span class="s3">\n\n    </span><span class="s1">// No need to randomize compound nodes or locked nodes</span><span class="s3">\n    </span><span class="s1">if (0 === n.children.length &amp;&amp; !n.isLocked) {</span><span class="s3">\n      </span><span class="s1">n.positionX = Math.random() * width;</span><span class="s3">\n      </span><span class="s1">n.positionY = Math.random() * height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {</span><span class="s3">\n  </span><span class="s1">var bb = layoutInfo.boundingBox;</span><span class="s3">\n  </span><span class="s1">var coseBB = {</span><span class="s3">\n    </span><span class="s1">x1: Infinity,</span><span class="s3">\n    </span><span class="s1">x2: -Infinity,</span><span class="s3">\n    </span><span class="s1">y1: Infinity,</span><span class="s3">\n    </span><span class="s1">y2: -Infinity</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (options.boundingBox) {</span><span class="s3">\n    </span><span class="s1">nodes.forEach(function (node) {</span><span class="s3">\n      </span><span class="s1">var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];</span><span class="s3">\n      </span><span class="s1">coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);</span><span class="s3">\n      </span><span class="s1">coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);</span><span class="s3">\n      </span><span class="s1">coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);</span><span class="s3">\n      </span><span class="s1">coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">coseBB.w = coseBB.x2 - coseBB.x1;</span><span class="s3">\n    </span><span class="s1">coseBB.h = coseBB.y2 - coseBB.y1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function (ele, i) {</span><span class="s3">\n    </span><span class="s1">var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];</span><span class="s3">\n    </span><span class="s1">if (options.boundingBox) {</span><span class="s3">\n      </span><span class="s1">// then add extra bounding box constraint</span><span class="s3">\n      </span><span class="s1">var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;</span><span class="s3">\n      </span><span class="s1">var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: bb.x1 + pctX * bb.w,</span><span class="s3">\n        </span><span class="s1">y: bb.y1 + pctY * bb.h</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: lnode.positionX,</span><span class="s3">\n        </span><span class="s1">y: lnode.positionY</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief          : Updates the positions of nodes in the network</span><span class="s3">\n </span><span class="s1">* @arg layoutInfo : LayoutInfo object</span><span class="s3">\n </span><span class="s1">* @arg cy         : Cytoscape object</span><span class="s3">\n </span><span class="s1">* @arg options    : Layout options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var refreshPositions = function refreshPositions(layoutInfo, cy, options) {</span><span class="s3">\n  </span><span class="s1">// var s = 'Refreshing positions';</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n  </span><span class="s1">var layout = options.layout;</span><span class="s3">\n  </span><span class="s1">var nodes = options.eles.nodes();</span><span class="s3">\n  </span><span class="s1">var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);</span><span class="s3">\n  </span><span class="s1">nodes.positions(getScaledPos);</span><span class="s3">\n\n  </span><span class="s1">// Trigger layoutReady only on first call</span><span class="s3">\n  </span><span class="s1">if (true !== layoutInfo.ready) {</span><span class="s3">\n    </span><span class="s1">// s = 'Triggering layoutready';</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n    </span><span class="s1">layoutInfo.ready = true;</span><span class="s3">\n    </span><span class="s1">layout.one('layoutready', options.ready);</span><span class="s3">\n    </span><span class="s1">layout.emit({</span><span class="s3">\n      </span><span class="s1">type: 'layoutready',</span><span class="s3">\n      </span><span class="s1">layout: this</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Logs a debug message in JS console, if DEBUG is ON</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// var logDebug = function(text) {</span><span class="s3">\n</span><span class="s1">//   if (DEBUG) {</span><span class="s3">\n</span><span class="s1">//     console.debug(text);</span><span class="s3">\n</span><span class="s1">//   }</span><span class="s3">\n</span><span class="s1">// };</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief          : Performs one iteration of the physical simulation</span><span class="s3">\n </span><span class="s1">* @arg layoutInfo : LayoutInfo object already initialized</span><span class="s3">\n </span><span class="s1">* @arg cy         : Cytoscape object</span><span class="s3">\n </span><span class="s1">* @arg options    : Layout options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var step = function step(layoutInfo, options, _step) {</span><span class="s3">\n  </span><span class="s1">// var s = </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n###############################</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nSTEP: </span><span class="s3">\&quot; </span><span class="s1">+ step;</span><span class="s3">\n  </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">n###############################</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n  </span><span class="s1">// Calculate node repulsions</span><span class="s3">\n  </span><span class="s1">calculateNodeForces(layoutInfo, options);</span><span class="s3">\n  </span><span class="s1">// Calculate edge forces</span><span class="s3">\n  </span><span class="s1">calculateEdgeForces(layoutInfo);</span><span class="s3">\n  </span><span class="s1">// Calculate gravity forces</span><span class="s3">\n  </span><span class="s1">calculateGravityForces(layoutInfo, options);</span><span class="s3">\n  </span><span class="s1">// Propagate forces from parent to child</span><span class="s3">\n  </span><span class="s1">propagateForces(layoutInfo);</span><span class="s3">\n  </span><span class="s1">// Update positions based on calculated forces</span><span class="s3">\n  </span><span class="s1">updatePositions(layoutInfo);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Computes the node repulsion forces</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">// Go through each of the graphs in graphSet</span><span class="s3">\n  </span><span class="s1">// Nodes only repel each other if they belong to the same graph</span><span class="s3">\n  </span><span class="s1">// var s = 'calculateNodeForces';</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.graphSet.length; i++) {</span><span class="s3">\n    </span><span class="s1">var graph = layoutInfo.graphSet[i];</span><span class="s3">\n    </span><span class="s1">var numNodes = graph.length;</span><span class="s3">\n\n    </span><span class="s1">// s = </span><span class="s3">\&quot;</span><span class="s1">Set: </span><span class="s3">\&quot; </span><span class="s1">+ graph.toString();</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n    </span><span class="s1">// Now get all the pairs of nodes</span><span class="s3">\n    </span><span class="s1">// Only get each pair once, (A, B) = (B, A)</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; numNodes; j++) {</span><span class="s3">\n      </span><span class="s1">var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];</span><span class="s3">\n      </span><span class="s1">for (var k = j + 1; k &lt; numNodes; k++) {</span><span class="s3">\n        </span><span class="s1">var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];</span><span class="s3">\n        </span><span class="s1">nodeRepulsion(node1, node2, layoutInfo, options);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var randomDistance = function randomDistance(max) {</span><span class="s3">\n  </span><span class="s1">return -1 + 2 * max * Math.random();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Compute the node repulsion forces between a pair of nodes</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">// var s = </span><span class="s3">\&quot;</span><span class="s1">Node repulsion. Node1: </span><span class="s3">\&quot; </span><span class="s1">+ node1.id + </span><span class="s3">\&quot; </span><span class="s1">Node2: </span><span class="s3">\&quot; </span><span class="s1">+ node2.id;</span><span class="s3">\n\n  </span><span class="s1">var cmptId1 = node1.cmptId;</span><span class="s3">\n  </span><span class="s1">var cmptId2 = node2.cmptId;</span><span class="s3">\n  </span><span class="s1">if (cmptId1 !== cmptId2 &amp;&amp; !layoutInfo.isCompound) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Get direction of line connecting both node centers</span><span class="s3">\n  </span><span class="s1">var directionX = node2.positionX - node1.positionX;</span><span class="s3">\n  </span><span class="s1">var directionY = node2.positionY - node1.positionY;</span><span class="s3">\n  </span><span class="s1">var maxRandDist = 1;</span><span class="s3">\n  </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">ndirectionX: </span><span class="s3">\&quot; </span><span class="s1">+ directionX + </span><span class="s3">\&quot;</span><span class="s1">, directionY: </span><span class="s3">\&quot; </span><span class="s1">+ directionY;</span><span class="s3">\n\n  </span><span class="s1">// If both centers are the same, apply a random force</span><span class="s3">\n  </span><span class="s1">if (0 === directionX &amp;&amp; 0 === directionY) {</span><span class="s3">\n    </span><span class="s1">directionX = randomDistance(maxRandDist);</span><span class="s3">\n    </span><span class="s1">directionY = randomDistance(maxRandDist);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var overlap = nodesOverlap(node1, node2, directionX, directionY);</span><span class="s3">\n  </span><span class="s1">if (overlap &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nNodes DO overlap.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nOverlap: </span><span class="s3">\&quot; </span><span class="s1">+ overlap;</span><span class="s3">\n    </span><span class="s1">// If nodes overlap, repulsion force is proportional</span><span class="s3">\n    </span><span class="s1">// to the overlap</span><span class="s3">\n    </span><span class="s1">var force = options.nodeOverlap * overlap;</span><span class="s3">\n\n    </span><span class="s1">// Compute the module and components of the force vector</span><span class="s3">\n    </span><span class="s1">var distance = Math.sqrt(directionX * directionX + directionY * directionY);</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nDistance: </span><span class="s3">\&quot; </span><span class="s1">+ distance;</span><span class="s3">\n    </span><span class="s1">var forceX = force * directionX / distance;</span><span class="s3">\n    </span><span class="s1">var forceY = force * directionY / distance;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nNodes do NOT overlap.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// If there's no overlap, force is inversely proportional</span><span class="s3">\n    </span><span class="s1">// to squared distance</span><span class="s3">\n\n    </span><span class="s1">// Get clipping points for both nodes</span><span class="s3">\n    </span><span class="s1">var point1 = findClippingPoint(node1, directionX, directionY);</span><span class="s3">\n    </span><span class="s1">var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);</span><span class="s3">\n\n    </span><span class="s1">// Use clipping points to compute distance</span><span class="s3">\n    </span><span class="s1">var distanceX = point2.x - point1.x;</span><span class="s3">\n    </span><span class="s1">var distanceY = point2.y - point1.y;</span><span class="s3">\n    </span><span class="s1">var distanceSqr = distanceX * distanceX + distanceY * distanceY;</span><span class="s3">\n    </span><span class="s1">var distance = Math.sqrt(distanceSqr);</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nDistance: </span><span class="s3">\&quot; </span><span class="s1">+ distance;</span><span class="s3">\n\n    </span><span class="s1">// Compute the module and components of the force vector</span><span class="s3">\n    </span><span class="s1">var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;</span><span class="s3">\n    </span><span class="s1">var forceX = force * distanceX / distance;</span><span class="s3">\n    </span><span class="s1">var forceY = force * distanceY / distance;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Apply force</span><span class="s3">\n  </span><span class="s1">if (!node1.isLocked) {</span><span class="s3">\n    </span><span class="s1">node1.offsetX -= forceX;</span><span class="s3">\n    </span><span class="s1">node1.offsetY -= forceY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!node2.isLocked) {</span><span class="s3">\n    </span><span class="s1">node2.offsetX += forceX;</span><span class="s3">\n    </span><span class="s1">node2.offsetY += forceY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nForceX: </span><span class="s3">\&quot; </span><span class="s1">+ forceX + </span><span class="s3">\&quot; </span><span class="s1">ForceY: </span><span class="s3">\&quot; </span><span class="s1">+ forceY;</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n  </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief  : Determines whether two nodes overlap or not</span><span class="s3">\n </span><span class="s1">* @return : Amount of overlapping (0 =&gt; no overlap)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {</span><span class="s3">\n  </span><span class="s1">if (dX &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var overlapX = node1.maxX - node2.minX;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var overlapX = node2.maxX - node1.minX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (dY &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var overlapY = node1.maxY - node2.minY;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var overlapY = node2.maxY - node1.minY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (overlapX &gt;= 0 &amp;&amp; overlapY &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">return Math.sqrt(overlapX * overlapX + overlapY * overlapY);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Finds the point in which an edge (direction dX, dY) intersects</span><span class="s3">\n </span><span class="s1">*          the rectangular bounding box of it's source/target node</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var findClippingPoint = function findClippingPoint(node, dX, dY) {</span><span class="s3">\n  </span><span class="s1">// Shorcuts</span><span class="s3">\n  </span><span class="s1">var X = node.positionX;</span><span class="s3">\n  </span><span class="s1">var Y = node.positionY;</span><span class="s3">\n  </span><span class="s1">var H = node.height || 1;</span><span class="s3">\n  </span><span class="s1">var W = node.width || 1;</span><span class="s3">\n  </span><span class="s1">var dirSlope = dY / dX;</span><span class="s3">\n  </span><span class="s1">var nodeSlope = H / W;</span><span class="s3">\n\n  </span><span class="s1">// var s = 'Computing clipping point of node ' + node.id +</span><span class="s3">\n  </span><span class="s1">//   </span><span class="s3">\&quot; </span><span class="s1">. Height:  </span><span class="s3">\&quot; </span><span class="s1">+ H + </span><span class="s3">\&quot;</span><span class="s1">, Width: </span><span class="s3">\&quot; </span><span class="s1">+ W +</span><span class="s3">\n  </span><span class="s1">//   </span><span class="s3">\&quot;\\</span><span class="s1">nDirection </span><span class="s3">\&quot; </span><span class="s1">+ dX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ dY;</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Compute intersection</span><span class="s3">\n  </span><span class="s1">var res = {};</span><span class="s3">\n\n  </span><span class="s1">// Case: Vertical direction (up)</span><span class="s3">\n  </span><span class="s1">if (0 === dX &amp;&amp; 0 &lt; dY) {</span><span class="s3">\n    </span><span class="s1">res.x = X;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nUp direction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">res.y = Y + H / 2;</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: Vertical direction (down)</span><span class="s3">\n  </span><span class="s1">if (0 === dX &amp;&amp; 0 &gt; dY) {</span><span class="s3">\n    </span><span class="s1">res.x = X;</span><span class="s3">\n    </span><span class="s1">res.y = Y + H / 2;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nDown direction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: Intersects the right border</span><span class="s3">\n  </span><span class="s1">if (0 &lt; dX &amp;&amp; -1 * nodeSlope &lt;= dirSlope &amp;&amp; dirSlope &lt;= nodeSlope) {</span><span class="s3">\n    </span><span class="s1">res.x = X + W / 2;</span><span class="s3">\n    </span><span class="s1">res.y = Y + W * dY / 2 / dX;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nRightborder</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: Intersects the left border</span><span class="s3">\n  </span><span class="s1">if (0 &gt; dX &amp;&amp; -1 * nodeSlope &lt;= dirSlope &amp;&amp; dirSlope &lt;= nodeSlope) {</span><span class="s3">\n    </span><span class="s1">res.x = X - W / 2;</span><span class="s3">\n    </span><span class="s1">res.y = Y - W * dY / 2 / dX;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nLeftborder</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: Intersects the top border</span><span class="s3">\n  </span><span class="s1">if (0 &lt; dY &amp;&amp; (dirSlope &lt;= -1 * nodeSlope || dirSlope &gt;= nodeSlope)) {</span><span class="s3">\n    </span><span class="s1">res.x = X + H * dX / 2 / dY;</span><span class="s3">\n    </span><span class="s1">res.y = Y + H / 2;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nTop border</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: Intersects the bottom border</span><span class="s3">\n  </span><span class="s1">if (0 &gt; dY &amp;&amp; (dirSlope &lt;= -1 * nodeSlope || dirSlope &gt;= nodeSlope)) {</span><span class="s3">\n    </span><span class="s1">res.x = X - H * dX / 2 / dY;</span><span class="s3">\n    </span><span class="s1">res.y = Y - H / 2;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nBottom border</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nClipping point found at </span><span class="s3">\&quot; </span><span class="s1">+ res.x + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ res.y;</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n  </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Calculates all edge forces</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">// Iterate over all edges</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.edgeSize; i++) {</span><span class="s3">\n    </span><span class="s1">// Get edge, source &amp; target nodes</span><span class="s3">\n    </span><span class="s1">var edge = layoutInfo.layoutEdges[i];</span><span class="s3">\n    </span><span class="s1">var sourceIx = layoutInfo.idToIndex[edge.sourceId];</span><span class="s3">\n    </span><span class="s1">var source = layoutInfo.layoutNodes[sourceIx];</span><span class="s3">\n    </span><span class="s1">var targetIx = layoutInfo.idToIndex[edge.targetId];</span><span class="s3">\n    </span><span class="s1">var target = layoutInfo.layoutNodes[targetIx];</span><span class="s3">\n\n    </span><span class="s1">// Get direction of line connecting both node centers</span><span class="s3">\n    </span><span class="s1">var directionX = target.positionX - source.positionX;</span><span class="s3">\n    </span><span class="s1">var directionY = target.positionY - source.positionY;</span><span class="s3">\n\n    </span><span class="s1">// If both centers are the same, do nothing.</span><span class="s3">\n    </span><span class="s1">// A random force has already been applied as node repulsion</span><span class="s3">\n    </span><span class="s1">if (0 === directionX &amp;&amp; 0 === directionY) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Get clipping points for both nodes</span><span class="s3">\n    </span><span class="s1">var point1 = findClippingPoint(source, directionX, directionY);</span><span class="s3">\n    </span><span class="s1">var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);</span><span class="s3">\n    </span><span class="s1">var lx = point2.x - point1.x;</span><span class="s3">\n    </span><span class="s1">var ly = point2.y - point1.y;</span><span class="s3">\n    </span><span class="s1">var l = Math.sqrt(lx * lx + ly * ly);</span><span class="s3">\n    </span><span class="s1">var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;</span><span class="s3">\n    </span><span class="s1">if (0 !== l) {</span><span class="s3">\n      </span><span class="s1">var forceX = force * lx / l;</span><span class="s3">\n      </span><span class="s1">var forceY = force * ly / l;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var forceX = 0;</span><span class="s3">\n      </span><span class="s1">var forceY = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Add this force to target and source nodes</span><span class="s3">\n    </span><span class="s1">if (!source.isLocked) {</span><span class="s3">\n      </span><span class="s1">source.offsetX += forceX;</span><span class="s3">\n      </span><span class="s1">source.offsetY += forceY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!target.isLocked) {</span><span class="s3">\n      </span><span class="s1">target.offsetX -= forceX;</span><span class="s3">\n      </span><span class="s1">target.offsetY -= forceY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nDistance: </span><span class="s3">\&quot; </span><span class="s1">+ l + </span><span class="s3">\&quot; </span><span class="s1">Force: (</span><span class="s3">\&quot; </span><span class="s1">+ forceX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ forceY + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Computes gravity forces for all nodes</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">if (options.gravity === 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var distThreshold = 1;</span><span class="s3">\n\n  </span><span class="s1">// var s = 'calculateGravityForces';</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.graphSet.length; i++) {</span><span class="s3">\n    </span><span class="s1">var graph = layoutInfo.graphSet[i];</span><span class="s3">\n    </span><span class="s1">var numNodes = graph.length;</span><span class="s3">\n\n    </span><span class="s1">// s = </span><span class="s3">\&quot;</span><span class="s1">Set: </span><span class="s3">\&quot; </span><span class="s1">+ graph.toString();</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n    </span><span class="s1">// Compute graph center</span><span class="s3">\n    </span><span class="s1">if (0 === i) {</span><span class="s3">\n      </span><span class="s1">var centerX = layoutInfo.clientHeight / 2;</span><span class="s3">\n      </span><span class="s1">var centerY = layoutInfo.clientWidth / 2;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Get Parent node for this graph, and use its position as center</span><span class="s3">\n      </span><span class="s1">var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];</span><span class="s3">\n      </span><span class="s1">var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];</span><span class="s3">\n      </span><span class="s1">var centerX = parent.positionX;</span><span class="s3">\n      </span><span class="s1">var centerY = parent.positionY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// s = </span><span class="s3">\&quot;</span><span class="s1">Center found at: </span><span class="s3">\&quot; </span><span class="s1">+ centerX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ centerY;</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n    </span><span class="s1">// Apply force to all nodes in graph</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; numNodes; j++) {</span><span class="s3">\n      </span><span class="s1">var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];</span><span class="s3">\n      </span><span class="s1">// s = </span><span class="s3">\&quot;</span><span class="s1">Node: </span><span class="s3">\&quot; </span><span class="s1">+ node.id;</span><span class="s3">\n\n      </span><span class="s1">if (node.isLocked) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var dx = centerX - node.positionX;</span><span class="s3">\n      </span><span class="s1">var dy = centerY - node.positionY;</span><span class="s3">\n      </span><span class="s1">var d = Math.sqrt(dx * dx + dy * dy);</span><span class="s3">\n      </span><span class="s1">if (d &gt; distThreshold) {</span><span class="s3">\n        </span><span class="s1">var fx = options.gravity * dx / d;</span><span class="s3">\n        </span><span class="s1">var fy = options.gravity * dy / d;</span><span class="s3">\n        </span><span class="s1">node.offsetX += fx;</span><span class="s3">\n        </span><span class="s1">node.offsetY += fy;</span><span class="s3">\n        </span><span class="s1">// s += </span><span class="s3">\&quot;</span><span class="s1">: Applied force: </span><span class="s3">\&quot; </span><span class="s1">+ fx + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ fy;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// logDebug(s);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief          : This function propagates the existing offsets from</span><span class="s3">\n </span><span class="s1">*                   parent nodes to its descendents.</span><span class="s3">\n </span><span class="s1">* @arg layoutInfo : layoutInfo Object</span><span class="s3">\n </span><span class="s1">* @arg cy         : cytoscape Object</span><span class="s3">\n </span><span class="s1">* @arg options    : Layout options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var propagateForces = function propagateForces(layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">// Inline implementation of a queue, used for traversing the graph in BFS order</span><span class="s3">\n  </span><span class="s1">var queue = [];</span><span class="s3">\n  </span><span class="s1">var start = 0; // Points to the start the queue</span><span class="s3">\n  </span><span class="s1">var end = -1; // Points to the end of the queue</span><span class="s3">\n\n  </span><span class="s1">// logDebug('propagateForces');</span><span class="s3">\n\n  </span><span class="s1">// Start by visiting the nodes in the root graph</span><span class="s3">\n  </span><span class="s1">queue.push.apply(queue, layoutInfo.graphSet[0]);</span><span class="s3">\n  </span><span class="s1">end += layoutInfo.graphSet[0].length;</span><span class="s3">\n\n  </span><span class="s1">// Traverse the graph, level by level,</span><span class="s3">\n  </span><span class="s1">while (start &lt;= end) {</span><span class="s3">\n    </span><span class="s1">// Get the node to visit and remove it from queue</span><span class="s3">\n    </span><span class="s1">var nodeId = queue[start++];</span><span class="s3">\n    </span><span class="s1">var nodeIndex = layoutInfo.idToIndex[nodeId];</span><span class="s3">\n    </span><span class="s1">var node = layoutInfo.layoutNodes[nodeIndex];</span><span class="s3">\n    </span><span class="s1">var children = node.children;</span><span class="s3">\n\n    </span><span class="s1">// We only need to process the node if it's compound</span><span class="s3">\n    </span><span class="s1">if (0 &lt; children.length &amp;&amp; !node.isLocked) {</span><span class="s3">\n      </span><span class="s1">var offX = node.offsetX;</span><span class="s3">\n      </span><span class="s1">var offY = node.offsetY;</span><span class="s3">\n\n      </span><span class="s1">// var s = </span><span class="s3">\&quot;</span><span class="s1">Propagating offset from parent node : </span><span class="s3">\&quot; </span><span class="s1">+ node.id +</span><span class="s3">\n      </span><span class="s1">//   </span><span class="s3">\&quot;</span><span class="s1">. OffsetX: </span><span class="s3">\&quot; </span><span class="s1">+ offX + </span><span class="s3">\&quot;</span><span class="s1">. OffsetY: </span><span class="s3">\&quot; </span><span class="s1">+ offY;</span><span class="s3">\n      </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">n Children: </span><span class="s3">\&quot; </span><span class="s1">+ children.toString();</span><span class="s3">\n      </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n        </span><span class="s1">var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];</span><span class="s3">\n        </span><span class="s1">// Propagate offset</span><span class="s3">\n        </span><span class="s1">childNode.offsetX += offX;</span><span class="s3">\n        </span><span class="s1">childNode.offsetY += offY;</span><span class="s3">\n        </span><span class="s1">// Add children to queue to be visited</span><span class="s3">\n        </span><span class="s1">queue[++end] = children[i];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Reset parent offsets</span><span class="s3">\n      </span><span class="s1">node.offsetX = 0;</span><span class="s3">\n      </span><span class="s1">node.offsetY = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Updates the layout model positions, based on</span><span class="s3">\n </span><span class="s1">*          the accumulated forces</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var updatePositions = function updatePositions(layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">// var s = 'Updating positions';</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n  </span><span class="s1">// Reset boundaries for compound nodes</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.nodeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var n = layoutInfo.layoutNodes[i];</span><span class="s3">\n    </span><span class="s1">if (0 &lt; n.children.length) {</span><span class="s3">\n      </span><span class="s1">// logDebug(</span><span class="s3">\&quot;</span><span class="s1">Resetting boundaries of compound node: </span><span class="s3">\&quot; </span><span class="s1">+ n.id);</span><span class="s3">\n      </span><span class="s1">n.maxX = undefined;</span><span class="s3">\n      </span><span class="s1">n.minX = undefined;</span><span class="s3">\n      </span><span class="s1">n.maxY = undefined;</span><span class="s3">\n      </span><span class="s1">n.minY = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.nodeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var n = layoutInfo.layoutNodes[i];</span><span class="s3">\n    </span><span class="s1">if (0 &lt; n.children.length || n.isLocked) {</span><span class="s3">\n      </span><span class="s1">// No need to set compound or locked node position</span><span class="s3">\n      </span><span class="s1">// logDebug(</span><span class="s3">\&quot;</span><span class="s1">Skipping position update of node: </span><span class="s3">\&quot; </span><span class="s1">+ n.id);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// s = </span><span class="s3">\&quot;</span><span class="s1">Node: </span><span class="s3">\&quot; </span><span class="s1">+ n.id + </span><span class="s3">\&quot; </span><span class="s1">Previous position: (</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    </span><span class="s1">// n.positionX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ n.positionY + </span><span class="s3">\&quot;</span><span class="s1">).</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// Limit displacement in order to improve stability</span><span class="s3">\n    </span><span class="s1">var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);</span><span class="s3">\n    </span><span class="s1">n.positionX += tempForce.x;</span><span class="s3">\n    </span><span class="s1">n.positionY += tempForce.y;</span><span class="s3">\n    </span><span class="s1">n.offsetX = 0;</span><span class="s3">\n    </span><span class="s1">n.offsetY = 0;</span><span class="s3">\n    </span><span class="s1">n.minX = n.positionX - n.width;</span><span class="s3">\n    </span><span class="s1">n.maxX = n.positionX + n.width;</span><span class="s3">\n    </span><span class="s1">n.minY = n.positionY - n.height;</span><span class="s3">\n    </span><span class="s1">n.maxY = n.positionY + n.height;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot; </span><span class="s1">New Position: (</span><span class="s3">\&quot; </span><span class="s1">+ n.positionX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ n.positionY + </span><span class="s3">\&quot;</span><span class="s1">).</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n    </span><span class="s1">// Update ancestry boudaries</span><span class="s3">\n    </span><span class="s1">_updateAncestryBoundaries(n, layoutInfo);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Update size, position of compund nodes</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layoutInfo.nodeSize; i++) {</span><span class="s3">\n    </span><span class="s1">var n = layoutInfo.layoutNodes[i];</span><span class="s3">\n    </span><span class="s1">if (0 &lt; n.children.length &amp;&amp; !n.isLocked) {</span><span class="s3">\n      </span><span class="s1">n.positionX = (n.maxX + n.minX) / 2;</span><span class="s3">\n      </span><span class="s1">n.positionY = (n.maxY + n.minY) / 2;</span><span class="s3">\n      </span><span class="s1">n.width = n.maxX - n.minX;</span><span class="s3">\n      </span><span class="s1">n.height = n.maxY - n.minY;</span><span class="s3">\n      </span><span class="s1">// s = </span><span class="s3">\&quot;</span><span class="s1">Updating position, size of compound node </span><span class="s3">\&quot; </span><span class="s1">+ n.id;</span><span class="s3">\n      </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nPositionX: </span><span class="s3">\&quot; </span><span class="s1">+ n.positionX + </span><span class="s3">\&quot;</span><span class="s1">, PositionY: </span><span class="s3">\&quot; </span><span class="s1">+ n.positionY;</span><span class="s3">\n      </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nWidth: </span><span class="s3">\&quot; </span><span class="s1">+ n.width + </span><span class="s3">\&quot;</span><span class="s1">, Height: </span><span class="s3">\&quot; </span><span class="s1">+ n.height;</span><span class="s3">\n      </span><span class="s1">// logDebug(s);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Limits a force (forceX, forceY) to be not</span><span class="s3">\n </span><span class="s1">*          greater (in modulo) than max.</span><span class="s3">\n </span><span class="s1">8          Preserves force direction.</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var limitForce = function limitForce(forceX, forceY, max) {</span><span class="s3">\n  </span><span class="s1">// var s = </span><span class="s3">\&quot;</span><span class="s1">Limiting force: (</span><span class="s3">\&quot; </span><span class="s1">+ forceX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ forceY + </span><span class="s3">\&quot;</span><span class="s1">). Max: </span><span class="s3">\&quot; </span><span class="s1">+ max;</span><span class="s3">\n  </span><span class="s1">var force = Math.sqrt(forceX * forceX + forceY * forceY);</span><span class="s3">\n  </span><span class="s1">if (force &gt; max) {</span><span class="s3">\n    </span><span class="s1">var res = {</span><span class="s3">\n      </span><span class="s1">x: max * forceX / force,</span><span class="s3">\n      </span><span class="s1">y: max * forceY / force</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var res = {</span><span class="s3">\n      </span><span class="s1">x: forceX,</span><span class="s3">\n      </span><span class="s1">y: forceY</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// s += </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">nResult: (</span><span class="s3">\&quot; </span><span class="s1">+ res.x + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ res.y + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n\n  </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : Function used for keeping track of compound node</span><span class="s3">\n </span><span class="s1">*          sizes, since they should bound all their subnodes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var _updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {</span><span class="s3">\n  </span><span class="s1">// var s = </span><span class="s3">\&quot;</span><span class="s1">Propagating new position/size of node </span><span class="s3">\&quot; </span><span class="s1">+ node.id;</span><span class="s3">\n  </span><span class="s1">var parentId = node.parentId;</span><span class="s3">\n  </span><span class="s1">if (null == parentId) {</span><span class="s3">\n    </span><span class="s1">// If there's no parent, we are done</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;</span><span class="s1">. No parent node.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Get Parent Node</span><span class="s3">\n  </span><span class="s1">var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];</span><span class="s3">\n  </span><span class="s1">var flag = false;</span><span class="s3">\n\n  </span><span class="s1">// MaxX</span><span class="s3">\n  </span><span class="s1">if (null == p.maxX || node.maxX + p.padRight &gt; p.maxX) {</span><span class="s3">\n    </span><span class="s1">p.maxX = node.maxX + p.padRight;</span><span class="s3">\n    </span><span class="s1">flag = true;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nNew maxX for parent node </span><span class="s3">\&quot; </span><span class="s1">+ p.id + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ p.maxX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// MinX</span><span class="s3">\n  </span><span class="s1">if (null == p.minX || node.minX - p.padLeft &lt; p.minX) {</span><span class="s3">\n    </span><span class="s1">p.minX = node.minX - p.padLeft;</span><span class="s3">\n    </span><span class="s1">flag = true;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nNew minX for parent node </span><span class="s3">\&quot; </span><span class="s1">+ p.id + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ p.minX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// MaxY</span><span class="s3">\n  </span><span class="s1">if (null == p.maxY || node.maxY + p.padBottom &gt; p.maxY) {</span><span class="s3">\n    </span><span class="s1">p.maxY = node.maxY + p.padBottom;</span><span class="s3">\n    </span><span class="s1">flag = true;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nNew maxY for parent node </span><span class="s3">\&quot; </span><span class="s1">+ p.id + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ p.maxY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// MinY</span><span class="s3">\n  </span><span class="s1">if (null == p.minY || node.minY - p.padTop &lt; p.minY) {</span><span class="s3">\n    </span><span class="s1">p.minY = node.minY - p.padTop;</span><span class="s3">\n    </span><span class="s1">flag = true;</span><span class="s3">\n    </span><span class="s1">// s += </span><span class="s3">\&quot;\\</span><span class="s1">nNew minY for parent node </span><span class="s3">\&quot; </span><span class="s1">+ p.id + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ p.minY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If updated boundaries, propagate changes upward</span><span class="s3">\n  </span><span class="s1">if (flag) {</span><span class="s3">\n    </span><span class="s1">// logDebug(s);</span><span class="s3">\n    </span><span class="s1">return _updateAncestryBoundaries(p, layoutInfo);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// s += </span><span class="s3">\&quot;</span><span class="s1">. No changes in boundaries/position of parent node </span><span class="s3">\&quot; </span><span class="s1">+ p.id;</span><span class="s3">\n  </span><span class="s1">// logDebug(s);</span><span class="s3">\n  </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var separateComponents = function separateComponents(layoutInfo, options) {</span><span class="s3">\n  </span><span class="s1">var nodes = layoutInfo.layoutNodes;</span><span class="s3">\n  </span><span class="s1">var components = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = nodes[i];</span><span class="s3">\n    </span><span class="s1">var cid = node.cmptId;</span><span class="s3">\n    </span><span class="s1">var component = components[cid] = components[cid] || [];</span><span class="s3">\n    </span><span class="s1">component.push(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var totalA = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; components.length; i++) {</span><span class="s3">\n    </span><span class="s1">var c = components[i];</span><span class="s3">\n    </span><span class="s1">if (!c) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">c.x1 = Infinity;</span><span class="s3">\n    </span><span class="s1">c.x2 = -Infinity;</span><span class="s3">\n    </span><span class="s1">c.y1 = Infinity;</span><span class="s3">\n    </span><span class="s1">c.y2 = -Infinity;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; c.length; j++) {</span><span class="s3">\n      </span><span class="s1">var n = c[j];</span><span class="s3">\n      </span><span class="s1">c.x1 = Math.min(c.x1, n.positionX - n.width / 2);</span><span class="s3">\n      </span><span class="s1">c.x2 = Math.max(c.x2, n.positionX + n.width / 2);</span><span class="s3">\n      </span><span class="s1">c.y1 = Math.min(c.y1, n.positionY - n.height / 2);</span><span class="s3">\n      </span><span class="s1">c.y2 = Math.max(c.y2, n.positionY + n.height / 2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">c.w = c.x2 - c.x1;</span><span class="s3">\n    </span><span class="s1">c.h = c.y2 - c.y1;</span><span class="s3">\n    </span><span class="s1">totalA += c.w * c.h;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">components.sort(function (c1, c2) {</span><span class="s3">\n    </span><span class="s1">return c2.w * c2.h - c1.w * c1.h;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var x = 0;</span><span class="s3">\n  </span><span class="s1">var y = 0;</span><span class="s3">\n  </span><span class="s1">var usedW = 0;</span><span class="s3">\n  </span><span class="s1">var rowH = 0;</span><span class="s3">\n  </span><span class="s1">var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; components.length; i++) {</span><span class="s3">\n    </span><span class="s1">var c = components[i];</span><span class="s3">\n    </span><span class="s1">if (!c) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; c.length; j++) {</span><span class="s3">\n      </span><span class="s1">var n = c[j];</span><span class="s3">\n      </span><span class="s1">if (!n.isLocked) {</span><span class="s3">\n        </span><span class="s1">n.positionX += x - c.x1;</span><span class="s3">\n        </span><span class="s1">n.positionY += y - c.y1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">x += c.w + options.componentSpacing;</span><span class="s3">\n    </span><span class="s1">usedW += c.w + options.componentSpacing;</span><span class="s3">\n    </span><span class="s1">rowH = Math.max(rowH, c.h);</span><span class="s3">\n    </span><span class="s1">if (usedW &gt; maxRowW) {</span><span class="s3">\n      </span><span class="s1">y += rowH + options.componentSpacing;</span><span class="s3">\n      </span><span class="s1">x = 0;</span><span class="s3">\n      </span><span class="s1">usedW = 0;</span><span class="s3">\n      </span><span class="s1">rowH = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defaults$3 = {</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// whether to fit the viewport to the graph</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// padding used on fit</span><span class="s3">\n  </span><span class="s1">boundingBox: undefined,</span><span class="s3">\n  </span><span class="s1">// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }</span><span class="s3">\n  </span><span class="s1">avoidOverlap: true,</span><span class="s3">\n  </span><span class="s1">// prevents node overlap, may overflow boundingBox if not enough space</span><span class="s3">\n  </span><span class="s1">avoidOverlapPadding: 10,</span><span class="s3">\n  </span><span class="s1">// extra spacing around nodes when avoidOverlap: true</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// Excludes the label when calculating node bounding boxes for the layout algorithm</span><span class="s3">\n  </span><span class="s1">spacingFactor: undefined,</span><span class="s3">\n  </span><span class="s1">// Applies a multiplicative factor (&gt;0) to expand or compress the overall area that the nodes take up</span><span class="s3">\n  </span><span class="s1">condense: false,</span><span class="s3">\n  </span><span class="s1">// uses all available space on false, uses minimal space on true</span><span class="s3">\n  </span><span class="s1">rows: undefined,</span><span class="s3">\n  </span><span class="s1">// force num of rows in the grid</span><span class="s3">\n  </span><span class="s1">cols: undefined,</span><span class="s3">\n  </span><span class="s1">// force num of columns in the grid</span><span class="s3">\n  </span><span class="s1">position: function position(node) {},</span><span class="s3">\n  </span><span class="s1">// returns { row, col } for element</span><span class="s3">\n  </span><span class="s1">sort: undefined,</span><span class="s3">\n  </span><span class="s1">// a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }</span><span class="s3">\n  </span><span class="s1">animate: false,</span><span class="s3">\n  </span><span class="s1">// whether to transition the node positions</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// duration of animation in ms if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// easing of animation if enabled</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">ready: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutready</span><span class="s3">\n  </span><span class="s1">stop: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutstop</span><span class="s3">\n  </span><span class="s1">transform: function transform(node, position) {</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">} // transform a given node position. Useful for changing flow direction in discrete layouts </span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function GridLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$3, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">GridLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var params = this.options;</span><span class="s3">\n  </span><span class="s1">var options = params;</span><span class="s3">\n  </span><span class="s1">var cy = params.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes().not(':parent');</span><span class="s3">\n  </span><span class="s1">if (options.sort) {</span><span class="s3">\n    </span><span class="s1">nodes = nodes.sort(options.sort);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {</span><span class="s3">\n    </span><span class="s1">x1: 0,</span><span class="s3">\n    </span><span class="s1">y1: 0,</span><span class="s3">\n    </span><span class="s1">w: cy.width(),</span><span class="s3">\n    </span><span class="s1">h: cy.height()</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">if (bb.h === 0 || bb.w === 0) {</span><span class="s3">\n    </span><span class="s1">eles.nodes().layoutPositions(this, options, function (ele) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: bb.x1,</span><span class="s3">\n        </span><span class="s1">y: bb.y1</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// width/height * splits^2 = cells where splits is number of times to split width</span><span class="s3">\n    </span><span class="s1">var cells = nodes.size();</span><span class="s3">\n    </span><span class="s1">var splits = Math.sqrt(cells * bb.h / bb.w);</span><span class="s3">\n    </span><span class="s1">var rows = Math.round(splits);</span><span class="s3">\n    </span><span class="s1">var cols = Math.round(bb.w / bb.h * splits);</span><span class="s3">\n    </span><span class="s1">var small = function small(val) {</span><span class="s3">\n      </span><span class="s1">if (val == null) {</span><span class="s3">\n        </span><span class="s1">return Math.min(rows, cols);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var min = Math.min(rows, cols);</span><span class="s3">\n        </span><span class="s1">if (min == rows) {</span><span class="s3">\n          </span><span class="s1">rows = val;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cols = val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var large = function large(val) {</span><span class="s3">\n      </span><span class="s1">if (val == null) {</span><span class="s3">\n        </span><span class="s1">return Math.max(rows, cols);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var max = Math.max(rows, cols);</span><span class="s3">\n        </span><span class="s1">if (max == rows) {</span><span class="s3">\n          </span><span class="s1">rows = val;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cols = val;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var oRows = options.rows;</span><span class="s3">\n    </span><span class="s1">var oCols = options.cols != null ? options.cols : options.columns;</span><span class="s3">\n\n    </span><span class="s1">// if rows or columns were set in options, use those values</span><span class="s3">\n    </span><span class="s1">if (oRows != null &amp;&amp; oCols != null) {</span><span class="s3">\n      </span><span class="s1">rows = oRows;</span><span class="s3">\n      </span><span class="s1">cols = oCols;</span><span class="s3">\n    </span><span class="s1">} else if (oRows != null &amp;&amp; oCols == null) {</span><span class="s3">\n      </span><span class="s1">rows = oRows;</span><span class="s3">\n      </span><span class="s1">cols = Math.ceil(cells / rows);</span><span class="s3">\n    </span><span class="s1">} else if (oRows == null &amp;&amp; oCols != null) {</span><span class="s3">\n      </span><span class="s1">cols = oCols;</span><span class="s3">\n      </span><span class="s1">rows = Math.ceil(cells / cols);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// otherwise use the automatic values and adjust accordingly</span><span class="s3">\n\n    </span><span class="s1">// if rounding was up, see if we can reduce rows or columns</span><span class="s3">\n    </span><span class="s1">else if (cols * rows &gt; cells) {</span><span class="s3">\n      </span><span class="s1">var sm = small();</span><span class="s3">\n      </span><span class="s1">var lg = large();</span><span class="s3">\n\n      </span><span class="s1">// reducing the small side takes away the most cells, so try it first</span><span class="s3">\n      </span><span class="s1">if ((sm - 1) * lg &gt;= cells) {</span><span class="s3">\n        </span><span class="s1">small(sm - 1);</span><span class="s3">\n      </span><span class="s1">} else if ((lg - 1) * sm &gt;= cells) {</span><span class="s3">\n        </span><span class="s1">large(lg - 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// if rounding was too low, add rows or columns</span><span class="s3">\n      </span><span class="s1">while (cols * rows &lt; cells) {</span><span class="s3">\n        </span><span class="s1">var _sm = small();</span><span class="s3">\n        </span><span class="s1">var _lg = large();</span><span class="s3">\n\n        </span><span class="s1">// try to add to larger side first (adds less in multiplication)</span><span class="s3">\n        </span><span class="s1">if ((_lg + 1) * _sm &gt;= cells) {</span><span class="s3">\n          </span><span class="s1">large(_lg + 1);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">small(_sm + 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var cellWidth = bb.w / cols;</span><span class="s3">\n    </span><span class="s1">var cellHeight = bb.h / rows;</span><span class="s3">\n    </span><span class="s1">if (options.condense) {</span><span class="s3">\n      </span><span class="s1">cellWidth = 0;</span><span class="s3">\n      </span><span class="s1">cellHeight = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (options.avoidOverlap) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">var node = nodes[i];</span><span class="s3">\n        </span><span class="s1">var pos = node._private.position;</span><span class="s3">\n        </span><span class="s1">if (pos.x == null || pos.y == null) {</span><span class="s3">\n          </span><span class="s1">// for bb</span><span class="s3">\n          </span><span class="s1">pos.x = 0;</span><span class="s3">\n          </span><span class="s1">pos.y = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var nbb = node.layoutDimensions(options);</span><span class="s3">\n        </span><span class="s1">var p = options.avoidOverlapPadding;</span><span class="s3">\n        </span><span class="s1">var w = nbb.w + p;</span><span class="s3">\n        </span><span class="s1">var h = nbb.h + p;</span><span class="s3">\n        </span><span class="s1">cellWidth = Math.max(cellWidth, w);</span><span class="s3">\n        </span><span class="s1">cellHeight = Math.max(cellHeight, h);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var cellUsed = {}; // e.g. 'c-0-2' =&gt; true</span><span class="s3">\n\n    </span><span class="s1">var used = function used(row, col) {</span><span class="s3">\n      </span><span class="s1">return cellUsed['c-' + row + '-' + col] ? true : false;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var use = function use(row, col) {</span><span class="s3">\n      </span><span class="s1">cellUsed['c-' + row + '-' + col] = true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// to keep track of current cell position</span><span class="s3">\n    </span><span class="s1">var row = 0;</span><span class="s3">\n    </span><span class="s1">var col = 0;</span><span class="s3">\n    </span><span class="s1">var moveToNextCell = function moveToNextCell() {</span><span class="s3">\n      </span><span class="s1">col++;</span><span class="s3">\n      </span><span class="s1">if (col &gt;= cols) {</span><span class="s3">\n        </span><span class="s1">col = 0;</span><span class="s3">\n        </span><span class="s1">row++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// get a cache of all the manual positions</span><span class="s3">\n    </span><span class="s1">var id2manPos = {};</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; nodes.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var _node = nodes[_i];</span><span class="s3">\n      </span><span class="s1">var rcPos = options.position(_node);</span><span class="s3">\n      </span><span class="s1">if (rcPos &amp;&amp; (rcPos.row !== undefined || rcPos.col !== undefined)) {</span><span class="s3">\n        </span><span class="s1">// must have at least row or col def'd</span><span class="s3">\n        </span><span class="s1">var _pos = {</span><span class="s3">\n          </span><span class="s1">row: rcPos.row,</span><span class="s3">\n          </span><span class="s1">col: rcPos.col</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (_pos.col === undefined) {</span><span class="s3">\n          </span><span class="s1">// find unused col</span><span class="s3">\n          </span><span class="s1">_pos.col = 0;</span><span class="s3">\n          </span><span class="s1">while (used(_pos.row, _pos.col)) {</span><span class="s3">\n            </span><span class="s1">_pos.col++;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (_pos.row === undefined) {</span><span class="s3">\n          </span><span class="s1">// find unused row</span><span class="s3">\n          </span><span class="s1">_pos.row = 0;</span><span class="s3">\n          </span><span class="s1">while (used(_pos.row, _pos.col)) {</span><span class="s3">\n            </span><span class="s1">_pos.row++;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">id2manPos[_node.id()] = _pos;</span><span class="s3">\n        </span><span class="s1">use(_pos.row, _pos.col);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var getPos = function getPos(element, i) {</span><span class="s3">\n      </span><span class="s1">var x, y;</span><span class="s3">\n      </span><span class="s1">if (element.locked() || element.isParent()) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// see if we have a manual position set</span><span class="s3">\n      </span><span class="s1">var rcPos = id2manPos[element.id()];</span><span class="s3">\n      </span><span class="s1">if (rcPos) {</span><span class="s3">\n        </span><span class="s1">x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;</span><span class="s3">\n        </span><span class="s1">y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// otherwise set automatically</span><span class="s3">\n\n        </span><span class="s1">while (used(row, col)) {</span><span class="s3">\n          </span><span class="s1">moveToNextCell();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">x = col * cellWidth + cellWidth / 2 + bb.x1;</span><span class="s3">\n        </span><span class="s1">y = row * cellHeight + cellHeight / 2 + bb.y1;</span><span class="s3">\n        </span><span class="s1">use(row, col);</span><span class="s3">\n        </span><span class="s1">moveToNextCell();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: x,</span><span class="s3">\n        </span><span class="s1">y: y</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">nodes.layoutPositions(this, options, getPos);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// default layout options</span><span class="s3">\n</span><span class="s1">var defaults$2 = {</span><span class="s3">\n  </span><span class="s1">ready: function ready() {},</span><span class="s3">\n  </span><span class="s1">// on layoutready</span><span class="s3">\n  </span><span class="s1">stop: function stop() {} // on layoutstop</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// constructor</span><span class="s3">\n</span><span class="s1">// options : object containing layout options</span><span class="s3">\n</span><span class="s1">function NullLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$2, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// runs the layout</span><span class="s3">\n</span><span class="s1">NullLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var options = this.options;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles; // elements to consider in the layout</span><span class="s3">\n  </span><span class="s1">var layout = this;</span><span class="s3">\n\n  </span><span class="s1">// cy is automatically populated for us in the constructor</span><span class="s3">\n  </span><span class="s1">// (disable eslint for next line as this serves as example layout code to external developers)</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-unused-vars</span><span class="s3">\n  </span><span class="s1">options.cy;</span><span class="s3">\n  </span><span class="s1">layout.emit('layoutstart');</span><span class="s3">\n\n  </span><span class="s1">// puts all nodes at (0, 0)</span><span class="s3">\n  </span><span class="s1">// n.b. most layouts would use layoutPositions(), instead of positions() and manual events</span><span class="s3">\n  </span><span class="s1">eles.nodes().positions(function () {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: 0,</span><span class="s3">\n      </span><span class="s1">y: 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// trigger layoutready when each node has had its position set at least once</span><span class="s3">\n  </span><span class="s1">layout.one('layoutready', options.ready);</span><span class="s3">\n  </span><span class="s1">layout.emit('layoutready');</span><span class="s3">\n\n  </span><span class="s1">// trigger layoutstop when the layout stops (e.g. finishes)</span><span class="s3">\n  </span><span class="s1">layout.one('layoutstop', options.stop);</span><span class="s3">\n  </span><span class="s1">layout.emit('layoutstop');</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// called on continuous layouts to stop them before they finish</span><span class="s3">\n</span><span class="s1">NullLayout.prototype.stop = function () {</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defaults$1 = {</span><span class="s3">\n  </span><span class="s1">positions: undefined,</span><span class="s3">\n  </span><span class="s1">// map of (node id) =&gt; (position obj); or function(node){ return somPos; }</span><span class="s3">\n  </span><span class="s1">zoom: undefined,</span><span class="s3">\n  </span><span class="s1">// the zoom level to set (prob want fit = false if set)</span><span class="s3">\n  </span><span class="s1">pan: undefined,</span><span class="s3">\n  </span><span class="s1">// the pan level to set (prob want fit = false if set)</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// whether to fit to viewport</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// padding on fit</span><span class="s3">\n  </span><span class="s1">spacingFactor: undefined,</span><span class="s3">\n  </span><span class="s1">// Applies a multiplicative factor (&gt;0) to expand or compress the overall area that the nodes take up</span><span class="s3">\n  </span><span class="s1">animate: false,</span><span class="s3">\n  </span><span class="s1">// whether to transition the node positions</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// duration of animation in ms if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// easing of animation if enabled</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">ready: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutready</span><span class="s3">\n  </span><span class="s1">stop: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutstop</span><span class="s3">\n  </span><span class="s1">transform: function transform(node, position) {</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">} // transform a given node position. Useful for changing flow direction in discrete layouts</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function PresetLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults$1, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">PresetLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var options = this.options;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes();</span><span class="s3">\n  </span><span class="s1">var posIsFn = fn$6(options.positions);</span><span class="s3">\n  </span><span class="s1">function getPosition(node) {</span><span class="s3">\n    </span><span class="s1">if (options.positions == null) {</span><span class="s3">\n      </span><span class="s1">return copyPosition(node.position());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (posIsFn) {</span><span class="s3">\n      </span><span class="s1">return options.positions(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var pos = options.positions[node._private.data.id];</span><span class="s3">\n    </span><span class="s1">if (pos == null) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodes.layoutPositions(this, options, function (node, i) {</span><span class="s3">\n    </span><span class="s1">var position = getPosition(node);</span><span class="s3">\n    </span><span class="s1">if (node.locked() || position == null) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var defaults = {</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// whether to fit to viewport</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// fit padding</span><span class="s3">\n  </span><span class="s1">boundingBox: undefined,</span><span class="s3">\n  </span><span class="s1">// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }</span><span class="s3">\n  </span><span class="s1">animate: false,</span><span class="s3">\n  </span><span class="s1">// whether to transition the node positions</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// duration of animation in ms if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// easing of animation if enabled</span><span class="s3">\n  </span><span class="s1">animateFilter: function animateFilter(node, i) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts</span><span class="s3">\n  </span><span class="s1">ready: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutready</span><span class="s3">\n  </span><span class="s1">stop: undefined,</span><span class="s3">\n  </span><span class="s1">// callback on layoutstop</span><span class="s3">\n  </span><span class="s1">transform: function transform(node, position) {</span><span class="s3">\n    </span><span class="s1">return position;</span><span class="s3">\n  </span><span class="s1">} // transform a given node position. Useful for changing flow direction in discrete layouts </span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function RandomLayout(options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend({}, defaults, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">RandomLayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var options = this.options;</span><span class="s3">\n  </span><span class="s1">var cy = options.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {</span><span class="s3">\n    </span><span class="s1">x1: 0,</span><span class="s3">\n    </span><span class="s1">y1: 0,</span><span class="s3">\n    </span><span class="s1">w: cy.width(),</span><span class="s3">\n    </span><span class="s1">h: cy.height()</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var getPos = function getPos(node, i) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: bb.x1 + Math.round(Math.random() * bb.w),</span><span class="s3">\n      </span><span class="s1">y: bb.y1 + Math.round(Math.random() * bb.h)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">eles.nodes().layoutPositions(this, options, getPos);</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var layout = [{</span><span class="s3">\n  </span><span class="s1">name: 'breadthfirst',</span><span class="s3">\n  </span><span class="s1">impl: BreadthFirstLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'circle',</span><span class="s3">\n  </span><span class="s1">impl: CircleLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'concentric',</span><span class="s3">\n  </span><span class="s1">impl: ConcentricLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'cose',</span><span class="s3">\n  </span><span class="s1">impl: CoseLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'grid',</span><span class="s3">\n  </span><span class="s1">impl: GridLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'null',</span><span class="s3">\n  </span><span class="s1">impl: NullLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'preset',</span><span class="s3">\n  </span><span class="s1">impl: PresetLayout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'random',</span><span class="s3">\n  </span><span class="s1">impl: RandomLayout</span><span class="s3">\n</span><span class="s1">}];</span><span class="s3">\n\n</span><span class="s1">function NullRenderer(options) {</span><span class="s3">\n  </span><span class="s1">this.options = options;</span><span class="s3">\n  </span><span class="s1">this.notifications = 0; // for testing</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var noop = function noop() {};</span><span class="s3">\n</span><span class="s1">var throwImgErr = function throwImgErr() {</span><span class="s3">\n  </span><span class="s1">throw new Error('A headless instance can not render images');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">NullRenderer.prototype = {</span><span class="s3">\n  </span><span class="s1">recalculateRenderedStyle: noop,</span><span class="s3">\n  </span><span class="s1">notify: function notify() {</span><span class="s3">\n    </span><span class="s1">this.notifications++;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">init: noop,</span><span class="s3">\n  </span><span class="s1">isHeadless: function isHeadless() {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">png: throwImgErr,</span><span class="s3">\n  </span><span class="s1">jpg: throwImgErr</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$f = {};</span><span class="s3">\n</span><span class="s1">BRp$f.arrowShapeWidth = 0.3;</span><span class="s3">\n</span><span class="s1">BRp$f.registerArrowShapes = function () {</span><span class="s3">\n  </span><span class="s1">var arrowShapes = this.arrowShapes = {};</span><span class="s3">\n  </span><span class="s1">var renderer = this;</span><span class="s3">\n\n  </span><span class="s1">// Contract for arrow shapes:</span><span class="s3">\n  </span><span class="s1">// 0, 0 is arrow tip</span><span class="s3">\n  </span><span class="s1">// (0, 1) is direction towards node</span><span class="s3">\n  </span><span class="s1">// (1, 0) is right</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// functional api:</span><span class="s3">\n  </span><span class="s1">// collide: check x, y in shape</span><span class="s3">\n  </span><span class="s1">// roughCollide: called before collide, no false negatives</span><span class="s3">\n  </span><span class="s1">// draw: draw</span><span class="s3">\n  </span><span class="s1">// spacing: dist(arrowTip, nodeBoundary)</span><span class="s3">\n  </span><span class="s1">// gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip</span><span class="s3">\n\n  </span><span class="s1">var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {</span><span class="s3">\n    </span><span class="s1">var x1 = translation.x - size / 2 - padding;</span><span class="s3">\n    </span><span class="s1">var x2 = translation.x + size / 2 + padding;</span><span class="s3">\n    </span><span class="s1">var y1 = translation.y - size / 2 - padding;</span><span class="s3">\n    </span><span class="s1">var y2 = translation.y + size / 2 + padding;</span><span class="s3">\n    </span><span class="s1">var inside = x1 &lt;= x &amp;&amp; x &lt;= x2 &amp;&amp; y1 &lt;= y &amp;&amp; y &lt;= y2;</span><span class="s3">\n    </span><span class="s1">return inside;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var transform = function transform(x, y, size, angle, translation) {</span><span class="s3">\n    </span><span class="s1">var xRotated = x * Math.cos(angle) - y * Math.sin(angle);</span><span class="s3">\n    </span><span class="s1">var yRotated = x * Math.sin(angle) + y * Math.cos(angle);</span><span class="s3">\n    </span><span class="s1">var xScaled = xRotated * size;</span><span class="s3">\n    </span><span class="s1">var yScaled = yRotated * size;</span><span class="s3">\n    </span><span class="s1">var xTranslated = xScaled + translation.x;</span><span class="s3">\n    </span><span class="s1">var yTranslated = yScaled + translation.y;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: xTranslated,</span><span class="s3">\n      </span><span class="s1">y: yTranslated</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var transformPoints = function transformPoints(pts, size, angle, translation) {</span><span class="s3">\n    </span><span class="s1">var retPts = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; pts.length; i += 2) {</span><span class="s3">\n      </span><span class="s1">var x = pts[i];</span><span class="s3">\n      </span><span class="s1">var y = pts[i + 1];</span><span class="s3">\n      </span><span class="s1">retPts.push(transform(x, y, size, angle, translation));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return retPts;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var pointsToArr = function pointsToArr(pts) {</span><span class="s3">\n    </span><span class="s1">var ret = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; pts.length; i++) {</span><span class="s3">\n      </span><span class="s1">var p = pts[i];</span><span class="s3">\n      </span><span class="s1">ret.push(p.x, p.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var standardGap = function standardGap(edge) {</span><span class="s3">\n    </span><span class="s1">return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var defineArrowShape = function defineArrowShape(name, defn) {</span><span class="s3">\n    </span><span class="s1">if (string(defn)) {</span><span class="s3">\n      </span><span class="s1">defn = arrowShapes[defn];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">arrowShapes[name] = extend({</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],</span><span class="s3">\n      </span><span class="s1">collide: function collide(x, y, size, angle, translation, padding) {</span><span class="s3">\n        </span><span class="s1">var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));</span><span class="s3">\n        </span><span class="s1">var inside = pointInsidePolygonPoints(x, y, points);</span><span class="s3">\n        </span><span class="s1">return inside;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">roughCollide: bbCollide,</span><span class="s3">\n      </span><span class="s1">draw: function draw(context, size, angle, translation) {</span><span class="s3">\n        </span><span class="s1">var points = transformPoints(this.points, size, angle, translation);</span><span class="s3">\n        </span><span class="s1">renderer.arrowShapeImpl('polygon')(context, points);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">spacing: function spacing(edge) {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">gap: standardGap</span><span class="s3">\n    </span><span class="s1">}, defn);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">defineArrowShape('none', {</span><span class="s3">\n    </span><span class="s1">collide: falsify,</span><span class="s3">\n    </span><span class="s1">roughCollide: falsify,</span><span class="s3">\n    </span><span class="s1">draw: noop$1,</span><span class="s3">\n    </span><span class="s1">spacing: zeroify,</span><span class="s3">\n    </span><span class="s1">gap: zeroify</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('triangle', {</span><span class="s3">\n    </span><span class="s1">points: [-0.15, -0.3, 0, 0, 0.15, -0.3]</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('arrow', 'triangle');</span><span class="s3">\n  </span><span class="s1">defineArrowShape('triangle-backcurve', {</span><span class="s3">\n    </span><span class="s1">points: arrowShapes['triangle'].points,</span><span class="s3">\n    </span><span class="s1">controlPoint: [0, -0.15],</span><span class="s3">\n    </span><span class="s1">roughCollide: bbCollide,</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, size, angle, translation, edgeWidth) {</span><span class="s3">\n      </span><span class="s1">var ptsTrans = transformPoints(this.points, size, angle, translation);</span><span class="s3">\n      </span><span class="s1">var ctrlPt = this.controlPoint;</span><span class="s3">\n      </span><span class="s1">var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);</span><span class="s3">\n      </span><span class="s1">renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">gap: function gap(edge) {</span><span class="s3">\n      </span><span class="s1">return standardGap(edge) * 0.8;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('triangle-tee', {</span><span class="s3">\n    </span><span class="s1">points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],</span><span class="s3">\n    </span><span class="s1">pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],</span><span class="s3">\n    </span><span class="s1">collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {</span><span class="s3">\n      </span><span class="s1">var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));</span><span class="s3">\n      </span><span class="s1">var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));</span><span class="s3">\n      </span><span class="s1">var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);</span><span class="s3">\n      </span><span class="s1">return inside;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, size, angle, translation, edgeWidth) {</span><span class="s3">\n      </span><span class="s1">var triPts = transformPoints(this.points, size, angle, translation);</span><span class="s3">\n      </span><span class="s1">var teePts = transformPoints(this.pointsTee, size, angle, translation);</span><span class="s3">\n      </span><span class="s1">renderer.arrowShapeImpl(this.name)(context, triPts, teePts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('circle-triangle', {</span><span class="s3">\n    </span><span class="s1">radius: 0.15,</span><span class="s3">\n    </span><span class="s1">pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],</span><span class="s3">\n    </span><span class="s1">collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {</span><span class="s3">\n      </span><span class="s1">var t = translation;</span><span class="s3">\n      </span><span class="s1">var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) &lt;= Math.pow((size + 2 * padding) * this.radius, 2);</span><span class="s3">\n      </span><span class="s1">var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));</span><span class="s3">\n      </span><span class="s1">return pointInsidePolygonPoints(x, y, triPts) || circleInside;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, size, angle, translation, edgeWidth) {</span><span class="s3">\n      </span><span class="s1">var triPts = transformPoints(this.pointsTr, size, angle, translation);</span><span class="s3">\n      </span><span class="s1">renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">spacing: function spacing(edge) {</span><span class="s3">\n      </span><span class="s1">return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('triangle-cross', {</span><span class="s3">\n    </span><span class="s1">points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],</span><span class="s3">\n    </span><span class="s1">baseCrossLinePts: [-0.15, -0.4,</span><span class="s3">\n    </span><span class="s1">// first half of the rectangle</span><span class="s3">\n    </span><span class="s1">-0.15, -0.4, 0.15, -0.4,</span><span class="s3">\n    </span><span class="s1">// second half of the rectangle</span><span class="s3">\n    </span><span class="s1">0.15, -0.4],</span><span class="s3">\n    </span><span class="s1">crossLinePts: function crossLinePts(size, edgeWidth) {</span><span class="s3">\n      </span><span class="s1">// shift points so that the distance between the cross points matches edge width</span><span class="s3">\n      </span><span class="s1">var p = this.baseCrossLinePts.slice();</span><span class="s3">\n      </span><span class="s1">var shiftFactor = edgeWidth / size;</span><span class="s3">\n      </span><span class="s1">var y0 = 3;</span><span class="s3">\n      </span><span class="s1">var y1 = 5;</span><span class="s3">\n      </span><span class="s1">p[y0] = p[y0] - shiftFactor;</span><span class="s3">\n      </span><span class="s1">p[y1] = p[y1] - shiftFactor;</span><span class="s3">\n      </span><span class="s1">return p;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {</span><span class="s3">\n      </span><span class="s1">var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));</span><span class="s3">\n      </span><span class="s1">var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));</span><span class="s3">\n      </span><span class="s1">var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);</span><span class="s3">\n      </span><span class="s1">return inside;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, size, angle, translation, edgeWidth) {</span><span class="s3">\n      </span><span class="s1">var triPts = transformPoints(this.points, size, angle, translation);</span><span class="s3">\n      </span><span class="s1">var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);</span><span class="s3">\n      </span><span class="s1">renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('vee', {</span><span class="s3">\n    </span><span class="s1">points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],</span><span class="s3">\n    </span><span class="s1">gap: function gap(edge) {</span><span class="s3">\n      </span><span class="s1">return standardGap(edge) * 0.525;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('circle', {</span><span class="s3">\n    </span><span class="s1">radius: 0.15,</span><span class="s3">\n    </span><span class="s1">collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {</span><span class="s3">\n      </span><span class="s1">var t = translation;</span><span class="s3">\n      </span><span class="s1">var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) &lt;= Math.pow((size + 2 * padding) * this.radius, 2);</span><span class="s3">\n      </span><span class="s1">return inside;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, size, angle, translation, edgeWidth) {</span><span class="s3">\n      </span><span class="s1">renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">spacing: function spacing(edge) {</span><span class="s3">\n      </span><span class="s1">return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('tee', {</span><span class="s3">\n    </span><span class="s1">points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],</span><span class="s3">\n    </span><span class="s1">spacing: function spacing(edge) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">gap: function gap(edge) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('square', {</span><span class="s3">\n    </span><span class="s1">points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('diamond', {</span><span class="s3">\n    </span><span class="s1">points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],</span><span class="s3">\n    </span><span class="s1">gap: function gap(edge) {</span><span class="s3">\n      </span><span class="s1">return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">defineArrowShape('chevron', {</span><span class="s3">\n    </span><span class="s1">points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],</span><span class="s3">\n    </span><span class="s1">gap: function gap(edge) {</span><span class="s3">\n      </span><span class="s1">return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$e = {};</span><span class="s3">\n\n</span><span class="s1">// Project mouse</span><span class="s3">\n</span><span class="s1">BRp$e.projectIntoViewport = function (clientX, clientY) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy;</span><span class="s3">\n  </span><span class="s1">var offsets = this.findContainerClientCoords();</span><span class="s3">\n  </span><span class="s1">var offsetLeft = offsets[0];</span><span class="s3">\n  </span><span class="s1">var offsetTop = offsets[1];</span><span class="s3">\n  </span><span class="s1">var scale = offsets[4];</span><span class="s3">\n  </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n  </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n  </span><span class="s1">var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;</span><span class="s3">\n  </span><span class="s1">var y = ((clientY - offsetTop) / scale - pan.y) / zoom;</span><span class="s3">\n  </span><span class="s1">return [x, y];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$e.findContainerClientCoords = function () {</span><span class="s3">\n  </span><span class="s1">if (this.containerBB) {</span><span class="s3">\n    </span><span class="s1">return this.containerBB;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var container = this.container;</span><span class="s3">\n  </span><span class="s1">var rect = container.getBoundingClientRect();</span><span class="s3">\n  </span><span class="s1">var style = this.cy.window().getComputedStyle(container);</span><span class="s3">\n  </span><span class="s1">var styleValue = function styleValue(name) {</span><span class="s3">\n    </span><span class="s1">return parseFloat(style.getPropertyValue(name));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var padding = {</span><span class="s3">\n    </span><span class="s1">left: styleValue('padding-left'),</span><span class="s3">\n    </span><span class="s1">right: styleValue('padding-right'),</span><span class="s3">\n    </span><span class="s1">top: styleValue('padding-top'),</span><span class="s3">\n    </span><span class="s1">bottom: styleValue('padding-bottom')</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var border = {</span><span class="s3">\n    </span><span class="s1">left: styleValue('border-left-width'),</span><span class="s3">\n    </span><span class="s1">right: styleValue('border-right-width'),</span><span class="s3">\n    </span><span class="s1">top: styleValue('border-top-width'),</span><span class="s3">\n    </span><span class="s1">bottom: styleValue('border-bottom-width')</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var clientWidth = container.clientWidth;</span><span class="s3">\n  </span><span class="s1">var clientHeight = container.clientHeight;</span><span class="s3">\n  </span><span class="s1">var paddingHor = padding.left + padding.right;</span><span class="s3">\n  </span><span class="s1">var paddingVer = padding.top + padding.bottom;</span><span class="s3">\n  </span><span class="s1">var borderHor = border.left + border.right;</span><span class="s3">\n  </span><span class="s1">var scale = rect.width / (clientWidth + borderHor);</span><span class="s3">\n  </span><span class="s1">var unscaledW = clientWidth - paddingHor;</span><span class="s3">\n  </span><span class="s1">var unscaledH = clientHeight - paddingVer;</span><span class="s3">\n  </span><span class="s1">var left = rect.left + padding.left + border.left;</span><span class="s3">\n  </span><span class="s1">var top = rect.top + padding.top + border.top;</span><span class="s3">\n  </span><span class="s1">return this.containerBB = [left, top, unscaledW, unscaledH, scale];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$e.invalidateContainerClientCoordsCache = function () {</span><span class="s3">\n  </span><span class="s1">this.containerBB = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$e.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {</span><span class="s3">\n  </span><span class="s1">return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$e.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var eles = r.getCachedZSortedEles();</span><span class="s3">\n  </span><span class="s1">var near = []; // 1 node max, 1 edge max</span><span class="s3">\n  </span><span class="s1">var zoom = r.cy.zoom();</span><span class="s3">\n  </span><span class="s1">var hasCompounds = r.cy.hasCompoundNodes();</span><span class="s3">\n  </span><span class="s1">var edgeThreshold = (isTouch ? 24 : 8) / zoom;</span><span class="s3">\n  </span><span class="s1">var nodeThreshold = (isTouch ? 8 : 2) / zoom;</span><span class="s3">\n  </span><span class="s1">var labelThreshold = (isTouch ? 8 : 2) / zoom;</span><span class="s3">\n  </span><span class="s1">var minSqDist = Infinity;</span><span class="s3">\n  </span><span class="s1">var nearEdge;</span><span class="s3">\n  </span><span class="s1">var nearNode;</span><span class="s3">\n  </span><span class="s1">if (interactiveElementsOnly) {</span><span class="s3">\n    </span><span class="s1">eles = eles.interactive;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function addEle(ele, sqDist) {</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">if (nearNode) {</span><span class="s3">\n        </span><span class="s1">return; // can't replace node</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nearNode = ele;</span><span class="s3">\n        </span><span class="s1">near.push(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele.isEdge() &amp;&amp; (sqDist == null || sqDist &lt; minSqDist)) {</span><span class="s3">\n      </span><span class="s1">if (nearEdge) {</span><span class="s3">\n        </span><span class="s1">// then replace existing edge</span><span class="s3">\n        </span><span class="s1">// can replace only if same z-index</span><span class="s3">\n        </span><span class="s1">if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value &amp;&amp; nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {</span><span class="s3">\n          </span><span class="s1">for (var i = 0; i &lt; near.length; i++) {</span><span class="s3">\n            </span><span class="s1">if (near[i].isEdge()) {</span><span class="s3">\n              </span><span class="s1">near[i] = ele;</span><span class="s3">\n              </span><span class="s1">nearEdge = ele;</span><span class="s3">\n              </span><span class="s1">minSqDist = sqDist != null ? sqDist : minSqDist;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">near.push(ele);</span><span class="s3">\n        </span><span class="s1">nearEdge = ele;</span><span class="s3">\n        </span><span class="s1">minSqDist = sqDist != null ? sqDist : minSqDist;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function checkNode(node) {</span><span class="s3">\n    </span><span class="s1">var width = node.outerWidth() + 2 * nodeThreshold;</span><span class="s3">\n    </span><span class="s1">var height = node.outerHeight() + 2 * nodeThreshold;</span><span class="s3">\n    </span><span class="s1">var hw = width / 2;</span><span class="s3">\n    </span><span class="s1">var hh = height / 2;</span><span class="s3">\n    </span><span class="s1">var pos = node.position();</span><span class="s3">\n    </span><span class="s1">var cornerRadius = node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue;</span><span class="s3">\n    </span><span class="s1">var rs = node._private.rscratch;</span><span class="s3">\n    </span><span class="s1">if (pos.x - hw &lt;= x &amp;&amp; x &lt;= pos.x + hw // bb check x</span><span class="s3">\n    </span><span class="s1">&amp;&amp; pos.y - hh &lt;= y &amp;&amp; y &lt;= pos.y + hh // bb check y</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">var shape = r.nodeShapes[self.getNodeShape(node)];</span><span class="s3">\n      </span><span class="s1">if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y, cornerRadius, rs)) {</span><span class="s3">\n        </span><span class="s1">addEle(node, 0);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function checkEdge(edge) {</span><span class="s3">\n    </span><span class="s1">var _p = edge._private;</span><span class="s3">\n    </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n    </span><span class="s1">var styleWidth = edge.pstyle('width').pfValue;</span><span class="s3">\n    </span><span class="s1">var scale = edge.pstyle('arrow-scale').value;</span><span class="s3">\n    </span><span class="s1">var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre</span><span class="s3">\n    </span><span class="s1">var widthSq = width * width;</span><span class="s3">\n    </span><span class="s1">var width2 = width * 2;</span><span class="s3">\n    </span><span class="s1">var src = _p.source;</span><span class="s3">\n    </span><span class="s1">var tgt = _p.target;</span><span class="s3">\n    </span><span class="s1">var sqDist;</span><span class="s3">\n    </span><span class="s1">if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {</span><span class="s3">\n      </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i + 3 &lt; pts.length; i += 2) {</span><span class="s3">\n        </span><span class="s1">if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) &amp;&amp; widthSq &gt; (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {</span><span class="s3">\n          </span><span class="s1">addEle(edge, sqDist);</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {</span><span class="s3">\n      </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i + 5 &lt; rs.allpts.length; i += 4) {</span><span class="s3">\n        </span><span class="s1">if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) &amp;&amp; widthSq &gt; (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {</span><span class="s3">\n          </span><span class="s1">addEle(edge, sqDist);</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if we're close to the edge but didn't hit it, maybe we hit its arrows</span><span class="s3">\n\n    </span><span class="s1">var src = src || _p.source;</span><span class="s3">\n    </span><span class="s1">var tgt = tgt || _p.target;</span><span class="s3">\n    </span><span class="s1">var arSize = self.getArrowWidth(styleWidth, scale);</span><span class="s3">\n    </span><span class="s1">var arrows = [{</span><span class="s3">\n      </span><span class="s1">name: 'source',</span><span class="s3">\n      </span><span class="s1">x: rs.arrowStartX,</span><span class="s3">\n      </span><span class="s1">y: rs.arrowStartY,</span><span class="s3">\n      </span><span class="s1">angle: rs.srcArrowAngle</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">name: 'target',</span><span class="s3">\n      </span><span class="s1">x: rs.arrowEndX,</span><span class="s3">\n      </span><span class="s1">y: rs.arrowEndY,</span><span class="s3">\n      </span><span class="s1">angle: rs.tgtArrowAngle</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">name: 'mid-source',</span><span class="s3">\n      </span><span class="s1">x: rs.midX,</span><span class="s3">\n      </span><span class="s1">y: rs.midY,</span><span class="s3">\n      </span><span class="s1">angle: rs.midsrcArrowAngle</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">name: 'mid-target',</span><span class="s3">\n      </span><span class="s1">x: rs.midX,</span><span class="s3">\n      </span><span class="s1">y: rs.midY,</span><span class="s3">\n      </span><span class="s1">angle: rs.midtgtArrowAngle</span><span class="s3">\n    </span><span class="s1">}];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; arrows.length; i++) {</span><span class="s3">\n      </span><span class="s1">var ar = arrows[i];</span><span class="s3">\n      </span><span class="s1">var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];</span><span class="s3">\n      </span><span class="s1">var edgeWidth = edge.pstyle('width').pfValue;</span><span class="s3">\n      </span><span class="s1">if (shape.roughCollide(x, y, arSize, ar.angle, {</span><span class="s3">\n        </span><span class="s1">x: ar.x,</span><span class="s3">\n        </span><span class="s1">y: ar.y</span><span class="s3">\n      </span><span class="s1">}, edgeWidth, edgeThreshold) &amp;&amp; shape.collide(x, y, arSize, ar.angle, {</span><span class="s3">\n        </span><span class="s1">x: ar.x,</span><span class="s3">\n        </span><span class="s1">y: ar.y</span><span class="s3">\n      </span><span class="s1">}, edgeWidth, edgeThreshold)) {</span><span class="s3">\n        </span><span class="s1">addEle(edge);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)</span><span class="s3">\n    </span><span class="s1">if (hasCompounds &amp;&amp; near.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">checkNode(src);</span><span class="s3">\n      </span><span class="s1">checkNode(tgt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function preprop(obj, name, pre) {</span><span class="s3">\n    </span><span class="s1">return getPrefixedProperty(obj, name, pre);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function checkLabel(ele, prefix) {</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">var th = labelThreshold;</span><span class="s3">\n    </span><span class="s1">var prefixDash;</span><span class="s3">\n    </span><span class="s1">if (prefix) {</span><span class="s3">\n      </span><span class="s1">prefixDash = prefix + '-';</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">prefixDash = '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ele.boundingBox();</span><span class="s3">\n    </span><span class="s1">var bb = _p.labelBounds[prefix || 'main'];</span><span class="s3">\n    </span><span class="s1">var text = ele.pstyle(prefixDash + 'label').value;</span><span class="s3">\n    </span><span class="s1">var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';</span><span class="s3">\n    </span><span class="s1">if (!eventsEnabled || !text) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var lx = preprop(_p.rscratch, 'labelX', prefix);</span><span class="s3">\n    </span><span class="s1">var ly = preprop(_p.rscratch, 'labelY', prefix);</span><span class="s3">\n    </span><span class="s1">var theta = preprop(_p.rscratch, 'labelAngle', prefix);</span><span class="s3">\n    </span><span class="s1">var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;</span><span class="s3">\n    </span><span class="s1">var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;</span><span class="s3">\n    </span><span class="s1">var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin</span><span class="s3">\n    </span><span class="s1">var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)</span><span class="s3">\n    </span><span class="s1">var ly1 = bb.y1 - th - oy;</span><span class="s3">\n    </span><span class="s1">var ly2 = bb.y2 + th - oy;</span><span class="s3">\n    </span><span class="s1">if (theta) {</span><span class="s3">\n      </span><span class="s1">var cos = Math.cos(theta);</span><span class="s3">\n      </span><span class="s1">var sin = Math.sin(theta);</span><span class="s3">\n      </span><span class="s1">var rotate = function rotate(x, y) {</span><span class="s3">\n        </span><span class="s1">x = x - lx;</span><span class="s3">\n        </span><span class="s1">y = y - ly;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">x: x * cos - y * sin + lx,</span><span class="s3">\n          </span><span class="s1">y: x * sin + y * cos + ly</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var px1y1 = rotate(lx1, ly1);</span><span class="s3">\n      </span><span class="s1">var px1y2 = rotate(lx1, ly2);</span><span class="s3">\n      </span><span class="s1">var px2y1 = rotate(lx2, ly1);</span><span class="s3">\n      </span><span class="s1">var px2y2 = rotate(lx2, ly2);</span><span class="s3">\n      </span><span class="s1">var points = [</span><span class="s3">\n      </span><span class="s1">// with the margin added after the rotation is applied</span><span class="s3">\n      </span><span class="s1">px1y1.x + ox, px1y1.y + oy, px2y1.x + ox, px2y1.y + oy, px2y2.x + ox, px2y2.y + oy, px1y2.x + ox, px1y2.y + oy];</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygonPoints(x, y, points)) {</span><span class="s3">\n        </span><span class="s1">addEle(ele);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// do a cheaper bb check</span><span class="s3">\n      </span><span class="s1">if (inBoundingBox(bb, x, y)) {</span><span class="s3">\n        </span><span class="s1">addEle(ele);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = eles.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">// reverse order for precedence</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">checkNode(ele) || checkLabel(ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// then edge</span><span class="s3">\n      </span><span class="s1">checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return near;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// 'Give me everything from this box'</span><span class="s3">\n</span><span class="s1">BRp$e.getAllInBox = function (x1, y1, x2, y2) {</span><span class="s3">\n  </span><span class="s1">var eles = this.getCachedZSortedEles().interactive;</span><span class="s3">\n  </span><span class="s1">var box = [];</span><span class="s3">\n  </span><span class="s1">var x1c = Math.min(x1, x2);</span><span class="s3">\n  </span><span class="s1">var x2c = Math.max(x1, x2);</span><span class="s3">\n  </span><span class="s1">var y1c = Math.min(y1, y2);</span><span class="s3">\n  </span><span class="s1">var y2c = Math.max(y1, y2);</span><span class="s3">\n  </span><span class="s1">x1 = x1c;</span><span class="s3">\n  </span><span class="s1">x2 = x2c;</span><span class="s3">\n  </span><span class="s1">y1 = y1c;</span><span class="s3">\n  </span><span class="s1">y2 = y2c;</span><span class="s3">\n  </span><span class="s1">var boxBb = makeBoundingBox({</span><span class="s3">\n    </span><span class="s1">x1: x1,</span><span class="s3">\n    </span><span class="s1">y1: y1,</span><span class="s3">\n    </span><span class="s1">x2: x2,</span><span class="s3">\n    </span><span class="s1">y2: y2</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">for (var e = 0; e &lt; eles.length; e++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[e];</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">var node = ele;</span><span class="s3">\n      </span><span class="s1">var nodeBb = node.boundingBox({</span><span class="s3">\n        </span><span class="s1">includeNodes: true,</span><span class="s3">\n        </span><span class="s1">includeEdges: false,</span><span class="s3">\n        </span><span class="s1">includeLabels: false</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">if (boundingBoxesIntersect(boxBb, nodeBb) &amp;&amp; !boundingBoxInBoundingBox(nodeBb, boxBb)) {</span><span class="s3">\n        </span><span class="s1">box.push(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var edge = ele;</span><span class="s3">\n      </span><span class="s1">var _p = edge._private;</span><span class="s3">\n      </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n      </span><span class="s1">if (rs.startX != null &amp;&amp; rs.startY != null &amp;&amp; !inBoundingBox(boxBb, rs.startX, rs.startY)) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (rs.endX != null &amp;&amp; rs.endY != null &amp;&amp; !inBoundingBox(boxBb, rs.endX, rs.endY)) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {</span><span class="s3">\n        </span><span class="s1">var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;</span><span class="s3">\n        </span><span class="s1">var allInside = true;</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; pts.length; i++) {</span><span class="s3">\n          </span><span class="s1">if (!pointInBoundingBox(boxBb, pts[i])) {</span><span class="s3">\n            </span><span class="s1">allInside = false;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (allInside) {</span><span class="s3">\n          </span><span class="s1">box.push(edge);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {</span><span class="s3">\n        </span><span class="s1">box.push(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return box;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$d = {};</span><span class="s3">\n</span><span class="s1">BRp$d.calculateArrowAngles = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var isHaystack = rs.edgeType === 'haystack';</span><span class="s3">\n  </span><span class="s1">var isBezier = rs.edgeType === 'bezier';</span><span class="s3">\n  </span><span class="s1">var isMultibezier = rs.edgeType === 'multibezier';</span><span class="s3">\n  </span><span class="s1">var isSegments = rs.edgeType === 'segments';</span><span class="s3">\n  </span><span class="s1">var isCompound = rs.edgeType === 'compound';</span><span class="s3">\n  </span><span class="s1">var isSelf = rs.edgeType === 'self';</span><span class="s3">\n\n  </span><span class="s1">// Displacement gives direction for arrowhead orientation</span><span class="s3">\n  </span><span class="s1">var dispX, dispY;</span><span class="s3">\n  </span><span class="s1">var startX, startY, endX, endY, midX, midY;</span><span class="s3">\n  </span><span class="s1">if (isHaystack) {</span><span class="s3">\n    </span><span class="s1">startX = rs.haystackPts[0];</span><span class="s3">\n    </span><span class="s1">startY = rs.haystackPts[1];</span><span class="s3">\n    </span><span class="s1">endX = rs.haystackPts[2];</span><span class="s3">\n    </span><span class="s1">endY = rs.haystackPts[3];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">startX = rs.arrowStartX;</span><span class="s3">\n    </span><span class="s1">startY = rs.arrowStartY;</span><span class="s3">\n    </span><span class="s1">endX = rs.arrowEndX;</span><span class="s3">\n    </span><span class="s1">endY = rs.arrowEndY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">midX = rs.midX;</span><span class="s3">\n  </span><span class="s1">midY = rs.midY;</span><span class="s3">\n\n  </span><span class="s1">// source</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">if (isSegments) {</span><span class="s3">\n    </span><span class="s1">dispX = startX - rs.segpts[0];</span><span class="s3">\n    </span><span class="s1">dispY = startY - rs.segpts[1];</span><span class="s3">\n  </span><span class="s1">} else if (isMultibezier || isCompound || isSelf || isBezier) {</span><span class="s3">\n    </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n    </span><span class="s1">var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);</span><span class="s3">\n    </span><span class="s1">var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);</span><span class="s3">\n    </span><span class="s1">dispX = startX - bX;</span><span class="s3">\n    </span><span class="s1">dispY = startY - bY;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">dispX = startX - midX;</span><span class="s3">\n    </span><span class="s1">dispY = startY - midY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rs.srcArrowAngle = getAngleFromDisp(dispX, dispY);</span><span class="s3">\n\n  </span><span class="s1">// mid target</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">var midX = rs.midX;</span><span class="s3">\n  </span><span class="s1">var midY = rs.midY;</span><span class="s3">\n  </span><span class="s1">if (isHaystack) {</span><span class="s3">\n    </span><span class="s1">midX = (startX + endX) / 2;</span><span class="s3">\n    </span><span class="s1">midY = (startY + endY) / 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dispX = endX - startX;</span><span class="s3">\n  </span><span class="s1">dispY = endY - startY;</span><span class="s3">\n  </span><span class="s1">if (isSegments) {</span><span class="s3">\n    </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n    </span><span class="s1">if (pts.length / 2 % 2 === 0) {</span><span class="s3">\n      </span><span class="s1">var i2 = pts.length / 2;</span><span class="s3">\n      </span><span class="s1">var i1 = i2 - 2;</span><span class="s3">\n      </span><span class="s1">dispX = pts[i2] - pts[i1];</span><span class="s3">\n      </span><span class="s1">dispY = pts[i2 + 1] - pts[i1 + 1];</span><span class="s3">\n    </span><span class="s1">} else if (rs.isRound) {</span><span class="s3">\n      </span><span class="s1">dispX = rs.midVector[1];</span><span class="s3">\n      </span><span class="s1">dispY = -rs.midVector[0];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var i2 = pts.length / 2 - 1;</span><span class="s3">\n      </span><span class="s1">var i1 = i2 - 2;</span><span class="s3">\n      </span><span class="s1">dispX = pts[i2] - pts[i1];</span><span class="s3">\n      </span><span class="s1">dispY = pts[i2 + 1] - pts[i1 + 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (isMultibezier || isCompound || isSelf) {</span><span class="s3">\n    </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n    </span><span class="s1">var cpts = rs.ctrlpts;</span><span class="s3">\n    </span><span class="s1">var bp0x, bp0y;</span><span class="s3">\n    </span><span class="s1">var bp1x, bp1y;</span><span class="s3">\n    </span><span class="s1">if (cpts.length / 2 % 2 === 0) {</span><span class="s3">\n      </span><span class="s1">var p0 = pts.length / 2 - 1; // startpt</span><span class="s3">\n      </span><span class="s1">var ic = p0 + 2;</span><span class="s3">\n      </span><span class="s1">var p1 = ic + 2;</span><span class="s3">\n      </span><span class="s1">bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);</span><span class="s3">\n      </span><span class="s1">bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);</span><span class="s3">\n      </span><span class="s1">bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);</span><span class="s3">\n      </span><span class="s1">bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var ic = pts.length / 2 - 1; // ctrpt</span><span class="s3">\n      </span><span class="s1">var p0 = ic - 2; // startpt</span><span class="s3">\n      </span><span class="s1">var p1 = ic + 2; // endpt</span><span class="s3">\n\n      </span><span class="s1">bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);</span><span class="s3">\n      </span><span class="s1">bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);</span><span class="s3">\n      </span><span class="s1">bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);</span><span class="s3">\n      </span><span class="s1">bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispX = bp1x - bp0x;</span><span class="s3">\n    </span><span class="s1">dispY = bp1y - bp0y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);</span><span class="s3">\n  </span><span class="s1">rs.midDispX = dispX;</span><span class="s3">\n  </span><span class="s1">rs.midDispY = dispY;</span><span class="s3">\n\n  </span><span class="s1">// mid source</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">dispX *= -1;</span><span class="s3">\n  </span><span class="s1">dispY *= -1;</span><span class="s3">\n  </span><span class="s1">if (isSegments) {</span><span class="s3">\n    </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n    </span><span class="s1">if (pts.length / 2 % 2 === 0) ; else if (!rs.isRound) {</span><span class="s3">\n      </span><span class="s1">var i2 = pts.length / 2 - 1;</span><span class="s3">\n      </span><span class="s1">var i3 = i2 + 2;</span><span class="s3">\n      </span><span class="s1">dispX = -(pts[i3] - pts[i2]);</span><span class="s3">\n      </span><span class="s1">dispY = -(pts[i3 + 1] - pts[i2 + 1]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY);</span><span class="s3">\n\n  </span><span class="s1">// target</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">if (isSegments) {</span><span class="s3">\n    </span><span class="s1">dispX = endX - rs.segpts[rs.segpts.length - 2];</span><span class="s3">\n    </span><span class="s1">dispY = endY - rs.segpts[rs.segpts.length - 1];</span><span class="s3">\n  </span><span class="s1">} else if (isMultibezier || isCompound || isSelf || isBezier) {</span><span class="s3">\n    </span><span class="s1">var pts = rs.allpts;</span><span class="s3">\n    </span><span class="s1">var l = pts.length;</span><span class="s3">\n    </span><span class="s1">var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);</span><span class="s3">\n    </span><span class="s1">var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);</span><span class="s3">\n    </span><span class="s1">dispX = endX - bX;</span><span class="s3">\n    </span><span class="s1">dispY = endY - bY;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">dispX = endX - midX;</span><span class="s3">\n    </span><span class="s1">dispY = endY - midY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$d.getArrowWidth = BRp$d.getArrowHeight = function (edgeWidth, scale) {</span><span class="s3">\n  </span><span class="s1">var cache = this.arrowWidthCache = this.arrowWidthCache || {};</span><span class="s3">\n  </span><span class="s1">var cachedVal = cache[edgeWidth + ', ' + scale];</span><span class="s3">\n  </span><span class="s1">if (cachedVal) {</span><span class="s3">\n    </span><span class="s1">return cachedVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;</span><span class="s3">\n  </span><span class="s1">cache[edgeWidth + ', ' + scale] = cachedVal;</span><span class="s3">\n  </span><span class="s1">return cachedVal;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Explained by Blindman67 at https://stackoverflow.com/a/44856925/11028828</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">// Declare reused variable to avoid reallocating variables every time the function is called</span><span class="s3">\n</span><span class="s1">var x,</span><span class="s3">\n  </span><span class="s1">y,</span><span class="s3">\n  </span><span class="s1">v1 = {},</span><span class="s3">\n  </span><span class="s1">v2 = {},</span><span class="s3">\n  </span><span class="s1">sinA,</span><span class="s3">\n  </span><span class="s1">sinA90,</span><span class="s3">\n  </span><span class="s1">radDirection,</span><span class="s3">\n  </span><span class="s1">drawDirection,</span><span class="s3">\n  </span><span class="s1">angle,</span><span class="s3">\n  </span><span class="s1">halfAngle,</span><span class="s3">\n  </span><span class="s1">cRadius,</span><span class="s3">\n  </span><span class="s1">lenOut,</span><span class="s3">\n  </span><span class="s1">radius,</span><span class="s3">\n  </span><span class="s1">limit;</span><span class="s3">\n</span><span class="s1">var startX, startY, stopX, stopY;</span><span class="s3">\n</span><span class="s1">var lastPoint;</span><span class="s3">\n\n</span><span class="s1">// convert 2 points into vector form, polar form, and normalised</span><span class="s3">\n</span><span class="s1">var asVec = function asVec(p, pp, v) {</span><span class="s3">\n  </span><span class="s1">v.x = pp.x - p.x;</span><span class="s3">\n  </span><span class="s1">v.y = pp.y - p.y;</span><span class="s3">\n  </span><span class="s1">v.len = Math.sqrt(v.x * v.x + v.y * v.y);</span><span class="s3">\n  </span><span class="s1">v.nx = v.x / v.len;</span><span class="s3">\n  </span><span class="s1">v.ny = v.y / v.len;</span><span class="s3">\n  </span><span class="s1">v.ang = Math.atan2(v.ny, v.nx);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var invertVec = function invertVec(originalV, invertedV) {</span><span class="s3">\n  </span><span class="s1">invertedV.x = originalV.x * -1;</span><span class="s3">\n  </span><span class="s1">invertedV.y = originalV.y * -1;</span><span class="s3">\n  </span><span class="s1">invertedV.nx = originalV.nx * -1;</span><span class="s3">\n  </span><span class="s1">invertedV.ny = originalV.ny * -1;</span><span class="s3">\n  </span><span class="s1">invertedV.ang = originalV.ang &gt; 0 ? -(Math.PI - originalV.ang) : Math.PI + originalV.ang;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var calcCornerArc = function calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius) {</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n  </span><span class="s1">// Part 1</span><span class="s3">\n  </span><span class="s1">previousPoint !== lastPoint ? asVec(currentPoint, previousPoint, v1) : invertVec(v2, v1); // Avoid recalculating vec if it is the invert of the last one calculated</span><span class="s3">\n  </span><span class="s1">asVec(currentPoint, nextPoint, v2);</span><span class="s3">\n  </span><span class="s1">sinA = v1.nx * v2.ny - v1.ny * v2.nx;</span><span class="s3">\n  </span><span class="s1">sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;</span><span class="s3">\n  </span><span class="s1">angle = Math.asin(Math.max(-1, Math.min(1, sinA)));</span><span class="s3">\n  </span><span class="s1">if (Math.abs(angle) &lt; 1e-6) {</span><span class="s3">\n    </span><span class="s1">x = currentPoint.x;</span><span class="s3">\n    </span><span class="s1">y = currentPoint.y;</span><span class="s3">\n    </span><span class="s1">cRadius = radius = 0;</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n  </span><span class="s1">radDirection = 1;</span><span class="s3">\n  </span><span class="s1">drawDirection = false;</span><span class="s3">\n  </span><span class="s1">if (sinA90 &lt; 0) {</span><span class="s3">\n    </span><span class="s1">if (angle &lt; 0) {</span><span class="s3">\n      </span><span class="s1">angle = Math.PI + angle;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">angle = Math.PI - angle;</span><span class="s3">\n      </span><span class="s1">radDirection = -1;</span><span class="s3">\n      </span><span class="s1">drawDirection = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (angle &gt; 0) {</span><span class="s3">\n      </span><span class="s1">radDirection = -1;</span><span class="s3">\n      </span><span class="s1">drawDirection = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (currentPoint.radius !== undefined) {</span><span class="s3">\n    </span><span class="s1">radius = currentPoint.radius;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">radius = radiusMax;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n  </span><span class="s1">// Part 2</span><span class="s3">\n  </span><span class="s1">halfAngle = angle / 2;</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n\n  </span><span class="s1">limit = Math.min(v1.len / 2, v2.len / 2);</span><span class="s3">\n  </span><span class="s1">if (isArcRadius) {</span><span class="s3">\n    </span><span class="s1">//-----------------------------------------</span><span class="s3">\n    </span><span class="s1">// Part 3</span><span class="s3">\n    </span><span class="s1">lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));</span><span class="s3">\n\n    </span><span class="s1">//-----------------------------------------</span><span class="s3">\n    </span><span class="s1">// Special part A</span><span class="s3">\n    </span><span class="s1">if (lenOut &gt; limit) {</span><span class="s3">\n      </span><span class="s1">lenOut = limit;</span><span class="s3">\n      </span><span class="s1">cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cRadius = radius;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">lenOut = Math.min(limit, radius);</span><span class="s3">\n    </span><span class="s1">cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n  </span><span class="s1">// Part 4</span><span class="s3">\n  </span><span class="s1">stopX = currentPoint.x + v2.nx * lenOut;</span><span class="s3">\n  </span><span class="s1">stopY = currentPoint.y + v2.ny * lenOut;</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n  </span><span class="s1">// Part 5</span><span class="s3">\n  </span><span class="s1">x = stopX - v2.ny * cRadius * radDirection;</span><span class="s3">\n  </span><span class="s1">y = stopY + v2.nx * cRadius * radDirection;</span><span class="s3">\n  </span><span class="s1">//-----------------------------------------</span><span class="s3">\n  </span><span class="s1">// Additional Part : calculate start point E</span><span class="s3">\n  </span><span class="s1">startX = currentPoint.x + v1.nx * lenOut;</span><span class="s3">\n  </span><span class="s1">startY = currentPoint.y + v1.ny * lenOut;</span><span class="s3">\n\n  </span><span class="s1">// Save last point to avoid recalculating vector when not needed</span><span class="s3">\n  </span><span class="s1">lastPoint = currentPoint;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Draw corner provided by {@link getRoundCorner}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param ctx :CanvasRenderingContext2D</span><span class="s3">\n </span><span class="s1">* @param roundCorner {{cx:number, cy:number, radius:number, endAngle: number, startAngle: number, counterClockwise: boolean}}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function drawPreparedRoundCorner(ctx, roundCorner) {</span><span class="s3">\n  </span><span class="s1">if (roundCorner.radius === 0) ctx.lineTo(roundCorner.cx, roundCorner.cy);else ctx.arc(roundCorner.cx, roundCorner.cy, roundCorner.radius, roundCorner.startAngle, roundCorner.endAngle, roundCorner.counterClockwise);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get round corner from a point and its previous and next neighbours in a path</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param previousPoint {{x: number, y:number, radius: number?}}</span><span class="s3">\n </span><span class="s1">* @param currentPoint {{x: number, y:number, radius: number?}}</span><span class="s3">\n </span><span class="s1">* @param nextPoint {{x: number, y:number, radius: number?}}</span><span class="s3">\n </span><span class="s1">* @param radiusMax :number</span><span class="s3">\n </span><span class="s1">* @param isArcRadius :boolean</span><span class="s3">\n </span><span class="s1">* @return {{</span><span class="s3">\n </span><span class="s1">* cx:number, cy:number, radius:number,</span><span class="s3">\n </span><span class="s1">* startX:number, startY:number,</span><span class="s3">\n </span><span class="s1">* stopX:number, stopY: number,</span><span class="s3">\n </span><span class="s1">* endAngle: number, startAngle: number, counterClockwise: boolean</span><span class="s3">\n </span><span class="s1">* }}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getRoundCorner(previousPoint, currentPoint, nextPoint, radiusMax) {</span><span class="s3">\n  </span><span class="s1">var isArcRadius = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true;</span><span class="s3">\n  </span><span class="s1">if (radiusMax === 0 || currentPoint.radius === 0) return {</span><span class="s3">\n    </span><span class="s1">cx: currentPoint.x,</span><span class="s3">\n    </span><span class="s1">cy: currentPoint.y,</span><span class="s3">\n    </span><span class="s1">radius: 0,</span><span class="s3">\n    </span><span class="s1">startX: currentPoint.x,</span><span class="s3">\n    </span><span class="s1">startY: currentPoint.y,</span><span class="s3">\n    </span><span class="s1">stopX: currentPoint.x,</span><span class="s3">\n    </span><span class="s1">stopY: currentPoint.y,</span><span class="s3">\n    </span><span class="s1">startAngle: undefined,</span><span class="s3">\n    </span><span class="s1">endAngle: undefined,</span><span class="s3">\n    </span><span class="s1">counterClockwise: undefined</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius);</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">cx: x,</span><span class="s3">\n    </span><span class="s1">cy: y,</span><span class="s3">\n    </span><span class="s1">radius: cRadius,</span><span class="s3">\n    </span><span class="s1">startX: startX,</span><span class="s3">\n    </span><span class="s1">startY: startY,</span><span class="s3">\n    </span><span class="s1">stopX: stopX,</span><span class="s3">\n    </span><span class="s1">stopY: stopY,</span><span class="s3">\n    </span><span class="s1">startAngle: v1.ang + Math.PI / 2 * radDirection,</span><span class="s3">\n    </span><span class="s1">endAngle: v2.ang - Math.PI / 2 * radDirection,</span><span class="s3">\n    </span><span class="s1">counterClockwise: drawDirection</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var BRp$c = {};</span><span class="s3">\n</span><span class="s1">BRp$c.findMidptPtsEtc = function (edge, pairInfo) {</span><span class="s3">\n  </span><span class="s1">var posPts = pairInfo.posPts,</span><span class="s3">\n    </span><span class="s1">intersectionPts = pairInfo.intersectionPts,</span><span class="s3">\n    </span><span class="s1">vectorNormInverse = pairInfo.vectorNormInverse;</span><span class="s3">\n  </span><span class="s1">var midptPts;</span><span class="s3">\n\n  </span><span class="s1">// n.b. assumes all edges in bezier bundle have same endpoints specified</span><span class="s3">\n  </span><span class="s1">var srcManEndpt = edge.pstyle('source-endpoint');</span><span class="s3">\n  </span><span class="s1">var tgtManEndpt = edge.pstyle('target-endpoint');</span><span class="s3">\n  </span><span class="s1">var haveManualEndPts = srcManEndpt.units != null &amp;&amp; tgtManEndpt.units != null;</span><span class="s3">\n  </span><span class="s1">var recalcVectorNormInverse = function recalcVectorNormInverse(x1, y1, x2, y2) {</span><span class="s3">\n    </span><span class="s1">var dy = y2 - y1;</span><span class="s3">\n    </span><span class="s1">var dx = x2 - x1;</span><span class="s3">\n    </span><span class="s1">var l = Math.sqrt(dx * dx + dy * dy);</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: -dy / l,</span><span class="s3">\n      </span><span class="s1">y: dx / l</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var edgeDistances = edge.pstyle('edge-distances').value;</span><span class="s3">\n  </span><span class="s1">switch (edgeDistances) {</span><span class="s3">\n    </span><span class="s1">case 'node-position':</span><span class="s3">\n      </span><span class="s1">midptPts = posPts;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'intersection':</span><span class="s3">\n      </span><span class="s1">midptPts = intersectionPts;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'endpoints':</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">if (haveManualEndPts) {</span><span class="s3">\n          </span><span class="s1">var _this$manualEndptToPx = this.manualEndptToPx(edge.source()[0], srcManEndpt),</span><span class="s3">\n            </span><span class="s1">_this$manualEndptToPx2 = _slicedToArray(_this$manualEndptToPx, 2),</span><span class="s3">\n            </span><span class="s1">x1 = _this$manualEndptToPx2[0],</span><span class="s3">\n            </span><span class="s1">y1 = _this$manualEndptToPx2[1];</span><span class="s3">\n          </span><span class="s1">var _this$manualEndptToPx3 = this.manualEndptToPx(edge.target()[0], tgtManEndpt),</span><span class="s3">\n            </span><span class="s1">_this$manualEndptToPx4 = _slicedToArray(_this$manualEndptToPx3, 2),</span><span class="s3">\n            </span><span class="s1">x2 = _this$manualEndptToPx4[0],</span><span class="s3">\n            </span><span class="s1">y2 = _this$manualEndptToPx4[1];</span><span class="s3">\n          </span><span class="s1">var endPts = {</span><span class="s3">\n            </span><span class="s1">x1: x1,</span><span class="s3">\n            </span><span class="s1">y1: y1,</span><span class="s3">\n            </span><span class="s1">x2: x2,</span><span class="s3">\n            </span><span class="s1">y2: y2</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">vectorNormInverse = recalcVectorNormInverse(x1, y1, x2, y2);</span><span class="s3">\n          </span><span class="s1">midptPts = endPts;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">warn(</span><span class="s3">\&quot;</span><span class="s1">Edge </span><span class="s3">\&quot;</span><span class="s1">.concat(edge.id(), </span><span class="s3">\&quot; </span><span class="s1">has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n          </span><span class="s1">midptPts = intersectionPts; // back to default</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">midptPts: midptPts,</span><span class="s3">\n    </span><span class="s1">vectorNormInverse: vectorNormInverse</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findHaystackPoints = function (edges) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n    </span><span class="s1">var _p = edge._private;</span><span class="s3">\n    </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n    </span><span class="s1">if (!rs.haystack) {</span><span class="s3">\n      </span><span class="s1">var angle = Math.random() * 2 * Math.PI;</span><span class="s3">\n      </span><span class="s1">rs.source = {</span><span class="s3">\n        </span><span class="s1">x: Math.cos(angle),</span><span class="s3">\n        </span><span class="s1">y: Math.sin(angle)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">angle = Math.random() * 2 * Math.PI;</span><span class="s3">\n      </span><span class="s1">rs.target = {</span><span class="s3">\n        </span><span class="s1">x: Math.cos(angle),</span><span class="s3">\n        </span><span class="s1">y: Math.sin(angle)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var src = _p.source;</span><span class="s3">\n    </span><span class="s1">var tgt = _p.target;</span><span class="s3">\n    </span><span class="s1">var srcPos = src.position();</span><span class="s3">\n    </span><span class="s1">var tgtPos = tgt.position();</span><span class="s3">\n    </span><span class="s1">var srcW = src.width();</span><span class="s3">\n    </span><span class="s1">var tgtW = tgt.width();</span><span class="s3">\n    </span><span class="s1">var srcH = src.height();</span><span class="s3">\n    </span><span class="s1">var tgtH = tgt.height();</span><span class="s3">\n    </span><span class="s1">var radius = edge.pstyle('haystack-radius').value;</span><span class="s3">\n    </span><span class="s1">var halfRadius = radius / 2; // b/c have to half width/height</span><span class="s3">\n\n    </span><span class="s1">rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];</span><span class="s3">\n    </span><span class="s1">rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;</span><span class="s3">\n    </span><span class="s1">rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;</span><span class="s3">\n\n    </span><span class="s1">// always override as haystack in case set to different type previously</span><span class="s3">\n    </span><span class="s1">rs.edgeType = 'haystack';</span><span class="s3">\n    </span><span class="s1">rs.haystack = true;</span><span class="s3">\n    </span><span class="s1">this.storeEdgeProjections(edge);</span><span class="s3">\n    </span><span class="s1">this.calculateArrowAngles(edge);</span><span class="s3">\n    </span><span class="s1">this.recalculateEdgeLabelProjections(edge);</span><span class="s3">\n    </span><span class="s1">this.calculateLabelAngles(edge);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findSegmentsPoints = function (edge, pairInfo) {</span><span class="s3">\n  </span><span class="s1">// Segments (multiple straight lines)</span><span class="s3">\n\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var segmentWs = edge.pstyle('segment-weights');</span><span class="s3">\n  </span><span class="s1">var segmentDs = edge.pstyle('segment-distances');</span><span class="s3">\n  </span><span class="s1">var segmentRs = edge.pstyle('segment-radii');</span><span class="s3">\n  </span><span class="s1">var segmentTs = edge.pstyle('radius-type');</span><span class="s3">\n  </span><span class="s1">var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);</span><span class="s3">\n  </span><span class="s1">var lastRadius = segmentRs.pfValue[segmentRs.pfValue.length - 1];</span><span class="s3">\n  </span><span class="s1">var lastRadiusType = segmentTs.pfValue[segmentTs.pfValue.length - 1];</span><span class="s3">\n  </span><span class="s1">rs.edgeType = 'segments';</span><span class="s3">\n  </span><span class="s1">rs.segpts = [];</span><span class="s3">\n  </span><span class="s1">rs.radii = [];</span><span class="s3">\n  </span><span class="s1">rs.isArcRadius = [];</span><span class="s3">\n  </span><span class="s1">for (var s = 0; s &lt; segmentsN; s++) {</span><span class="s3">\n    </span><span class="s1">var w = segmentWs.pfValue[s];</span><span class="s3">\n    </span><span class="s1">var d = segmentDs.pfValue[s];</span><span class="s3">\n    </span><span class="s1">var w1 = 1 - w;</span><span class="s3">\n    </span><span class="s1">var w2 = w;</span><span class="s3">\n    </span><span class="s1">var _this$findMidptPtsEtc = this.findMidptPtsEtc(edge, pairInfo),</span><span class="s3">\n      </span><span class="s1">midptPts = _this$findMidptPtsEtc.midptPts,</span><span class="s3">\n      </span><span class="s1">vectorNormInverse = _this$findMidptPtsEtc.vectorNormInverse;</span><span class="s3">\n    </span><span class="s1">var adjustedMidpt = {</span><span class="s3">\n      </span><span class="s1">x: midptPts.x1 * w1 + midptPts.x2 * w2,</span><span class="s3">\n      </span><span class="s1">y: midptPts.y1 * w1 + midptPts.y2 * w2</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);</span><span class="s3">\n    </span><span class="s1">rs.radii.push(segmentRs.pfValue[s] !== undefined ? segmentRs.pfValue[s] : lastRadius);</span><span class="s3">\n    </span><span class="s1">rs.isArcRadius.push((segmentTs.pfValue[s] !== undefined ? segmentTs.pfValue[s] : lastRadiusType) === 'arc-radius');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {</span><span class="s3">\n  </span><span class="s1">// Self-edge</span><span class="s3">\n\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var dirCounts = pairInfo.dirCounts,</span><span class="s3">\n    </span><span class="s1">srcPos = pairInfo.srcPos;</span><span class="s3">\n  </span><span class="s1">var ctrlptDists = edge.pstyle('control-point-distances');</span><span class="s3">\n  </span><span class="s1">var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;</span><span class="s3">\n  </span><span class="s1">var loopDir = edge.pstyle('loop-direction').pfValue;</span><span class="s3">\n  </span><span class="s1">var loopSwp = edge.pstyle('loop-sweep').pfValue;</span><span class="s3">\n  </span><span class="s1">var stepSize = edge.pstyle('control-point-step-size').pfValue;</span><span class="s3">\n  </span><span class="s1">rs.edgeType = 'self';</span><span class="s3">\n  </span><span class="s1">var j = i;</span><span class="s3">\n  </span><span class="s1">var loopDist = stepSize;</span><span class="s3">\n  </span><span class="s1">if (edgeIsUnbundled) {</span><span class="s3">\n    </span><span class="s1">j = 0;</span><span class="s3">\n    </span><span class="s1">loopDist = ctrlptDist;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var loopAngle = loopDir - Math.PI / 2;</span><span class="s3">\n  </span><span class="s1">var outAngle = loopAngle - loopSwp / 2;</span><span class="s3">\n  </span><span class="s1">var inAngle = loopAngle + loopSwp / 2;</span><span class="s3">\n\n  </span><span class="s1">// increase by step size for overlapping loops, keyed on direction and sweep values</span><span class="s3">\n  </span><span class="s1">var dc = String(loopDir + '_' + loopSwp);</span><span class="s3">\n  </span><span class="s1">j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];</span><span class="s3">\n  </span><span class="s1">rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {</span><span class="s3">\n  </span><span class="s1">// Compound edge</span><span class="s3">\n\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">rs.edgeType = 'compound';</span><span class="s3">\n  </span><span class="s1">var srcPos = pairInfo.srcPos,</span><span class="s3">\n    </span><span class="s1">tgtPos = pairInfo.tgtPos,</span><span class="s3">\n    </span><span class="s1">srcW = pairInfo.srcW,</span><span class="s3">\n    </span><span class="s1">srcH = pairInfo.srcH,</span><span class="s3">\n    </span><span class="s1">tgtW = pairInfo.tgtW,</span><span class="s3">\n    </span><span class="s1">tgtH = pairInfo.tgtH;</span><span class="s3">\n  </span><span class="s1">var stepSize = edge.pstyle('control-point-step-size').pfValue;</span><span class="s3">\n  </span><span class="s1">var ctrlptDists = edge.pstyle('control-point-distances');</span><span class="s3">\n  </span><span class="s1">var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;</span><span class="s3">\n  </span><span class="s1">var j = i;</span><span class="s3">\n  </span><span class="s1">var loopDist = stepSize;</span><span class="s3">\n  </span><span class="s1">if (edgeIsUnbundled) {</span><span class="s3">\n    </span><span class="s1">j = 0;</span><span class="s3">\n    </span><span class="s1">loopDist = ctrlptDist;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var loopW = 50;</span><span class="s3">\n  </span><span class="s1">var loopaPos = {</span><span class="s3">\n    </span><span class="s1">x: srcPos.x - srcW / 2,</span><span class="s3">\n    </span><span class="s1">y: srcPos.y - srcH / 2</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var loopbPos = {</span><span class="s3">\n    </span><span class="s1">x: tgtPos.x - tgtW / 2,</span><span class="s3">\n    </span><span class="s1">y: tgtPos.y - tgtH / 2</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var loopPos = {</span><span class="s3">\n    </span><span class="s1">x: Math.min(loopaPos.x, loopbPos.x),</span><span class="s3">\n    </span><span class="s1">y: Math.min(loopaPos.y, loopbPos.y)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// avoids cases with impossible beziers</span><span class="s3">\n  </span><span class="s1">var minCompoundStretch = 0.5;</span><span class="s3">\n  </span><span class="s1">var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));</span><span class="s3">\n  </span><span class="s1">var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));</span><span class="s3">\n  </span><span class="s1">rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findStraightEdgePoints = function (edge) {</span><span class="s3">\n  </span><span class="s1">// Straight edge within bundle</span><span class="s3">\n\n  </span><span class="s1">edge._private.rscratch.edgeType = 'straight';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var stepSize = edge.pstyle('control-point-step-size').pfValue;</span><span class="s3">\n  </span><span class="s1">var ctrlptDists = edge.pstyle('control-point-distances');</span><span class="s3">\n  </span><span class="s1">var ctrlptWs = edge.pstyle('control-point-weights');</span><span class="s3">\n  </span><span class="s1">var bezierN = ctrlptDists &amp;&amp; ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;</span><span class="s3">\n  </span><span class="s1">var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;</span><span class="s3">\n  </span><span class="s1">var ctrlptWeight = ctrlptWs.value[0];</span><span class="s3">\n\n  </span><span class="s1">// (Multi)bezier</span><span class="s3">\n\n  </span><span class="s1">var multi = edgeIsUnbundled;</span><span class="s3">\n  </span><span class="s1">rs.edgeType = multi ? 'multibezier' : 'bezier';</span><span class="s3">\n  </span><span class="s1">rs.ctrlpts = [];</span><span class="s3">\n  </span><span class="s1">for (var b = 0; b &lt; bezierN; b++) {</span><span class="s3">\n    </span><span class="s1">var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">var manctrlptDist = undefined;</span><span class="s3">\n    </span><span class="s1">var sign = signum(normctrlptDist);</span><span class="s3">\n    </span><span class="s1">if (multi) {</span><span class="s3">\n      </span><span class="s1">ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size</span><span class="s3">\n      </span><span class="s1">ctrlptWeight = ctrlptWs.value[b];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (edgeIsUnbundled) {</span><span class="s3">\n      </span><span class="s1">// multi or single unbundled</span><span class="s3">\n      </span><span class="s1">manctrlptDist = ctrlptDist;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;</span><span class="s3">\n    </span><span class="s1">var w1 = 1 - ctrlptWeight;</span><span class="s3">\n    </span><span class="s1">var w2 = ctrlptWeight;</span><span class="s3">\n    </span><span class="s1">var _this$findMidptPtsEtc2 = this.findMidptPtsEtc(edge, pairInfo),</span><span class="s3">\n      </span><span class="s1">midptPts = _this$findMidptPtsEtc2.midptPts,</span><span class="s3">\n      </span><span class="s1">vectorNormInverse = _this$findMidptPtsEtc2.vectorNormInverse;</span><span class="s3">\n    </span><span class="s1">var adjustedMidpt = {</span><span class="s3">\n      </span><span class="s1">x: midptPts.x1 * w1 + midptPts.x2 * w2,</span><span class="s3">\n      </span><span class="s1">y: midptPts.y1 * w1 + midptPts.y2 * w2</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findTaxiPoints = function (edge, pairInfo) {</span><span class="s3">\n  </span><span class="s1">// Taxicab geometry with two turns maximum</span><span class="s3">\n\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">rs.edgeType = 'segments';</span><span class="s3">\n  </span><span class="s1">var VERTICAL = 'vertical';</span><span class="s3">\n  </span><span class="s1">var HORIZONTAL = 'horizontal';</span><span class="s3">\n  </span><span class="s1">var LEFTWARD = 'leftward';</span><span class="s3">\n  </span><span class="s1">var RIGHTWARD = 'rightward';</span><span class="s3">\n  </span><span class="s1">var DOWNWARD = 'downward';</span><span class="s3">\n  </span><span class="s1">var UPWARD = 'upward';</span><span class="s3">\n  </span><span class="s1">var AUTO = 'auto';</span><span class="s3">\n  </span><span class="s1">var posPts = pairInfo.posPts,</span><span class="s3">\n    </span><span class="s1">srcW = pairInfo.srcW,</span><span class="s3">\n    </span><span class="s1">srcH = pairInfo.srcH,</span><span class="s3">\n    </span><span class="s1">tgtW = pairInfo.tgtW,</span><span class="s3">\n    </span><span class="s1">tgtH = pairInfo.tgtH;</span><span class="s3">\n  </span><span class="s1">var edgeDistances = edge.pstyle('edge-distances').value;</span><span class="s3">\n  </span><span class="s1">var dIncludesNodeBody = edgeDistances !== 'node-position';</span><span class="s3">\n  </span><span class="s1">var taxiDir = edge.pstyle('taxi-direction').value;</span><span class="s3">\n  </span><span class="s1">var rawTaxiDir = taxiDir; // unprocessed value</span><span class="s3">\n  </span><span class="s1">var taxiTurn = edge.pstyle('taxi-turn');</span><span class="s3">\n  </span><span class="s1">var turnIsPercent = taxiTurn.units === '%';</span><span class="s3">\n  </span><span class="s1">var taxiTurnPfVal = taxiTurn.pfValue;</span><span class="s3">\n  </span><span class="s1">var turnIsNegative = taxiTurnPfVal &lt; 0; // i.e. from target side</span><span class="s3">\n  </span><span class="s1">var minD = edge.pstyle('taxi-turn-min-distance').pfValue;</span><span class="s3">\n  </span><span class="s1">var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;</span><span class="s3">\n  </span><span class="s1">var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;</span><span class="s3">\n  </span><span class="s1">var pdx = posPts.x2 - posPts.x1;</span><span class="s3">\n  </span><span class="s1">var pdy = posPts.y2 - posPts.y1;</span><span class="s3">\n\n  </span><span class="s1">// take away the effective w/h from the magnitude of the delta value</span><span class="s3">\n  </span><span class="s1">var subDWH = function subDWH(dxy, dwh) {</span><span class="s3">\n    </span><span class="s1">if (dxy &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return Math.max(dxy - dwh, 0);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return Math.min(dxy + dwh, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var dx = subDWH(pdx, dw);</span><span class="s3">\n  </span><span class="s1">var dy = subDWH(pdy, dh);</span><span class="s3">\n  </span><span class="s1">var isExplicitDir = false;</span><span class="s3">\n  </span><span class="s1">if (rawTaxiDir === AUTO) {</span><span class="s3">\n    </span><span class="s1">taxiDir = Math.abs(dx) &gt; Math.abs(dy) ? HORIZONTAL : VERTICAL;</span><span class="s3">\n  </span><span class="s1">} else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {</span><span class="s3">\n    </span><span class="s1">taxiDir = VERTICAL;</span><span class="s3">\n    </span><span class="s1">isExplicitDir = true;</span><span class="s3">\n  </span><span class="s1">} else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {</span><span class="s3">\n    </span><span class="s1">taxiDir = HORIZONTAL;</span><span class="s3">\n    </span><span class="s1">isExplicitDir = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var isVert = taxiDir === VERTICAL;</span><span class="s3">\n  </span><span class="s1">var l = isVert ? dy : dx;</span><span class="s3">\n  </span><span class="s1">var pl = isVert ? pdy : pdx;</span><span class="s3">\n  </span><span class="s1">var sgnL = signum(pl);</span><span class="s3">\n  </span><span class="s1">var forcedDir = false;</span><span class="s3">\n  </span><span class="s1">if (!(isExplicitDir &amp;&amp; (turnIsPercent || turnIsNegative)) // forcing in this case would cause weird growing in the opposite direction</span><span class="s3">\n  </span><span class="s1">&amp;&amp; (rawTaxiDir === DOWNWARD &amp;&amp; pl &lt; 0 || rawTaxiDir === UPWARD &amp;&amp; pl &gt; 0 || rawTaxiDir === LEFTWARD &amp;&amp; pl &gt; 0 || rawTaxiDir === RIGHTWARD &amp;&amp; pl &lt; 0)) {</span><span class="s3">\n    </span><span class="s1">sgnL *= -1;</span><span class="s3">\n    </span><span class="s1">l = sgnL * Math.abs(l);</span><span class="s3">\n    </span><span class="s1">forcedDir = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var d;</span><span class="s3">\n  </span><span class="s1">if (turnIsPercent) {</span><span class="s3">\n    </span><span class="s1">var p = taxiTurnPfVal &lt; 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;</span><span class="s3">\n    </span><span class="s1">d = p * l;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var k = taxiTurnPfVal &lt; 0 ? l : 0;</span><span class="s3">\n    </span><span class="s1">d = k + taxiTurnPfVal * sgnL;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var getIsTooClose = function getIsTooClose(d) {</span><span class="s3">\n    </span><span class="s1">return Math.abs(d) &lt; minD || Math.abs(d) &gt;= Math.abs(l);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var isTooCloseSrc = getIsTooClose(d);</span><span class="s3">\n  </span><span class="s1">var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));</span><span class="s3">\n  </span><span class="s1">var isTooClose = isTooCloseSrc || isTooCloseTgt;</span><span class="s3">\n  </span><span class="s1">if (isTooClose &amp;&amp; !forcedDir) {</span><span class="s3">\n    </span><span class="s1">// non-ideal routing</span><span class="s3">\n    </span><span class="s1">if (isVert) {</span><span class="s3">\n      </span><span class="s1">// vertical fallbacks</span><span class="s3">\n      </span><span class="s1">var lShapeInsideSrc = Math.abs(pl) &lt;= srcH / 2;</span><span class="s3">\n      </span><span class="s1">var lShapeInsideTgt = Math.abs(pdx) &lt;= tgtW / 2;</span><span class="s3">\n      </span><span class="s1">if (lShapeInsideSrc) {</span><span class="s3">\n        </span><span class="s1">// horizontal Z-shape (direction not respected)</span><span class="s3">\n        </span><span class="s1">var x = (posPts.x1 + posPts.x2) / 2;</span><span class="s3">\n        </span><span class="s1">var y1 = posPts.y1,</span><span class="s3">\n          </span><span class="s1">y2 = posPts.y2;</span><span class="s3">\n        </span><span class="s1">rs.segpts = [x, y1, x, y2];</span><span class="s3">\n      </span><span class="s1">} else if (lShapeInsideTgt) {</span><span class="s3">\n        </span><span class="s1">// vertical Z-shape (distance not respected)</span><span class="s3">\n        </span><span class="s1">var y = (posPts.y1 + posPts.y2) / 2;</span><span class="s3">\n        </span><span class="s1">var x1 = posPts.x1,</span><span class="s3">\n          </span><span class="s1">x2 = posPts.x2;</span><span class="s3">\n        </span><span class="s1">rs.segpts = [x1, y, x2, y];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// L-shape fallback (turn distance not respected, but works well with tree siblings)</span><span class="s3">\n        </span><span class="s1">rs.segpts = [posPts.x1, posPts.y2];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// horizontal fallbacks</span><span class="s3">\n      </span><span class="s1">var _lShapeInsideSrc = Math.abs(pl) &lt;= srcW / 2;</span><span class="s3">\n      </span><span class="s1">var _lShapeInsideTgt = Math.abs(pdy) &lt;= tgtH / 2;</span><span class="s3">\n      </span><span class="s1">if (_lShapeInsideSrc) {</span><span class="s3">\n        </span><span class="s1">// vertical Z-shape (direction not respected)</span><span class="s3">\n        </span><span class="s1">var _y = (posPts.y1 + posPts.y2) / 2;</span><span class="s3">\n        </span><span class="s1">var _x = posPts.x1,</span><span class="s3">\n          </span><span class="s1">_x2 = posPts.x2;</span><span class="s3">\n        </span><span class="s1">rs.segpts = [_x, _y, _x2, _y];</span><span class="s3">\n      </span><span class="s1">} else if (_lShapeInsideTgt) {</span><span class="s3">\n        </span><span class="s1">// horizontal Z-shape (turn distance not respected)</span><span class="s3">\n        </span><span class="s1">var _x3 = (posPts.x1 + posPts.x2) / 2;</span><span class="s3">\n        </span><span class="s1">var _y2 = posPts.y1,</span><span class="s3">\n          </span><span class="s1">_y3 = posPts.y2;</span><span class="s3">\n        </span><span class="s1">rs.segpts = [_x3, _y2, _x3, _y3];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// L-shape (turn distance not respected, but works well for tree siblings)</span><span class="s3">\n        </span><span class="s1">rs.segpts = [posPts.x2, posPts.y1];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// ideal routing</span><span class="s3">\n    </span><span class="s1">if (isVert) {</span><span class="s3">\n      </span><span class="s1">var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);</span><span class="s3">\n      </span><span class="s1">var _x4 = posPts.x1,</span><span class="s3">\n        </span><span class="s1">_x5 = posPts.x2;</span><span class="s3">\n      </span><span class="s1">rs.segpts = [_x4, _y4, _x5, _y4];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// horizontal</span><span class="s3">\n      </span><span class="s1">var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);</span><span class="s3">\n      </span><span class="s1">var _y5 = posPts.y1,</span><span class="s3">\n        </span><span class="s1">_y6 = posPts.y2;</span><span class="s3">\n      </span><span class="s1">rs.segpts = [_x6, _y5, _x6, _y6];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rs.isRound) {</span><span class="s3">\n    </span><span class="s1">var radius = edge.pstyle('taxi-radius').value;</span><span class="s3">\n    </span><span class="s1">var isArcRadius = edge.pstyle('radius-type').value[0] === 'arc-radius';</span><span class="s3">\n    </span><span class="s1">rs.radii = new Array(rs.segpts.length / 2).fill(radius);</span><span class="s3">\n    </span><span class="s1">rs.isArcRadius = new Array(rs.segpts.length / 2).fill(isArcRadius);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.tryToCorrectInvalidPoints = function (edge, pairInfo) {</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n\n  </span><span class="s1">// can only correct beziers for now...</span><span class="s3">\n  </span><span class="s1">if (rs.edgeType === 'bezier') {</span><span class="s3">\n    </span><span class="s1">var srcPos = pairInfo.srcPos,</span><span class="s3">\n      </span><span class="s1">tgtPos = pairInfo.tgtPos,</span><span class="s3">\n      </span><span class="s1">srcW = pairInfo.srcW,</span><span class="s3">\n      </span><span class="s1">srcH = pairInfo.srcH,</span><span class="s3">\n      </span><span class="s1">tgtW = pairInfo.tgtW,</span><span class="s3">\n      </span><span class="s1">tgtH = pairInfo.tgtH,</span><span class="s3">\n      </span><span class="s1">srcShape = pairInfo.srcShape,</span><span class="s3">\n      </span><span class="s1">tgtShape = pairInfo.tgtShape,</span><span class="s3">\n      </span><span class="s1">srcCornerRadius = pairInfo.srcCornerRadius,</span><span class="s3">\n      </span><span class="s1">tgtCornerRadius = pairInfo.tgtCornerRadius,</span><span class="s3">\n      </span><span class="s1">srcRs = pairInfo.srcRs,</span><span class="s3">\n      </span><span class="s1">tgtRs = pairInfo.tgtRs;</span><span class="s3">\n    </span><span class="s1">var badStart = !number$1(rs.startX) || !number$1(rs.startY);</span><span class="s3">\n    </span><span class="s1">var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);</span><span class="s3">\n    </span><span class="s1">var badEnd = !number$1(rs.endX) || !number$1(rs.endY);</span><span class="s3">\n    </span><span class="s1">var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);</span><span class="s3">\n    </span><span class="s1">var minCpADistFactor = 3;</span><span class="s3">\n    </span><span class="s1">var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;</span><span class="s3">\n    </span><span class="s1">var minCpADist = minCpADistFactor * arrowW;</span><span class="s3">\n    </span><span class="s1">var startACpDist = dist({</span><span class="s3">\n      </span><span class="s1">x: rs.ctrlpts[0],</span><span class="s3">\n      </span><span class="s1">y: rs.ctrlpts[1]</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">x: rs.startX,</span><span class="s3">\n      </span><span class="s1">y: rs.startY</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var closeStartACp = startACpDist &lt; minCpADist;</span><span class="s3">\n    </span><span class="s1">var endACpDist = dist({</span><span class="s3">\n      </span><span class="s1">x: rs.ctrlpts[0],</span><span class="s3">\n      </span><span class="s1">y: rs.ctrlpts[1]</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">x: rs.endX,</span><span class="s3">\n      </span><span class="s1">y: rs.endY</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var closeEndACp = endACpDist &lt; minCpADist;</span><span class="s3">\n    </span><span class="s1">var overlapping = false;</span><span class="s3">\n    </span><span class="s1">if (badStart || badAStart || closeStartACp) {</span><span class="s3">\n      </span><span class="s1">overlapping = true;</span><span class="s3">\n\n      </span><span class="s1">// project control point along line from src centre to outside the src shape</span><span class="s3">\n      </span><span class="s1">// (otherwise intersection will yield nothing)</span><span class="s3">\n      </span><span class="s1">var cpD = {</span><span class="s3">\n        </span><span class="s1">// delta</span><span class="s3">\n        </span><span class="s1">x: rs.ctrlpts[0] - srcPos.x,</span><span class="s3">\n        </span><span class="s1">y: rs.ctrlpts[1] - srcPos.y</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line</span><span class="s3">\n      </span><span class="s1">var cpM = {</span><span class="s3">\n        </span><span class="s1">// normalised delta</span><span class="s3">\n        </span><span class="s1">x: cpD.x / cpL,</span><span class="s3">\n        </span><span class="s1">y: cpD.y / cpL</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var radius = Math.max(srcW, srcH);</span><span class="s3">\n      </span><span class="s1">var cpProj = {</span><span class="s3">\n        </span><span class="s1">// *2 radius guarantees outside shape</span><span class="s3">\n        </span><span class="s1">x: rs.ctrlpts[0] + cpM.x * 2 * radius,</span><span class="s3">\n        </span><span class="s1">y: rs.ctrlpts[1] + cpM.y * 2 * radius</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0, srcCornerRadius, srcRs);</span><span class="s3">\n      </span><span class="s1">if (closeStartACp) {</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (badEnd || badAEnd || closeEndACp) {</span><span class="s3">\n      </span><span class="s1">overlapping = true;</span><span class="s3">\n\n      </span><span class="s1">// project control point along line from tgt centre to outside the tgt shape</span><span class="s3">\n      </span><span class="s1">// (otherwise intersection will yield nothing)</span><span class="s3">\n      </span><span class="s1">var _cpD = {</span><span class="s3">\n        </span><span class="s1">// delta</span><span class="s3">\n        </span><span class="s1">x: rs.ctrlpts[0] - tgtPos.x,</span><span class="s3">\n        </span><span class="s1">y: rs.ctrlpts[1] - tgtPos.y</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line</span><span class="s3">\n      </span><span class="s1">var _cpM = {</span><span class="s3">\n        </span><span class="s1">// normalised delta</span><span class="s3">\n        </span><span class="s1">x: _cpD.x / _cpL,</span><span class="s3">\n        </span><span class="s1">y: _cpD.y / _cpL</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var _radius = Math.max(srcW, srcH);</span><span class="s3">\n      </span><span class="s1">var _cpProj = {</span><span class="s3">\n        </span><span class="s1">// *2 radius guarantees outside shape</span><span class="s3">\n        </span><span class="s1">x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,</span><span class="s3">\n        </span><span class="s1">y: rs.ctrlpts[1] + _cpM.y * 2 * _radius</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0, tgtCornerRadius, tgtRs);</span><span class="s3">\n      </span><span class="s1">if (closeEndACp) {</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;</span><span class="s3">\n        </span><span class="s1">rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (overlapping) {</span><span class="s3">\n      </span><span class="s1">// recalc endpts</span><span class="s3">\n      </span><span class="s1">this.findEndpoints(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.storeAllpts = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {</span><span class="s3">\n    </span><span class="s1">rs.allpts = [];</span><span class="s3">\n    </span><span class="s1">rs.allpts.push(rs.startX, rs.startY);</span><span class="s3">\n    </span><span class="s1">for (var b = 0; b + 1 &lt; rs.ctrlpts.length; b += 2) {</span><span class="s3">\n      </span><span class="s1">// ctrl pt itself</span><span class="s3">\n      </span><span class="s1">rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);</span><span class="s3">\n\n      </span><span class="s1">// the midpt between ctrlpts as intermediate destination pts</span><span class="s3">\n      </span><span class="s1">if (b + 3 &lt; rs.ctrlpts.length) {</span><span class="s3">\n        </span><span class="s1">rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rs.allpts.push(rs.endX, rs.endY);</span><span class="s3">\n    </span><span class="s1">var m, mt;</span><span class="s3">\n    </span><span class="s1">if (rs.ctrlpts.length / 2 % 2 === 0) {</span><span class="s3">\n      </span><span class="s1">m = rs.allpts.length / 2 - 1;</span><span class="s3">\n      </span><span class="s1">rs.midX = rs.allpts[m];</span><span class="s3">\n      </span><span class="s1">rs.midY = rs.allpts[m + 1];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">m = rs.allpts.length / 2 - 3;</span><span class="s3">\n      </span><span class="s1">mt = 0.5;</span><span class="s3">\n      </span><span class="s1">rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);</span><span class="s3">\n      </span><span class="s1">rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (rs.edgeType === 'straight') {</span><span class="s3">\n    </span><span class="s1">// need to calc these after endpts</span><span class="s3">\n    </span><span class="s1">rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];</span><span class="s3">\n\n    </span><span class="s1">// default midpt for labels etc</span><span class="s3">\n    </span><span class="s1">rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;</span><span class="s3">\n    </span><span class="s1">rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;</span><span class="s3">\n  </span><span class="s1">} else if (rs.edgeType === 'segments') {</span><span class="s3">\n    </span><span class="s1">rs.allpts = [];</span><span class="s3">\n    </span><span class="s1">rs.allpts.push(rs.startX, rs.startY);</span><span class="s3">\n    </span><span class="s1">rs.allpts.push.apply(rs.allpts, rs.segpts);</span><span class="s3">\n    </span><span class="s1">rs.allpts.push(rs.endX, rs.endY);</span><span class="s3">\n    </span><span class="s1">if (rs.isRound) {</span><span class="s3">\n      </span><span class="s1">rs.roundCorners = [];</span><span class="s3">\n      </span><span class="s1">for (var i = 2; i + 3 &lt; rs.allpts.length; i += 2) {</span><span class="s3">\n        </span><span class="s1">var radius = rs.radii[i / 2 - 1];</span><span class="s3">\n        </span><span class="s1">var isArcRadius = rs.isArcRadius[i / 2 - 1];</span><span class="s3">\n        </span><span class="s1">rs.roundCorners.push(getRoundCorner({</span><span class="s3">\n          </span><span class="s1">x: rs.allpts[i - 2],</span><span class="s3">\n          </span><span class="s1">y: rs.allpts[i - 1]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: rs.allpts[i],</span><span class="s3">\n          </span><span class="s1">y: rs.allpts[i + 1],</span><span class="s3">\n          </span><span class="s1">radius: radius</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: rs.allpts[i + 2],</span><span class="s3">\n          </span><span class="s1">y: rs.allpts[i + 3]</span><span class="s3">\n        </span><span class="s1">}, radius, isArcRadius));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (rs.segpts.length % 4 === 0) {</span><span class="s3">\n      </span><span class="s1">var i2 = rs.segpts.length / 2;</span><span class="s3">\n      </span><span class="s1">var i1 = i2 - 2;</span><span class="s3">\n      </span><span class="s1">rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;</span><span class="s3">\n      </span><span class="s1">rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var _i = rs.segpts.length / 2 - 1;</span><span class="s3">\n      </span><span class="s1">if (!rs.isRound) {</span><span class="s3">\n        </span><span class="s1">rs.midX = rs.segpts[_i];</span><span class="s3">\n        </span><span class="s1">rs.midY = rs.segpts[_i + 1];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var point = {</span><span class="s3">\n          </span><span class="s1">x: rs.segpts[_i],</span><span class="s3">\n          </span><span class="s1">y: rs.segpts[_i + 1]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var corner = rs.roundCorners[_i / 2];</span><span class="s3">\n        </span><span class="s1">if (corner.radius === 0) {</span><span class="s3">\n          </span><span class="s1">// On collinear points</span><span class="s3">\n          </span><span class="s1">var nextPoint = {</span><span class="s3">\n            </span><span class="s1">x: rs.segpts[_i + 2],</span><span class="s3">\n            </span><span class="s1">y: rs.segpts[_i + 3]</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">rs.midX = point.x;</span><span class="s3">\n          </span><span class="s1">rs.midY = point.y;</span><span class="s3">\n          </span><span class="s1">rs.midVector = [point.y - nextPoint.y, nextPoint.x - point.x];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// On rounded points</span><span class="s3">\n          </span><span class="s1">var v = [point.x - corner.cx, point.y - corner.cy];</span><span class="s3">\n          </span><span class="s1">var factor = corner.radius / Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));</span><span class="s3">\n          </span><span class="s1">v = v.map(function (c) {</span><span class="s3">\n            </span><span class="s1">return c * factor;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">rs.midX = corner.cx + v[0];</span><span class="s3">\n          </span><span class="s1">rs.midY = corner.cy + v[1];</span><span class="s3">\n          </span><span class="s1">rs.midVector = v;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.checkForInvalidEdgeWarning = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge[0]._private.rscratch;</span><span class="s3">\n  </span><span class="s1">if (rs.nodesOverlap || number$1(rs.startX) &amp;&amp; number$1(rs.startY) &amp;&amp; number$1(rs.endX) &amp;&amp; number$1(rs.endY)) {</span><span class="s3">\n    </span><span class="s1">rs.loggedErr = false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (!rs.loggedErr) {</span><span class="s3">\n      </span><span class="s1">rs.loggedErr = true;</span><span class="s3">\n      </span><span class="s1">warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.findEdgeControlPoints = function (edges) {</span><span class="s3">\n  </span><span class="s1">var _this = this;</span><span class="s3">\n  </span><span class="s1">if (!edges || edges.length === 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n  </span><span class="s1">var hasCompounds = cy.hasCompoundNodes();</span><span class="s3">\n  </span><span class="s1">var hashTable = new Map$1();</span><span class="s3">\n  </span><span class="s1">var getKey = function getKey(pairId, edgeIsUnbundled) {</span><span class="s3">\n    </span><span class="s1">return [].concat(_toConsumableArray(pairId), [edgeIsUnbundled ? 1 : 0]).join('-');</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var pairIds = [];</span><span class="s3">\n  </span><span class="s1">var haystackEdges = [];</span><span class="s3">\n\n  </span><span class="s1">// create a table of edge (src, tgt) =&gt; list of edges between them</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n    </span><span class="s1">var _p = edge._private;</span><span class="s3">\n    </span><span class="s1">var curveStyle = edge.pstyle('curve-style').value;</span><span class="s3">\n\n    </span><span class="s1">// ignore edges who are not to be displayed</span><span class="s3">\n    </span><span class="s1">// they shouldn't take up space</span><span class="s3">\n    </span><span class="s1">if (edge.removed() || !edge.takesUpSpace()) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (curveStyle === 'haystack') {</span><span class="s3">\n      </span><span class="s1">haystackEdges.push(edge);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle.endsWith('segments') || curveStyle === 'straight' || curveStyle === 'straight-triangle' || curveStyle.endsWith('taxi');</span><span class="s3">\n    </span><span class="s1">var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';</span><span class="s3">\n    </span><span class="s1">var src = _p.source;</span><span class="s3">\n    </span><span class="s1">var tgt = _p.target;</span><span class="s3">\n    </span><span class="s1">var srcIndex = src.poolIndex();</span><span class="s3">\n    </span><span class="s1">var tgtIndex = tgt.poolIndex();</span><span class="s3">\n    </span><span class="s1">var pairId = [srcIndex, tgtIndex].sort();</span><span class="s3">\n    </span><span class="s1">var key = getKey(pairId, edgeIsUnbundled);</span><span class="s3">\n    </span><span class="s1">var tableEntry = hashTable.get(key);</span><span class="s3">\n    </span><span class="s1">if (tableEntry == null) {</span><span class="s3">\n      </span><span class="s1">tableEntry = {</span><span class="s3">\n        </span><span class="s1">eles: []</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">pairIds.push({</span><span class="s3">\n        </span><span class="s1">pairId: pairId,</span><span class="s3">\n        </span><span class="s1">edgeIsUnbundled: edgeIsUnbundled</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">hashTable.set(key, tableEntry);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tableEntry.eles.push(edge);</span><span class="s3">\n    </span><span class="s1">if (edgeIsUnbundled) {</span><span class="s3">\n      </span><span class="s1">tableEntry.hasUnbundled = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (edgeIsBezier) {</span><span class="s3">\n      </span><span class="s1">tableEntry.hasBezier = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// for each pair (src, tgt), create the ctrl pts</span><span class="s3">\n  </span><span class="s1">// Nested for loop is OK; total number of iterations for both loops = edgeCount</span><span class="s3">\n  </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n    </span><span class="s1">var _pairIds$p = pairIds[p],</span><span class="s3">\n      </span><span class="s1">pairId = _pairIds$p.pairId,</span><span class="s3">\n      </span><span class="s1">edgeIsUnbundled = _pairIds$p.edgeIsUnbundled;</span><span class="s3">\n    </span><span class="s1">var key = getKey(pairId, edgeIsUnbundled);</span><span class="s3">\n    </span><span class="s1">var pairInfo = hashTable.get(key);</span><span class="s3">\n    </span><span class="s1">var swappedpairInfo;</span><span class="s3">\n    </span><span class="s1">if (!pairInfo.hasUnbundled) {</span><span class="s3">\n      </span><span class="s1">var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {</span><span class="s3">\n        </span><span class="s1">return e.isBundledBezier();</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">clearArray(pairInfo.eles);</span><span class="s3">\n      </span><span class="s1">pllEdges.forEach(function (edge) {</span><span class="s3">\n        </span><span class="s1">return pairInfo.eles.push(edge);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// for each pair id, the edges should be sorted by index</span><span class="s3">\n      </span><span class="s1">pairInfo.eles.sort(function (edge1, edge2) {</span><span class="s3">\n        </span><span class="s1">return edge1.poolIndex() - edge2.poolIndex();</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var firstEdge = pairInfo.eles[0];</span><span class="s3">\n    </span><span class="s1">var src = firstEdge.source();</span><span class="s3">\n    </span><span class="s1">var tgt = firstEdge.target();</span><span class="s3">\n\n    </span><span class="s1">// make sure src/tgt distinction is consistent w.r.t. pairId</span><span class="s3">\n    </span><span class="s1">if (src.poolIndex() &gt; tgt.poolIndex()) {</span><span class="s3">\n      </span><span class="s1">var temp = src;</span><span class="s3">\n      </span><span class="s1">src = tgt;</span><span class="s3">\n      </span><span class="s1">tgt = temp;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var srcPos = pairInfo.srcPos = src.position();</span><span class="s3">\n    </span><span class="s1">var tgtPos = pairInfo.tgtPos = tgt.position();</span><span class="s3">\n    </span><span class="s1">var srcW = pairInfo.srcW = src.outerWidth();</span><span class="s3">\n    </span><span class="s1">var srcH = pairInfo.srcH = src.outerHeight();</span><span class="s3">\n    </span><span class="s1">var tgtW = pairInfo.tgtW = tgt.outerWidth();</span><span class="s3">\n    </span><span class="s1">var tgtH = pairInfo.tgtH = tgt.outerHeight();</span><span class="s3">\n    </span><span class="s1">var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];</span><span class="s3">\n    </span><span class="s1">var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];</span><span class="s3">\n    </span><span class="s1">var srcCornerRadius = pairInfo.srcCornerRadius = src.pstyle('corner-radius').value === 'auto' ? 'auto' : src.pstyle('corner-radius').pfValue;</span><span class="s3">\n    </span><span class="s1">var tgtCornerRadius = pairInfo.tgtCornerRadius = tgt.pstyle('corner-radius').value === 'auto' ? 'auto' : tgt.pstyle('corner-radius').pfValue;</span><span class="s3">\n    </span><span class="s1">var tgtRs = pairInfo.tgtRs = tgt._private.rscratch;</span><span class="s3">\n    </span><span class="s1">var srcRs = pairInfo.srcRs = src._private.rscratch;</span><span class="s3">\n    </span><span class="s1">pairInfo.dirCounts = {</span><span class="s3">\n      </span><span class="s1">'north': 0,</span><span class="s3">\n      </span><span class="s1">'west': 0,</span><span class="s3">\n      </span><span class="s1">'south': 0,</span><span class="s3">\n      </span><span class="s1">'east': 0,</span><span class="s3">\n      </span><span class="s1">'northwest': 0,</span><span class="s3">\n      </span><span class="s1">'southwest': 0,</span><span class="s3">\n      </span><span class="s1">'northeast': 0,</span><span class="s3">\n      </span><span class="s1">'southeast': 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (var _i2 = 0; _i2 &lt; pairInfo.eles.length; _i2++) {</span><span class="s3">\n      </span><span class="s1">var _edge = pairInfo.eles[_i2];</span><span class="s3">\n      </span><span class="s1">var rs = _edge[0]._private.rscratch;</span><span class="s3">\n      </span><span class="s1">var _curveStyle = _edge.pstyle('curve-style').value;</span><span class="s3">\n      </span><span class="s1">var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle.endsWith('segments') || _curveStyle.endsWith('taxi');</span><span class="s3">\n\n      </span><span class="s1">// whether the normalised pair order is the reverse of the edge's src-tgt order</span><span class="s3">\n      </span><span class="s1">var edgeIsSwapped = !src.same(_edge.source());</span><span class="s3">\n      </span><span class="s1">if (!pairInfo.calculatedIntersection &amp;&amp; src !== tgt &amp;&amp; (pairInfo.hasBezier || pairInfo.hasUnbundled)) {</span><span class="s3">\n        </span><span class="s1">pairInfo.calculatedIntersection = true;</span><span class="s3">\n\n        </span><span class="s1">// pt outside src shape to calc distance/displacement from src to tgt</span><span class="s3">\n        </span><span class="s1">var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0, srcCornerRadius, srcRs);</span><span class="s3">\n        </span><span class="s1">var srcIntn = pairInfo.srcIntn = srcOutside;</span><span class="s3">\n\n        </span><span class="s1">// pt outside tgt shape to calc distance/displacement from src to tgt</span><span class="s3">\n        </span><span class="s1">var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0, tgtCornerRadius, tgtRs);</span><span class="s3">\n        </span><span class="s1">var tgtIntn = pairInfo.tgtIntn = tgtOutside;</span><span class="s3">\n        </span><span class="s1">var intersectionPts = pairInfo.intersectionPts = {</span><span class="s3">\n          </span><span class="s1">x1: srcOutside[0],</span><span class="s3">\n          </span><span class="s1">x2: tgtOutside[0],</span><span class="s3">\n          </span><span class="s1">y1: srcOutside[1],</span><span class="s3">\n          </span><span class="s1">y2: tgtOutside[1]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var posPts = pairInfo.posPts = {</span><span class="s3">\n          </span><span class="s1">x1: srcPos.x,</span><span class="s3">\n          </span><span class="s1">x2: tgtPos.x,</span><span class="s3">\n          </span><span class="s1">y1: srcPos.y,</span><span class="s3">\n          </span><span class="s1">y2: tgtPos.y</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var dy = tgtOutside[1] - srcOutside[1];</span><span class="s3">\n        </span><span class="s1">var dx = tgtOutside[0] - srcOutside[0];</span><span class="s3">\n        </span><span class="s1">var l = Math.sqrt(dx * dx + dy * dy);</span><span class="s3">\n        </span><span class="s1">var vector = pairInfo.vector = {</span><span class="s3">\n          </span><span class="s1">x: dx,</span><span class="s3">\n          </span><span class="s1">y: dy</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var vectorNorm = pairInfo.vectorNorm = {</span><span class="s3">\n          </span><span class="s1">x: vector.x / l,</span><span class="s3">\n          </span><span class="s1">y: vector.y / l</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">var vectorNormInverse = {</span><span class="s3">\n          </span><span class="s1">x: -vectorNorm.y,</span><span class="s3">\n          </span><span class="s1">y: vectorNorm.x</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">// if node shapes overlap, then no ctrl pts to draw</span><span class="s3">\n        </span><span class="s1">pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y, tgtCornerRadius, tgtRs) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y, srcCornerRadius, srcRs);</span><span class="s3">\n        </span><span class="s1">pairInfo.vectorNormInverse = vectorNormInverse;</span><span class="s3">\n        </span><span class="s1">swappedpairInfo = {</span><span class="s3">\n          </span><span class="s1">nodesOverlap: pairInfo.nodesOverlap,</span><span class="s3">\n          </span><span class="s1">dirCounts: pairInfo.dirCounts,</span><span class="s3">\n          </span><span class="s1">calculatedIntersection: true,</span><span class="s3">\n          </span><span class="s1">hasBezier: pairInfo.hasBezier,</span><span class="s3">\n          </span><span class="s1">hasUnbundled: pairInfo.hasUnbundled,</span><span class="s3">\n          </span><span class="s1">eles: pairInfo.eles,</span><span class="s3">\n          </span><span class="s1">srcPos: tgtPos,</span><span class="s3">\n          </span><span class="s1">srcRs: tgtRs,</span><span class="s3">\n          </span><span class="s1">tgtPos: srcPos,</span><span class="s3">\n          </span><span class="s1">tgtRs: srcRs,</span><span class="s3">\n          </span><span class="s1">srcW: tgtW,</span><span class="s3">\n          </span><span class="s1">srcH: tgtH,</span><span class="s3">\n          </span><span class="s1">tgtW: srcW,</span><span class="s3">\n          </span><span class="s1">tgtH: srcH,</span><span class="s3">\n          </span><span class="s1">srcIntn: tgtIntn,</span><span class="s3">\n          </span><span class="s1">tgtIntn: srcIntn,</span><span class="s3">\n          </span><span class="s1">srcShape: tgtShape,</span><span class="s3">\n          </span><span class="s1">tgtShape: srcShape,</span><span class="s3">\n          </span><span class="s1">posPts: {</span><span class="s3">\n            </span><span class="s1">x1: posPts.x2,</span><span class="s3">\n            </span><span class="s1">y1: posPts.y2,</span><span class="s3">\n            </span><span class="s1">x2: posPts.x1,</span><span class="s3">\n            </span><span class="s1">y2: posPts.y1</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">intersectionPts: {</span><span class="s3">\n            </span><span class="s1">x1: intersectionPts.x2,</span><span class="s3">\n            </span><span class="s1">y1: intersectionPts.y2,</span><span class="s3">\n            </span><span class="s1">x2: intersectionPts.x1,</span><span class="s3">\n            </span><span class="s1">y2: intersectionPts.y1</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">vector: {</span><span class="s3">\n            </span><span class="s1">x: -vector.x,</span><span class="s3">\n            </span><span class="s1">y: -vector.y</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">vectorNorm: {</span><span class="s3">\n            </span><span class="s1">x: -vectorNorm.x,</span><span class="s3">\n            </span><span class="s1">y: -vectorNorm.y</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">vectorNormInverse: {</span><span class="s3">\n            </span><span class="s1">x: -vectorNormInverse.x,</span><span class="s3">\n            </span><span class="s1">y: -vectorNormInverse.y</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;</span><span class="s3">\n      </span><span class="s1">rs.nodesOverlap = passedPairInfo.nodesOverlap;</span><span class="s3">\n      </span><span class="s1">rs.srcIntn = passedPairInfo.srcIntn;</span><span class="s3">\n      </span><span class="s1">rs.tgtIntn = passedPairInfo.tgtIntn;</span><span class="s3">\n      </span><span class="s1">rs.isRound = _curveStyle.startsWith('round');</span><span class="s3">\n      </span><span class="s1">if (hasCompounds &amp;&amp; (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) &amp;&amp; (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) &amp;&amp; src.isParent())) {</span><span class="s3">\n        </span><span class="s1">_this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);</span><span class="s3">\n      </span><span class="s1">} else if (src === tgt) {</span><span class="s3">\n        </span><span class="s1">_this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);</span><span class="s3">\n      </span><span class="s1">} else if (_curveStyle.endsWith('segments')) {</span><span class="s3">\n        </span><span class="s1">_this.findSegmentsPoints(_edge, passedPairInfo);</span><span class="s3">\n      </span><span class="s1">} else if (_curveStyle.endsWith('taxi')) {</span><span class="s3">\n        </span><span class="s1">_this.findTaxiPoints(_edge, passedPairInfo);</span><span class="s3">\n      </span><span class="s1">} else if (_curveStyle === 'straight' || !_edgeIsUnbundled &amp;&amp; pairInfo.eles.length % 2 === 1 &amp;&amp; _i2 === Math.floor(pairInfo.eles.length / 2)) {</span><span class="s3">\n        </span><span class="s1">_this.findStraightEdgePoints(_edge);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">_this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">_this.findEndpoints(_edge);</span><span class="s3">\n      </span><span class="s1">_this.tryToCorrectInvalidPoints(_edge, passedPairInfo);</span><span class="s3">\n      </span><span class="s1">_this.checkForInvalidEdgeWarning(_edge);</span><span class="s3">\n      </span><span class="s1">_this.storeAllpts(_edge);</span><span class="s3">\n      </span><span class="s1">_this.storeEdgeProjections(_edge);</span><span class="s3">\n      </span><span class="s1">_this.calculateArrowAngles(_edge);</span><span class="s3">\n      </span><span class="s1">_this.recalculateEdgeLabelProjections(_edge);</span><span class="s3">\n      </span><span class="s1">_this.calculateLabelAngles(_edge);</span><span class="s3">\n    </span><span class="s1">} // for pair edges</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (var p = 0; p &lt; pairIds.length; p++) {</span><span class="s3">\n    </span><span class="s1">_loop();</span><span class="s3">\n  </span><span class="s1">} // for pair ids</span><span class="s3">\n\n  </span><span class="s1">// haystacks avoid the expense of pairInfo stuff (intersections etc.)</span><span class="s3">\n  </span><span class="s1">this.findHaystackPoints(haystackEdges);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function getPts(pts) {</span><span class="s3">\n  </span><span class="s1">var retPts = [];</span><span class="s3">\n  </span><span class="s1">if (pts == null) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; pts.length; i += 2) {</span><span class="s3">\n    </span><span class="s1">var x = pts[i];</span><span class="s3">\n    </span><span class="s1">var y = pts[i + 1];</span><span class="s3">\n    </span><span class="s1">retPts.push({</span><span class="s3">\n      </span><span class="s1">x: x,</span><span class="s3">\n      </span><span class="s1">y: y</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return retPts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">BRp$c.getSegmentPoints = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge[0]._private.rscratch;</span><span class="s3">\n  </span><span class="s1">this.recalculateRenderedStyle(edge);</span><span class="s3">\n  </span><span class="s1">var type = rs.edgeType;</span><span class="s3">\n  </span><span class="s1">if (type === 'segments') {</span><span class="s3">\n    </span><span class="s1">return getPts(rs.segpts);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.getControlPoints = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge[0]._private.rscratch;</span><span class="s3">\n  </span><span class="s1">this.recalculateRenderedStyle(edge);</span><span class="s3">\n  </span><span class="s1">var type = rs.edgeType;</span><span class="s3">\n  </span><span class="s1">if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {</span><span class="s3">\n    </span><span class="s1">return getPts(rs.ctrlpts);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$c.getEdgeMidpoint = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge[0]._private.rscratch;</span><span class="s3">\n  </span><span class="s1">this.recalculateRenderedStyle(edge);</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">x: rs.midX,</span><span class="s3">\n    </span><span class="s1">y: rs.midY</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$b = {};</span><span class="s3">\n</span><span class="s1">BRp$b.manualEndptToPx = function (node, prop) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var npos = node.position();</span><span class="s3">\n  </span><span class="s1">var w = node.outerWidth();</span><span class="s3">\n  </span><span class="s1">var h = node.outerHeight();</span><span class="s3">\n  </span><span class="s1">var rs = node._private.rscratch;</span><span class="s3">\n  </span><span class="s1">if (prop.value.length === 2) {</span><span class="s3">\n    </span><span class="s1">var p = [prop.pfValue[0], prop.pfValue[1]];</span><span class="s3">\n    </span><span class="s1">if (prop.units[0] === '%') {</span><span class="s3">\n      </span><span class="s1">p[0] = p[0] * w;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (prop.units[1] === '%') {</span><span class="s3">\n      </span><span class="s1">p[1] = p[1] * h;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">p[0] += npos.x;</span><span class="s3">\n    </span><span class="s1">p[1] += npos.y;</span><span class="s3">\n    </span><span class="s1">return p;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var angle = prop.pfValue[0];</span><span class="s3">\n    </span><span class="s1">angle = -Math.PI / 2 + angle; // start at 12 o'clock</span><span class="s3">\n\n    </span><span class="s1">var l = 2 * Math.max(w, h);</span><span class="s3">\n    </span><span class="s1">var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];</span><span class="s3">\n    </span><span class="s1">return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0, node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue, rs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$b.findEndpoints = function (edge) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var intersect;</span><span class="s3">\n  </span><span class="s1">var source = edge.source()[0];</span><span class="s3">\n  </span><span class="s1">var target = edge.target()[0];</span><span class="s3">\n  </span><span class="s1">var srcPos = source.position();</span><span class="s3">\n  </span><span class="s1">var tgtPos = target.position();</span><span class="s3">\n  </span><span class="s1">var tgtArShape = edge.pstyle('target-arrow-shape').value;</span><span class="s3">\n  </span><span class="s1">var srcArShape = edge.pstyle('source-arrow-shape').value;</span><span class="s3">\n  </span><span class="s1">var tgtDist = edge.pstyle('target-distance-from-node').pfValue;</span><span class="s3">\n  </span><span class="s1">var srcDist = edge.pstyle('source-distance-from-node').pfValue;</span><span class="s3">\n  </span><span class="s1">var srcRs = source._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var tgtRs = target._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var curveStyle = edge.pstyle('curve-style').value;</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var et = rs.edgeType;</span><span class="s3">\n  </span><span class="s1">var taxi = curveStyle === 'taxi';</span><span class="s3">\n  </span><span class="s1">var self = et === 'self' || et === 'compound';</span><span class="s3">\n  </span><span class="s1">var bezier = et === 'bezier' || et === 'multibezier' || self;</span><span class="s3">\n  </span><span class="s1">var multi = et !== 'bezier';</span><span class="s3">\n  </span><span class="s1">var lines = et === 'straight' || et === 'segments';</span><span class="s3">\n  </span><span class="s1">var segments = et === 'segments';</span><span class="s3">\n  </span><span class="s1">var hasEndpts = bezier || multi || lines;</span><span class="s3">\n  </span><span class="s1">var overrideEndpts = self || taxi;</span><span class="s3">\n  </span><span class="s1">var srcManEndpt = edge.pstyle('source-endpoint');</span><span class="s3">\n  </span><span class="s1">var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;</span><span class="s3">\n  </span><span class="s1">var srcCornerRadius = source.pstyle('corner-radius').value === 'auto' ? 'auto' : source.pstyle('corner-radius').pfValue;</span><span class="s3">\n  </span><span class="s1">var tgtManEndpt = edge.pstyle('target-endpoint');</span><span class="s3">\n  </span><span class="s1">var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;</span><span class="s3">\n  </span><span class="s1">var tgtCornerRadius = target.pstyle('corner-radius').value === 'auto' ? 'auto' : target.pstyle('corner-radius').pfValue;</span><span class="s3">\n  </span><span class="s1">rs.srcManEndpt = srcManEndpt;</span><span class="s3">\n  </span><span class="s1">rs.tgtManEndpt = tgtManEndpt;</span><span class="s3">\n  </span><span class="s1">var p1; // last known point of edge on target side</span><span class="s3">\n  </span><span class="s1">var p2; // last known point of edge on source side</span><span class="s3">\n\n  </span><span class="s1">var p1_i; // point to intersect with target shape</span><span class="s3">\n  </span><span class="s1">var p2_i; // point to intersect with source shape</span><span class="s3">\n\n  </span><span class="s1">if (bezier) {</span><span class="s3">\n    </span><span class="s1">var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];</span><span class="s3">\n    </span><span class="s1">var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;</span><span class="s3">\n    </span><span class="s1">p1 = cpEnd;</span><span class="s3">\n    </span><span class="s1">p2 = cpStart;</span><span class="s3">\n  </span><span class="s1">} else if (lines) {</span><span class="s3">\n    </span><span class="s1">var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);</span><span class="s3">\n    </span><span class="s1">var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);</span><span class="s3">\n    </span><span class="s1">p1 = tgtArrowFromPt;</span><span class="s3">\n    </span><span class="s1">p2 = srcArrowFromPt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (tgtManEndptVal === 'inside-to-node') {</span><span class="s3">\n    </span><span class="s1">intersect = [tgtPos.x, tgtPos.y];</span><span class="s3">\n  </span><span class="s1">} else if (tgtManEndpt.units) {</span><span class="s3">\n    </span><span class="s1">intersect = this.manualEndptToPx(target, tgtManEndpt);</span><span class="s3">\n  </span><span class="s1">} else if (tgtManEndptVal === 'outside-to-line') {</span><span class="s3">\n    </span><span class="s1">intersect = rs.tgtIntn; // use cached value from ctrlpt calc</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {</span><span class="s3">\n      </span><span class="s1">p1_i = p1;</span><span class="s3">\n    </span><span class="s1">} else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {</span><span class="s3">\n      </span><span class="s1">p1_i = [srcPos.x, srcPos.y];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0, tgtCornerRadius, tgtRs);</span><span class="s3">\n    </span><span class="s1">if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {</span><span class="s3">\n      </span><span class="s1">var trs = target._private.rscratch;</span><span class="s3">\n      </span><span class="s1">var lw = trs.labelWidth;</span><span class="s3">\n      </span><span class="s1">var lh = trs.labelHeight;</span><span class="s3">\n      </span><span class="s1">var lx = trs.labelX;</span><span class="s3">\n      </span><span class="s1">var ly = trs.labelY;</span><span class="s3">\n      </span><span class="s1">var lw2 = lw / 2;</span><span class="s3">\n      </span><span class="s1">var lh2 = lh / 2;</span><span class="s3">\n      </span><span class="s1">var va = target.pstyle('text-valign').value;</span><span class="s3">\n      </span><span class="s1">if (va === 'top') {</span><span class="s3">\n        </span><span class="s1">ly -= lh2;</span><span class="s3">\n      </span><span class="s1">} else if (va === 'bottom') {</span><span class="s3">\n        </span><span class="s1">ly += lh2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var ha = target.pstyle('text-halign').value;</span><span class="s3">\n      </span><span class="s1">if (ha === 'left') {</span><span class="s3">\n        </span><span class="s1">lx -= lw2;</span><span class="s3">\n      </span><span class="s1">} else if (ha === 'right') {</span><span class="s3">\n        </span><span class="s1">lx += lw2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);</span><span class="s3">\n      </span><span class="s1">if (labelIntersect.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">var refPt = srcPos;</span><span class="s3">\n        </span><span class="s1">var intSqdist = sqdist(refPt, array2point(intersect));</span><span class="s3">\n        </span><span class="s1">var labIntSqdist = sqdist(refPt, array2point(labelIntersect));</span><span class="s3">\n        </span><span class="s1">var minSqDist = intSqdist;</span><span class="s3">\n        </span><span class="s1">if (labIntSqdist &lt; intSqdist) {</span><span class="s3">\n          </span><span class="s1">intersect = labelIntersect;</span><span class="s3">\n          </span><span class="s1">minSqDist = labIntSqdist;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (labelIntersect.length &gt; 2) {</span><span class="s3">\n          </span><span class="s1">var labInt2SqDist = sqdist(refPt, {</span><span class="s3">\n            </span><span class="s1">x: labelIntersect[2],</span><span class="s3">\n            </span><span class="s1">y: labelIntersect[3]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (labInt2SqDist &lt; minSqDist) {</span><span class="s3">\n            </span><span class="s1">intersect = [labelIntersect[2], labelIntersect[3]];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);</span><span class="s3">\n  </span><span class="s1">var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);</span><span class="s3">\n  </span><span class="s1">rs.endX = edgeEnd[0];</span><span class="s3">\n  </span><span class="s1">rs.endY = edgeEnd[1];</span><span class="s3">\n  </span><span class="s1">rs.arrowEndX = arrowEnd[0];</span><span class="s3">\n  </span><span class="s1">rs.arrowEndY = arrowEnd[1];</span><span class="s3">\n  </span><span class="s1">if (srcManEndptVal === 'inside-to-node') {</span><span class="s3">\n    </span><span class="s1">intersect = [srcPos.x, srcPos.y];</span><span class="s3">\n  </span><span class="s1">} else if (srcManEndpt.units) {</span><span class="s3">\n    </span><span class="s1">intersect = this.manualEndptToPx(source, srcManEndpt);</span><span class="s3">\n  </span><span class="s1">} else if (srcManEndptVal === 'outside-to-line') {</span><span class="s3">\n    </span><span class="s1">intersect = rs.srcIntn; // use cached value from ctrlpt calc</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {</span><span class="s3">\n      </span><span class="s1">p2_i = p2;</span><span class="s3">\n    </span><span class="s1">} else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {</span><span class="s3">\n      </span><span class="s1">p2_i = [tgtPos.x, tgtPos.y];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0, srcCornerRadius, srcRs);</span><span class="s3">\n    </span><span class="s1">if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {</span><span class="s3">\n      </span><span class="s1">var srs = source._private.rscratch;</span><span class="s3">\n      </span><span class="s1">var _lw = srs.labelWidth;</span><span class="s3">\n      </span><span class="s1">var _lh = srs.labelHeight;</span><span class="s3">\n      </span><span class="s1">var _lx = srs.labelX;</span><span class="s3">\n      </span><span class="s1">var _ly = srs.labelY;</span><span class="s3">\n      </span><span class="s1">var _lw2 = _lw / 2;</span><span class="s3">\n      </span><span class="s1">var _lh2 = _lh / 2;</span><span class="s3">\n      </span><span class="s1">var _va = source.pstyle('text-valign').value;</span><span class="s3">\n      </span><span class="s1">if (_va === 'top') {</span><span class="s3">\n        </span><span class="s1">_ly -= _lh2;</span><span class="s3">\n      </span><span class="s1">} else if (_va === 'bottom') {</span><span class="s3">\n        </span><span class="s1">_ly += _lh2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var _ha = source.pstyle('text-halign').value;</span><span class="s3">\n      </span><span class="s1">if (_ha === 'left') {</span><span class="s3">\n        </span><span class="s1">_lx -= _lw2;</span><span class="s3">\n      </span><span class="s1">} else if (_ha === 'right') {</span><span class="s3">\n        </span><span class="s1">_lx += _lw2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);</span><span class="s3">\n      </span><span class="s1">if (_labelIntersect.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">var _refPt = tgtPos;</span><span class="s3">\n        </span><span class="s1">var _intSqdist = sqdist(_refPt, array2point(intersect));</span><span class="s3">\n        </span><span class="s1">var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));</span><span class="s3">\n        </span><span class="s1">var _minSqDist = _intSqdist;</span><span class="s3">\n        </span><span class="s1">if (_labIntSqdist &lt; _intSqdist) {</span><span class="s3">\n          </span><span class="s1">intersect = [_labelIntersect[0], _labelIntersect[1]];</span><span class="s3">\n          </span><span class="s1">_minSqDist = _labIntSqdist;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (_labelIntersect.length &gt; 2) {</span><span class="s3">\n          </span><span class="s1">var _labInt2SqDist = sqdist(_refPt, {</span><span class="s3">\n            </span><span class="s1">x: _labelIntersect[2],</span><span class="s3">\n            </span><span class="s1">y: _labelIntersect[3]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (_labInt2SqDist &lt; _minSqDist) {</span><span class="s3">\n            </span><span class="s1">intersect = [_labelIntersect[2], _labelIntersect[3]];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);</span><span class="s3">\n  </span><span class="s1">var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);</span><span class="s3">\n  </span><span class="s1">rs.startX = edgeStart[0];</span><span class="s3">\n  </span><span class="s1">rs.startY = edgeStart[1];</span><span class="s3">\n  </span><span class="s1">rs.arrowStartX = arrowStart[0];</span><span class="s3">\n  </span><span class="s1">rs.arrowStartY = arrowStart[1];</span><span class="s3">\n  </span><span class="s1">if (hasEndpts) {</span><span class="s3">\n    </span><span class="s1">if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {</span><span class="s3">\n      </span><span class="s1">rs.badLine = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">rs.badLine = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$b.getSourceEndpoint = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge[0]._private.rscratch;</span><span class="s3">\n  </span><span class="s1">this.recalculateRenderedStyle(edge);</span><span class="s3">\n  </span><span class="s1">switch (rs.edgeType) {</span><span class="s3">\n    </span><span class="s1">case 'haystack':</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: rs.haystackPts[0],</span><span class="s3">\n        </span><span class="s1">y: rs.haystackPts[1]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: rs.arrowStartX,</span><span class="s3">\n        </span><span class="s1">y: rs.arrowStartY</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$b.getTargetEndpoint = function (edge) {</span><span class="s3">\n  </span><span class="s1">var rs = edge[0]._private.rscratch;</span><span class="s3">\n  </span><span class="s1">this.recalculateRenderedStyle(edge);</span><span class="s3">\n  </span><span class="s1">switch (rs.edgeType) {</span><span class="s3">\n    </span><span class="s1">case 'haystack':</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: rs.haystackPts[2],</span><span class="s3">\n        </span><span class="s1">y: rs.haystackPts[3]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: rs.arrowEndX,</span><span class="s3">\n        </span><span class="s1">y: rs.arrowEndY</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$a = {};</span><span class="s3">\n</span><span class="s1">function pushBezierPts(r, edge, pts) {</span><span class="s3">\n  </span><span class="s1">var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {</span><span class="s3">\n    </span><span class="s1">return qbezierAt(p1, p2, p3, t);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var _p = edge._private;</span><span class="s3">\n  </span><span class="s1">var bpts = _p.rstyle.bezierPts;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; r.bezierProjPcts.length; i++) {</span><span class="s3">\n    </span><span class="s1">var p = r.bezierProjPcts[i];</span><span class="s3">\n    </span><span class="s1">bpts.push({</span><span class="s3">\n      </span><span class="s1">x: qbezierAt$1(pts[0], pts[2], pts[4], p),</span><span class="s3">\n      </span><span class="s1">y: qbezierAt$1(pts[1], pts[3], pts[5], p)</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">BRp$a.storeEdgeProjections = function (edge) {</span><span class="s3">\n  </span><span class="s1">var _p = edge._private;</span><span class="s3">\n  </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var et = rs.edgeType;</span><span class="s3">\n\n  </span><span class="s1">// clear the cached points state</span><span class="s3">\n  </span><span class="s1">_p.rstyle.bezierPts = null;</span><span class="s3">\n  </span><span class="s1">_p.rstyle.linePts = null;</span><span class="s3">\n  </span><span class="s1">_p.rstyle.haystackPts = null;</span><span class="s3">\n  </span><span class="s1">if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {</span><span class="s3">\n    </span><span class="s1">_p.rstyle.bezierPts = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i + 5 &lt; rs.allpts.length; i += 4) {</span><span class="s3">\n      </span><span class="s1">pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (et === 'segments') {</span><span class="s3">\n    </span><span class="s1">var lpts = _p.rstyle.linePts = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i + 1 &lt; rs.allpts.length; i += 2) {</span><span class="s3">\n      </span><span class="s1">lpts.push({</span><span class="s3">\n        </span><span class="s1">x: rs.allpts[i],</span><span class="s3">\n        </span><span class="s1">y: rs.allpts[i + 1]</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (et === 'haystack') {</span><span class="s3">\n    </span><span class="s1">var hpts = rs.haystackPts;</span><span class="s3">\n    </span><span class="s1">_p.rstyle.haystackPts = [{</span><span class="s3">\n      </span><span class="s1">x: hpts[0],</span><span class="s3">\n      </span><span class="s1">y: hpts[1]</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n      </span><span class="s1">x: hpts[2],</span><span class="s3">\n      </span><span class="s1">y: hpts[3]</span><span class="s3">\n    </span><span class="s1">}];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">_p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$a.recalculateEdgeProjections = function (edges) {</span><span class="s3">\n  </span><span class="s1">this.findEdgeControlPoints(edges);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$9 = {};</span><span class="s3">\n</span><span class="s1">BRp$9.recalculateNodeLabelProjection = function (node) {</span><span class="s3">\n  </span><span class="s1">var content = node.pstyle('label').strValue;</span><span class="s3">\n  </span><span class="s1">if (emptyString(content)) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var textX, textY;</span><span class="s3">\n  </span><span class="s1">var _p = node._private;</span><span class="s3">\n  </span><span class="s1">var nodeWidth = node.width();</span><span class="s3">\n  </span><span class="s1">var nodeHeight = node.height();</span><span class="s3">\n  </span><span class="s1">var padding = node.padding();</span><span class="s3">\n  </span><span class="s1">var nodePos = node.position();</span><span class="s3">\n  </span><span class="s1">var textHalign = node.pstyle('text-halign').strValue;</span><span class="s3">\n  </span><span class="s1">var textValign = node.pstyle('text-valign').strValue;</span><span class="s3">\n  </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var rstyle = _p.rstyle;</span><span class="s3">\n  </span><span class="s1">switch (textHalign) {</span><span class="s3">\n    </span><span class="s1">case 'left':</span><span class="s3">\n      </span><span class="s1">textX = nodePos.x - nodeWidth / 2 - padding;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'right':</span><span class="s3">\n      </span><span class="s1">textX = nodePos.x + nodeWidth / 2 + padding;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">// e.g. center</span><span class="s3">\n      </span><span class="s1">textX = nodePos.x;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">switch (textValign) {</span><span class="s3">\n    </span><span class="s1">case 'top':</span><span class="s3">\n      </span><span class="s1">textY = nodePos.y - nodeHeight / 2 - padding;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'bottom':</span><span class="s3">\n      </span><span class="s1">textY = nodePos.y + nodeHeight / 2 + padding;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">// e.g. middle</span><span class="s3">\n      </span><span class="s1">textY = nodePos.y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rs.labelX = textX;</span><span class="s3">\n  </span><span class="s1">rs.labelY = textY;</span><span class="s3">\n  </span><span class="s1">rstyle.labelX = textX;</span><span class="s3">\n  </span><span class="s1">rstyle.labelY = textY;</span><span class="s3">\n  </span><span class="s1">this.calculateLabelAngles(node);</span><span class="s3">\n  </span><span class="s1">this.applyLabelDimensions(node);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {</span><span class="s3">\n  </span><span class="s1">var angle = Math.atan(dy / dx);</span><span class="s3">\n  </span><span class="s1">if (dx === 0 &amp;&amp; angle &lt; 0) {</span><span class="s3">\n    </span><span class="s1">angle = angle * -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return angle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var lineAngle = function lineAngle(p0, p1) {</span><span class="s3">\n  </span><span class="s1">var dx = p1.x - p0.x;</span><span class="s3">\n  </span><span class="s1">var dy = p1.y - p0.y;</span><span class="s3">\n  </span><span class="s1">return lineAngleFromDelta(dx, dy);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var bezierAngle = function bezierAngle(p0, p1, p2, t) {</span><span class="s3">\n  </span><span class="s1">var t0 = bound(0, t - 0.001, 1);</span><span class="s3">\n  </span><span class="s1">var t1 = bound(0, t + 0.001, 1);</span><span class="s3">\n  </span><span class="s1">var lp0 = qbezierPtAt(p0, p1, p2, t0);</span><span class="s3">\n  </span><span class="s1">var lp1 = qbezierPtAt(p0, p1, p2, t1);</span><span class="s3">\n  </span><span class="s1">return lineAngle(lp0, lp1);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.recalculateEdgeLabelProjections = function (edge) {</span><span class="s3">\n  </span><span class="s1">var p;</span><span class="s3">\n  </span><span class="s1">var _p = edge._private;</span><span class="s3">\n  </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var content = {</span><span class="s3">\n    </span><span class="s1">mid: edge.pstyle('label').strValue,</span><span class="s3">\n    </span><span class="s1">source: edge.pstyle('source-label').strValue,</span><span class="s3">\n    </span><span class="s1">target: edge.pstyle('target-label').strValue</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (content.mid || content.source || content.target) ; else {</span><span class="s3">\n    </span><span class="s1">return; // no labels =&gt; no calcs</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add center point to style so bounding box calculations can use it</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">p = {</span><span class="s3">\n    </span><span class="s1">x: rs.midX,</span><span class="s3">\n    </span><span class="s1">y: rs.midY</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setRs = function setRs(propName, prefix, value) {</span><span class="s3">\n    </span><span class="s1">setPrefixedProperty(_p.rscratch, propName, prefix, value);</span><span class="s3">\n    </span><span class="s1">setPrefixedProperty(_p.rstyle, propName, prefix, value);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">setRs('labelX', null, p.x);</span><span class="s3">\n  </span><span class="s1">setRs('labelY', null, p.y);</span><span class="s3">\n  </span><span class="s1">var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);</span><span class="s3">\n  </span><span class="s1">setRs('labelAutoAngle', null, midAngle);</span><span class="s3">\n  </span><span class="s1">var _createControlPointInfo = function createControlPointInfo() {</span><span class="s3">\n    </span><span class="s1">if (_createControlPointInfo.cache) {</span><span class="s3">\n      </span><span class="s1">return _createControlPointInfo.cache;</span><span class="s3">\n    </span><span class="s1">} // use cache so only 1x per edge</span><span class="s3">\n\n    </span><span class="s1">var ctrlpts = [];</span><span class="s3">\n\n    </span><span class="s1">// store each ctrlpt info init</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i + 5 &lt; rs.allpts.length; i += 4) {</span><span class="s3">\n      </span><span class="s1">var p0 = {</span><span class="s3">\n        </span><span class="s1">x: rs.allpts[i],</span><span class="s3">\n        </span><span class="s1">y: rs.allpts[i + 1]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var p1 = {</span><span class="s3">\n        </span><span class="s1">x: rs.allpts[i + 2],</span><span class="s3">\n        </span><span class="s1">y: rs.allpts[i + 3]</span><span class="s3">\n      </span><span class="s1">}; // ctrlpt</span><span class="s3">\n      </span><span class="s1">var p2 = {</span><span class="s3">\n        </span><span class="s1">x: rs.allpts[i + 4],</span><span class="s3">\n        </span><span class="s1">y: rs.allpts[i + 5]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">ctrlpts.push({</span><span class="s3">\n        </span><span class="s1">p0: p0,</span><span class="s3">\n        </span><span class="s1">p1: p1,</span><span class="s3">\n        </span><span class="s1">p2: p2,</span><span class="s3">\n        </span><span class="s1">startDist: 0,</span><span class="s3">\n        </span><span class="s1">length: 0,</span><span class="s3">\n        </span><span class="s1">segments: []</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var bpts = _p.rstyle.bezierPts;</span><span class="s3">\n    </span><span class="s1">var nProjs = r.bezierProjPcts.length;</span><span class="s3">\n    </span><span class="s1">function addSegment(cp, p0, p1, t0, t1) {</span><span class="s3">\n      </span><span class="s1">var length = dist(p0, p1);</span><span class="s3">\n      </span><span class="s1">var prevSegment = cp.segments[cp.segments.length - 1];</span><span class="s3">\n      </span><span class="s1">var segment = {</span><span class="s3">\n        </span><span class="s1">p0: p0,</span><span class="s3">\n        </span><span class="s1">p1: p1,</span><span class="s3">\n        </span><span class="s1">t0: t0,</span><span class="s3">\n        </span><span class="s1">t1: t1,</span><span class="s3">\n        </span><span class="s1">startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,</span><span class="s3">\n        </span><span class="s1">length: length</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">cp.segments.push(segment);</span><span class="s3">\n      </span><span class="s1">cp.length += length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// update each ctrlpt with segment info</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; ctrlpts.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var cp = ctrlpts[_i];</span><span class="s3">\n      </span><span class="s1">var prevCp = ctrlpts[_i - 1];</span><span class="s3">\n      </span><span class="s1">if (prevCp) {</span><span class="s3">\n        </span><span class="s1">cp.startDist = prevCp.startDist + prevCp.length;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first</span><span class="s3">\n\n      </span><span class="s1">for (var j = 0; j &lt; nProjs - 1; j++) {</span><span class="s3">\n        </span><span class="s1">addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _createControlPointInfo.cache = ctrlpts;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var calculateEndProjection = function calculateEndProjection(prefix) {</span><span class="s3">\n    </span><span class="s1">var angle;</span><span class="s3">\n    </span><span class="s1">var isSrc = prefix === 'source';</span><span class="s3">\n    </span><span class="s1">if (!content[prefix]) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var offset = edge.pstyle(prefix + '-text-offset').pfValue;</span><span class="s3">\n    </span><span class="s1">switch (rs.edgeType) {</span><span class="s3">\n      </span><span class="s1">case 'self':</span><span class="s3">\n      </span><span class="s1">case 'compound':</span><span class="s3">\n      </span><span class="s1">case 'bezier':</span><span class="s3">\n      </span><span class="s1">case 'multibezier':</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var cps = _createControlPointInfo();</span><span class="s3">\n          </span><span class="s1">var selected;</span><span class="s3">\n          </span><span class="s1">var startDist = 0;</span><span class="s3">\n          </span><span class="s1">var totalDist = 0;</span><span class="s3">\n\n          </span><span class="s1">// find the segment we're on</span><span class="s3">\n          </span><span class="s1">for (var i = 0; i &lt; cps.length; i++) {</span><span class="s3">\n            </span><span class="s1">var _cp = cps[isSrc ? i : cps.length - 1 - i];</span><span class="s3">\n            </span><span class="s1">for (var j = 0; j &lt; _cp.segments.length; j++) {</span><span class="s3">\n              </span><span class="s1">var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];</span><span class="s3">\n              </span><span class="s1">var lastSeg = i === cps.length - 1 &amp;&amp; j === _cp.segments.length - 1;</span><span class="s3">\n              </span><span class="s1">startDist = totalDist;</span><span class="s3">\n              </span><span class="s1">totalDist += _seg.length;</span><span class="s3">\n              </span><span class="s1">if (totalDist &gt;= offset || lastSeg) {</span><span class="s3">\n                </span><span class="s1">selected = {</span><span class="s3">\n                  </span><span class="s1">cp: _cp,</span><span class="s3">\n                  </span><span class="s1">segment: _seg</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (selected) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var cp = selected.cp;</span><span class="s3">\n          </span><span class="s1">var seg = selected.segment;</span><span class="s3">\n          </span><span class="s1">var tSegment = (offset - startDist) / seg.length;</span><span class="s3">\n          </span><span class="s1">var segDt = seg.t1 - seg.t0;</span><span class="s3">\n          </span><span class="s1">var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;</span><span class="s3">\n          </span><span class="s1">t = bound(0, t, 1);</span><span class="s3">\n          </span><span class="s1">p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);</span><span class="s3">\n          </span><span class="s1">angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'straight':</span><span class="s3">\n      </span><span class="s1">case 'segments':</span><span class="s3">\n      </span><span class="s1">case 'haystack':</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var d = 0,</span><span class="s3">\n            </span><span class="s1">di,</span><span class="s3">\n            </span><span class="s1">d0;</span><span class="s3">\n          </span><span class="s1">var p0, p1;</span><span class="s3">\n          </span><span class="s1">var l = rs.allpts.length;</span><span class="s3">\n          </span><span class="s1">for (var _i2 = 0; _i2 + 3 &lt; l; _i2 += 2) {</span><span class="s3">\n            </span><span class="s1">if (isSrc) {</span><span class="s3">\n              </span><span class="s1">p0 = {</span><span class="s3">\n                </span><span class="s1">x: rs.allpts[_i2],</span><span class="s3">\n                </span><span class="s1">y: rs.allpts[_i2 + 1]</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n              </span><span class="s1">p1 = {</span><span class="s3">\n                </span><span class="s1">x: rs.allpts[_i2 + 2],</span><span class="s3">\n                </span><span class="s1">y: rs.allpts[_i2 + 3]</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">p0 = {</span><span class="s3">\n                </span><span class="s1">x: rs.allpts[l - 2 - _i2],</span><span class="s3">\n                </span><span class="s1">y: rs.allpts[l - 1 - _i2]</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n              </span><span class="s1">p1 = {</span><span class="s3">\n                </span><span class="s1">x: rs.allpts[l - 4 - _i2],</span><span class="s3">\n                </span><span class="s1">y: rs.allpts[l - 3 - _i2]</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">di = dist(p0, p1);</span><span class="s3">\n            </span><span class="s1">d0 = d;</span><span class="s3">\n            </span><span class="s1">d += di;</span><span class="s3">\n            </span><span class="s1">if (d &gt;= offset) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var pD = offset - d0;</span><span class="s3">\n          </span><span class="s1">var _t = pD / di;</span><span class="s3">\n          </span><span class="s1">_t = bound(0, _t, 1);</span><span class="s3">\n          </span><span class="s1">p = lineAt(p0, p1, _t);</span><span class="s3">\n          </span><span class="s1">angle = lineAngle(p0, p1);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setRs('labelX', prefix, p.x);</span><span class="s3">\n    </span><span class="s1">setRs('labelY', prefix, p.y);</span><span class="s3">\n    </span><span class="s1">setRs('labelAutoAngle', prefix, angle);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">calculateEndProjection('source');</span><span class="s3">\n  </span><span class="s1">calculateEndProjection('target');</span><span class="s3">\n  </span><span class="s1">this.applyLabelDimensions(edge);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.applyLabelDimensions = function (ele) {</span><span class="s3">\n  </span><span class="s1">this.applyPrefixedLabelDimensions(ele);</span><span class="s3">\n  </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n    </span><span class="s1">this.applyPrefixedLabelDimensions(ele, 'source');</span><span class="s3">\n    </span><span class="s1">this.applyPrefixedLabelDimensions(ele, 'target');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.applyPrefixedLabelDimensions = function (ele, prefix) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var text = this.getLabelText(ele, prefix);</span><span class="s3">\n  </span><span class="s1">var labelDims = this.calculateLabelDimensions(ele, text);</span><span class="s3">\n  </span><span class="s1">var lineHeight = ele.pstyle('line-height').pfValue;</span><span class="s3">\n  </span><span class="s1">var textWrap = ele.pstyle('text-wrap').strValue;</span><span class="s3">\n  </span><span class="s1">var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];</span><span class="s3">\n  </span><span class="s1">var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);</span><span class="s3">\n  </span><span class="s1">var normPerLineHeight = labelDims.height / numLines;</span><span class="s3">\n  </span><span class="s1">var labelLineHeight = normPerLineHeight * lineHeight;</span><span class="s3">\n  </span><span class="s1">var width = labelDims.width;</span><span class="s3">\n  </span><span class="s1">var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;</span><span class="s3">\n  </span><span class="s1">setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);</span><span class="s3">\n  </span><span class="s1">setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);</span><span class="s3">\n  </span><span class="s1">setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);</span><span class="s3">\n  </span><span class="s1">setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);</span><span class="s3">\n  </span><span class="s1">setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.getLabelText = function (ele, prefix) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var pfd = prefix ? prefix + '-' : '';</span><span class="s3">\n  </span><span class="s1">var text = ele.pstyle(pfd + 'label').strValue;</span><span class="s3">\n  </span><span class="s1">var textTransform = ele.pstyle('text-transform').value;</span><span class="s3">\n  </span><span class="s1">var rscratch = function rscratch(propName, value) {</span><span class="s3">\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">setPrefixedProperty(_p.rscratch, propName, prefix, value);</span><span class="s3">\n      </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return getPrefixedProperty(_p.rscratch, propName, prefix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// for empty text, skip all processing</span><span class="s3">\n  </span><span class="s1">if (!text) {</span><span class="s3">\n    </span><span class="s1">return '';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (textTransform == 'none') ; else if (textTransform == 'uppercase') {</span><span class="s3">\n    </span><span class="s1">text = text.toUpperCase();</span><span class="s3">\n  </span><span class="s1">} else if (textTransform == 'lowercase') {</span><span class="s3">\n    </span><span class="s1">text = text.toLowerCase();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var wrapStyle = ele.pstyle('text-wrap').value;</span><span class="s3">\n  </span><span class="s1">if (wrapStyle === 'wrap') {</span><span class="s3">\n    </span><span class="s1">var labelKey = rscratch('labelKey');</span><span class="s3">\n\n    </span><span class="s1">// save recalc if the label is the same as before</span><span class="s3">\n    </span><span class="s1">if (labelKey != null &amp;&amp; rscratch('labelWrapKey') === labelKey) {</span><span class="s3">\n      </span><span class="s1">return rscratch('labelWrapCachedText');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var zwsp = </span><span class="s3">\&quot;\\</span><span class="s1">u200B</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">var lines = text.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n    </span><span class="s1">var maxW = ele.pstyle('text-max-width').pfValue;</span><span class="s3">\n    </span><span class="s1">var overflow = ele.pstyle('text-overflow-wrap').value;</span><span class="s3">\n    </span><span class="s1">var overflowAny = overflow === 'anywhere';</span><span class="s3">\n    </span><span class="s1">var wrappedLines = [];</span><span class="s3">\n    </span><span class="s1">var separatorRegex = /[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">u200b]+|$/g; // Include end of string to add last word</span><span class="s3">\n\n    </span><span class="s1">for (var l = 0; l &lt; lines.length; l++) {</span><span class="s3">\n      </span><span class="s1">var line = lines[l];</span><span class="s3">\n      </span><span class="s1">var lineDims = this.calculateLabelDimensions(ele, line);</span><span class="s3">\n      </span><span class="s1">var lineW = lineDims.width;</span><span class="s3">\n      </span><span class="s1">if (overflowAny) {</span><span class="s3">\n        </span><span class="s1">var processedLine = line.split('').join(zwsp);</span><span class="s3">\n        </span><span class="s1">line = processedLine;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (lineW &gt; maxW) {</span><span class="s3">\n        </span><span class="s1">// line is too long</span><span class="s3">\n        </span><span class="s1">var separatorMatches = line.matchAll(separatorRegex);</span><span class="s3">\n        </span><span class="s1">var subline = '';</span><span class="s3">\n        </span><span class="s1">var previousIndex = 0;</span><span class="s3">\n        </span><span class="s1">// Add fake match</span><span class="s3">\n        </span><span class="s1">var _iterator = _createForOfIteratorHelper(separatorMatches),</span><span class="s3">\n          </span><span class="s1">_step;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">for (_iterator.s(); !(_step = _iterator.n()).done;) {</span><span class="s3">\n            </span><span class="s1">var separatorMatch = _step.value;</span><span class="s3">\n            </span><span class="s1">var wordSeparator = separatorMatch[0];</span><span class="s3">\n            </span><span class="s1">var word = line.substring(previousIndex, separatorMatch.index);</span><span class="s3">\n            </span><span class="s1">previousIndex = separatorMatch.index + wordSeparator.length;</span><span class="s3">\n            </span><span class="s1">var testLine = subline.length === 0 ? word : subline + word + wordSeparator;</span><span class="s3">\n            </span><span class="s1">var testDims = this.calculateLabelDimensions(ele, testLine);</span><span class="s3">\n            </span><span class="s1">var testW = testDims.width;</span><span class="s3">\n            </span><span class="s1">if (testW &lt;= maxW) {</span><span class="s3">\n              </span><span class="s1">// word fits on current line</span><span class="s3">\n              </span><span class="s1">subline += word + wordSeparator;</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// word starts new line</span><span class="s3">\n              </span><span class="s1">if (subline) {</span><span class="s3">\n                </span><span class="s1">wrappedLines.push(subline);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">subline = word + wordSeparator;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// if there's remaining text, put it in a wrapped line</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">_iterator.e(err);</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">_iterator.f();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!subline.match(/^[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">u200b]+$/)) {</span><span class="s3">\n          </span><span class="s1">wrappedLines.push(subline);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// line is already short enough</span><span class="s3">\n        </span><span class="s1">wrappedLines.push(line);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} // for</span><span class="s3">\n\n    </span><span class="s1">rscratch('labelWrapCachedLines', wrappedLines);</span><span class="s3">\n    </span><span class="s1">text = rscratch('labelWrapCachedText', wrappedLines.join('</span><span class="s3">\\</span><span class="s1">n'));</span><span class="s3">\n    </span><span class="s1">rscratch('labelWrapKey', labelKey);</span><span class="s3">\n  </span><span class="s1">} else if (wrapStyle === 'ellipsis') {</span><span class="s3">\n    </span><span class="s1">var _maxW = ele.pstyle('text-max-width').pfValue;</span><span class="s3">\n    </span><span class="s1">var ellipsized = '';</span><span class="s3">\n    </span><span class="s1">var ellipsis = </span><span class="s3">\&quot;\\</span><span class="s1">u2026</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">var incLastCh = false;</span><span class="s3">\n    </span><span class="s1">if (this.calculateLabelDimensions(ele, text).width &lt; _maxW) {</span><span class="s3">\n      </span><span class="s1">// the label already fits</span><span class="s3">\n      </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; text.length; i++) {</span><span class="s3">\n      </span><span class="s1">var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;</span><span class="s3">\n      </span><span class="s1">if (widthWithNextCh &gt; _maxW) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ellipsized += text[i];</span><span class="s3">\n      </span><span class="s1">if (i === text.length - 1) {</span><span class="s3">\n        </span><span class="s1">incLastCh = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!incLastCh) {</span><span class="s3">\n      </span><span class="s1">ellipsized += ellipsis;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ellipsized;</span><span class="s3">\n  </span><span class="s1">} // if ellipsize</span><span class="s3">\n\n  </span><span class="s1">return text;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.getLabelJustification = function (ele) {</span><span class="s3">\n  </span><span class="s1">var justification = ele.pstyle('text-justification').strValue;</span><span class="s3">\n  </span><span class="s1">var textHalign = ele.pstyle('text-halign').strValue;</span><span class="s3">\n  </span><span class="s1">if (justification === 'auto') {</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">switch (textHalign) {</span><span class="s3">\n        </span><span class="s1">case 'left':</span><span class="s3">\n          </span><span class="s1">return 'right';</span><span class="s3">\n        </span><span class="s1">case 'right':</span><span class="s3">\n          </span><span class="s1">return 'left';</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return 'center';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return 'center';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return justification;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.calculateLabelDimensions = function (ele, text) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var containerWindow = r.cy.window();</span><span class="s3">\n  </span><span class="s1">var document = containerWindow.document;</span><span class="s3">\n  </span><span class="s1">var cacheKey = hashString(text, ele._private.labelDimsKey);</span><span class="s3">\n  </span><span class="s1">var cache = r.labelDimCache || (r.labelDimCache = []);</span><span class="s3">\n  </span><span class="s1">var existingVal = cache[cacheKey];</span><span class="s3">\n  </span><span class="s1">if (existingVal != null) {</span><span class="s3">\n    </span><span class="s1">return existingVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var padding = 0; // add padding around text dims, as the measurement isn't that accurate</span><span class="s3">\n  </span><span class="s1">var fStyle = ele.pstyle('font-style').strValue;</span><span class="s3">\n  </span><span class="s1">var size = ele.pstyle('font-size').pfValue;</span><span class="s3">\n  </span><span class="s1">var family = ele.pstyle('font-family').strValue;</span><span class="s3">\n  </span><span class="s1">var weight = ele.pstyle('font-weight').strValue;</span><span class="s3">\n  </span><span class="s1">var canvas = this.labelCalcCanvas;</span><span class="s3">\n  </span><span class="s1">var c2d = this.labelCalcCanvasContext;</span><span class="s3">\n  </span><span class="s1">if (!canvas) {</span><span class="s3">\n    </span><span class="s1">canvas = this.labelCalcCanvas = document.createElement('canvas');</span><span class="s3">\n    </span><span class="s1">c2d = this.labelCalcCanvasContext = canvas.getContext('2d');</span><span class="s3">\n    </span><span class="s1">var ds = canvas.style;</span><span class="s3">\n    </span><span class="s1">ds.position = 'absolute';</span><span class="s3">\n    </span><span class="s1">ds.left = '-9999px';</span><span class="s3">\n    </span><span class="s1">ds.top = '-9999px';</span><span class="s3">\n    </span><span class="s1">ds.zIndex = '-1';</span><span class="s3">\n    </span><span class="s1">ds.visibility = 'hidden';</span><span class="s3">\n    </span><span class="s1">ds.pointerEvents = 'none';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">c2d.font = </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(fStyle, </span><span class="s3">\&quot; \&quot;</span><span class="s1">).concat(weight, </span><span class="s3">\&quot; \&quot;</span><span class="s1">).concat(size, </span><span class="s3">\&quot;</span><span class="s1">px </span><span class="s3">\&quot;</span><span class="s1">).concat(family);</span><span class="s3">\n  </span><span class="s1">var width = 0;</span><span class="s3">\n  </span><span class="s1">var height = 0;</span><span class="s3">\n  </span><span class="s1">var lines = text.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; lines.length; i++) {</span><span class="s3">\n    </span><span class="s1">var line = lines[i];</span><span class="s3">\n    </span><span class="s1">var metrics = c2d.measureText(line);</span><span class="s3">\n    </span><span class="s1">var w = Math.ceil(metrics.width);</span><span class="s3">\n    </span><span class="s1">var h = size;</span><span class="s3">\n    </span><span class="s1">width = Math.max(w, width);</span><span class="s3">\n    </span><span class="s1">height += h;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">width += padding;</span><span class="s3">\n  </span><span class="s1">height += padding;</span><span class="s3">\n  </span><span class="s1">return cache[cacheKey] = {</span><span class="s3">\n    </span><span class="s1">width: width,</span><span class="s3">\n    </span><span class="s1">height: height</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.calculateLabelAngle = function (ele, prefix) {</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n  </span><span class="s1">var prefixDash = prefix ? prefix + '-' : '';</span><span class="s3">\n  </span><span class="s1">var rot = ele.pstyle(prefixDash + 'text-rotation');</span><span class="s3">\n  </span><span class="s1">var rotStr = rot.strValue;</span><span class="s3">\n  </span><span class="s1">if (rotStr === 'none') {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">} else if (isEdge &amp;&amp; rotStr === 'autorotate') {</span><span class="s3">\n    </span><span class="s1">return rs.labelAutoAngle;</span><span class="s3">\n  </span><span class="s1">} else if (rotStr === 'autorotate') {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return rot.pfValue;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$9.calculateLabelAngles = function (ele) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">rs.labelAngle = r.calculateLabelAngle(ele);</span><span class="s3">\n  </span><span class="s1">if (isEdge) {</span><span class="s3">\n    </span><span class="s1">rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');</span><span class="s3">\n    </span><span class="s1">rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$8 = {};</span><span class="s3">\n</span><span class="s1">var TOO_SMALL_CUT_RECT = 28;</span><span class="s3">\n</span><span class="s1">var warnedCutRect = false;</span><span class="s3">\n</span><span class="s1">BRp$8.getNodeShape = function (node) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var shape = node.pstyle('shape').value;</span><span class="s3">\n  </span><span class="s1">if (shape === 'cutrectangle' &amp;&amp; (node.width() &lt; TOO_SMALL_CUT_RECT || node.height() &lt; TOO_SMALL_CUT_RECT)) {</span><span class="s3">\n    </span><span class="s1">if (!warnedCutRect) {</span><span class="s3">\n      </span><span class="s1">warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');</span><span class="s3">\n      </span><span class="s1">warnedCutRect = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 'rectangle';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (node.isParent()) {</span><span class="s3">\n    </span><span class="s1">if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {</span><span class="s3">\n      </span><span class="s1">return shape;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return 'rectangle';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (shape === 'polygon') {</span><span class="s3">\n    </span><span class="s1">var points = node.pstyle('shape-polygon-points').value;</span><span class="s3">\n    </span><span class="s1">return r.nodeShapes.makePolygon(points).name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return shape;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$7 = {};</span><span class="s3">\n</span><span class="s1">BRp$7.registerCalculationListeners = function () {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy;</span><span class="s3">\n  </span><span class="s1">var elesToUpdate = cy.collection();</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var enqueue = function enqueue(eles) {</span><span class="s3">\n    </span><span class="s1">var dirtyStyleCaches = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n    </span><span class="s1">elesToUpdate.merge(eles);</span><span class="s3">\n    </span><span class="s1">if (dirtyStyleCaches) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = eles[i];</span><span class="s3">\n        </span><span class="s1">var _p = ele._private;</span><span class="s3">\n        </span><span class="s1">var rstyle = _p.rstyle;</span><span class="s3">\n        </span><span class="s1">rstyle.clean = false;</span><span class="s3">\n        </span><span class="s1">rstyle.cleanConnected = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {</span><span class="s3">\n    </span><span class="s1">var ele = e.target;</span><span class="s3">\n    </span><span class="s1">enqueue(ele);</span><span class="s3">\n  </span><span class="s1">}).on('style.* background.*', function onDirtyStyle(e) {</span><span class="s3">\n    </span><span class="s1">var ele = e.target;</span><span class="s3">\n    </span><span class="s1">enqueue(ele, false);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var updateEleCalcs = function updateEleCalcs(willDraw) {</span><span class="s3">\n    </span><span class="s1">if (willDraw) {</span><span class="s3">\n      </span><span class="s1">var fns = r.onUpdateEleCalcsFns;</span><span class="s3">\n\n      </span><span class="s1">// because we need to have up-to-date style (e.g. stylesheet mappers)</span><span class="s3">\n      </span><span class="s1">// before calculating rendered style (and pstyle might not be called yet)</span><span class="s3">\n      </span><span class="s1">elesToUpdate.cleanStyle();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; elesToUpdate.length; i++) {</span><span class="s3">\n        </span><span class="s1">var ele = elesToUpdate[i];</span><span class="s3">\n        </span><span class="s1">var rstyle = ele._private.rstyle;</span><span class="s3">\n        </span><span class="s1">if (ele.isNode() &amp;&amp; !rstyle.cleanConnected) {</span><span class="s3">\n          </span><span class="s1">enqueue(ele.connectedEdges());</span><span class="s3">\n          </span><span class="s1">rstyle.cleanConnected = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (fns) {</span><span class="s3">\n        </span><span class="s1">for (var _i = 0; _i &lt; fns.length; _i++) {</span><span class="s3">\n          </span><span class="s1">var fn = fns[_i];</span><span class="s3">\n          </span><span class="s1">fn(willDraw, elesToUpdate);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.recalculateRenderedStyle(elesToUpdate);</span><span class="s3">\n      </span><span class="s1">elesToUpdate = cy.collection();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.flushRenderedStyleQueue = function () {</span><span class="s3">\n    </span><span class="s1">updateEleCalcs(true);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$7.onUpdateEleCalcs = function (fn) {</span><span class="s3">\n  </span><span class="s1">var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];</span><span class="s3">\n  </span><span class="s1">fns.push(fn);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$7.recalculateRenderedStyle = function (eles, useCache) {</span><span class="s3">\n  </span><span class="s1">var isCleanConnected = function isCleanConnected(ele) {</span><span class="s3">\n    </span><span class="s1">return ele._private.rstyle.cleanConnected;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (eles.length === 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var edges = [];</span><span class="s3">\n  </span><span class="s1">var nodes = [];</span><span class="s3">\n\n  </span><span class="s1">// the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()</span><span class="s3">\n  </span><span class="s1">if (this.destroyed) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// use cache by default for perf</span><span class="s3">\n  </span><span class="s1">if (useCache === undefined) {</span><span class="s3">\n    </span><span class="s1">useCache = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">var _p = ele._private;</span><span class="s3">\n    </span><span class="s1">var rstyle = _p.rstyle;</span><span class="s3">\n\n    </span><span class="s1">// an edge may be implicitly dirty b/c of one of its connected nodes</span><span class="s3">\n    </span><span class="s1">// (and a request for recalc may come in between frames)</span><span class="s3">\n    </span><span class="s1">if (ele.isEdge() &amp;&amp; (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {</span><span class="s3">\n      </span><span class="s1">rstyle.clean = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele.isEdge() &amp;&amp; ele.isBundledBezier()) {</span><span class="s3">\n      </span><span class="s1">if (ele.parallelEdges().some(function (ele) {</span><span class="s3">\n        </span><span class="s1">return !ele._private.rstyle.clean &amp;&amp; ele.isBundledBezier();</span><span class="s3">\n      </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">rstyle.clean = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// only update if dirty and in graph</span><span class="s3">\n    </span><span class="s1">if (useCache &amp;&amp; rstyle.clean || ele.removed()) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// only update if not display: none</span><span class="s3">\n    </span><span class="s1">if (ele.pstyle('display').value === 'none') {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (_p.group === 'nodes') {</span><span class="s3">\n      </span><span class="s1">nodes.push(ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// edges</span><span class="s3">\n      </span><span class="s1">edges.push(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rstyle.clean = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// update node data from projections</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; nodes.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var _ele = nodes[_i2];</span><span class="s3">\n    </span><span class="s1">var _p2 = _ele._private;</span><span class="s3">\n    </span><span class="s1">var _rstyle = _p2.rstyle;</span><span class="s3">\n    </span><span class="s1">var pos = _ele.position();</span><span class="s3">\n    </span><span class="s1">this.recalculateNodeLabelProjection(_ele);</span><span class="s3">\n    </span><span class="s1">_rstyle.nodeX = pos.x;</span><span class="s3">\n    </span><span class="s1">_rstyle.nodeY = pos.y;</span><span class="s3">\n    </span><span class="s1">_rstyle.nodeW = _ele.pstyle('width').pfValue;</span><span class="s3">\n    </span><span class="s1">_rstyle.nodeH = _ele.pstyle('height').pfValue;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.recalculateEdgeProjections(edges);</span><span class="s3">\n\n  </span><span class="s1">// update edge data from projections</span><span class="s3">\n  </span><span class="s1">for (var _i3 = 0; _i3 &lt; edges.length; _i3++) {</span><span class="s3">\n    </span><span class="s1">var _ele2 = edges[_i3];</span><span class="s3">\n    </span><span class="s1">var _p3 = _ele2._private;</span><span class="s3">\n    </span><span class="s1">var _rstyle2 = _p3.rstyle;</span><span class="s3">\n    </span><span class="s1">var rs = _p3.rscratch;</span><span class="s3">\n\n    </span><span class="s1">// update rstyle positions</span><span class="s3">\n    </span><span class="s1">_rstyle2.srcX = rs.arrowStartX;</span><span class="s3">\n    </span><span class="s1">_rstyle2.srcY = rs.arrowStartY;</span><span class="s3">\n    </span><span class="s1">_rstyle2.tgtX = rs.arrowEndX;</span><span class="s3">\n    </span><span class="s1">_rstyle2.tgtY = rs.arrowEndY;</span><span class="s3">\n    </span><span class="s1">_rstyle2.midX = rs.midX;</span><span class="s3">\n    </span><span class="s1">_rstyle2.midY = rs.midY;</span><span class="s3">\n    </span><span class="s1">_rstyle2.labelAngle = rs.labelAngle;</span><span class="s3">\n    </span><span class="s1">_rstyle2.sourceLabelAngle = rs.sourceLabelAngle;</span><span class="s3">\n    </span><span class="s1">_rstyle2.targetLabelAngle = rs.targetLabelAngle;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$6 = {};</span><span class="s3">\n</span><span class="s1">BRp$6.updateCachedGrabbedEles = function () {</span><span class="s3">\n  </span><span class="s1">var eles = this.cachedZSortedEles;</span><span class="s3">\n  </span><span class="s1">if (!eles) {</span><span class="s3">\n    </span><span class="s1">// just let this be recalculated on the next z sort tick</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">eles.drag = [];</span><span class="s3">\n  </span><span class="s1">eles.nondrag = [];</span><span class="s3">\n  </span><span class="s1">var grabTargets = [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">var rs = ele._private.rscratch;</span><span class="s3">\n    </span><span class="s1">if (ele.grabbed() &amp;&amp; !ele.isParent()) {</span><span class="s3">\n      </span><span class="s1">grabTargets.push(ele);</span><span class="s3">\n    </span><span class="s1">} else if (rs.inDragLayer) {</span><span class="s3">\n      </span><span class="s1">eles.drag.push(ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">eles.nondrag.push(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// put the grab target nodes last so it's on top of its neighbourhood</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; grabTargets.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = grabTargets[i];</span><span class="s3">\n    </span><span class="s1">eles.drag.push(ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$6.invalidateCachedZSortedEles = function () {</span><span class="s3">\n  </span><span class="s1">this.cachedZSortedEles = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$6.getCachedZSortedEles = function (forceRecalc) {</span><span class="s3">\n  </span><span class="s1">if (forceRecalc || !this.cachedZSortedEles) {</span><span class="s3">\n    </span><span class="s1">var eles = this.cy.mutableElements().toArray();</span><span class="s3">\n    </span><span class="s1">eles.sort(zIndexSort);</span><span class="s3">\n    </span><span class="s1">eles.interactive = eles.filter(function (ele) {</span><span class="s3">\n      </span><span class="s1">return ele.interactive();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">this.cachedZSortedEles = eles;</span><span class="s3">\n    </span><span class="s1">this.updateCachedGrabbedEles();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">eles = this.cachedZSortedEles;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return eles;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$5 = {};</span><span class="s3">\n</span><span class="s1">[BRp$e, BRp$d, BRp$c, BRp$b, BRp$a, BRp$9, BRp$8, BRp$7, BRp$6].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(BRp$5, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var BRp$4 = {};</span><span class="s3">\n</span><span class="s1">BRp$4.getCachedImage = function (url, crossOrigin, onLoad) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var imageCache = r.imageCache = r.imageCache || {};</span><span class="s3">\n  </span><span class="s1">var cache = imageCache[url];</span><span class="s3">\n  </span><span class="s1">if (cache) {</span><span class="s3">\n    </span><span class="s1">if (!cache.image.complete) {</span><span class="s3">\n      </span><span class="s1">cache.image.addEventListener('load', onLoad);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cache.image;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">cache = imageCache[url] = imageCache[url] || {};</span><span class="s3">\n    </span><span class="s1">var image = cache.image = new Image(); // eslint-disable-line no-undef</span><span class="s3">\n\n    </span><span class="s1">image.addEventListener('load', onLoad);</span><span class="s3">\n    </span><span class="s1">image.addEventListener('error', function () {</span><span class="s3">\n      </span><span class="s1">image.error = true;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// #1582 safari doesn't load data uris with crossOrigin properly</span><span class="s3">\n    </span><span class="s1">// https://bugs.webkit.org/show_bug.cgi?id=123978</span><span class="s3">\n    </span><span class="s1">var dataUriPrefix = 'data:';</span><span class="s3">\n    </span><span class="s1">var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;</span><span class="s3">\n    </span><span class="s1">if (!isDataUri) {</span><span class="s3">\n      </span><span class="s1">// if crossorigin is 'null'(stringified), then manually set it to null </span><span class="s3">\n      </span><span class="s1">crossOrigin = crossOrigin === 'null' ? null : crossOrigin;</span><span class="s3">\n      </span><span class="s1">image.crossOrigin = crossOrigin; // prevent tainted canvas</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">image.src = url;</span><span class="s3">\n    </span><span class="s1">return image;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$3 = {};</span><span class="s3">\n\n</span><span class="s1">/* global document, ResizeObserver, MutationObserver */</span><span class="s3">\n\n</span><span class="s1">BRp$3.registerBinding = function (target, event, handler, useCapture) {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-line no-unused-vars</span><span class="s3">\n  </span><span class="s1">var args = Array.prototype.slice.apply(arguments, [1]); // copy</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(target)) {</span><span class="s3">\n    </span><span class="s1">var res = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; target.length; i++) {</span><span class="s3">\n      </span><span class="s1">var t = target[i];</span><span class="s3">\n      </span><span class="s1">if (t !== undefined) {</span><span class="s3">\n        </span><span class="s1">var b = this.binder(t);</span><span class="s3">\n        </span><span class="s1">res.push(b.on.apply(b, args));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var b = this.binder(target);</span><span class="s3">\n  </span><span class="s1">return b.on.apply(b, args);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$3.binder = function (tgt) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var containerWindow = r.cy.window();</span><span class="s3">\n  </span><span class="s1">var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);</span><span class="s3">\n  </span><span class="s1">if (r.supportsPassiveEvents == null) {</span><span class="s3">\n    </span><span class="s1">// from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection</span><span class="s3">\n    </span><span class="s1">var supportsPassive = false;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">var opts = Object.defineProperty({}, 'passive', {</span><span class="s3">\n        </span><span class="s1">get: function get() {</span><span class="s3">\n          </span><span class="s1">supportsPassive = true;</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">containerWindow.addEventListener('test', null, opts);</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// not supported</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.supportsPassiveEvents = supportsPassive;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var on = function on(event, handler, useCapture) {</span><span class="s3">\n    </span><span class="s1">var args = Array.prototype.slice.call(arguments);</span><span class="s3">\n    </span><span class="s1">if (tgtIsDom &amp;&amp; r.supportsPassiveEvents) {</span><span class="s3">\n      </span><span class="s1">// replace useCapture w/ opts obj</span><span class="s3">\n      </span><span class="s1">args[2] = {</span><span class="s3">\n        </span><span class="s1">capture: useCapture != null ? useCapture : false,</span><span class="s3">\n        </span><span class="s1">passive: false,</span><span class="s3">\n        </span><span class="s1">once: false</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.bindings.push({</span><span class="s3">\n      </span><span class="s1">target: tgt,</span><span class="s3">\n      </span><span class="s1">args: args</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">(tgt.addEventListener || tgt.on).apply(tgt, args);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">on: on,</span><span class="s3">\n    </span><span class="s1">addEventListener: on,</span><span class="s3">\n    </span><span class="s1">addListener: on,</span><span class="s3">\n    </span><span class="s1">bind: on</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$3.nodeIsDraggable = function (node) {</span><span class="s3">\n  </span><span class="s1">return node &amp;&amp; node.isNode() &amp;&amp; !node.locked() &amp;&amp; node.grabbable();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$3.nodeIsGrabbable = function (node) {</span><span class="s3">\n  </span><span class="s1">return this.nodeIsDraggable(node) &amp;&amp; node.interactive();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$3.load = function () {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var containerWindow = r.cy.window();</span><span class="s3">\n  </span><span class="s1">var isSelected = function isSelected(ele) {</span><span class="s3">\n    </span><span class="s1">return ele.selected();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getShadowRoot = function getShadowRoot(element) {</span><span class="s3">\n    </span><span class="s1">var rootNode = element.getRootNode();</span><span class="s3">\n    </span><span class="s1">// Check if the root node is a shadow root</span><span class="s3">\n    </span><span class="s1">if (rootNode &amp;&amp; rootNode.nodeType === 11 &amp;&amp; rootNode.host !== undefined) {</span><span class="s3">\n      </span><span class="s1">return rootNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var triggerEvents = function triggerEvents(target, names, e, position) {</span><span class="s3">\n    </span><span class="s1">if (target == null) {</span><span class="s3">\n      </span><span class="s1">target = r.cy;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; names.length; i++) {</span><span class="s3">\n      </span><span class="s1">var name = names[i];</span><span class="s3">\n      </span><span class="s1">target.emit({</span><span class="s3">\n        </span><span class="s1">originalEvent: e,</span><span class="s3">\n        </span><span class="s1">type: name,</span><span class="s3">\n        </span><span class="s1">position: position</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var isMultSelKeyDown = function isMultSelKeyDown(e) {</span><span class="s3">\n    </span><span class="s1">return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {</span><span class="s3">\n    </span><span class="s1">var allowPassthrough = true;</span><span class="s3">\n    </span><span class="s1">if (r.cy.hasCompoundNodes() &amp;&amp; down &amp;&amp; down.pannable()) {</span><span class="s3">\n      </span><span class="s1">// a grabbable compound node below the ele =&gt; no passthrough panning</span><span class="s3">\n      </span><span class="s1">for (var i = 0; downs &amp;&amp; i &lt; downs.length; i++) {</span><span class="s3">\n        </span><span class="s1">var down = downs[i];</span><span class="s3">\n\n        </span><span class="s1">//if any parent node in event hierarchy isn't pannable, reject passthrough</span><span class="s3">\n        </span><span class="s1">if (down.isNode() &amp;&amp; down.isParent() &amp;&amp; !down.pannable()) {</span><span class="s3">\n          </span><span class="s1">allowPassthrough = false;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">allowPassthrough = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return allowPassthrough;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setGrabbed = function setGrabbed(ele) {</span><span class="s3">\n    </span><span class="s1">ele[0]._private.grabbed = true;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setFreed = function setFreed(ele) {</span><span class="s3">\n    </span><span class="s1">ele[0]._private.grabbed = false;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setInDragLayer = function setInDragLayer(ele) {</span><span class="s3">\n    </span><span class="s1">ele[0]._private.rscratch.inDragLayer = true;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setOutDragLayer = function setOutDragLayer(ele) {</span><span class="s3">\n    </span><span class="s1">ele[0]._private.rscratch.inDragLayer = false;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setGrabTarget = function setGrabTarget(ele) {</span><span class="s3">\n    </span><span class="s1">ele[0]._private.rscratch.isGrabTarget = true;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var removeGrabTarget = function removeGrabTarget(ele) {</span><span class="s3">\n    </span><span class="s1">ele[0]._private.rscratch.isGrabTarget = false;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var addToDragList = function addToDragList(ele, opts) {</span><span class="s3">\n    </span><span class="s1">var list = opts.addToList;</span><span class="s3">\n    </span><span class="s1">var listHasEle = list.has(ele);</span><span class="s3">\n    </span><span class="s1">if (!listHasEle &amp;&amp; ele.grabbable() &amp;&amp; !ele.locked()) {</span><span class="s3">\n      </span><span class="s1">list.merge(ele);</span><span class="s3">\n      </span><span class="s1">setGrabbed(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// helper function to determine which child nodes and inner edges</span><span class="s3">\n  </span><span class="s1">// of a compound node to be dragged as well as the grabbed and selected nodes</span><span class="s3">\n  </span><span class="s1">var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {</span><span class="s3">\n    </span><span class="s1">if (!node.cy().hasCompoundNodes()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (opts.inDragLayer == null &amp;&amp; opts.addToList == null) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // nothing to do</span><span class="s3">\n\n    </span><span class="s1">var innerNodes = node.descendants();</span><span class="s3">\n    </span><span class="s1">if (opts.inDragLayer) {</span><span class="s3">\n      </span><span class="s1">innerNodes.forEach(setInDragLayer);</span><span class="s3">\n      </span><span class="s1">innerNodes.connectedEdges().forEach(setInDragLayer);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (opts.addToList) {</span><span class="s3">\n      </span><span class="s1">addToDragList(innerNodes, opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// adds the given nodes and its neighbourhood to the drag layer</span><span class="s3">\n  </span><span class="s1">var addNodesToDrag = function addNodesToDrag(nodes, opts) {</span><span class="s3">\n    </span><span class="s1">opts = opts || {};</span><span class="s3">\n    </span><span class="s1">var hasCompoundNodes = nodes.cy().hasCompoundNodes();</span><span class="s3">\n    </span><span class="s1">if (opts.inDragLayer) {</span><span class="s3">\n      </span><span class="s1">nodes.forEach(setInDragLayer);</span><span class="s3">\n      </span><span class="s1">nodes.neighborhood().stdFilter(function (ele) {</span><span class="s3">\n        </span><span class="s1">return !hasCompoundNodes || ele.isEdge();</span><span class="s3">\n      </span><span class="s1">}).forEach(setInDragLayer);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (opts.addToList) {</span><span class="s3">\n      </span><span class="s1">nodes.forEach(function (ele) {</span><span class="s3">\n        </span><span class="s1">addToDragList(ele, opts);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addDescendantsToDrag(nodes, opts); // always add to drag</span><span class="s3">\n\n    </span><span class="s1">// also add nodes and edges related to the topmost ancestor</span><span class="s3">\n    </span><span class="s1">updateAncestorsInDragLayer(nodes, {</span><span class="s3">\n      </span><span class="s1">inDragLayer: opts.inDragLayer</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">r.updateCachedGrabbedEles();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var addNodeToDrag = addNodesToDrag;</span><span class="s3">\n  </span><span class="s1">var freeDraggedElements = function freeDraggedElements(grabbedEles) {</span><span class="s3">\n    </span><span class="s1">if (!grabbedEles) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// just go over all elements rather than doing a bunch of (possibly expensive) traversals</span><span class="s3">\n    </span><span class="s1">r.getCachedZSortedEles().forEach(function (ele) {</span><span class="s3">\n      </span><span class="s1">setFreed(ele);</span><span class="s3">\n      </span><span class="s1">setOutDragLayer(ele);</span><span class="s3">\n      </span><span class="s1">removeGrabTarget(ele);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">r.updateCachedGrabbedEles();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// helper function to determine which ancestor nodes and edges should go</span><span class="s3">\n  </span><span class="s1">// to the drag layer (or should be removed from drag layer).</span><span class="s3">\n  </span><span class="s1">var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {</span><span class="s3">\n    </span><span class="s1">if (opts.inDragLayer == null &amp;&amp; opts.addToList == null) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // nothing to do</span><span class="s3">\n\n    </span><span class="s1">if (!node.cy().hasCompoundNodes()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// find top-level parent</span><span class="s3">\n    </span><span class="s1">var parent = node.ancestors().orphans();</span><span class="s3">\n\n    </span><span class="s1">// no parent node: no nodes to add to the drag layer</span><span class="s3">\n    </span><span class="s1">if (parent.same(node)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());</span><span class="s3">\n    </span><span class="s1">var edges = nodes.connectedEdges();</span><span class="s3">\n    </span><span class="s1">if (opts.inDragLayer) {</span><span class="s3">\n      </span><span class="s1">edges.forEach(setInDragLayer);</span><span class="s3">\n      </span><span class="s1">nodes.forEach(setInDragLayer);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (opts.addToList) {</span><span class="s3">\n      </span><span class="s1">nodes.forEach(function (ele) {</span><span class="s3">\n        </span><span class="s1">addToDragList(ele, opts);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var blurActiveDomElement = function blurActiveDomElement() {</span><span class="s3">\n    </span><span class="s1">if (document.activeElement != null &amp;&amp; document.activeElement.blur != null) {</span><span class="s3">\n      </span><span class="s1">document.activeElement.blur();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var haveMutationsApi = typeof MutationObserver !== 'undefined';</span><span class="s3">\n  </span><span class="s1">var haveResizeObserverApi = typeof ResizeObserver !== 'undefined';</span><span class="s3">\n\n  </span><span class="s1">// watch for when the cy container is removed from the dom</span><span class="s3">\n  </span><span class="s1">if (haveMutationsApi) {</span><span class="s3">\n    </span><span class="s1">r.removeObserver = new MutationObserver(function (mutns) {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-line no-undef</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; mutns.length; i++) {</span><span class="s3">\n        </span><span class="s1">var mutn = mutns[i];</span><span class="s3">\n        </span><span class="s1">var rNodes = mutn.removedNodes;</span><span class="s3">\n        </span><span class="s1">if (rNodes) {</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; rNodes.length; j++) {</span><span class="s3">\n            </span><span class="s1">var rNode = rNodes[j];</span><span class="s3">\n            </span><span class="s1">if (rNode === r.container) {</span><span class="s3">\n              </span><span class="s1">r.destroy();</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (r.container.parentNode) {</span><span class="s3">\n      </span><span class="s1">r.removeObserver.observe(r.container.parentNode, {</span><span class="s3">\n        </span><span class="s1">childList: true</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-line no-unused-vars</span><span class="s3">\n      </span><span class="s1">r.destroy();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var onResize = debounce(function () {</span><span class="s3">\n    </span><span class="s1">r.cy.resize();</span><span class="s3">\n  </span><span class="s1">}, 100);</span><span class="s3">\n  </span><span class="s1">if (haveMutationsApi) {</span><span class="s3">\n    </span><span class="s1">r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef</span><span class="s3">\n\n    </span><span class="s1">r.styleObserver.observe(r.container, {</span><span class="s3">\n      </span><span class="s1">attributes: true</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// auto resize</span><span class="s3">\n  </span><span class="s1">r.registerBinding(containerWindow, 'resize', onResize); // eslint-disable-line no-undef</span><span class="s3">\n\n  </span><span class="s1">if (haveResizeObserverApi) {</span><span class="s3">\n    </span><span class="s1">r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef</span><span class="s3">\n\n    </span><span class="s1">r.resizeObserver.observe(r.container);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var forEachUp = function forEachUp(domEle, fn) {</span><span class="s3">\n    </span><span class="s1">while (domEle != null) {</span><span class="s3">\n      </span><span class="s1">fn(domEle);</span><span class="s3">\n      </span><span class="s1">domEle = domEle.parentNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var invalidateCoords = function invalidateCoords() {</span><span class="s3">\n    </span><span class="s1">r.invalidateContainerClientCoordsCache();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">forEachUp(r.container, function (domEle) {</span><span class="s3">\n    </span><span class="s1">r.registerBinding(domEle, 'transitionend', invalidateCoords);</span><span class="s3">\n    </span><span class="s1">r.registerBinding(domEle, 'animationend', invalidateCoords);</span><span class="s3">\n    </span><span class="s1">r.registerBinding(domEle, 'scroll', invalidateCoords);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// stop right click menu from appearing on cy</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'contextmenu', function (e) {</span><span class="s3">\n    </span><span class="s1">e.preventDefault();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var inBoxSelection = function inBoxSelection() {</span><span class="s3">\n    </span><span class="s1">return r.selection[4] !== 0;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var eventInContainer = function eventInContainer(e) {</span><span class="s3">\n    </span><span class="s1">// save cycles if mouse events aren't to be captured</span><span class="s3">\n    </span><span class="s1">var containerPageCoords = r.findContainerClientCoords();</span><span class="s3">\n    </span><span class="s1">var x = containerPageCoords[0];</span><span class="s3">\n    </span><span class="s1">var y = containerPageCoords[1];</span><span class="s3">\n    </span><span class="s1">var width = containerPageCoords[2];</span><span class="s3">\n    </span><span class="s1">var height = containerPageCoords[3];</span><span class="s3">\n    </span><span class="s1">var positions = e.touches ? e.touches : [e];</span><span class="s3">\n    </span><span class="s1">var atLeastOnePosInside = false;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; positions.length; i++) {</span><span class="s3">\n      </span><span class="s1">var p = positions[i];</span><span class="s3">\n      </span><span class="s1">if (x &lt;= p.clientX &amp;&amp; p.clientX &lt;= x + width &amp;&amp; y &lt;= p.clientY &amp;&amp; p.clientY &lt;= y + height) {</span><span class="s3">\n        </span><span class="s1">atLeastOnePosInside = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!atLeastOnePosInside) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var container = r.container;</span><span class="s3">\n    </span><span class="s1">var target = e.target;</span><span class="s3">\n    </span><span class="s1">var tParent = target.parentNode;</span><span class="s3">\n    </span><span class="s1">var containerIsTarget = false;</span><span class="s3">\n    </span><span class="s1">while (tParent) {</span><span class="s3">\n      </span><span class="s1">if (tParent === container) {</span><span class="s3">\n        </span><span class="s1">containerIsTarget = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">tParent = tParent.parentNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!containerIsTarget) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} // if target is outisde cy container, then this event is not for us</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// Primary key</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {</span><span class="s3">\n    </span><span class="s1">if (!eventInContainer(e)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// during left mouse button gestures, ignore other buttons</span><span class="s3">\n    </span><span class="s1">if (r.hoverData.which === 1 &amp;&amp; e.which !== 1) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">e.preventDefault();</span><span class="s3">\n    </span><span class="s1">blurActiveDomElement();</span><span class="s3">\n    </span><span class="s1">r.hoverData.capture = true;</span><span class="s3">\n    </span><span class="s1">r.hoverData.which = e.which;</span><span class="s3">\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var gpos = [e.clientX, e.clientY];</span><span class="s3">\n    </span><span class="s1">var pos = r.projectIntoViewport(gpos[0], gpos[1]);</span><span class="s3">\n    </span><span class="s1">var select = r.selection;</span><span class="s3">\n    </span><span class="s1">var nears = r.findNearestElements(pos[0], pos[1], true, false);</span><span class="s3">\n    </span><span class="s1">var near = nears[0];</span><span class="s3">\n    </span><span class="s1">var draggedElements = r.dragData.possibleDragElements;</span><span class="s3">\n    </span><span class="s1">r.hoverData.mdownPos = pos;</span><span class="s3">\n    </span><span class="s1">r.hoverData.mdownGPos = gpos;</span><span class="s3">\n    </span><span class="s1">var checkForTaphold = function checkForTaphold() {</span><span class="s3">\n      </span><span class="s1">r.hoverData.tapholdCancelled = false;</span><span class="s3">\n      </span><span class="s1">clearTimeout(r.hoverData.tapholdTimeout);</span><span class="s3">\n      </span><span class="s1">r.hoverData.tapholdTimeout = setTimeout(function () {</span><span class="s3">\n        </span><span class="s1">if (r.hoverData.tapholdCancelled) {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var ele = r.hoverData.down;</span><span class="s3">\n          </span><span class="s1">if (ele) {</span><span class="s3">\n            </span><span class="s1">ele.emit({</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: 'taphold',</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: pos[0],</span><span class="s3">\n                </span><span class="s1">y: pos[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cy.emit({</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: 'taphold',</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: pos[0],</span><span class="s3">\n                </span><span class="s1">y: pos[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, r.tapholdDuration);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Right click button</span><span class="s3">\n    </span><span class="s1">if (e.which == 3) {</span><span class="s3">\n      </span><span class="s1">r.hoverData.cxtStarted = true;</span><span class="s3">\n      </span><span class="s1">var cxtEvt = {</span><span class="s3">\n        </span><span class="s1">originalEvent: e,</span><span class="s3">\n        </span><span class="s1">type: 'cxttapstart',</span><span class="s3">\n        </span><span class="s1">position: {</span><span class="s3">\n          </span><span class="s1">x: pos[0],</span><span class="s3">\n          </span><span class="s1">y: pos[1]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (near) {</span><span class="s3">\n        </span><span class="s1">near.activate();</span><span class="s3">\n        </span><span class="s1">near.emit(cxtEvt);</span><span class="s3">\n        </span><span class="s1">r.hoverData.down = near;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cy.emit(cxtEvt);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.hoverData.downTime = new Date().getTime();</span><span class="s3">\n      </span><span class="s1">r.hoverData.cxtDragged = false;</span><span class="s3">\n\n      </span><span class="s1">// Primary button</span><span class="s3">\n    </span><span class="s1">} else if (e.which == 1) {</span><span class="s3">\n      </span><span class="s1">if (near) {</span><span class="s3">\n        </span><span class="s1">near.activate();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Element dragging</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">// If something is under the cursor and it is draggable, prepare to grab it</span><span class="s3">\n        </span><span class="s1">if (near != null) {</span><span class="s3">\n          </span><span class="s1">if (r.nodeIsGrabbable(near)) {</span><span class="s3">\n            </span><span class="s1">var makeEvent = function makeEvent(type) {</span><span class="s3">\n              </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">originalEvent: e,</span><span class="s3">\n                </span><span class="s1">type: type,</span><span class="s3">\n                </span><span class="s1">position: {</span><span class="s3">\n                  </span><span class="s1">x: pos[0],</span><span class="s3">\n                  </span><span class="s1">y: pos[1]</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">var triggerGrab = function triggerGrab(ele) {</span><span class="s3">\n              </span><span class="s1">ele.emit(makeEvent('grab'));</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">setGrabTarget(near);</span><span class="s3">\n            </span><span class="s1">if (!near.selected()) {</span><span class="s3">\n              </span><span class="s1">draggedElements = r.dragData.possibleDragElements = cy.collection();</span><span class="s3">\n              </span><span class="s1">addNodeToDrag(near, {</span><span class="s3">\n                </span><span class="s1">addToList: draggedElements</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">near.emit(makeEvent('grabon')).emit(makeEvent('grab'));</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">draggedElements = r.dragData.possibleDragElements = cy.collection();</span><span class="s3">\n              </span><span class="s1">var selectedNodes = cy.$(function (ele) {</span><span class="s3">\n                </span><span class="s1">return ele.isNode() &amp;&amp; ele.selected() &amp;&amp; r.nodeIsGrabbable(ele);</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">addNodesToDrag(selectedNodes, {</span><span class="s3">\n                </span><span class="s1">addToList: draggedElements</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">near.emit(makeEvent('grabon'));</span><span class="s3">\n              </span><span class="s1">selectedNodes.forEach(triggerGrab);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n            </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.hoverData.down = near;</span><span class="s3">\n        </span><span class="s1">r.hoverData.downs = nears;</span><span class="s3">\n        </span><span class="s1">r.hoverData.downTime = new Date().getTime();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {</span><span class="s3">\n        </span><span class="s1">x: pos[0],</span><span class="s3">\n        </span><span class="s1">y: pos[1]</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">if (near == null) {</span><span class="s3">\n        </span><span class="s1">select[4] = 1;</span><span class="s3">\n        </span><span class="s1">r.data.bgActivePosistion = {</span><span class="s3">\n          </span><span class="s1">x: pos[0],</span><span class="s3">\n          </span><span class="s1">y: pos[1]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">} else if (near.pannable()) {</span><span class="s3">\n        </span><span class="s1">select[4] = 1; // for future pan</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">checkForTaphold();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Initialize selection box coordinates</span><span class="s3">\n    </span><span class="s1">select[0] = select[2] = pos[0];</span><span class="s3">\n    </span><span class="s1">select[1] = select[3] = pos[1];</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">var shadowRoot = getShadowRoot(r.container);</span><span class="s3">\n  </span><span class="s1">r.registerBinding([containerWindow, shadowRoot], 'mousemove', function mousemoveHandler(e) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">var capture = r.hoverData.capture;</span><span class="s3">\n    </span><span class="s1">if (!capture &amp;&amp; !eventInContainer(e)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var preventDefault = false;</span><span class="s3">\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">var gpos = [e.clientX, e.clientY];</span><span class="s3">\n    </span><span class="s1">var pos = r.projectIntoViewport(gpos[0], gpos[1]);</span><span class="s3">\n    </span><span class="s1">var mdownPos = r.hoverData.mdownPos;</span><span class="s3">\n    </span><span class="s1">var mdownGPos = r.hoverData.mdownGPos;</span><span class="s3">\n    </span><span class="s1">var select = r.selection;</span><span class="s3">\n    </span><span class="s1">var near = null;</span><span class="s3">\n    </span><span class="s1">if (!r.hoverData.draggingEles &amp;&amp; !r.hoverData.dragging &amp;&amp; !r.hoverData.selecting) {</span><span class="s3">\n      </span><span class="s1">near = r.findNearestElement(pos[0], pos[1], true, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var last = r.hoverData.last;</span><span class="s3">\n    </span><span class="s1">var down = r.hoverData.down;</span><span class="s3">\n    </span><span class="s1">var disp = [pos[0] - select[2], pos[1] - select[3]];</span><span class="s3">\n    </span><span class="s1">var draggedElements = r.dragData.possibleDragElements;</span><span class="s3">\n    </span><span class="s1">var isOverThresholdDrag;</span><span class="s3">\n    </span><span class="s1">if (mdownGPos) {</span><span class="s3">\n      </span><span class="s1">var dx = gpos[0] - mdownGPos[0];</span><span class="s3">\n      </span><span class="s1">var dx2 = dx * dx;</span><span class="s3">\n      </span><span class="s1">var dy = gpos[1] - mdownGPos[1];</span><span class="s3">\n      </span><span class="s1">var dy2 = dy * dy;</span><span class="s3">\n      </span><span class="s1">var dist2 = dx2 + dy2;</span><span class="s3">\n      </span><span class="s1">r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 &gt;= r.desktopTapThreshold2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var multSelKeyDown = isMultSelKeyDown(e);</span><span class="s3">\n    </span><span class="s1">if (isOverThresholdDrag) {</span><span class="s3">\n      </span><span class="s1">r.hoverData.tapholdCancelled = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var updateDragDelta = function updateDragDelta() {</span><span class="s3">\n      </span><span class="s1">var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];</span><span class="s3">\n      </span><span class="s1">if (dragDelta.length === 0) {</span><span class="s3">\n        </span><span class="s1">dragDelta.push(disp[0]);</span><span class="s3">\n        </span><span class="s1">dragDelta.push(disp[1]);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dragDelta[0] += disp[0];</span><span class="s3">\n        </span><span class="s1">dragDelta[1] += disp[1];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">preventDefault = true;</span><span class="s3">\n    </span><span class="s1">triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {</span><span class="s3">\n      </span><span class="s1">x: pos[0],</span><span class="s3">\n      </span><span class="s1">y: pos[1]</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var goIntoBoxMode = function goIntoBoxMode() {</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">if (!r.hoverData.selecting) {</span><span class="s3">\n        </span><span class="s1">cy.emit({</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">type: 'boxstart',</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">select[4] = 1;</span><span class="s3">\n      </span><span class="s1">r.hoverData.selecting = true;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// trigger context drag if rmouse down</span><span class="s3">\n    </span><span class="s1">if (r.hoverData.which === 3) {</span><span class="s3">\n      </span><span class="s1">// but only if over threshold</span><span class="s3">\n      </span><span class="s1">if (isOverThresholdDrag) {</span><span class="s3">\n        </span><span class="s1">var cxtEvt = {</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">type: 'cxtdrag',</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (down) {</span><span class="s3">\n          </span><span class="s1">down.emit(cxtEvt);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cy.emit(cxtEvt);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.hoverData.cxtDragged = true;</span><span class="s3">\n        </span><span class="s1">if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {</span><span class="s3">\n          </span><span class="s1">if (r.hoverData.cxtOver) {</span><span class="s3">\n            </span><span class="s1">r.hoverData.cxtOver.emit({</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: 'cxtdragout',</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: pos[0],</span><span class="s3">\n                </span><span class="s1">y: pos[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">r.hoverData.cxtOver = near;</span><span class="s3">\n          </span><span class="s1">if (near) {</span><span class="s3">\n            </span><span class="s1">near.emit({</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: 'cxtdragover',</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: pos[0],</span><span class="s3">\n                </span><span class="s1">y: pos[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check if we are drag panning the entire graph</span><span class="s3">\n    </span><span class="s1">} else if (r.hoverData.dragging) {</span><span class="s3">\n      </span><span class="s1">preventDefault = true;</span><span class="s3">\n      </span><span class="s1">if (cy.panningEnabled() &amp;&amp; cy.userPanningEnabled()) {</span><span class="s3">\n        </span><span class="s1">var deltaP;</span><span class="s3">\n        </span><span class="s1">if (r.hoverData.justStartedPan) {</span><span class="s3">\n          </span><span class="s1">var mdPos = r.hoverData.mdownPos;</span><span class="s3">\n          </span><span class="s1">deltaP = {</span><span class="s3">\n            </span><span class="s1">x: (pos[0] - mdPos[0]) * zoom,</span><span class="s3">\n            </span><span class="s1">y: (pos[1] - mdPos[1]) * zoom</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">r.hoverData.justStartedPan = false;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">deltaP = {</span><span class="s3">\n            </span><span class="s1">x: disp[0] * zoom,</span><span class="s3">\n            </span><span class="s1">y: disp[1] * zoom</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cy.panBy(deltaP);</span><span class="s3">\n        </span><span class="s1">cy.emit('dragpan');</span><span class="s3">\n        </span><span class="s1">r.hoverData.dragged = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Needs reproject due to pan changing viewport</span><span class="s3">\n      </span><span class="s1">pos = r.projectIntoViewport(e.clientX, e.clientY);</span><span class="s3">\n\n      </span><span class="s1">// Checks primary button down &amp; out of time &amp; mouse not moved much</span><span class="s3">\n    </span><span class="s1">} else if (select[4] == 1 &amp;&amp; (down == null || down.pannable())) {</span><span class="s3">\n      </span><span class="s1">if (isOverThresholdDrag) {</span><span class="s3">\n        </span><span class="s1">if (!r.hoverData.dragging &amp;&amp; cy.boxSelectionEnabled() &amp;&amp; (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {</span><span class="s3">\n          </span><span class="s1">goIntoBoxMode();</span><span class="s3">\n        </span><span class="s1">} else if (!r.hoverData.selecting &amp;&amp; cy.panningEnabled() &amp;&amp; cy.userPanningEnabled()) {</span><span class="s3">\n          </span><span class="s1">var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);</span><span class="s3">\n          </span><span class="s1">if (allowPassthrough) {</span><span class="s3">\n            </span><span class="s1">r.hoverData.dragging = true;</span><span class="s3">\n            </span><span class="s1">r.hoverData.justStartedPan = true;</span><span class="s3">\n            </span><span class="s1">select[4] = 0;</span><span class="s3">\n            </span><span class="s1">r.data.bgActivePosistion = array2point(mdownPos);</span><span class="s3">\n            </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n            </span><span class="s1">r.redraw();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (down &amp;&amp; down.pannable() &amp;&amp; down.active()) {</span><span class="s3">\n          </span><span class="s1">down.unactivate();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (down &amp;&amp; down.pannable() &amp;&amp; down.active()) {</span><span class="s3">\n        </span><span class="s1">down.unactivate();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if ((!down || !down.grabbed()) &amp;&amp; near != last) {</span><span class="s3">\n        </span><span class="s1">if (last) {</span><span class="s3">\n          </span><span class="s1">triggerEvents(last, ['mouseout', 'tapdragout'], e, {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (near) {</span><span class="s3">\n          </span><span class="s1">triggerEvents(near, ['mouseover', 'tapdragover'], e, {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.hoverData.last = near;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (down) {</span><span class="s3">\n        </span><span class="s1">if (isOverThresholdDrag) {</span><span class="s3">\n          </span><span class="s1">// then we can take action</span><span class="s3">\n\n          </span><span class="s1">if (cy.boxSelectionEnabled() &amp;&amp; multSelKeyDown) {</span><span class="s3">\n            </span><span class="s1">// then selection overrides</span><span class="s3">\n            </span><span class="s1">if (down &amp;&amp; down.grabbed()) {</span><span class="s3">\n              </span><span class="s1">freeDraggedElements(draggedElements);</span><span class="s3">\n              </span><span class="s1">down.emit('freeon');</span><span class="s3">\n              </span><span class="s1">draggedElements.emit('free');</span><span class="s3">\n              </span><span class="s1">if (r.dragData.didDrag) {</span><span class="s3">\n                </span><span class="s1">down.emit('dragfreeon');</span><span class="s3">\n                </span><span class="s1">draggedElements.emit('dragfree');</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">goIntoBoxMode();</span><span class="s3">\n          </span><span class="s1">} else if (down &amp;&amp; down.grabbed() &amp;&amp; r.nodeIsDraggable(down)) {</span><span class="s3">\n            </span><span class="s1">// drag node</span><span class="s3">\n            </span><span class="s1">var justStartedDrag = !r.dragData.didDrag;</span><span class="s3">\n            </span><span class="s1">if (justStartedDrag) {</span><span class="s3">\n              </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">r.dragData.didDrag = true; // indicate that we actually did drag the node</span><span class="s3">\n\n            </span><span class="s1">// now, add the elements to the drag layer if not done already</span><span class="s3">\n            </span><span class="s1">if (!r.hoverData.draggingEles) {</span><span class="s3">\n              </span><span class="s1">addNodesToDrag(draggedElements, {</span><span class="s3">\n                </span><span class="s1">inDragLayer: true</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var totalShift = {</span><span class="s3">\n              </span><span class="s1">x: 0,</span><span class="s3">\n              </span><span class="s1">y: 0</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">if (number$1(disp[0]) &amp;&amp; number$1(disp[1])) {</span><span class="s3">\n              </span><span class="s1">totalShift.x += disp[0];</span><span class="s3">\n              </span><span class="s1">totalShift.y += disp[1];</span><span class="s3">\n              </span><span class="s1">if (justStartedDrag) {</span><span class="s3">\n                </span><span class="s1">var dragDelta = r.hoverData.dragDelta;</span><span class="s3">\n                </span><span class="s1">if (dragDelta &amp;&amp; number$1(dragDelta[0]) &amp;&amp; number$1(dragDelta[1])) {</span><span class="s3">\n                  </span><span class="s1">totalShift.x += dragDelta[0];</span><span class="s3">\n                  </span><span class="s1">totalShift.y += dragDelta[1];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">r.hoverData.draggingEles = true;</span><span class="s3">\n            </span><span class="s1">draggedElements.silentShift(totalShift).emit('position drag');</span><span class="s3">\n            </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n            </span><span class="s1">r.redraw();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// otherwise save drag delta for when we actually start dragging so the relative grab pos is constant</span><span class="s3">\n          </span><span class="s1">updateDragDelta();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// prevent the dragging from triggering text selection on the page</span><span class="s3">\n      </span><span class="s1">preventDefault = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">select[2] = pos[0];</span><span class="s3">\n    </span><span class="s1">select[3] = pos[1];</span><span class="s3">\n    </span><span class="s1">if (preventDefault) {</span><span class="s3">\n      </span><span class="s1">if (e.stopPropagation) e.stopPropagation();</span><span class="s3">\n      </span><span class="s1">if (e.preventDefault) e.preventDefault();</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">var clickTimeout, didDoubleClick, prevClickTimeStamp;</span><span class="s3">\n  </span><span class="s1">r.registerBinding(containerWindow, 'mouseup', function mouseupHandler(e) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">// during left mouse button gestures, ignore other buttons</span><span class="s3">\n    </span><span class="s1">if (r.hoverData.which === 1 &amp;&amp; e.which !== 1 &amp;&amp; r.hoverData.capture) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var capture = r.hoverData.capture;</span><span class="s3">\n    </span><span class="s1">if (!capture) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.hoverData.capture = false;</span><span class="s3">\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var pos = r.projectIntoViewport(e.clientX, e.clientY);</span><span class="s3">\n    </span><span class="s1">var select = r.selection;</span><span class="s3">\n    </span><span class="s1">var near = r.findNearestElement(pos[0], pos[1], true, false);</span><span class="s3">\n    </span><span class="s1">var draggedElements = r.dragData.possibleDragElements;</span><span class="s3">\n    </span><span class="s1">var down = r.hoverData.down;</span><span class="s3">\n    </span><span class="s1">var multSelKeyDown = isMultSelKeyDown(e);</span><span class="s3">\n    </span><span class="s1">if (r.data.bgActivePosistion) {</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.hoverData.tapholdCancelled = true;</span><span class="s3">\n    </span><span class="s1">r.data.bgActivePosistion = undefined; // not active bg now</span><span class="s3">\n\n    </span><span class="s1">if (down) {</span><span class="s3">\n      </span><span class="s1">down.unactivate();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (r.hoverData.which === 3) {</span><span class="s3">\n      </span><span class="s1">var cxtEvt = {</span><span class="s3">\n        </span><span class="s1">originalEvent: e,</span><span class="s3">\n        </span><span class="s1">type: 'cxttapend',</span><span class="s3">\n        </span><span class="s1">position: {</span><span class="s3">\n          </span><span class="s1">x: pos[0],</span><span class="s3">\n          </span><span class="s1">y: pos[1]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (down) {</span><span class="s3">\n        </span><span class="s1">down.emit(cxtEvt);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cy.emit(cxtEvt);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!r.hoverData.cxtDragged) {</span><span class="s3">\n        </span><span class="s1">var cxtTap = {</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">type: 'cxttap',</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (down) {</span><span class="s3">\n          </span><span class="s1">down.emit(cxtTap);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cy.emit(cxtTap);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.hoverData.cxtDragged = false;</span><span class="s3">\n      </span><span class="s1">r.hoverData.which = null;</span><span class="s3">\n    </span><span class="s1">} else if (r.hoverData.which === 1) {</span><span class="s3">\n      </span><span class="s1">triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {</span><span class="s3">\n        </span><span class="s1">x: pos[0],</span><span class="s3">\n        </span><span class="s1">y: pos[1]</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">if (!r.dragData.didDrag &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// didn't move a node around</span><span class="s3">\n      </span><span class="s1">!r.hoverData.dragged &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// didn't pan</span><span class="s3">\n      </span><span class="s1">!r.hoverData.selecting &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// not box selection</span><span class="s3">\n      </span><span class="s1">!r.hoverData.isOverThresholdDrag // didn't move too much</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">triggerEvents(down, [</span><span class="s3">\&quot;</span><span class="s1">click</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">tap</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">vclick</span><span class="s3">\&quot;</span><span class="s1">], e, {</span><span class="s3">\n          </span><span class="s1">x: pos[0],</span><span class="s3">\n          </span><span class="s1">y: pos[1]</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">didDoubleClick = false;</span><span class="s3">\n        </span><span class="s1">if (e.timeStamp - prevClickTimeStamp &lt;= cy.multiClickDebounceTime()) {</span><span class="s3">\n          </span><span class="s1">clickTimeout &amp;&amp; clearTimeout(clickTimeout);</span><span class="s3">\n          </span><span class="s1">didDoubleClick = true;</span><span class="s3">\n          </span><span class="s1">prevClickTimeStamp = null;</span><span class="s3">\n          </span><span class="s1">triggerEvents(down, [</span><span class="s3">\&quot;</span><span class="s1">dblclick</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dbltap</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">vdblclick</span><span class="s3">\&quot;</span><span class="s1">], e, {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">clickTimeout = setTimeout(function () {</span><span class="s3">\n            </span><span class="s1">if (didDoubleClick) return;</span><span class="s3">\n            </span><span class="s1">triggerEvents(down, [</span><span class="s3">\&quot;</span><span class="s1">oneclick</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onetap</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">voneclick</span><span class="s3">\&quot;</span><span class="s1">], e, {</span><span class="s3">\n              </span><span class="s1">x: pos[0],</span><span class="s3">\n              </span><span class="s1">y: pos[1]</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}, cy.multiClickDebounceTime());</span><span class="s3">\n          </span><span class="s1">prevClickTimeStamp = e.timeStamp;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something</span><span class="s3">\n      </span><span class="s1">if (down == null // not mousedown on node</span><span class="s3">\n      </span><span class="s1">&amp;&amp; !r.dragData.didDrag // didn't move the node around</span><span class="s3">\n      </span><span class="s1">&amp;&amp; !r.hoverData.selecting // not box selection</span><span class="s3">\n      </span><span class="s1">&amp;&amp; !r.hoverData.dragged // didn't pan</span><span class="s3">\n      </span><span class="s1">&amp;&amp; !isMultSelKeyDown(e)) {</span><span class="s3">\n        </span><span class="s1">cy.$(isSelected).unselect(['tapunselect']);</span><span class="s3">\n        </span><span class="s1">if (draggedElements.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.dragData.possibleDragElements = draggedElements = cy.collection();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Single selection</span><span class="s3">\n      </span><span class="s1">if (near == down &amp;&amp; !r.dragData.didDrag &amp;&amp; !r.hoverData.selecting) {</span><span class="s3">\n        </span><span class="s1">if (near != null &amp;&amp; near._private.selectable) {</span><span class="s3">\n          </span><span class="s1">if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {</span><span class="s3">\n            </span><span class="s1">if (near.selected()) {</span><span class="s3">\n              </span><span class="s1">near.unselect(['tapunselect']);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">near.select(['tapselect']);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">if (!multSelKeyDown) {</span><span class="s3">\n              </span><span class="s1">cy.$(isSelected).unmerge(near).unselect(['tapunselect']);</span><span class="s3">\n              </span><span class="s1">near.select(['tapselect']);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (r.hoverData.selecting) {</span><span class="s3">\n        </span><span class="s1">var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));</span><span class="s3">\n        </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n        </span><span class="s1">if (box.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cy.emit({</span><span class="s3">\n          </span><span class="s1">type: 'boxend',</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: pos[0],</span><span class="s3">\n            </span><span class="s1">y: pos[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">var eleWouldBeSelected = function eleWouldBeSelected(ele) {</span><span class="s3">\n          </span><span class="s1">return ele.selectable() &amp;&amp; !ele.selected();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (cy.selectionType() === 'additive') {</span><span class="s3">\n          </span><span class="s1">box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (!multSelKeyDown) {</span><span class="s3">\n            </span><span class="s1">cy.$(isSelected).unmerge(box).unselect();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// always need redraw in case eles unselectable</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Cancel drag pan</span><span class="s3">\n      </span><span class="s1">if (r.hoverData.dragging) {</span><span class="s3">\n        </span><span class="s1">r.hoverData.dragging = false;</span><span class="s3">\n        </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!select[4]) {</span><span class="s3">\n        </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">var downWasGrabbed = down &amp;&amp; down.grabbed();</span><span class="s3">\n        </span><span class="s1">freeDraggedElements(draggedElements);</span><span class="s3">\n        </span><span class="s1">if (downWasGrabbed) {</span><span class="s3">\n          </span><span class="s1">down.emit('freeon');</span><span class="s3">\n          </span><span class="s1">draggedElements.emit('free');</span><span class="s3">\n          </span><span class="s1">if (r.dragData.didDrag) {</span><span class="s3">\n            </span><span class="s1">down.emit('dragfreeon');</span><span class="s3">\n            </span><span class="s1">draggedElements.emit('dragfree');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} // else not right mouse</span><span class="s3">\n\n    </span><span class="s1">select[4] = 0;</span><span class="s3">\n    </span><span class="s1">r.hoverData.down = null;</span><span class="s3">\n    </span><span class="s1">r.hoverData.cxtStarted = false;</span><span class="s3">\n    </span><span class="s1">r.hoverData.draggingEles = false;</span><span class="s3">\n    </span><span class="s1">r.hoverData.selecting = false;</span><span class="s3">\n    </span><span class="s1">r.hoverData.isOverThresholdDrag = false;</span><span class="s3">\n    </span><span class="s1">r.dragData.didDrag = false;</span><span class="s3">\n    </span><span class="s1">r.hoverData.dragged = false;</span><span class="s3">\n    </span><span class="s1">r.hoverData.dragDelta = [];</span><span class="s3">\n    </span><span class="s1">r.hoverData.mdownPos = null;</span><span class="s3">\n    </span><span class="s1">r.hoverData.mdownGPos = null;</span><span class="s3">\n    </span><span class="s1">r.hoverData.which = null;</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">var wheelHandler = function wheelHandler(e) {</span><span class="s3">\n    </span><span class="s1">if (r.scrollingPage) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} // while scrolling, ignore wheel-to-zoom</span><span class="s3">\n\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n    </span><span class="s1">var pos = r.projectIntoViewport(e.clientX, e.clientY);</span><span class="s3">\n    </span><span class="s1">var rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];</span><span class="s3">\n    </span><span class="s1">if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {</span><span class="s3">\n      </span><span class="s1">// if pan dragging or cxt dragging, wheel movements make no zoom</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cy.panningEnabled() &amp;&amp; cy.userPanningEnabled() &amp;&amp; cy.zoomingEnabled() &amp;&amp; cy.userZoomingEnabled()) {</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">r.data.wheelZooming = true;</span><span class="s3">\n      </span><span class="s1">clearTimeout(r.data.wheelTimeout);</span><span class="s3">\n      </span><span class="s1">r.data.wheelTimeout = setTimeout(function () {</span><span class="s3">\n        </span><span class="s1">r.data.wheelZooming = false;</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">}, 150);</span><span class="s3">\n      </span><span class="s1">var diff;</span><span class="s3">\n      </span><span class="s1">if (e.deltaY != null) {</span><span class="s3">\n        </span><span class="s1">diff = e.deltaY / -250;</span><span class="s3">\n      </span><span class="s1">} else if (e.wheelDeltaY != null) {</span><span class="s3">\n        </span><span class="s1">diff = e.wheelDeltaY / 1000;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">diff = e.wheelDelta / 1000;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">diff = diff * r.wheelSensitivity;</span><span class="s3">\n      </span><span class="s1">var needsWheelFix = e.deltaMode === 1;</span><span class="s3">\n      </span><span class="s1">if (needsWheelFix) {</span><span class="s3">\n        </span><span class="s1">// fixes slow wheel events on ff/linux and ff/windows</span><span class="s3">\n        </span><span class="s1">diff *= 33;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var newZoom = cy.zoom() * Math.pow(10, diff);</span><span class="s3">\n      </span><span class="s1">if (e.type === 'gesturechange') {</span><span class="s3">\n        </span><span class="s1">newZoom = r.gestureStartZoom * e.scale;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cy.zoom({</span><span class="s3">\n        </span><span class="s1">level: newZoom,</span><span class="s3">\n        </span><span class="s1">renderedPosition: {</span><span class="s3">\n          </span><span class="s1">x: rpos[0],</span><span class="s3">\n          </span><span class="s1">y: rpos[1]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">cy.emit(e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// Functions to help with whether mouse wheel should trigger zooming</span><span class="s3">\n  </span><span class="s1">// --</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'wheel', wheelHandler, true);</span><span class="s3">\n\n  </span><span class="s1">// disable nonstandard wheel events</span><span class="s3">\n  </span><span class="s1">// r.registerBinding(r.container, 'mousewheel', wheelHandler, true);</span><span class="s3">\n  </span><span class="s1">// r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);</span><span class="s3">\n  </span><span class="s1">// r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox</span><span class="s3">\n\n  </span><span class="s1">r.registerBinding(containerWindow, 'scroll', function scrollHandler(e) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-line no-unused-vars</span><span class="s3">\n    </span><span class="s1">r.scrollingPage = true;</span><span class="s3">\n    </span><span class="s1">clearTimeout(r.scrollingPageTimeout);</span><span class="s3">\n    </span><span class="s1">r.scrollingPageTimeout = setTimeout(function () {</span><span class="s3">\n      </span><span class="s1">r.scrollingPage = false;</span><span class="s3">\n    </span><span class="s1">}, 250);</span><span class="s3">\n  </span><span class="s1">}, true);</span><span class="s3">\n\n  </span><span class="s1">// desktop safari pinch to zoom start</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {</span><span class="s3">\n    </span><span class="s1">r.gestureStartZoom = r.cy.zoom();</span><span class="s3">\n    </span><span class="s1">if (!r.hasTouchStarted) {</span><span class="s3">\n      </span><span class="s1">// don't affect touch devices like iphone</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, true);</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'gesturechange', function (e) {</span><span class="s3">\n    </span><span class="s1">if (!r.hasTouchStarted) {</span><span class="s3">\n      </span><span class="s1">// don't affect touch devices like iphone</span><span class="s3">\n      </span><span class="s1">wheelHandler(e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, true);</span><span class="s3">\n\n  </span><span class="s1">// Functions to help with handling mouseout/mouseover on the Cytoscape container</span><span class="s3">\n  </span><span class="s1">// Handle mouseout on Cytoscape container</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {</span><span class="s3">\n    </span><span class="s1">var pos = r.projectIntoViewport(e.clientX, e.clientY);</span><span class="s3">\n    </span><span class="s1">r.cy.emit({</span><span class="s3">\n      </span><span class="s1">originalEvent: e,</span><span class="s3">\n      </span><span class="s1">type: 'mouseout',</span><span class="s3">\n      </span><span class="s1">position: {</span><span class="s3">\n        </span><span class="s1">x: pos[0],</span><span class="s3">\n        </span><span class="s1">y: pos[1]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {</span><span class="s3">\n    </span><span class="s1">var pos = r.projectIntoViewport(e.clientX, e.clientY);</span><span class="s3">\n    </span><span class="s1">r.cy.emit({</span><span class="s3">\n      </span><span class="s1">originalEvent: e,</span><span class="s3">\n      </span><span class="s1">type: 'mouseover',</span><span class="s3">\n      </span><span class="s1">position: {</span><span class="s3">\n        </span><span class="s1">x: pos[0],</span><span class="s3">\n        </span><span class="s1">y: pos[1]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom</span><span class="s3">\n  </span><span class="s1">var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom</span><span class="s3">\n  </span><span class="s1">var center1, modelCenter1; // center point on start pinch to zoom</span><span class="s3">\n  </span><span class="s1">var offsetLeft, offsetTop;</span><span class="s3">\n  </span><span class="s1">var containerWidth, containerHeight;</span><span class="s3">\n  </span><span class="s1">var twoFingersStartInside;</span><span class="s3">\n  </span><span class="s1">var distance = function distance(x1, y1, x2, y2) {</span><span class="s3">\n    </span><span class="s1">return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var distanceSq = function distanceSq(x1, y1, x2, y2) {</span><span class="s3">\n    </span><span class="s1">return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var touchstartHandler;</span><span class="s3">\n  </span><span class="s1">r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {</span><span class="s3">\n    </span><span class="s1">r.hasTouchStarted = true;</span><span class="s3">\n    </span><span class="s1">if (!eventInContainer(e)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blurActiveDomElement();</span><span class="s3">\n    </span><span class="s1">r.touchData.capture = true;</span><span class="s3">\n    </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var now = r.touchData.now;</span><span class="s3">\n    </span><span class="s1">var earlier = r.touchData.earlier;</span><span class="s3">\n    </span><span class="s1">if (e.touches[0]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);</span><span class="s3">\n      </span><span class="s1">now[0] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[1] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[1]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);</span><span class="s3">\n      </span><span class="s1">now[2] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[3] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[2]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);</span><span class="s3">\n      </span><span class="s1">now[4] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[5] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// record starting points for pinch-to-zoom</span><span class="s3">\n    </span><span class="s1">if (e.touches[1]) {</span><span class="s3">\n      </span><span class="s1">r.touchData.singleTouchMoved = true;</span><span class="s3">\n      </span><span class="s1">freeDraggedElements(r.dragData.touchDragEles);</span><span class="s3">\n      </span><span class="s1">var offsets = r.findContainerClientCoords();</span><span class="s3">\n      </span><span class="s1">offsetLeft = offsets[0];</span><span class="s3">\n      </span><span class="s1">offsetTop = offsets[1];</span><span class="s3">\n      </span><span class="s1">containerWidth = offsets[2];</span><span class="s3">\n      </span><span class="s1">containerHeight = offsets[3];</span><span class="s3">\n      </span><span class="s1">f1x1 = e.touches[0].clientX - offsetLeft;</span><span class="s3">\n      </span><span class="s1">f1y1 = e.touches[0].clientY - offsetTop;</span><span class="s3">\n      </span><span class="s1">f2x1 = e.touches[1].clientX - offsetLeft;</span><span class="s3">\n      </span><span class="s1">f2y1 = e.touches[1].clientY - offsetTop;</span><span class="s3">\n      </span><span class="s1">twoFingersStartInside = 0 &lt;= f1x1 &amp;&amp; f1x1 &lt;= containerWidth &amp;&amp; 0 &lt;= f2x1 &amp;&amp; f2x1 &lt;= containerWidth &amp;&amp; 0 &lt;= f1y1 &amp;&amp; f1y1 &lt;= containerHeight &amp;&amp; 0 &lt;= f2y1 &amp;&amp; f2y1 &lt;= containerHeight;</span><span class="s3">\n      </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n      </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n      </span><span class="s1">distance1 = distance(f1x1, f1y1, f2x1, f2y1);</span><span class="s3">\n      </span><span class="s1">distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);</span><span class="s3">\n      </span><span class="s1">center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];</span><span class="s3">\n      </span><span class="s1">modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];</span><span class="s3">\n\n      </span><span class="s1">// consider context tap</span><span class="s3">\n      </span><span class="s1">var cxtDistThreshold = 200;</span><span class="s3">\n      </span><span class="s1">var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;</span><span class="s3">\n      </span><span class="s1">if (distance1Sq &lt; cxtDistThresholdSq &amp;&amp; !e.touches[2]) {</span><span class="s3">\n        </span><span class="s1">var near1 = r.findNearestElement(now[0], now[1], true, true);</span><span class="s3">\n        </span><span class="s1">var near2 = r.findNearestElement(now[2], now[3], true, true);</span><span class="s3">\n        </span><span class="s1">if (near1 &amp;&amp; near1.isNode()) {</span><span class="s3">\n          </span><span class="s1">near1.activate().emit({</span><span class="s3">\n            </span><span class="s1">originalEvent: e,</span><span class="s3">\n            </span><span class="s1">type: 'cxttapstart',</span><span class="s3">\n            </span><span class="s1">position: {</span><span class="s3">\n              </span><span class="s1">x: now[0],</span><span class="s3">\n              </span><span class="s1">y: now[1]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">r.touchData.start = near1;</span><span class="s3">\n        </span><span class="s1">} else if (near2 &amp;&amp; near2.isNode()) {</span><span class="s3">\n          </span><span class="s1">near2.activate().emit({</span><span class="s3">\n            </span><span class="s1">originalEvent: e,</span><span class="s3">\n            </span><span class="s1">type: 'cxttapstart',</span><span class="s3">\n            </span><span class="s1">position: {</span><span class="s3">\n              </span><span class="s1">x: now[0],</span><span class="s3">\n              </span><span class="s1">y: now[1]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">r.touchData.start = near2;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cy.emit({</span><span class="s3">\n            </span><span class="s1">originalEvent: e,</span><span class="s3">\n            </span><span class="s1">type: 'cxttapstart',</span><span class="s3">\n            </span><span class="s1">position: {</span><span class="s3">\n              </span><span class="s1">x: now[0],</span><span class="s3">\n              </span><span class="s1">y: now[1]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (r.touchData.start) {</span><span class="s3">\n          </span><span class="s1">r.touchData.start._private.grabbed = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.touchData.cxt = true;</span><span class="s3">\n        </span><span class="s1">r.touchData.cxtDragged = false;</span><span class="s3">\n        </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[2]) {</span><span class="s3">\n      </span><span class="s1">// ignore</span><span class="s3">\n\n      </span><span class="s1">// safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)</span><span class="s3">\n      </span><span class="s1">if (cy.boxSelectionEnabled()) {</span><span class="s3">\n        </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (e.touches[1]) ; else if (e.touches[0]) {</span><span class="s3">\n      </span><span class="s1">var nears = r.findNearestElements(now[0], now[1], true, true);</span><span class="s3">\n      </span><span class="s1">var near = nears[0];</span><span class="s3">\n      </span><span class="s1">if (near != null) {</span><span class="s3">\n        </span><span class="s1">near.activate();</span><span class="s3">\n        </span><span class="s1">r.touchData.start = near;</span><span class="s3">\n        </span><span class="s1">r.touchData.starts = nears;</span><span class="s3">\n        </span><span class="s1">if (r.nodeIsGrabbable(near)) {</span><span class="s3">\n          </span><span class="s1">var draggedEles = r.dragData.touchDragEles = cy.collection();</span><span class="s3">\n          </span><span class="s1">var selectedNodes = null;</span><span class="s3">\n          </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n          </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n          </span><span class="s1">if (near.selected()) {</span><span class="s3">\n            </span><span class="s1">// reset drag elements, since near will be added again</span><span class="s3">\n\n            </span><span class="s1">selectedNodes = cy.$(function (ele) {</span><span class="s3">\n              </span><span class="s1">return ele.selected() &amp;&amp; r.nodeIsGrabbable(ele);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">addNodesToDrag(selectedNodes, {</span><span class="s3">\n              </span><span class="s1">addToList: draggedEles</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">addNodeToDrag(near, {</span><span class="s3">\n              </span><span class="s1">addToList: draggedEles</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">setGrabTarget(near);</span><span class="s3">\n          </span><span class="s1">var makeEvent = function makeEvent(type) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: type,</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: now[0],</span><span class="s3">\n                </span><span class="s1">y: now[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">near.emit(makeEvent('grabon'));</span><span class="s3">\n          </span><span class="s1">if (selectedNodes) {</span><span class="s3">\n            </span><span class="s1">selectedNodes.forEach(function (n) {</span><span class="s3">\n              </span><span class="s1">n.emit(makeEvent('grab'));</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">near.emit(makeEvent('grab'));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {</span><span class="s3">\n        </span><span class="s1">x: now[0],</span><span class="s3">\n        </span><span class="s1">y: now[1]</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">if (near == null) {</span><span class="s3">\n        </span><span class="s1">r.data.bgActivePosistion = {</span><span class="s3">\n          </span><span class="s1">x: pos[0],</span><span class="s3">\n          </span><span class="s1">y: pos[1]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Tap, taphold</span><span class="s3">\n      </span><span class="s1">// -----</span><span class="s3">\n\n      </span><span class="s1">r.touchData.singleTouchMoved = false;</span><span class="s3">\n      </span><span class="s1">r.touchData.singleTouchStartTime = +new Date();</span><span class="s3">\n      </span><span class="s1">clearTimeout(r.touchData.tapholdTimeout);</span><span class="s3">\n      </span><span class="s1">r.touchData.tapholdTimeout = setTimeout(function () {</span><span class="s3">\n        </span><span class="s1">if (r.touchData.singleTouchMoved === false &amp;&amp; !r.pinching // if pinching, then taphold unselect shouldn't take effect</span><span class="s3">\n        </span><span class="s1">&amp;&amp; !r.touchData.selecting // box selection shouldn't allow taphold through</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">triggerEvents(r.touchData.start, ['taphold'], e, {</span><span class="s3">\n            </span><span class="s1">x: now[0],</span><span class="s3">\n            </span><span class="s1">y: now[1]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, r.tapholdDuration);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches.length &gt;= 1) {</span><span class="s3">\n      </span><span class="s1">var sPos = r.touchData.startPosition = [null, null, null, null, null, null];</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; now.length; i++) {</span><span class="s3">\n        </span><span class="s1">sPos[i] = earlier[i] = now[i];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var touch0 = e.touches[0];</span><span class="s3">\n      </span><span class="s1">r.touchData.startGPosition = [touch0.clientX, touch0.clientY];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">var touchmoveHandler;</span><span class="s3">\n  </span><span class="s1">r.registerBinding(containerWindow, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">var capture = r.touchData.capture;</span><span class="s3">\n    </span><span class="s1">if (!capture &amp;&amp; !eventInContainer(e)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var select = r.selection;</span><span class="s3">\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var now = r.touchData.now;</span><span class="s3">\n    </span><span class="s1">var earlier = r.touchData.earlier;</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">if (e.touches[0]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);</span><span class="s3">\n      </span><span class="s1">now[0] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[1] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[1]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);</span><span class="s3">\n      </span><span class="s1">now[2] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[3] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[2]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);</span><span class="s3">\n      </span><span class="s1">now[4] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[5] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var startGPos = r.touchData.startGPosition;</span><span class="s3">\n    </span><span class="s1">var isOverThresholdDrag;</span><span class="s3">\n    </span><span class="s1">if (capture &amp;&amp; e.touches[0] &amp;&amp; startGPos) {</span><span class="s3">\n      </span><span class="s1">var disp = [];</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; now.length; j++) {</span><span class="s3">\n        </span><span class="s1">disp[j] = now[j] - earlier[j];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var dx = e.touches[0].clientX - startGPos[0];</span><span class="s3">\n      </span><span class="s1">var dx2 = dx * dx;</span><span class="s3">\n      </span><span class="s1">var dy = e.touches[0].clientY - startGPos[1];</span><span class="s3">\n      </span><span class="s1">var dy2 = dy * dy;</span><span class="s3">\n      </span><span class="s1">var dist2 = dx2 + dy2;</span><span class="s3">\n      </span><span class="s1">isOverThresholdDrag = dist2 &gt;= r.touchTapThreshold2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// context swipe cancelling</span><span class="s3">\n    </span><span class="s1">if (capture &amp;&amp; r.touchData.cxt) {</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">var f1x2 = e.touches[0].clientX - offsetLeft,</span><span class="s3">\n        </span><span class="s1">f1y2 = e.touches[0].clientY - offsetTop;</span><span class="s3">\n      </span><span class="s1">var f2x2 = e.touches[1].clientX - offsetLeft,</span><span class="s3">\n        </span><span class="s1">f2y2 = e.touches[1].clientY - offsetTop;</span><span class="s3">\n      </span><span class="s1">// var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );</span><span class="s3">\n      </span><span class="s1">var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);</span><span class="s3">\n      </span><span class="s1">var factorSq = distance2Sq / distance1Sq;</span><span class="s3">\n      </span><span class="s1">var distThreshold = 150;</span><span class="s3">\n      </span><span class="s1">var distThresholdSq = distThreshold * distThreshold;</span><span class="s3">\n      </span><span class="s1">var factorThreshold = 1.5;</span><span class="s3">\n      </span><span class="s1">var factorThresholdSq = factorThreshold * factorThreshold;</span><span class="s3">\n\n      </span><span class="s1">// cancel ctx gestures if the distance b/t the fingers increases</span><span class="s3">\n      </span><span class="s1">if (factorSq &gt;= factorThresholdSq || distance2Sq &gt;= distThresholdSq) {</span><span class="s3">\n        </span><span class="s1">r.touchData.cxt = false;</span><span class="s3">\n        </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n        </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n        </span><span class="s1">var cxtEvt = {</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">type: 'cxttapend',</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: now[0],</span><span class="s3">\n            </span><span class="s1">y: now[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (r.touchData.start) {</span><span class="s3">\n          </span><span class="s1">r.touchData.start.unactivate().emit(cxtEvt);</span><span class="s3">\n          </span><span class="s1">r.touchData.start = null;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cy.emit(cxtEvt);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// context swipe</span><span class="s3">\n    </span><span class="s1">if (capture &amp;&amp; r.touchData.cxt) {</span><span class="s3">\n      </span><span class="s1">var cxtEvt = {</span><span class="s3">\n        </span><span class="s1">originalEvent: e,</span><span class="s3">\n        </span><span class="s1">type: 'cxtdrag',</span><span class="s3">\n        </span><span class="s1">position: {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">if (r.touchData.start) {</span><span class="s3">\n        </span><span class="s1">r.touchData.start.emit(cxtEvt);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cy.emit(cxtEvt);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (r.touchData.start) {</span><span class="s3">\n        </span><span class="s1">r.touchData.start._private.grabbed = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.touchData.cxtDragged = true;</span><span class="s3">\n      </span><span class="s1">var near = r.findNearestElement(now[0], now[1], true, true);</span><span class="s3">\n      </span><span class="s1">if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {</span><span class="s3">\n        </span><span class="s1">if (r.touchData.cxtOver) {</span><span class="s3">\n          </span><span class="s1">r.touchData.cxtOver.emit({</span><span class="s3">\n            </span><span class="s1">originalEvent: e,</span><span class="s3">\n            </span><span class="s1">type: 'cxtdragout',</span><span class="s3">\n            </span><span class="s1">position: {</span><span class="s3">\n              </span><span class="s1">x: now[0],</span><span class="s3">\n              </span><span class="s1">y: now[1]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.touchData.cxtOver = near;</span><span class="s3">\n        </span><span class="s1">if (near) {</span><span class="s3">\n          </span><span class="s1">near.emit({</span><span class="s3">\n            </span><span class="s1">originalEvent: e,</span><span class="s3">\n            </span><span class="s1">type: 'cxtdragover',</span><span class="s3">\n            </span><span class="s1">position: {</span><span class="s3">\n              </span><span class="s1">x: now[0],</span><span class="s3">\n              </span><span class="s1">y: now[1]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// box selection</span><span class="s3">\n    </span><span class="s1">} else if (capture &amp;&amp; e.touches[2] &amp;&amp; cy.boxSelectionEnabled()) {</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">this.lastThreeTouch = +new Date();</span><span class="s3">\n      </span><span class="s1">if (!r.touchData.selecting) {</span><span class="s3">\n        </span><span class="s1">cy.emit({</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">type: 'boxstart',</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: now[0],</span><span class="s3">\n            </span><span class="s1">y: now[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.touchData.selecting = true;</span><span class="s3">\n      </span><span class="s1">r.touchData.didSelect = true;</span><span class="s3">\n      </span><span class="s1">select[4] = 1;</span><span class="s3">\n      </span><span class="s1">if (!select || select.length === 0 || select[0] === undefined) {</span><span class="s3">\n        </span><span class="s1">select[0] = (now[0] + now[2] + now[4]) / 3;</span><span class="s3">\n        </span><span class="s1">select[1] = (now[1] + now[3] + now[5]) / 3;</span><span class="s3">\n        </span><span class="s1">select[2] = (now[0] + now[2] + now[4]) / 3 + 1;</span><span class="s3">\n        </span><span class="s1">select[3] = (now[1] + now[3] + now[5]) / 3 + 1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">select[2] = (now[0] + now[2] + now[4]) / 3;</span><span class="s3">\n        </span><span class="s1">select[3] = (now[1] + now[3] + now[5]) / 3;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n\n      </span><span class="s1">// pinch to zoom</span><span class="s3">\n    </span><span class="s1">} else if (capture &amp;&amp; e.touches[1] &amp;&amp; !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom</span><span class="s3">\n    </span><span class="s1">&amp;&amp; cy.zoomingEnabled() &amp;&amp; cy.panningEnabled() &amp;&amp; cy.userZoomingEnabled() &amp;&amp; cy.userPanningEnabled()) {</span><span class="s3">\n      </span><span class="s1">// two fingers =&gt; pinch to zoom</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">var draggedEles = r.dragData.touchDragEles;</span><span class="s3">\n      </span><span class="s1">if (draggedEles) {</span><span class="s3">\n        </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; draggedEles.length; i++) {</span><span class="s3">\n          </span><span class="s1">var de_p = draggedEles[i]._private;</span><span class="s3">\n          </span><span class="s1">de_p.grabbed = false;</span><span class="s3">\n          </span><span class="s1">de_p.rscratch.inDragLayer = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var _start = r.touchData.start;</span><span class="s3">\n\n      </span><span class="s1">// (x2, y2) for fingers 1 and 2</span><span class="s3">\n      </span><span class="s1">var f1x2 = e.touches[0].clientX - offsetLeft,</span><span class="s3">\n        </span><span class="s1">f1y2 = e.touches[0].clientY - offsetTop;</span><span class="s3">\n      </span><span class="s1">var f2x2 = e.touches[1].clientX - offsetLeft,</span><span class="s3">\n        </span><span class="s1">f2y2 = e.touches[1].clientY - offsetTop;</span><span class="s3">\n      </span><span class="s1">var distance2 = distance(f1x2, f1y2, f2x2, f2y2);</span><span class="s3">\n      </span><span class="s1">// var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );</span><span class="s3">\n      </span><span class="s1">// var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );</span><span class="s3">\n      </span><span class="s1">var factor = distance2 / distance1;</span><span class="s3">\n      </span><span class="s1">if (twoFingersStartInside) {</span><span class="s3">\n        </span><span class="s1">// delta finger1</span><span class="s3">\n        </span><span class="s1">var df1x = f1x2 - f1x1;</span><span class="s3">\n        </span><span class="s1">var df1y = f1y2 - f1y1;</span><span class="s3">\n\n        </span><span class="s1">// delta finger 2</span><span class="s3">\n        </span><span class="s1">var df2x = f2x2 - f2x1;</span><span class="s3">\n        </span><span class="s1">var df2y = f2y2 - f2y1;</span><span class="s3">\n\n        </span><span class="s1">// translation is the normalised vector of the two fingers movement</span><span class="s3">\n        </span><span class="s1">// i.e. so pinching cancels out and moving together pans</span><span class="s3">\n        </span><span class="s1">var tx = (df1x + df2x) / 2;</span><span class="s3">\n        </span><span class="s1">var ty = (df1y + df2y) / 2;</span><span class="s3">\n\n        </span><span class="s1">// now calculate the zoom</span><span class="s3">\n        </span><span class="s1">var zoom1 = cy.zoom();</span><span class="s3">\n        </span><span class="s1">var zoom2 = zoom1 * factor;</span><span class="s3">\n        </span><span class="s1">var pan1 = cy.pan();</span><span class="s3">\n\n        </span><span class="s1">// the model center point converted to the current rendered pos</span><span class="s3">\n        </span><span class="s1">var ctrx = modelCenter1[0] * zoom1 + pan1.x;</span><span class="s3">\n        </span><span class="s1">var ctry = modelCenter1[1] * zoom1 + pan1.y;</span><span class="s3">\n        </span><span class="s1">var pan2 = {</span><span class="s3">\n          </span><span class="s1">x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,</span><span class="s3">\n          </span><span class="s1">y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">// remove dragged eles</span><span class="s3">\n        </span><span class="s1">if (_start &amp;&amp; _start.active()) {</span><span class="s3">\n          </span><span class="s1">var draggedEles = r.dragData.touchDragEles;</span><span class="s3">\n          </span><span class="s1">freeDraggedElements(draggedEles);</span><span class="s3">\n          </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n          </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n          </span><span class="s1">_start.unactivate().emit('freeon');</span><span class="s3">\n          </span><span class="s1">draggedEles.emit('free');</span><span class="s3">\n          </span><span class="s1">if (r.dragData.didDrag) {</span><span class="s3">\n            </span><span class="s1">_start.emit('dragfreeon');</span><span class="s3">\n            </span><span class="s1">draggedEles.emit('dragfree');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cy.viewport({</span><span class="s3">\n          </span><span class="s1">zoom: zoom2,</span><span class="s3">\n          </span><span class="s1">pan: pan2,</span><span class="s3">\n          </span><span class="s1">cancelOnFailedZoom: true</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">cy.emit('pinchzoom');</span><span class="s3">\n        </span><span class="s1">distance1 = distance2;</span><span class="s3">\n        </span><span class="s1">f1x1 = f1x2;</span><span class="s3">\n        </span><span class="s1">f1y1 = f1y2;</span><span class="s3">\n        </span><span class="s1">f2x1 = f2x2;</span><span class="s3">\n        </span><span class="s1">f2y1 = f2y2;</span><span class="s3">\n        </span><span class="s1">r.pinching = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Re-project</span><span class="s3">\n      </span><span class="s1">if (e.touches[0]) {</span><span class="s3">\n        </span><span class="s1">var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);</span><span class="s3">\n        </span><span class="s1">now[0] = pos[0];</span><span class="s3">\n        </span><span class="s1">now[1] = pos[1];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (e.touches[1]) {</span><span class="s3">\n        </span><span class="s1">var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);</span><span class="s3">\n        </span><span class="s1">now[2] = pos[0];</span><span class="s3">\n        </span><span class="s1">now[3] = pos[1];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (e.touches[2]) {</span><span class="s3">\n        </span><span class="s1">var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);</span><span class="s3">\n        </span><span class="s1">now[4] = pos[0];</span><span class="s3">\n        </span><span class="s1">now[5] = pos[1];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (e.touches[0] &amp;&amp; !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">var start = r.touchData.start;</span><span class="s3">\n      </span><span class="s1">var last = r.touchData.last;</span><span class="s3">\n      </span><span class="s1">var near;</span><span class="s3">\n      </span><span class="s1">if (!r.hoverData.draggingEles &amp;&amp; !r.swipePanning) {</span><span class="s3">\n        </span><span class="s1">near = r.findNearestElement(now[0], now[1], true, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (capture &amp;&amp; start != null) {</span><span class="s3">\n        </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// dragging nodes</span><span class="s3">\n      </span><span class="s1">if (capture &amp;&amp; start != null &amp;&amp; r.nodeIsDraggable(start)) {</span><span class="s3">\n        </span><span class="s1">if (isOverThresholdDrag) {</span><span class="s3">\n          </span><span class="s1">// then dragging can happen</span><span class="s3">\n          </span><span class="s1">var draggedEles = r.dragData.touchDragEles;</span><span class="s3">\n          </span><span class="s1">var justStartedDrag = !r.dragData.didDrag;</span><span class="s3">\n          </span><span class="s1">if (justStartedDrag) {</span><span class="s3">\n            </span><span class="s1">addNodesToDrag(draggedEles, {</span><span class="s3">\n              </span><span class="s1">inDragLayer: true</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">r.dragData.didDrag = true;</span><span class="s3">\n          </span><span class="s1">var totalShift = {</span><span class="s3">\n            </span><span class="s1">x: 0,</span><span class="s3">\n            </span><span class="s1">y: 0</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">if (number$1(disp[0]) &amp;&amp; number$1(disp[1])) {</span><span class="s3">\n            </span><span class="s1">totalShift.x += disp[0];</span><span class="s3">\n            </span><span class="s1">totalShift.y += disp[1];</span><span class="s3">\n            </span><span class="s1">if (justStartedDrag) {</span><span class="s3">\n              </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n              </span><span class="s1">var dragDelta = r.touchData.dragDelta;</span><span class="s3">\n              </span><span class="s1">if (dragDelta &amp;&amp; number$1(dragDelta[0]) &amp;&amp; number$1(dragDelta[1])) {</span><span class="s3">\n                </span><span class="s1">totalShift.x += dragDelta[0];</span><span class="s3">\n                </span><span class="s1">totalShift.y += dragDelta[1];</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">r.hoverData.draggingEles = true;</span><span class="s3">\n          </span><span class="s1">draggedEles.silentShift(totalShift).emit('position drag');</span><span class="s3">\n          </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n          </span><span class="s1">if (r.touchData.startPosition[0] == earlier[0] &amp;&amp; r.touchData.startPosition[1] == earlier[1]) {</span><span class="s3">\n            </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">r.redraw();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// otherwise keep track of drag delta for later</span><span class="s3">\n          </span><span class="s1">var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];</span><span class="s3">\n          </span><span class="s1">if (dragDelta.length === 0) {</span><span class="s3">\n            </span><span class="s1">dragDelta.push(disp[0]);</span><span class="s3">\n            </span><span class="s1">dragDelta.push(disp[1]);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">dragDelta[0] += disp[0];</span><span class="s3">\n            </span><span class="s1">dragDelta[1] += disp[1];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// touchmove</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if ((!start || !start.grabbed()) &amp;&amp; near != last) {</span><span class="s3">\n          </span><span class="s1">if (last) {</span><span class="s3">\n            </span><span class="s1">last.emit({</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: 'tapdragout',</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: now[0],</span><span class="s3">\n                </span><span class="s1">y: now[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (near) {</span><span class="s3">\n            </span><span class="s1">near.emit({</span><span class="s3">\n              </span><span class="s1">originalEvent: e,</span><span class="s3">\n              </span><span class="s1">type: 'tapdragover',</span><span class="s3">\n              </span><span class="s1">position: {</span><span class="s3">\n                </span><span class="s1">x: now[0],</span><span class="s3">\n                </span><span class="s1">y: now[1]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.touchData.last = near;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// check to cancel taphold</span><span class="s3">\n      </span><span class="s1">if (capture) {</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; now.length; i++) {</span><span class="s3">\n          </span><span class="s1">if (now[i] &amp;&amp; r.touchData.startPosition[i] &amp;&amp; isOverThresholdDrag) {</span><span class="s3">\n            </span><span class="s1">r.touchData.singleTouchMoved = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// panning</span><span class="s3">\n      </span><span class="s1">if (capture &amp;&amp; (start == null || start.pannable()) &amp;&amp; cy.panningEnabled() &amp;&amp; cy.userPanningEnabled()) {</span><span class="s3">\n        </span><span class="s1">var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);</span><span class="s3">\n        </span><span class="s1">if (allowPassthrough) {</span><span class="s3">\n          </span><span class="s1">e.preventDefault();</span><span class="s3">\n          </span><span class="s1">if (!r.data.bgActivePosistion) {</span><span class="s3">\n            </span><span class="s1">r.data.bgActivePosistion = array2point(r.touchData.startPosition);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (r.swipePanning) {</span><span class="s3">\n            </span><span class="s1">cy.panBy({</span><span class="s3">\n              </span><span class="s1">x: disp[0] * zoom,</span><span class="s3">\n              </span><span class="s1">y: disp[1] * zoom</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">cy.emit('dragpan');</span><span class="s3">\n          </span><span class="s1">} else if (isOverThresholdDrag) {</span><span class="s3">\n            </span><span class="s1">r.swipePanning = true;</span><span class="s3">\n            </span><span class="s1">cy.panBy({</span><span class="s3">\n              </span><span class="s1">x: dx * zoom,</span><span class="s3">\n              </span><span class="s1">y: dy * zoom</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">cy.emit('dragpan');</span><span class="s3">\n            </span><span class="s1">if (start) {</span><span class="s3">\n              </span><span class="s1">start.unactivate();</span><span class="s3">\n              </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n              </span><span class="s1">r.touchData.start = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Re-project</span><span class="s3">\n        </span><span class="s1">var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);</span><span class="s3">\n        </span><span class="s1">now[0] = pos[0];</span><span class="s3">\n        </span><span class="s1">now[1] = pos[1];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; now.length; j++) {</span><span class="s3">\n      </span><span class="s1">earlier[j] = now[j];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning</span><span class="s3">\n    </span><span class="s1">if (capture &amp;&amp; e.touches.length &gt; 0 &amp;&amp; !r.hoverData.draggingEles &amp;&amp; !r.swipePanning &amp;&amp; r.data.bgActivePosistion != null) {</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n  </span><span class="s1">var touchcancelHandler;</span><span class="s3">\n  </span><span class="s1">r.registerBinding(containerWindow, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-line no-unused-vars</span><span class="s3">\n    </span><span class="s1">var start = r.touchData.start;</span><span class="s3">\n    </span><span class="s1">r.touchData.capture = false;</span><span class="s3">\n    </span><span class="s1">if (start) {</span><span class="s3">\n      </span><span class="s1">start.unactivate();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;</span><span class="s3">\n  </span><span class="s1">r.registerBinding(containerWindow, 'touchend', touchendHandler = function touchendHandler(e) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-line no-unused-vars</span><span class="s3">\n    </span><span class="s1">var start = r.touchData.start;</span><span class="s3">\n    </span><span class="s1">var capture = r.touchData.capture;</span><span class="s3">\n    </span><span class="s1">if (capture) {</span><span class="s3">\n      </span><span class="s1">if (e.touches.length === 0) {</span><span class="s3">\n        </span><span class="s1">r.touchData.capture = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var select = r.selection;</span><span class="s3">\n    </span><span class="s1">r.swipePanning = false;</span><span class="s3">\n    </span><span class="s1">r.hoverData.draggingEles = false;</span><span class="s3">\n    </span><span class="s1">var cy = r.cy;</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">var now = r.touchData.now;</span><span class="s3">\n    </span><span class="s1">var earlier = r.touchData.earlier;</span><span class="s3">\n    </span><span class="s1">if (e.touches[0]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);</span><span class="s3">\n      </span><span class="s1">now[0] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[1] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[1]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);</span><span class="s3">\n      </span><span class="s1">now[2] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[3] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[2]) {</span><span class="s3">\n      </span><span class="s1">var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);</span><span class="s3">\n      </span><span class="s1">now[4] = pos[0];</span><span class="s3">\n      </span><span class="s1">now[5] = pos[1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (start) {</span><span class="s3">\n      </span><span class="s1">start.unactivate();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ctxTapend;</span><span class="s3">\n    </span><span class="s1">if (r.touchData.cxt) {</span><span class="s3">\n      </span><span class="s1">ctxTapend = {</span><span class="s3">\n        </span><span class="s1">originalEvent: e,</span><span class="s3">\n        </span><span class="s1">type: 'cxttapend',</span><span class="s3">\n        </span><span class="s1">position: {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (start) {</span><span class="s3">\n        </span><span class="s1">start.emit(ctxTapend);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cy.emit(ctxTapend);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!r.touchData.cxtDragged) {</span><span class="s3">\n        </span><span class="s1">var ctxTap = {</span><span class="s3">\n          </span><span class="s1">originalEvent: e,</span><span class="s3">\n          </span><span class="s1">type: 'cxttap',</span><span class="s3">\n          </span><span class="s1">position: {</span><span class="s3">\n            </span><span class="s1">x: now[0],</span><span class="s3">\n            </span><span class="s1">y: now[1]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (start) {</span><span class="s3">\n          </span><span class="s1">start.emit(ctxTap);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cy.emit(ctxTap);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (r.touchData.start) {</span><span class="s3">\n        </span><span class="s1">r.touchData.start._private.grabbed = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.touchData.cxt = false;</span><span class="s3">\n      </span><span class="s1">r.touchData.start = null;</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// no more box selection if we don't have three fingers</span><span class="s3">\n    </span><span class="s1">if (!e.touches[2] &amp;&amp; cy.boxSelectionEnabled() &amp;&amp; r.touchData.selecting) {</span><span class="s3">\n      </span><span class="s1">r.touchData.selecting = false;</span><span class="s3">\n      </span><span class="s1">var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));</span><span class="s3">\n      </span><span class="s1">select[0] = undefined;</span><span class="s3">\n      </span><span class="s1">select[1] = undefined;</span><span class="s3">\n      </span><span class="s1">select[2] = undefined;</span><span class="s3">\n      </span><span class="s1">select[3] = undefined;</span><span class="s3">\n      </span><span class="s1">select[4] = 0;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">cy.emit({</span><span class="s3">\n        </span><span class="s1">type: 'boxend',</span><span class="s3">\n        </span><span class="s1">originalEvent: e,</span><span class="s3">\n        </span><span class="s1">position: {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">var eleWouldBeSelected = function eleWouldBeSelected(ele) {</span><span class="s3">\n        </span><span class="s1">return ele.selectable() &amp;&amp; !ele.selected();</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');</span><span class="s3">\n      </span><span class="s1">if (box.nonempty()) {</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (start != null) {</span><span class="s3">\n      </span><span class="s1">start.unactivate();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches[2]) {</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n    </span><span class="s1">} else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {</span><span class="s3">\n      </span><span class="s1">r.data.bgActivePosistion = undefined;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n      </span><span class="s1">var draggedEles = r.dragData.touchDragEles;</span><span class="s3">\n      </span><span class="s1">if (start != null) {</span><span class="s3">\n        </span><span class="s1">var startWasGrabbed = start._private.grabbed;</span><span class="s3">\n        </span><span class="s1">freeDraggedElements(draggedEles);</span><span class="s3">\n        </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">if (startWasGrabbed) {</span><span class="s3">\n          </span><span class="s1">start.emit('freeon');</span><span class="s3">\n          </span><span class="s1">draggedEles.emit('free');</span><span class="s3">\n          </span><span class="s1">if (r.dragData.didDrag) {</span><span class="s3">\n            </span><span class="s1">start.emit('dragfreeon');</span><span class="s3">\n            </span><span class="s1">draggedEles.emit('dragfree');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">start.unactivate();</span><span class="s3">\n        </span><span class="s1">r.touchData.start = null;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var near = r.findNearestElement(now[0], now[1], true, true);</span><span class="s3">\n        </span><span class="s1">triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var dx = r.touchData.startPosition[0] - now[0];</span><span class="s3">\n      </span><span class="s1">var dx2 = dx * dx;</span><span class="s3">\n      </span><span class="s1">var dy = r.touchData.startPosition[1] - now[1];</span><span class="s3">\n      </span><span class="s1">var dy2 = dy * dy;</span><span class="s3">\n      </span><span class="s1">var dist2 = dx2 + dy2;</span><span class="s3">\n      </span><span class="s1">var rdist2 = dist2 * zoom * zoom;</span><span class="s3">\n\n      </span><span class="s1">// Tap event, roughly same as mouse click event for touch</span><span class="s3">\n      </span><span class="s1">if (!r.touchData.singleTouchMoved) {</span><span class="s3">\n        </span><span class="s1">if (!start) {</span><span class="s3">\n          </span><span class="s1">cy.$(':selected').unselect(['tapunselect']);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">triggerEvents(start, ['tap', 'vclick'], e, {</span><span class="s3">\n          </span><span class="s1">x: now[0],</span><span class="s3">\n          </span><span class="s1">y: now[1]</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">didDoubleTouch = false;</span><span class="s3">\n        </span><span class="s1">if (e.timeStamp - prevTouchTimeStamp &lt;= cy.multiClickDebounceTime()) {</span><span class="s3">\n          </span><span class="s1">touchTimeout &amp;&amp; clearTimeout(touchTimeout);</span><span class="s3">\n          </span><span class="s1">didDoubleTouch = true;</span><span class="s3">\n          </span><span class="s1">prevTouchTimeStamp = null;</span><span class="s3">\n          </span><span class="s1">triggerEvents(start, ['dbltap', 'vdblclick'], e, {</span><span class="s3">\n            </span><span class="s1">x: now[0],</span><span class="s3">\n            </span><span class="s1">y: now[1]</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">touchTimeout = setTimeout(function () {</span><span class="s3">\n            </span><span class="s1">if (didDoubleTouch) return;</span><span class="s3">\n            </span><span class="s1">triggerEvents(start, ['onetap', 'voneclick'], e, {</span><span class="s3">\n              </span><span class="s1">x: now[0],</span><span class="s3">\n              </span><span class="s1">y: now[1]</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}, cy.multiClickDebounceTime());</span><span class="s3">\n          </span><span class="s1">prevTouchTimeStamp = e.timeStamp;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance</span><span class="s3">\n      </span><span class="s1">if (start != null &amp;&amp; !r.dragData.didDrag // didn't drag nodes around</span><span class="s3">\n      </span><span class="s1">&amp;&amp; start._private.selectable &amp;&amp; rdist2 &lt; r.touchTapThreshold2 &amp;&amp; !r.pinching // pinch to zoom should not affect selection</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (cy.selectionType() === 'single') {</span><span class="s3">\n          </span><span class="s1">cy.$(isSelected).unmerge(start).unselect(['tapunselect']);</span><span class="s3">\n          </span><span class="s1">start.select(['tapselect']);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (start.selected()) {</span><span class="s3">\n            </span><span class="s1">start.unselect(['tapunselect']);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">start.select(['tapselect']);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.touchData.singleTouchMoved = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; now.length; j++) {</span><span class="s3">\n      </span><span class="s1">earlier[j] = now[j];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.dragData.didDrag = false; // reset for next touchstart</span><span class="s3">\n\n    </span><span class="s1">if (e.touches.length === 0) {</span><span class="s3">\n      </span><span class="s1">r.touchData.dragDelta = [];</span><span class="s3">\n      </span><span class="s1">r.touchData.startPosition = [null, null, null, null, null, null];</span><span class="s3">\n      </span><span class="s1">r.touchData.startGPosition = null;</span><span class="s3">\n      </span><span class="s1">r.touchData.didSelect = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (e.touches.length &lt; 2) {</span><span class="s3">\n      </span><span class="s1">if (e.touches.length === 1) {</span><span class="s3">\n        </span><span class="s1">// the old start global pos'n may not be the same finger that remains</span><span class="s3">\n        </span><span class="s1">r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.pinching = false;</span><span class="s3">\n      </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">//r.redraw();</span><span class="s3">\n  </span><span class="s1">}, false);</span><span class="s3">\n\n  </span><span class="s1">// fallback compatibility layer for ms pointer events</span><span class="s3">\n  </span><span class="s1">if (typeof TouchEvent === 'undefined') {</span><span class="s3">\n    </span><span class="s1">var pointers = [];</span><span class="s3">\n    </span><span class="s1">var makeTouch = function makeTouch(e) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">clientX: e.clientX,</span><span class="s3">\n        </span><span class="s1">clientY: e.clientY,</span><span class="s3">\n        </span><span class="s1">force: 1,</span><span class="s3">\n        </span><span class="s1">identifier: e.pointerId,</span><span class="s3">\n        </span><span class="s1">pageX: e.pageX,</span><span class="s3">\n        </span><span class="s1">pageY: e.pageY,</span><span class="s3">\n        </span><span class="s1">radiusX: e.width / 2,</span><span class="s3">\n        </span><span class="s1">radiusY: e.height / 2,</span><span class="s3">\n        </span><span class="s1">screenX: e.screenX,</span><span class="s3">\n        </span><span class="s1">screenY: e.screenY,</span><span class="s3">\n        </span><span class="s1">target: e.target</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var makePointer = function makePointer(e) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">event: e,</span><span class="s3">\n        </span><span class="s1">touch: makeTouch(e)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var addPointer = function addPointer(e) {</span><span class="s3">\n      </span><span class="s1">pointers.push(makePointer(e));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var removePointer = function removePointer(e) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; pointers.length; i++) {</span><span class="s3">\n        </span><span class="s1">var p = pointers[i];</span><span class="s3">\n        </span><span class="s1">if (p.event.pointerId === e.pointerId) {</span><span class="s3">\n          </span><span class="s1">pointers.splice(i, 1);</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var updatePointer = function updatePointer(e) {</span><span class="s3">\n      </span><span class="s1">var p = pointers.filter(function (p) {</span><span class="s3">\n        </span><span class="s1">return p.event.pointerId === e.pointerId;</span><span class="s3">\n      </span><span class="s1">})[0];</span><span class="s3">\n      </span><span class="s1">p.event = e;</span><span class="s3">\n      </span><span class="s1">p.touch = makeTouch(e);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var addTouchesToEvent = function addTouchesToEvent(e) {</span><span class="s3">\n      </span><span class="s1">e.touches = pointers.map(function (p) {</span><span class="s3">\n        </span><span class="s1">return p.touch;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var pointerIsMouse = function pointerIsMouse(e) {</span><span class="s3">\n      </span><span class="s1">return e.pointerType === 'mouse' || e.pointerType === 4;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">r.registerBinding(r.container, 'pointerdown', function (e) {</span><span class="s3">\n      </span><span class="s1">if (pointerIsMouse(e)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // mouse already handled</span><span class="s3">\n\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">addPointer(e);</span><span class="s3">\n      </span><span class="s1">addTouchesToEvent(e);</span><span class="s3">\n      </span><span class="s1">touchstartHandler(e);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">r.registerBinding(r.container, 'pointerup', function (e) {</span><span class="s3">\n      </span><span class="s1">if (pointerIsMouse(e)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // mouse already handled</span><span class="s3">\n\n      </span><span class="s1">removePointer(e);</span><span class="s3">\n      </span><span class="s1">addTouchesToEvent(e);</span><span class="s3">\n      </span><span class="s1">touchendHandler(e);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">r.registerBinding(r.container, 'pointercancel', function (e) {</span><span class="s3">\n      </span><span class="s1">if (pointerIsMouse(e)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // mouse already handled</span><span class="s3">\n\n      </span><span class="s1">removePointer(e);</span><span class="s3">\n      </span><span class="s1">addTouchesToEvent(e);</span><span class="s3">\n      </span><span class="s1">touchcancelHandler(e);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">r.registerBinding(r.container, 'pointermove', function (e) {</span><span class="s3">\n      </span><span class="s1">if (pointerIsMouse(e)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} // mouse already handled</span><span class="s3">\n\n      </span><span class="s1">e.preventDefault();</span><span class="s3">\n      </span><span class="s1">updatePointer(e);</span><span class="s3">\n      </span><span class="s1">addTouchesToEvent(e);</span><span class="s3">\n      </span><span class="s1">touchmoveHandler(e);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$2 = {};</span><span class="s3">\n</span><span class="s1">BRp$2.generatePolygon = function (name, points) {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes[name] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: name,</span><span class="s3">\n    </span><span class="s1">points: points,</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.generateEllipse = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes['ellipse'] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: 'ellipse',</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">return checkInEllipse(x, y, width, height, centerX, centerY, padding);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.generateRoundPolygon = function (name, points) {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes[name] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: name,</span><span class="s3">\n    </span><span class="s1">points: points,</span><span class="s3">\n    </span><span class="s1">getOrCreateCorners: function getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, field) {</span><span class="s3">\n      </span><span class="s1">if (rs[field] !== undefined &amp;&amp; rs[field + '-cx'] === centerX &amp;&amp; rs[field + '-cy'] === centerY) {</span><span class="s3">\n        </span><span class="s1">return rs[field];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">rs[field] = new Array(points.length / 2);</span><span class="s3">\n      </span><span class="s1">rs[field + '-cx'] = centerX;</span><span class="s3">\n      </span><span class="s1">rs[field + '-cy'] = centerY;</span><span class="s3">\n      </span><span class="s1">var halfW = width / 2;</span><span class="s3">\n      </span><span class="s1">var halfH = height / 2;</span><span class="s3">\n      </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(width, height) : cornerRadius;</span><span class="s3">\n      </span><span class="s1">var p = new Array(points.length / 2);</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; points.length / 2; _i++) {</span><span class="s3">\n        </span><span class="s1">p[_i] = {</span><span class="s3">\n          </span><span class="s1">x: centerX + halfW * points[_i * 2],</span><span class="s3">\n          </span><span class="s1">y: centerY + halfH * points[_i * 2 + 1]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var i,</span><span class="s3">\n        </span><span class="s1">p1,</span><span class="s3">\n        </span><span class="s1">p2,</span><span class="s3">\n        </span><span class="s1">p3,</span><span class="s3">\n        </span><span class="s1">len = p.length;</span><span class="s3">\n      </span><span class="s1">p1 = p[len - 1];</span><span class="s3">\n      </span><span class="s1">// for each point</span><span class="s3">\n      </span><span class="s1">for (i = 0; i &lt; len; i++) {</span><span class="s3">\n        </span><span class="s1">p2 = p[i % len];</span><span class="s3">\n        </span><span class="s1">p3 = p[(i + 1) % len];</span><span class="s3">\n        </span><span class="s1">rs[field][i] = getRoundCorner(p1, p2, p3, cornerRadius);</span><span class="s3">\n        </span><span class="s1">p1 = p2;</span><span class="s3">\n        </span><span class="s1">p2 = p3;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return rs[field];</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius, rs) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'drawCorners'));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius, rs) {</span><span class="s3">\n      </span><span class="s1">return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height, padding, this.getOrCreateCorners(nodeX, nodeY, width, height, cornerRadius, rs, 'corners'));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius, rs) {</span><span class="s3">\n      </span><span class="s1">return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'corners'));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.generateRoundRectangle = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: 'round-rectangle',</span><span class="s3">\n    </span><span class="s1">points: generateUnitNgonPointsFitToSquare(4, 0),</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">var halfWidth = width / 2;</span><span class="s3">\n      </span><span class="s1">var halfHeight = height / 2;</span><span class="s3">\n      </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;</span><span class="s3">\n      </span><span class="s1">cornerRadius = Math.min(halfWidth, halfHeight, cornerRadius);</span><span class="s3">\n      </span><span class="s1">var diam = cornerRadius * 2;</span><span class="s3">\n\n      </span><span class="s1">// Check hBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check vBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check top left quarter circle</span><span class="s3">\n      </span><span class="s1">if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY - halfHeight + cornerRadius, padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check top right quarter circle</span><span class="s3">\n      </span><span class="s1">if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY - halfHeight + cornerRadius, padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check bottom right quarter circle</span><span class="s3">\n      </span><span class="s1">if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY + halfHeight - cornerRadius, padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check bottom left quarter circle</span><span class="s3">\n      </span><span class="s1">if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY + halfHeight - cornerRadius, padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.generateCutRectangle = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: 'cut-rectangle',</span><span class="s3">\n    </span><span class="s1">cornerLength: getCutRectangleCornerLength(),</span><span class="s3">\n    </span><span class="s1">points: generateUnitNgonPointsFitToSquare(4, 0),</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, null, cornerRadius);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;</span><span class="s3">\n      </span><span class="s1">var hh = height / 2;</span><span class="s3">\n      </span><span class="s1">var hw = width / 2;</span><span class="s3">\n      </span><span class="s1">var xBegin = centerX - hw;</span><span class="s3">\n      </span><span class="s1">var xEnd = centerX + hw;</span><span class="s3">\n      </span><span class="s1">var yBegin = centerY - hh;</span><span class="s3">\n      </span><span class="s1">var yEnd = centerY + hh;</span><span class="s3">\n\n      </span><span class="s1">// points are in clockwise order, inner (imaginary) triangle pt on [4, 5]</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],</span><span class="s3">\n        </span><span class="s1">topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],</span><span class="s3">\n        </span><span class="s1">bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],</span><span class="s3">\n        </span><span class="s1">bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY, cornerRadius);</span><span class="s3">\n      </span><span class="s1">var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);</span><span class="s3">\n      </span><span class="s1">return polygonIntersectLine(x, y, pts, nodeX, nodeY);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;</span><span class="s3">\n      </span><span class="s1">// Check hBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * cl, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check vBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * cl, height, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);</span><span class="s3">\n      </span><span class="s1">return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.generateBarrel = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes['barrel'] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: 'barrel',</span><span class="s3">\n    </span><span class="s1">points: generateUnitNgonPointsFitToSquare(4, 0),</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">// use two fixed t values for the bezier curve approximation</span><span class="s3">\n\n      </span><span class="s1">var t0 = 0.15;</span><span class="s3">\n      </span><span class="s1">var t1 = 0.5;</span><span class="s3">\n      </span><span class="s1">var t2 = 0.85;</span><span class="s3">\n      </span><span class="s1">var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);</span><span class="s3">\n      </span><span class="s1">var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {</span><span class="s3">\n        </span><span class="s1">// approximate curve pts based on the two t values</span><span class="s3">\n        </span><span class="s1">var m0 = qbezierPtAt({</span><span class="s3">\n          </span><span class="s1">x: pts[0],</span><span class="s3">\n          </span><span class="s1">y: pts[1]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: pts[2],</span><span class="s3">\n          </span><span class="s1">y: pts[3]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: pts[4],</span><span class="s3">\n          </span><span class="s1">y: pts[5]</span><span class="s3">\n        </span><span class="s1">}, t0);</span><span class="s3">\n        </span><span class="s1">var m1 = qbezierPtAt({</span><span class="s3">\n          </span><span class="s1">x: pts[0],</span><span class="s3">\n          </span><span class="s1">y: pts[1]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: pts[2],</span><span class="s3">\n          </span><span class="s1">y: pts[3]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: pts[4],</span><span class="s3">\n          </span><span class="s1">y: pts[5]</span><span class="s3">\n        </span><span class="s1">}, t1);</span><span class="s3">\n        </span><span class="s1">var m2 = qbezierPtAt({</span><span class="s3">\n          </span><span class="s1">x: pts[0],</span><span class="s3">\n          </span><span class="s1">y: pts[1]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: pts[2],</span><span class="s3">\n          </span><span class="s1">y: pts[3]</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n          </span><span class="s1">x: pts[4],</span><span class="s3">\n          </span><span class="s1">y: pts[5]</span><span class="s3">\n        </span><span class="s1">}, t2);</span><span class="s3">\n        </span><span class="s1">return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));</span><span class="s3">\n      </span><span class="s1">return polygonIntersectLine(x, y, pts, nodeX, nodeY);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {</span><span class="s3">\n      </span><span class="s1">var hh = height / 2;</span><span class="s3">\n      </span><span class="s1">var hw = width / 2;</span><span class="s3">\n      </span><span class="s1">var xBegin = centerX - hw;</span><span class="s3">\n      </span><span class="s1">var xEnd = centerX + hw;</span><span class="s3">\n      </span><span class="s1">var yBegin = centerY - hh;</span><span class="s3">\n      </span><span class="s1">var yEnd = centerY + hh;</span><span class="s3">\n      </span><span class="s1">var curveConstants = getBarrelCurveConstants(width, height);</span><span class="s3">\n      </span><span class="s1">var hOffset = curveConstants.heightOffset;</span><span class="s3">\n      </span><span class="s1">var wOffset = curveConstants.widthOffset;</span><span class="s3">\n      </span><span class="s1">var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;</span><span class="s3">\n\n      </span><span class="s1">// points are in clockwise order, inner (imaginary) control pt on [4, 5]</span><span class="s3">\n      </span><span class="s1">var pts = {</span><span class="s3">\n        </span><span class="s1">topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],</span><span class="s3">\n        </span><span class="s1">topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],</span><span class="s3">\n        </span><span class="s1">bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],</span><span class="s3">\n        </span><span class="s1">bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">pts.topLeft.isTop = true;</span><span class="s3">\n      </span><span class="s1">pts.topRight.isTop = true;</span><span class="s3">\n      </span><span class="s1">pts.bottomLeft.isBottom = true;</span><span class="s3">\n      </span><span class="s1">pts.bottomRight.isBottom = true;</span><span class="s3">\n      </span><span class="s1">return pts;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">var curveConstants = getBarrelCurveConstants(width, height);</span><span class="s3">\n      </span><span class="s1">var hOffset = curveConstants.heightOffset;</span><span class="s3">\n      </span><span class="s1">var wOffset = curveConstants.widthOffset;</span><span class="s3">\n\n      </span><span class="s1">// Check hBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check vBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);</span><span class="s3">\n      </span><span class="s1">var getCurveT = function getCurveT(x, y, curvePts) {</span><span class="s3">\n        </span><span class="s1">var x0 = curvePts[4];</span><span class="s3">\n        </span><span class="s1">var x1 = curvePts[2];</span><span class="s3">\n        </span><span class="s1">var x2 = curvePts[0];</span><span class="s3">\n        </span><span class="s1">var y0 = curvePts[5];</span><span class="s3">\n        </span><span class="s1">// var y1 = curvePts[ 3 ];</span><span class="s3">\n        </span><span class="s1">var y2 = curvePts[1];</span><span class="s3">\n        </span><span class="s1">var xMin = Math.min(x0, x2);</span><span class="s3">\n        </span><span class="s1">var xMax = Math.max(x0, x2);</span><span class="s3">\n        </span><span class="s1">var yMin = Math.min(y0, y2);</span><span class="s3">\n        </span><span class="s1">var yMax = Math.max(y0, y2);</span><span class="s3">\n        </span><span class="s1">if (xMin &lt;= x &amp;&amp; x &lt;= xMax &amp;&amp; yMin &lt;= y &amp;&amp; y &lt;= yMax) {</span><span class="s3">\n          </span><span class="s1">var coeff = bezierPtsToQuadCoeff(x0, x1, x2);</span><span class="s3">\n          </span><span class="s1">var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);</span><span class="s3">\n          </span><span class="s1">var validRoots = roots.filter(function (r) {</span><span class="s3">\n            </span><span class="s1">return 0 &lt;= r &amp;&amp; r &lt;= 1;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (validRoots.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">return validRoots[0];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var curveRegions = Object.keys(barrelCurvePts);</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; curveRegions.length; i++) {</span><span class="s3">\n        </span><span class="s1">var corner = curveRegions[i];</span><span class="s3">\n        </span><span class="s1">var cornerPts = barrelCurvePts[corner];</span><span class="s3">\n        </span><span class="s1">var t = getCurveT(x, y, cornerPts);</span><span class="s3">\n        </span><span class="s1">if (t == null) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var y0 = cornerPts[5];</span><span class="s3">\n        </span><span class="s1">var y1 = cornerPts[3];</span><span class="s3">\n        </span><span class="s1">var y2 = cornerPts[1];</span><span class="s3">\n        </span><span class="s1">var bezY = qbezierAt(y0, y1, y2, t);</span><span class="s3">\n        </span><span class="s1">if (cornerPts.isTop &amp;&amp; bezY &lt;= y) {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cornerPts.isBottom &amp;&amp; y &lt;= bezY) {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.generateBottomRoundrectangle = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {</span><span class="s3">\n    </span><span class="s1">renderer: this,</span><span class="s3">\n    </span><span class="s1">name: 'bottom-round-rectangle',</span><span class="s3">\n    </span><span class="s1">points: generateUnitNgonPointsFitToSquare(4, 0),</span><span class="s3">\n    </span><span class="s1">draw: function draw(context, centerX, centerY, width, height, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">var topStartX = nodeX - (width / 2 + padding);</span><span class="s3">\n      </span><span class="s1">var topStartY = nodeY - (height / 2 + padding);</span><span class="s3">\n      </span><span class="s1">var topEndY = topStartY;</span><span class="s3">\n      </span><span class="s1">var topEndX = nodeX + (width / 2 + padding);</span><span class="s3">\n      </span><span class="s1">var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);</span><span class="s3">\n      </span><span class="s1">if (topIntersections.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">return topIntersections;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {</span><span class="s3">\n      </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;</span><span class="s3">\n      </span><span class="s1">var diam = 2 * cornerRadius;</span><span class="s3">\n\n      </span><span class="s1">// Check hBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check vBox</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// check non-rounded top side</span><span class="s3">\n      </span><span class="s1">var outerWidth = width / 2 + 2 * padding;</span><span class="s3">\n      </span><span class="s1">var outerHeight = height / 2 + 2 * padding;</span><span class="s3">\n      </span><span class="s1">var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];</span><span class="s3">\n      </span><span class="s1">if (pointInsidePolygonPoints(x, y, points)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check bottom right quarter circle</span><span class="s3">\n      </span><span class="s1">if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check bottom left quarter circle</span><span class="s3">\n      </span><span class="s1">if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$2.registerNodeShapes = function () {</span><span class="s3">\n  </span><span class="s1">var nodeShapes = this.nodeShapes = {};</span><span class="s3">\n  </span><span class="s1">var renderer = this;</span><span class="s3">\n  </span><span class="s1">this.generateEllipse();</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));</span><span class="s3">\n  </span><span class="s1">this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));</span><span class="s3">\n  </span><span class="s1">nodeShapes['square'] = nodeShapes['rectangle'];</span><span class="s3">\n  </span><span class="s1">this.generateRoundRectangle();</span><span class="s3">\n  </span><span class="s1">this.generateCutRectangle();</span><span class="s3">\n  </span><span class="s1">this.generateBarrel();</span><span class="s3">\n  </span><span class="s1">this.generateBottomRoundrectangle();</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];</span><span class="s3">\n    </span><span class="s1">this.generatePolygon('diamond', diamondPoints);</span><span class="s3">\n    </span><span class="s1">this.generateRoundPolygon('round-diamond', diamondPoints);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));</span><span class="s3">\n  </span><span class="s1">this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));</span><span class="s3">\n  </span><span class="s1">this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));</span><span class="s3">\n  </span><span class="s1">this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));</span><span class="s3">\n  </span><span class="s1">this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));</span><span class="s3">\n  </span><span class="s1">var star5Points = new Array(20);</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var outerPoints = generateUnitNgonPoints(5, 0);</span><span class="s3">\n    </span><span class="s1">var innerPoints = generateUnitNgonPoints(5, Math.PI / 5);</span><span class="s3">\n\n    </span><span class="s1">// Outer radius is 1; inner radius of star is smaller</span><span class="s3">\n    </span><span class="s1">var innerRadius = 0.5 * (3 - Math.sqrt(5));</span><span class="s3">\n    </span><span class="s1">innerRadius *= 1.57;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; innerPoints.length / 2; i++) {</span><span class="s3">\n      </span><span class="s1">innerPoints[i * 2] *= innerRadius;</span><span class="s3">\n      </span><span class="s1">innerPoints[i * 2 + 1] *= innerRadius;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; 20 / 4; i++) {</span><span class="s3">\n      </span><span class="s1">star5Points[i * 4] = outerPoints[i * 2];</span><span class="s3">\n      </span><span class="s1">star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];</span><span class="s3">\n      </span><span class="s1">star5Points[i * 4 + 2] = innerPoints[i * 2];</span><span class="s3">\n      </span><span class="s1">star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">star5Points = fitPolygonToSquare(star5Points);</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('star', star5Points);</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);</span><span class="s3">\n  </span><span class="s1">this.generatePolygon('right-rhomboid', [-0.333, -1, 1, -1, 0.333, 1, -1, 1]);</span><span class="s3">\n  </span><span class="s1">this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];</span><span class="s3">\n    </span><span class="s1">this.generatePolygon('tag', tagPoints);</span><span class="s3">\n    </span><span class="s1">this.generateRoundPolygon('round-tag', tagPoints);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodeShapes.makePolygon = function (points) {</span><span class="s3">\n    </span><span class="s1">// use caching on user-specified polygons so they are as fast as native shapes</span><span class="s3">\n\n    </span><span class="s1">var key = points.join('$');</span><span class="s3">\n    </span><span class="s1">var name = 'polygon-' + key;</span><span class="s3">\n    </span><span class="s1">var shape;</span><span class="s3">\n    </span><span class="s1">if (shape = this[name]) {</span><span class="s3">\n      </span><span class="s1">// got cached shape</span><span class="s3">\n      </span><span class="s1">return shape;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// create and cache new shape</span><span class="s3">\n    </span><span class="s1">return renderer.generatePolygon(name, points);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BRp$1 = {};</span><span class="s3">\n</span><span class="s1">BRp$1.timeToRender = function () {</span><span class="s3">\n  </span><span class="s1">return this.redrawTotalTime / this.redrawCount;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$1.redraw = function (options) {</span><span class="s3">\n  </span><span class="s1">options = options || staticEmptyObject();</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">if (r.averageRedrawTime === undefined) {</span><span class="s3">\n    </span><span class="s1">r.averageRedrawTime = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.lastRedrawTime === undefined) {</span><span class="s3">\n    </span><span class="s1">r.lastRedrawTime = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.lastDrawTime === undefined) {</span><span class="s3">\n    </span><span class="s1">r.lastDrawTime = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.requestedFrame = true;</span><span class="s3">\n  </span><span class="s1">r.renderOptions = options;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$1.beforeRender = function (fn, priority) {</span><span class="s3">\n  </span><span class="s1">// the renderer can't add tick callbacks when destroyed</span><span class="s3">\n  </span><span class="s1">if (this.destroyed) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (priority == null) {</span><span class="s3">\n    </span><span class="s1">error('Priority is not optional for beforeRender');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var cbs = this.beforeRenderCallbacks;</span><span class="s3">\n  </span><span class="s1">cbs.push({</span><span class="s3">\n    </span><span class="s1">fn: fn,</span><span class="s3">\n    </span><span class="s1">priority: priority</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// higher priority callbacks executed first</span><span class="s3">\n  </span><span class="s1">cbs.sort(function (a, b) {</span><span class="s3">\n    </span><span class="s1">return b.priority - a.priority;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {</span><span class="s3">\n  </span><span class="s1">var cbs = r.beforeRenderCallbacks;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; cbs.length; i++) {</span><span class="s3">\n    </span><span class="s1">cbs[i].fn(willDraw, startTime);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp$1.startRenderLoop = function () {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n  </span><span class="s1">if (r.renderLoopStarted) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r.renderLoopStarted = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var _renderFn = function renderFn(requestTime) {</span><span class="s3">\n    </span><span class="s1">if (r.destroyed) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cy.batching()) ; else if (r.requestedFrame &amp;&amp; !r.skipFrame) {</span><span class="s3">\n      </span><span class="s1">beforeRenderCallbacks(r, true, requestTime);</span><span class="s3">\n      </span><span class="s1">var startTime = performanceNow();</span><span class="s3">\n      </span><span class="s1">r.render(r.renderOptions);</span><span class="s3">\n      </span><span class="s1">var endTime = r.lastDrawTime = performanceNow();</span><span class="s3">\n      </span><span class="s1">if (r.averageRedrawTime === undefined) {</span><span class="s3">\n        </span><span class="s1">r.averageRedrawTime = endTime - startTime;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (r.redrawCount === undefined) {</span><span class="s3">\n        </span><span class="s1">r.redrawCount = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.redrawCount++;</span><span class="s3">\n      </span><span class="s1">if (r.redrawTotalTime === undefined) {</span><span class="s3">\n        </span><span class="s1">r.redrawTotalTime = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var duration = endTime - startTime;</span><span class="s3">\n      </span><span class="s1">r.redrawTotalTime += duration;</span><span class="s3">\n      </span><span class="s1">r.lastRedrawTime = duration;</span><span class="s3">\n\n      </span><span class="s1">// use a weighted average with a bias from the previous average so we don't spike so easily</span><span class="s3">\n      </span><span class="s1">r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;</span><span class="s3">\n      </span><span class="s1">r.requestedFrame = false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">beforeRenderCallbacks(r, false, requestTime);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.skipFrame = false;</span><span class="s3">\n    </span><span class="s1">requestAnimationFrame(_renderFn);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">requestAnimationFrame(_renderFn);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var BaseRenderer = function BaseRenderer(options) {</span><span class="s3">\n  </span><span class="s1">this.init(options);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var BR = BaseRenderer;</span><span class="s3">\n</span><span class="s1">var BRp = BR.prototype;</span><span class="s3">\n</span><span class="s1">BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];</span><span class="s3">\n</span><span class="s1">BRp.init = function (options) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">r.options = options;</span><span class="s3">\n  </span><span class="s1">r.cy = options.cy;</span><span class="s3">\n  </span><span class="s1">var ctr = r.container = options.cy.container();</span><span class="s3">\n  </span><span class="s1">var containerWindow = r.cy.window();</span><span class="s3">\n\n  </span><span class="s1">// prepend a stylesheet in the head such that</span><span class="s3">\n  </span><span class="s1">if (containerWindow) {</span><span class="s3">\n    </span><span class="s1">var document = containerWindow.document;</span><span class="s3">\n    </span><span class="s1">var head = document.head;</span><span class="s3">\n    </span><span class="s1">var stylesheetId = '__________cytoscape_stylesheet';</span><span class="s3">\n    </span><span class="s1">var className = '__________cytoscape_container';</span><span class="s3">\n    </span><span class="s1">var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;</span><span class="s3">\n    </span><span class="s1">if (ctr.className.indexOf(className) &lt; 0) {</span><span class="s3">\n      </span><span class="s1">ctr.className = (ctr.className || '') + ' ' + className;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!stylesheetAlreadyExists) {</span><span class="s3">\n      </span><span class="s1">var stylesheet = document.createElement('style');</span><span class="s3">\n      </span><span class="s1">stylesheet.id = stylesheetId;</span><span class="s3">\n      </span><span class="s1">stylesheet.textContent = '.' + className + ' { position: relative; }';</span><span class="s3">\n      </span><span class="s1">head.insertBefore(stylesheet, head.children[0]); // first so lowest priority</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var computedStyle = containerWindow.getComputedStyle(ctr);</span><span class="s3">\n    </span><span class="s1">var position = computedStyle.getPropertyValue('position');</span><span class="s3">\n    </span><span class="s1">if (position === 'static') {</span><span class="s3">\n      </span><span class="s1">warn('A Cytoscape container has style position:static and so can not use UI extensions properly');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag</span><span class="s3">\n\n  </span><span class="s1">r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];</span><span class="s3">\n\n  </span><span class="s1">//--Pointer-related data</span><span class="s3">\n  </span><span class="s1">r.hoverData = {</span><span class="s3">\n    </span><span class="s1">down: null,</span><span class="s3">\n    </span><span class="s1">last: null,</span><span class="s3">\n    </span><span class="s1">downTime: null,</span><span class="s3">\n    </span><span class="s1">triggerMode: null,</span><span class="s3">\n    </span><span class="s1">dragging: false,</span><span class="s3">\n    </span><span class="s1">initialPan: [null, null],</span><span class="s3">\n    </span><span class="s1">capture: false</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.dragData = {</span><span class="s3">\n    </span><span class="s1">possibleDragElements: []</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.touchData = {</span><span class="s3">\n    </span><span class="s1">start: null,</span><span class="s3">\n    </span><span class="s1">capture: false,</span><span class="s3">\n    </span><span class="s1">// These 3 fields related to tap, taphold events</span><span class="s3">\n    </span><span class="s1">startPosition: [null, null, null, null, null, null],</span><span class="s3">\n    </span><span class="s1">singleTouchStartTime: null,</span><span class="s3">\n    </span><span class="s1">singleTouchMoved: true,</span><span class="s3">\n    </span><span class="s1">now: [null, null, null, null, null, null],</span><span class="s3">\n    </span><span class="s1">earlier: [null, null, null, null, null, null]</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.redraws = 0;</span><span class="s3">\n  </span><span class="s1">r.showFps = options.showFps;</span><span class="s3">\n  </span><span class="s1">r.debug = options.debug;</span><span class="s3">\n  </span><span class="s1">r.webgl = options.webgl;</span><span class="s3">\n  </span><span class="s1">r.hideEdgesOnViewport = options.hideEdgesOnViewport;</span><span class="s3">\n  </span><span class="s1">r.textureOnViewport = options.textureOnViewport;</span><span class="s3">\n  </span><span class="s1">r.wheelSensitivity = options.wheelSensitivity;</span><span class="s3">\n  </span><span class="s1">r.motionBlurEnabled = options.motionBlur; // on by default</span><span class="s3">\n  </span><span class="s1">r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;</span><span class="s3">\n  </span><span class="s1">r.motionBlur = options.motionBlur; // for initial kick off</span><span class="s3">\n  </span><span class="s1">r.motionBlurOpacity = options.motionBlurOpacity;</span><span class="s3">\n  </span><span class="s1">r.motionBlurTransparency = 1 - r.motionBlurOpacity;</span><span class="s3">\n  </span><span class="s1">r.motionBlurPxRatio = 1;</span><span class="s3">\n  </span><span class="s1">r.mbPxRBlurry = 1; //0.8;</span><span class="s3">\n  </span><span class="s1">r.minMbLowQualFrames = 4;</span><span class="s3">\n  </span><span class="s1">r.fullQualityMb = false;</span><span class="s3">\n  </span><span class="s1">r.clearedForMotionBlur = [];</span><span class="s3">\n  </span><span class="s1">r.desktopTapThreshold = options.desktopTapThreshold;</span><span class="s3">\n  </span><span class="s1">r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;</span><span class="s3">\n  </span><span class="s1">r.touchTapThreshold = options.touchTapThreshold;</span><span class="s3">\n  </span><span class="s1">r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;</span><span class="s3">\n  </span><span class="s1">r.tapholdDuration = 500;</span><span class="s3">\n  </span><span class="s1">r.bindings = [];</span><span class="s3">\n  </span><span class="s1">r.beforeRenderCallbacks = [];</span><span class="s3">\n  </span><span class="s1">r.beforeRenderPriorities = {</span><span class="s3">\n    </span><span class="s1">// higher priority execs before lower one</span><span class="s3">\n    </span><span class="s1">animations: 400,</span><span class="s3">\n    </span><span class="s1">eleCalcs: 300,</span><span class="s3">\n    </span><span class="s1">eleTxrDeq: 200,</span><span class="s3">\n    </span><span class="s1">lyrTxrDeq: 150,</span><span class="s3">\n    </span><span class="s1">lyrTxrSkip: 100</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.registerNodeShapes();</span><span class="s3">\n  </span><span class="s1">r.registerArrowShapes();</span><span class="s3">\n  </span><span class="s1">r.registerCalculationListeners();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp.notify = function (eventName, eles) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n\n  </span><span class="s1">// the renderer can't be notified after it's destroyed</span><span class="s3">\n  </span><span class="s1">if (this.destroyed) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eventName === 'init') {</span><span class="s3">\n    </span><span class="s1">r.load();</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eventName === 'destroy') {</span><span class="s3">\n    </span><span class="s1">r.destroy();</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eventName === 'add' || eventName === 'remove' || eventName === 'move' &amp;&amp; cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {</span><span class="s3">\n    </span><span class="s1">r.invalidateCachedZSortedEles();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eventName === 'viewport') {</span><span class="s3">\n    </span><span class="s1">r.redrawHint('select', true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eventName === 'gc') {</span><span class="s3">\n    </span><span class="s1">r.redrawHint('gc', true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {</span><span class="s3">\n    </span><span class="s1">r.invalidateContainerClientCoordsCache();</span><span class="s3">\n    </span><span class="s1">r.matchCanvasSize(r.container);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n  </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n  </span><span class="s1">this.startRenderLoop();</span><span class="s3">\n  </span><span class="s1">this.redraw();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp.destroy = function () {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">r.destroyed = true;</span><span class="s3">\n  </span><span class="s1">r.cy.stopAnimationLoop();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; r.bindings.length; i++) {</span><span class="s3">\n    </span><span class="s1">var binding = r.bindings[i];</span><span class="s3">\n    </span><span class="s1">var b = binding;</span><span class="s3">\n    </span><span class="s1">var tgt = b.target;</span><span class="s3">\n    </span><span class="s1">(tgt.off || tgt.removeEventListener).apply(tgt, b.args);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.bindings = [];</span><span class="s3">\n  </span><span class="s1">r.beforeRenderCallbacks = [];</span><span class="s3">\n  </span><span class="s1">r.onUpdateEleCalcsFns = [];</span><span class="s3">\n  </span><span class="s1">if (r.removeObserver) {</span><span class="s3">\n    </span><span class="s1">r.removeObserver.disconnect();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.styleObserver) {</span><span class="s3">\n    </span><span class="s1">r.styleObserver.disconnect();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.resizeObserver) {</span><span class="s3">\n    </span><span class="s1">r.resizeObserver.disconnect();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.labelCalcDiv) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n      </span><span class="s1">// ie10 issue #1014</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">BRp.isHeadless = function () {</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">[BRp$f, BRp$5, BRp$4, BRp$3, BRp$2, BRp$1].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(BRp, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var fullFpsTime = 1000 / 60; // assume 60 frames per second</span><span class="s3">\n\n</span><span class="s1">var defs = {</span><span class="s3">\n  </span><span class="s1">setupDequeueing: function setupDequeueing(opts) {</span><span class="s3">\n    </span><span class="s1">return function setupDequeueingImpl() {</span><span class="s3">\n      </span><span class="s1">var self = this;</span><span class="s3">\n      </span><span class="s1">var r = this.renderer;</span><span class="s3">\n      </span><span class="s1">if (self.dequeueingSetup) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">self.dequeueingSetup = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var queueRedraw = debounce(function () {</span><span class="s3">\n        </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n        </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n        </span><span class="s1">r.redraw();</span><span class="s3">\n      </span><span class="s1">}, opts.deqRedrawThreshold);</span><span class="s3">\n      </span><span class="s1">var dequeue = function dequeue(willDraw, frameStartTime) {</span><span class="s3">\n        </span><span class="s1">var startTime = performanceNow();</span><span class="s3">\n        </span><span class="s1">var avgRenderTime = r.averageRedrawTime;</span><span class="s3">\n        </span><span class="s1">var renderTime = r.lastRedrawTime;</span><span class="s3">\n        </span><span class="s1">var deqd = [];</span><span class="s3">\n        </span><span class="s1">var extent = r.cy.extent();</span><span class="s3">\n        </span><span class="s1">var pixelRatio = r.getPixelRatio();</span><span class="s3">\n\n        </span><span class="s1">// if we aren't in a tick that causes a draw, then the rendered style</span><span class="s3">\n        </span><span class="s1">// queue won't automatically be flushed before dequeueing starts</span><span class="s3">\n        </span><span class="s1">if (!willDraw) {</span><span class="s3">\n          </span><span class="s1">r.flushRenderedStyleQueue();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (true) {</span><span class="s3">\n          </span><span class="s1">// eslint-disable-line no-constant-condition</span><span class="s3">\n          </span><span class="s1">var now = performanceNow();</span><span class="s3">\n          </span><span class="s1">var duration = now - startTime;</span><span class="s3">\n          </span><span class="s1">var frameDuration = now - frameStartTime;</span><span class="s3">\n          </span><span class="s1">if (renderTime &lt; fullFpsTime) {</span><span class="s3">\n            </span><span class="s1">// if we're rendering faster than the ideal fps, then do dequeueing</span><span class="s3">\n            </span><span class="s1">// during all of the remaining frame time</span><span class="s3">\n\n            </span><span class="s1">var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);</span><span class="s3">\n            </span><span class="s1">if (frameDuration &gt;= opts.deqFastCost * timeAvailable) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">if (willDraw) {</span><span class="s3">\n              </span><span class="s1">if (duration &gt;= opts.deqCost * renderTime || duration &gt;= opts.deqAvgCost * avgRenderTime) {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else if (frameDuration &gt;= opts.deqNoDrawCost * fullFpsTime) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var thisDeqd = opts.deq(self, pixelRatio, extent);</span><span class="s3">\n          </span><span class="s1">if (thisDeqd.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">for (var i = 0; i &lt; thisDeqd.length; i++) {</span><span class="s3">\n              </span><span class="s1">deqd.push(thisDeqd[i]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// callbacks on dequeue</span><span class="s3">\n        </span><span class="s1">if (deqd.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">opts.onDeqd(self, deqd);</span><span class="s3">\n          </span><span class="s1">if (!willDraw &amp;&amp; opts.shouldRedraw(self, deqd, pixelRatio, extent)) {</span><span class="s3">\n            </span><span class="s1">queueRedraw();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var priority = opts.priority || noop$1;</span><span class="s3">\n      </span><span class="s1">r.beforeRender(dequeue, priority(self));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Allows lookups for (ele, lvl) =&gt; cache.</span><span class="s3">\n</span><span class="s1">// Uses keys so elements may share the same cache.</span><span class="s3">\n</span><span class="s1">var ElementTextureCacheLookup = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function ElementTextureCacheLookup(getKey) {</span><span class="s3">\n    </span><span class="s1">var doesEleInvalidateKey = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : falsify;</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, ElementTextureCacheLookup);</span><span class="s3">\n    </span><span class="s1">this.idsByKey = new Map$1();</span><span class="s3">\n    </span><span class="s1">this.keyForId = new Map$1();</span><span class="s3">\n    </span><span class="s1">this.cachesByLvl = new Map$1();</span><span class="s3">\n    </span><span class="s1">this.lvls = [];</span><span class="s3">\n    </span><span class="s1">this.getKey = getKey;</span><span class="s3">\n    </span><span class="s1">this.doesEleInvalidateKey = doesEleInvalidateKey;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(ElementTextureCacheLookup, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getIdsFor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getIdsFor(key) {</span><span class="s3">\n      </span><span class="s1">if (key == null) {</span><span class="s3">\n        </span><span class="s1">error(</span><span class="s3">\&quot;</span><span class="s1">Can not get id list for null key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var idsByKey = this.idsByKey;</span><span class="s3">\n      </span><span class="s1">var ids = this.idsByKey.get(key);</span><span class="s3">\n      </span><span class="s1">if (!ids) {</span><span class="s3">\n        </span><span class="s1">ids = new Set$1();</span><span class="s3">\n        </span><span class="s1">idsByKey.set(key, ids);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ids;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">addIdForKey</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function addIdForKey(key, id) {</span><span class="s3">\n      </span><span class="s1">if (key != null) {</span><span class="s3">\n        </span><span class="s1">this.getIdsFor(key).add(id);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">deleteIdForKey</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function deleteIdForKey(key, id) {</span><span class="s3">\n      </span><span class="s1">if (key != null) {</span><span class="s3">\n        </span><span class="s1">this.getIdsFor(key)[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](id);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getNumberOfIdsForKey</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getNumberOfIdsForKey(key) {</span><span class="s3">\n      </span><span class="s1">if (key == null) {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return this.getIdsFor(key).size;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">updateKeyMappingFor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function updateKeyMappingFor(ele) {</span><span class="s3">\n      </span><span class="s1">var id = ele.id();</span><span class="s3">\n      </span><span class="s1">var prevKey = this.keyForId.get(id);</span><span class="s3">\n      </span><span class="s1">var currKey = this.getKey(ele);</span><span class="s3">\n      </span><span class="s1">this.deleteIdForKey(prevKey, id);</span><span class="s3">\n      </span><span class="s1">this.addIdForKey(currKey, id);</span><span class="s3">\n      </span><span class="s1">this.keyForId.set(id, currKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">deleteKeyMappingFor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function deleteKeyMappingFor(ele) {</span><span class="s3">\n      </span><span class="s1">var id = ele.id();</span><span class="s3">\n      </span><span class="s1">var prevKey = this.keyForId.get(id);</span><span class="s3">\n      </span><span class="s1">this.deleteIdForKey(prevKey, id);</span><span class="s3">\n      </span><span class="s1">this.keyForId[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">keyHasChangedFor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function keyHasChangedFor(ele) {</span><span class="s3">\n      </span><span class="s1">var id = ele.id();</span><span class="s3">\n      </span><span class="s1">var prevKey = this.keyForId.get(id);</span><span class="s3">\n      </span><span class="s1">var newKey = this.getKey(ele);</span><span class="s3">\n      </span><span class="s1">return prevKey !== newKey;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">isInvalid</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function isInvalid(ele) {</span><span class="s3">\n      </span><span class="s1">return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getCachesAt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getCachesAt(lvl) {</span><span class="s3">\n      </span><span class="s1">var cachesByLvl = this.cachesByLvl,</span><span class="s3">\n        </span><span class="s1">lvls = this.lvls;</span><span class="s3">\n      </span><span class="s1">var caches = cachesByLvl.get(lvl);</span><span class="s3">\n      </span><span class="s1">if (!caches) {</span><span class="s3">\n        </span><span class="s1">caches = new Map$1();</span><span class="s3">\n        </span><span class="s1">cachesByLvl.set(lvl, caches);</span><span class="s3">\n        </span><span class="s1">lvls.push(lvl);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return caches;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getCache</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getCache(key, lvl) {</span><span class="s3">\n      </span><span class="s1">return this.getCachesAt(lvl).get(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function get(ele, lvl) {</span><span class="s3">\n      </span><span class="s1">var key = this.getKey(ele);</span><span class="s3">\n      </span><span class="s1">var cache = this.getCache(key, lvl);</span><span class="s3">\n\n      </span><span class="s1">// getting for an element may need to add to the id list b/c eles can share keys</span><span class="s3">\n      </span><span class="s1">if (cache != null) {</span><span class="s3">\n        </span><span class="s1">this.updateKeyMappingFor(ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return cache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getForCachedKey</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getForCachedKey(ele, lvl) {</span><span class="s3">\n      </span><span class="s1">var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key</span><span class="s3">\n      </span><span class="s1">var cache = this.getCache(key, lvl);</span><span class="s3">\n      </span><span class="s1">return cache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">hasCache</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function hasCache(key, lvl) {</span><span class="s3">\n      </span><span class="s1">return this.getCachesAt(lvl).has(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">has</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function has(ele, lvl) {</span><span class="s3">\n      </span><span class="s1">var key = this.getKey(ele);</span><span class="s3">\n      </span><span class="s1">return this.hasCache(key, lvl);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">setCache</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function setCache(key, lvl, cache) {</span><span class="s3">\n      </span><span class="s1">cache.key = key;</span><span class="s3">\n      </span><span class="s1">this.getCachesAt(lvl).set(key, cache);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function set(ele, lvl, cache) {</span><span class="s3">\n      </span><span class="s1">var key = this.getKey(ele);</span><span class="s3">\n      </span><span class="s1">this.setCache(key, lvl, cache);</span><span class="s3">\n      </span><span class="s1">this.updateKeyMappingFor(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">deleteCache</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function deleteCache(key, lvl) {</span><span class="s3">\n      </span><span class="s1">this.getCachesAt(lvl)[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _delete(ele, lvl) {</span><span class="s3">\n      </span><span class="s1">var key = this.getKey(ele);</span><span class="s3">\n      </span><span class="s1">this.deleteCache(key, lvl);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">invalidateKey</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function invalidateKey(key) {</span><span class="s3">\n      </span><span class="s1">var _this = this;</span><span class="s3">\n      </span><span class="s1">this.lvls.forEach(function (lvl) {</span><span class="s3">\n        </span><span class="s1">return _this.deleteCache(key, lvl);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">invalidate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function invalidate(ele) {</span><span class="s3">\n      </span><span class="s1">var id = ele.id();</span><span class="s3">\n      </span><span class="s1">var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)</span><span class="s3">\n\n      </span><span class="s1">this.deleteKeyMappingFor(ele);</span><span class="s3">\n      </span><span class="s1">var entireKeyInvalidated = this.doesEleInvalidateKey(ele);</span><span class="s3">\n      </span><span class="s1">if (entireKeyInvalidated) {</span><span class="s3">\n        </span><span class="s1">// clear mapping for current key</span><span class="s3">\n        </span><span class="s1">this.invalidateKey(key);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">var minTxrH = 25; // the size of the texture cache for small height eles (special case)</span><span class="s3">\n</span><span class="s1">var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up</span><span class="s3">\n</span><span class="s1">var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render</span><span class="s3">\n</span><span class="s1">var maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)</span><span class="s3">\n</span><span class="s1">var maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used</span><span class="s3">\n</span><span class="s1">var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps</span><span class="s3">\n</span><span class="s1">var defTxrWidth = 1024; // default/minimum texture width</span><span class="s3">\n</span><span class="s1">var maxTxrW = 1024; // the maximum width of a texture</span><span class="s3">\n</span><span class="s1">var maxTxrH = 1024; // the maximum height of a texture</span><span class="s3">\n</span><span class="s1">var minUtility = 0.2; // if usage of texture is less than this, it is retired</span><span class="s3">\n</span><span class="s1">var maxFullness = 0.8; // fullness of texture after which queue removal is checked</span><span class="s3">\n</span><span class="s1">var maxFullnessChecks = 10; // dequeued after this many checks</span><span class="s3">\n</span><span class="s1">var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame</span><span class="s3">\n</span><span class="s1">var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time</span><span class="s3">\n</span><span class="s1">var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing</span><span class="s3">\n</span><span class="s1">var deqFastCost$1 = 0.9; // % of frame time to be used when &gt;60fps</span><span class="s3">\n</span><span class="s1">var deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile</span><span class="s3">\n</span><span class="s1">var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch</span><span class="s3">\n\n</span><span class="s1">var getTxrReasons = {</span><span class="s3">\n  </span><span class="s1">dequeue: 'dequeue',</span><span class="s3">\n  </span><span class="s1">downscale: 'downscale',</span><span class="s3">\n  </span><span class="s1">highQuality: 'highQuality'</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var initDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">getKey: null,</span><span class="s3">\n  </span><span class="s1">doesEleInvalidateKey: falsify,</span><span class="s3">\n  </span><span class="s1">drawElement: null,</span><span class="s3">\n  </span><span class="s1">getBoundingBox: null,</span><span class="s3">\n  </span><span class="s1">getRotationPoint: null,</span><span class="s3">\n  </span><span class="s1">getRotationOffset: null,</span><span class="s3">\n  </span><span class="s1">isVisible: trueify,</span><span class="s3">\n  </span><span class="s1">allowEdgeTxrCaching: true,</span><span class="s3">\n  </span><span class="s1">allowParentTxrCaching: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">self.renderer = renderer;</span><span class="s3">\n  </span><span class="s1">self.onDequeues = [];</span><span class="s3">\n  </span><span class="s1">var opts = initDefaults(initOptions);</span><span class="s3">\n  </span><span class="s1">extend(self, opts);</span><span class="s3">\n  </span><span class="s1">self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);</span><span class="s3">\n  </span><span class="s1">self.setupDequeueing();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ETCp = ElementTextureCache.prototype;</span><span class="s3">\n</span><span class="s1">ETCp.reasons = getTxrReasons;</span><span class="s3">\n\n</span><span class="s1">// the list of textures in which new subtextures for elements can be placed</span><span class="s3">\n</span><span class="s1">ETCp.getTextureQueue = function (txrH) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">self.eleImgCaches = self.eleImgCaches || {};</span><span class="s3">\n  </span><span class="s1">return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// the list of usused textures which can be recycled (in use in texture queue)</span><span class="s3">\n</span><span class="s1">ETCp.getRetiredTextureQueue = function (txrH) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};</span><span class="s3">\n  </span><span class="s1">var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];</span><span class="s3">\n  </span><span class="s1">return rtxtrQ;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// queue of element draw requests at different scale levels</span><span class="s3">\n</span><span class="s1">ETCp.getElementQueue = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {</span><span class="s3">\n    </span><span class="s1">return b.reqs - a.reqs;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return q;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// queue of element draw requests at different scale levels (element id lookup)</span><span class="s3">\n</span><span class="s1">ETCp.getElementKeyToQueue = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};</span><span class="s3">\n  </span><span class="s1">return k2q;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var r = this.renderer;</span><span class="s3">\n  </span><span class="s1">var zoom = r.cy.zoom();</span><span class="s3">\n  </span><span class="s1">var lookup = this.lookup;</span><span class="s3">\n  </span><span class="s1">if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!self.allowEdgeTxrCaching &amp;&amp; ele.isEdge() || !self.allowParentTxrCaching &amp;&amp; ele.isParent()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (lvl == null) {</span><span class="s3">\n    </span><span class="s1">lvl = Math.ceil(log2(zoom * pxRatio));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (lvl &lt; minLvl$1) {</span><span class="s3">\n    </span><span class="s1">lvl = minLvl$1;</span><span class="s3">\n  </span><span class="s1">} else if (zoom &gt;= maxZoom$1 || lvl &gt; maxLvl$1) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var scale = Math.pow(2, lvl);</span><span class="s3">\n  </span><span class="s1">var eleScaledH = bb.h * scale;</span><span class="s3">\n  </span><span class="s1">var eleScaledW = bb.w * scale;</span><span class="s3">\n  </span><span class="s1">var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);</span><span class="s3">\n  </span><span class="s1">if (!this.isVisible(ele, scaledLabelShown)) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var eleCache = lookup.get(ele, lvl);</span><span class="s3">\n\n  </span><span class="s1">// if this get was on an unused/invalidated cache, then restore the texture usage metric</span><span class="s3">\n  </span><span class="s1">if (eleCache &amp;&amp; eleCache.invalidated) {</span><span class="s3">\n    </span><span class="s1">eleCache.invalidated = false;</span><span class="s3">\n    </span><span class="s1">eleCache.texture.invalidatedWidth -= eleCache.width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eleCache) {</span><span class="s3">\n    </span><span class="s1">return eleCache;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var txrH; // which texture height this ele belongs to</span><span class="s3">\n\n  </span><span class="s1">if (eleScaledH &lt;= minTxrH) {</span><span class="s3">\n    </span><span class="s1">txrH = minTxrH;</span><span class="s3">\n  </span><span class="s1">} else if (eleScaledH &lt;= txrStepH) {</span><span class="s3">\n    </span><span class="s1">txrH = txrStepH;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (eleScaledH &gt; maxTxrH || eleScaledW &gt; maxTxrW) {</span><span class="s3">\n    </span><span class="s1">return null; // caching large elements is not efficient</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var txrQ = self.getTextureQueue(txrH);</span><span class="s3">\n\n  </span><span class="s1">// first try the second last one in case it has space at the end</span><span class="s3">\n  </span><span class="s1">var txr = txrQ[txrQ.length - 2];</span><span class="s3">\n  </span><span class="s1">var addNewTxr = function addNewTxr() {</span><span class="s3">\n    </span><span class="s1">return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// try the last one if there is no second last one</span><span class="s3">\n  </span><span class="s1">if (!txr) {</span><span class="s3">\n    </span><span class="s1">txr = txrQ[txrQ.length - 1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the last one doesn't exist, we need a first one</span><span class="s3">\n  </span><span class="s1">if (!txr) {</span><span class="s3">\n    </span><span class="s1">txr = addNewTxr();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if there's no room in the current texture, we need a new one</span><span class="s3">\n  </span><span class="s1">if (txr.width - txr.usedWidth &lt; eleScaledW) {</span><span class="s3">\n    </span><span class="s1">txr = addNewTxr();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var scalableFrom = function scalableFrom(otherCache) {</span><span class="s3">\n    </span><span class="s1">return otherCache &amp;&amp; otherCache.scaledLabelShown === scaledLabelShown;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var deqing = reason &amp;&amp; reason === getTxrReasons.dequeue;</span><span class="s3">\n  </span><span class="s1">var highQualityReq = reason &amp;&amp; reason === getTxrReasons.highQuality;</span><span class="s3">\n  </span><span class="s1">var downscaleReq = reason &amp;&amp; reason === getTxrReasons.downscale;</span><span class="s3">\n  </span><span class="s1">var higherCache; // the nearest cache with a higher level</span><span class="s3">\n  </span><span class="s1">for (var l = lvl + 1; l &lt;= maxLvl$1; l++) {</span><span class="s3">\n    </span><span class="s1">var c = lookup.get(ele, l);</span><span class="s3">\n    </span><span class="s1">if (c) {</span><span class="s3">\n      </span><span class="s1">higherCache = c;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var oneUpCache = higherCache &amp;&amp; higherCache.level === lvl + 1 ? higherCache : null;</span><span class="s3">\n  </span><span class="s1">var downscale = function downscale() {</span><span class="s3">\n    </span><span class="s1">txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// reset ele area in texture</span><span class="s3">\n  </span><span class="s1">txr.context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n  </span><span class="s1">txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);</span><span class="s3">\n  </span><span class="s1">if (scalableFrom(oneUpCache)) {</span><span class="s3">\n    </span><span class="s1">// then we can relatively cheaply rescale the existing image w/o rerendering</span><span class="s3">\n    </span><span class="s1">downscale();</span><span class="s3">\n  </span><span class="s1">} else if (scalableFrom(higherCache)) {</span><span class="s3">\n    </span><span class="s1">// then use the higher cache for now and queue the next level down</span><span class="s3">\n    </span><span class="s1">// to cheaply scale towards the smaller level</span><span class="s3">\n\n    </span><span class="s1">if (highQualityReq) {</span><span class="s3">\n      </span><span class="s1">for (var _l = higherCache.level; _l &gt; lvl; _l--) {</span><span class="s3">\n        </span><span class="s1">oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">downscale();</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">self.queueElement(ele, higherCache.level - 1);</span><span class="s3">\n      </span><span class="s1">return higherCache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var lowerCache; // the nearest cache with a lower level</span><span class="s3">\n    </span><span class="s1">if (!deqing &amp;&amp; !highQualityReq &amp;&amp; !downscaleReq) {</span><span class="s3">\n      </span><span class="s1">for (var _l2 = lvl - 1; _l2 &gt;= minLvl$1; _l2--) {</span><span class="s3">\n        </span><span class="s1">var _c = lookup.get(ele, _l2);</span><span class="s3">\n        </span><span class="s1">if (_c) {</span><span class="s3">\n          </span><span class="s1">lowerCache = _c;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (scalableFrom(lowerCache)) {</span><span class="s3">\n      </span><span class="s1">// then use the lower quality cache for now and queue the better one for later</span><span class="s3">\n\n      </span><span class="s1">self.queueElement(ele, lvl);</span><span class="s3">\n      </span><span class="s1">return lowerCache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">txr.context.translate(txr.usedWidth, 0);</span><span class="s3">\n    </span><span class="s1">txr.context.scale(scale, scale);</span><span class="s3">\n    </span><span class="s1">this.drawElement(txr.context, ele, bb, scaledLabelShown, false);</span><span class="s3">\n    </span><span class="s1">txr.context.scale(1 / scale, 1 / scale);</span><span class="s3">\n    </span><span class="s1">txr.context.translate(-txr.usedWidth, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">eleCache = {</span><span class="s3">\n    </span><span class="s1">x: txr.usedWidth,</span><span class="s3">\n    </span><span class="s1">texture: txr,</span><span class="s3">\n    </span><span class="s1">level: lvl,</span><span class="s3">\n    </span><span class="s1">scale: scale,</span><span class="s3">\n    </span><span class="s1">width: eleScaledW,</span><span class="s3">\n    </span><span class="s1">height: eleScaledH,</span><span class="s3">\n    </span><span class="s1">scaledLabelShown: scaledLabelShown</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);</span><span class="s3">\n  </span><span class="s1">txr.eleCaches.push(eleCache);</span><span class="s3">\n  </span><span class="s1">lookup.set(ele, lvl, eleCache);</span><span class="s3">\n  </span><span class="s1">self.checkTextureFullness(txr);</span><span class="s3">\n  </span><span class="s1">return eleCache;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.invalidateElements = function (eles) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">this.invalidateElement(eles[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.invalidateElement = function (ele) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var lookup = self.lookup;</span><span class="s3">\n  </span><span class="s1">var caches = [];</span><span class="s3">\n  </span><span class="s1">var invalid = lookup.isInvalid(ele);</span><span class="s3">\n  </span><span class="s1">if (!invalid) {</span><span class="s3">\n    </span><span class="s1">return; // override the invalidation request if the element key has not changed</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var lvl = minLvl$1; lvl &lt;= maxLvl$1; lvl++) {</span><span class="s3">\n    </span><span class="s1">var cache = lookup.getForCachedKey(ele, lvl);</span><span class="s3">\n    </span><span class="s1">if (cache) {</span><span class="s3">\n      </span><span class="s1">caches.push(cache);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var noOtherElesUseCache = lookup.invalidate(ele);</span><span class="s3">\n  </span><span class="s1">if (noOtherElesUseCache) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; caches.length; i++) {</span><span class="s3">\n      </span><span class="s1">var _cache = caches[i];</span><span class="s3">\n      </span><span class="s1">var txr = _cache.texture;</span><span class="s3">\n\n      </span><span class="s1">// remove space from the texture it belongs to</span><span class="s3">\n      </span><span class="s1">txr.invalidatedWidth += _cache.width;</span><span class="s3">\n\n      </span><span class="s1">// mark the cache as invalidated</span><span class="s3">\n      </span><span class="s1">_cache.invalidated = true;</span><span class="s3">\n\n      </span><span class="s1">// retire the texture if its utility is low</span><span class="s3">\n      </span><span class="s1">self.checkTextureUtility(txr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// remove from queue since the old req was for the old state</span><span class="s3">\n  </span><span class="s1">self.removeFromQueue(ele);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.checkTextureUtility = function (txr) {</span><span class="s3">\n  </span><span class="s1">// invalidate all entries in the cache if the cache size is small</span><span class="s3">\n  </span><span class="s1">if (txr.invalidatedWidth &gt;= minUtility * txr.width) {</span><span class="s3">\n    </span><span class="s1">this.retireTexture(txr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.checkTextureFullness = function (txr) {</span><span class="s3">\n  </span><span class="s1">// if texture has been mostly filled and passed over several times, remove</span><span class="s3">\n  </span><span class="s1">// it from the queue so we don't need to waste time looking at it to put new things</span><span class="s3">\n\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var txrQ = self.getTextureQueue(txr.height);</span><span class="s3">\n  </span><span class="s1">if (txr.usedWidth / txr.width &gt; maxFullness &amp;&amp; txr.fullnessChecks &gt;= maxFullnessChecks) {</span><span class="s3">\n    </span><span class="s1">removeFromArray(txrQ, txr);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">txr.fullnessChecks++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.retireTexture = function (txr) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var txrH = txr.height;</span><span class="s3">\n  </span><span class="s1">var txrQ = self.getTextureQueue(txrH);</span><span class="s3">\n  </span><span class="s1">var lookup = this.lookup;</span><span class="s3">\n\n  </span><span class="s1">// retire the texture from the active / searchable queue:</span><span class="s3">\n\n  </span><span class="s1">removeFromArray(txrQ, txr);</span><span class="s3">\n  </span><span class="s1">txr.retired = true;</span><span class="s3">\n\n  </span><span class="s1">// remove the refs from the eles to the caches:</span><span class="s3">\n\n  </span><span class="s1">var eleCaches = txr.eleCaches;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eleCaches.length; i++) {</span><span class="s3">\n    </span><span class="s1">var eleCache = eleCaches[i];</span><span class="s3">\n    </span><span class="s1">lookup.deleteCache(eleCache.key, eleCache.level);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">clearArray(eleCaches);</span><span class="s3">\n\n  </span><span class="s1">// add the texture to a retired queue so it can be recycled in future:</span><span class="s3">\n\n  </span><span class="s1">var rtxtrQ = self.getRetiredTextureQueue(txrH);</span><span class="s3">\n  </span><span class="s1">rtxtrQ.push(txr);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.addTexture = function (txrH, minW) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var txrQ = self.getTextureQueue(txrH);</span><span class="s3">\n  </span><span class="s1">var txr = {};</span><span class="s3">\n  </span><span class="s1">txrQ.push(txr);</span><span class="s3">\n  </span><span class="s1">txr.eleCaches = [];</span><span class="s3">\n  </span><span class="s1">txr.height = txrH;</span><span class="s3">\n  </span><span class="s1">txr.width = Math.max(defTxrWidth, minW);</span><span class="s3">\n  </span><span class="s1">txr.usedWidth = 0;</span><span class="s3">\n  </span><span class="s1">txr.invalidatedWidth = 0;</span><span class="s3">\n  </span><span class="s1">txr.fullnessChecks = 0;</span><span class="s3">\n  </span><span class="s1">txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);</span><span class="s3">\n  </span><span class="s1">txr.context = txr.canvas.getContext('2d');</span><span class="s3">\n  </span><span class="s1">return txr;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.recycleTexture = function (txrH, minW) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var txrQ = self.getTextureQueue(txrH);</span><span class="s3">\n  </span><span class="s1">var rtxtrQ = self.getRetiredTextureQueue(txrH);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; rtxtrQ.length; i++) {</span><span class="s3">\n    </span><span class="s1">var txr = rtxtrQ[i];</span><span class="s3">\n    </span><span class="s1">if (txr.width &gt;= minW) {</span><span class="s3">\n      </span><span class="s1">txr.retired = false;</span><span class="s3">\n      </span><span class="s1">txr.usedWidth = 0;</span><span class="s3">\n      </span><span class="s1">txr.invalidatedWidth = 0;</span><span class="s3">\n      </span><span class="s1">txr.fullnessChecks = 0;</span><span class="s3">\n      </span><span class="s1">clearArray(txr.eleCaches);</span><span class="s3">\n      </span><span class="s1">txr.context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n      </span><span class="s1">txr.context.clearRect(0, 0, txr.width, txr.height);</span><span class="s3">\n      </span><span class="s1">removeFromArray(rtxtrQ, txr);</span><span class="s3">\n      </span><span class="s1">txrQ.push(txr);</span><span class="s3">\n      </span><span class="s1">return txr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.queueElement = function (ele, lvl) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var q = self.getElementQueue();</span><span class="s3">\n  </span><span class="s1">var k2q = self.getElementKeyToQueue();</span><span class="s3">\n  </span><span class="s1">var key = this.getKey(ele);</span><span class="s3">\n  </span><span class="s1">var existingReq = k2q[key];</span><span class="s3">\n  </span><span class="s1">if (existingReq) {</span><span class="s3">\n    </span><span class="s1">// use the max lvl b/c in between lvls are cheap to make</span><span class="s3">\n    </span><span class="s1">existingReq.level = Math.max(existingReq.level, lvl);</span><span class="s3">\n    </span><span class="s1">existingReq.eles.merge(ele);</span><span class="s3">\n    </span><span class="s1">existingReq.reqs++;</span><span class="s3">\n    </span><span class="s1">q.updateItem(existingReq);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var req = {</span><span class="s3">\n      </span><span class="s1">eles: ele.spawn().merge(ele),</span><span class="s3">\n      </span><span class="s1">level: lvl,</span><span class="s3">\n      </span><span class="s1">reqs: 1,</span><span class="s3">\n      </span><span class="s1">key: key</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">q.push(req);</span><span class="s3">\n    </span><span class="s1">k2q[key] = req;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.dequeue = function (pxRatio /*, extent*/) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var q = self.getElementQueue();</span><span class="s3">\n  </span><span class="s1">var k2q = self.getElementKeyToQueue();</span><span class="s3">\n  </span><span class="s1">var dequeued = [];</span><span class="s3">\n  </span><span class="s1">var lookup = self.lookup;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; maxDeqSize$1; i++) {</span><span class="s3">\n    </span><span class="s1">if (q.size() &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var req = q.pop();</span><span class="s3">\n      </span><span class="s1">var key = req.key;</span><span class="s3">\n      </span><span class="s1">var ele = req.eles[0]; // all eles have the same key</span><span class="s3">\n      </span><span class="s1">var cacheExists = lookup.hasCache(ele, req.level);</span><span class="s3">\n\n      </span><span class="s1">// clear out the key to req lookup</span><span class="s3">\n      </span><span class="s1">k2q[key] = null;</span><span class="s3">\n\n      </span><span class="s1">// dequeueing isn't necessary with an existing cache</span><span class="s3">\n      </span><span class="s1">if (cacheExists) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">dequeued.push(req);</span><span class="s3">\n      </span><span class="s1">var bb = self.getBoundingBox(ele);</span><span class="s3">\n      </span><span class="s1">self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return dequeued;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.removeFromQueue = function (ele) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var q = self.getElementQueue();</span><span class="s3">\n  </span><span class="s1">var k2q = self.getElementKeyToQueue();</span><span class="s3">\n  </span><span class="s1">var key = this.getKey(ele);</span><span class="s3">\n  </span><span class="s1">var req = k2q[key];</span><span class="s3">\n  </span><span class="s1">if (req != null) {</span><span class="s3">\n    </span><span class="s1">if (req.eles.length === 1) {</span><span class="s3">\n      </span><span class="s1">// remove if last ele in the req</span><span class="s3">\n      </span><span class="s1">// bring to front of queue</span><span class="s3">\n      </span><span class="s1">req.reqs = MAX_INT$1;</span><span class="s3">\n      </span><span class="s1">q.updateItem(req);</span><span class="s3">\n      </span><span class="s1">q.pop(); // remove from queue</span><span class="s3">\n\n      </span><span class="s1">k2q[key] = null; // remove from lookup map</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// otherwise just remove ele from req</span><span class="s3">\n      </span><span class="s1">req.eles.unmerge(ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.onDequeue = function (fn) {</span><span class="s3">\n  </span><span class="s1">this.onDequeues.push(fn);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.offDequeue = function (fn) {</span><span class="s3">\n  </span><span class="s1">removeFromArray(this.onDequeues, fn);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">ETCp.setupDequeueing = defs.setupDequeueing({</span><span class="s3">\n  </span><span class="s1">deqRedrawThreshold: deqRedrawThreshold$1,</span><span class="s3">\n  </span><span class="s1">deqCost: deqCost$1,</span><span class="s3">\n  </span><span class="s1">deqAvgCost: deqAvgCost$1,</span><span class="s3">\n  </span><span class="s1">deqNoDrawCost: deqNoDrawCost$1,</span><span class="s3">\n  </span><span class="s1">deqFastCost: deqFastCost$1,</span><span class="s3">\n  </span><span class="s1">deq: function deq(self, pxRatio, extent) {</span><span class="s3">\n    </span><span class="s1">return self.dequeue(pxRatio, extent);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">onDeqd: function onDeqd(self, deqd) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; self.onDequeues.length; i++) {</span><span class="s3">\n      </span><span class="s1">var fn = self.onDequeues[i];</span><span class="s3">\n      </span><span class="s1">fn(deqd);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; deqd.length; i++) {</span><span class="s3">\n      </span><span class="s1">var eles = deqd[i].eles;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; eles.length; j++) {</span><span class="s3">\n        </span><span class="s1">var bb = eles[j].boundingBox();</span><span class="s3">\n        </span><span class="s1">if (boundingBoxesIntersect(bb, extent)) {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">priority: function priority(self) {</span><span class="s3">\n    </span><span class="s1">return self.renderer.beforeRenderPriorities.eleTxrDeq;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var defNumLayers = 1; // default number of layers to use</span><span class="s3">\n</span><span class="s1">var minLvl = -4; // when scaling smaller than that we don't need to re-render</span><span class="s3">\n</span><span class="s1">var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)</span><span class="s3">\n</span><span class="s1">var maxZoom = 3.99; // beyond this zoom level, layered textures are not used</span><span class="s3">\n</span><span class="s1">var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile</span><span class="s3">\n</span><span class="s1">var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates</span><span class="s3">\n</span><span class="s1">var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame</span><span class="s3">\n</span><span class="s1">var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time</span><span class="s3">\n</span><span class="s1">var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing</span><span class="s3">\n</span><span class="s1">var deqFastCost = 0.9; // % of frame time to be used when &gt;60fps</span><span class="s3">\n</span><span class="s1">var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch</span><span class="s3">\n</span><span class="s1">var invalidThreshold = 250; // time threshold for disabling b/c of invalidations</span><span class="s3">\n</span><span class="s1">var maxLayerArea = 4000 * 4000; // layers can't be bigger than this</span><span class="s3">\n</span><span class="s1">var maxLayerDim = 32767; // maximum size for the width/height of layer canvases</span><span class="s3">\n</span><span class="s1">var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)</span><span class="s3">\n\n</span><span class="s1">// var log = function(){ console.log.apply( console, arguments ); };</span><span class="s3">\n\n</span><span class="s1">var LayeredTextureCache = function LayeredTextureCache(renderer) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var r = self.renderer = renderer;</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n  </span><span class="s1">self.layersByLevel = {}; // e.g. 2 =&gt; [ layer1, layer2, ..., layerN ]</span><span class="s3">\n\n  </span><span class="s1">self.firstGet = true;</span><span class="s3">\n  </span><span class="s1">self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;</span><span class="s3">\n  </span><span class="s1">self.skipping = false;</span><span class="s3">\n  </span><span class="s1">self.eleTxrDeqs = cy.collection();</span><span class="s3">\n  </span><span class="s1">self.scheduleElementRefinement = debounce(function () {</span><span class="s3">\n    </span><span class="s1">self.refineElementTextures(self.eleTxrDeqs);</span><span class="s3">\n    </span><span class="s1">self.eleTxrDeqs.unmerge(self.eleTxrDeqs);</span><span class="s3">\n  </span><span class="s1">}, refineEleDebounceTime);</span><span class="s3">\n  </span><span class="s1">r.beforeRender(function (willDraw, now) {</span><span class="s3">\n    </span><span class="s1">if (now - self.lastInvalidationTime &lt;= invalidThreshold) {</span><span class="s3">\n      </span><span class="s1">self.skipping = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">self.skipping = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, r.beforeRenderPriorities.lyrTxrSkip);</span><span class="s3">\n  </span><span class="s1">var qSort = function qSort(a, b) {</span><span class="s3">\n    </span><span class="s1">return b.reqs - a.reqs;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">self.layersQueue = new Heap(qSort);</span><span class="s3">\n  </span><span class="s1">self.setupDequeueing();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var LTCp = LayeredTextureCache.prototype;</span><span class="s3">\n</span><span class="s1">var layerIdPool = 0;</span><span class="s3">\n</span><span class="s1">var MAX_INT = Math.pow(2, 53) - 1;</span><span class="s3">\n</span><span class="s1">LTCp.makeLayer = function (bb, lvl) {</span><span class="s3">\n  </span><span class="s1">var scale = Math.pow(2, lvl);</span><span class="s3">\n  </span><span class="s1">var w = Math.ceil(bb.w * scale);</span><span class="s3">\n  </span><span class="s1">var h = Math.ceil(bb.h * scale);</span><span class="s3">\n  </span><span class="s1">var canvas = this.renderer.makeOffscreenCanvas(w, h);</span><span class="s3">\n  </span><span class="s1">var layer = {</span><span class="s3">\n    </span><span class="s1">id: layerIdPool = ++layerIdPool % MAX_INT,</span><span class="s3">\n    </span><span class="s1">bb: bb,</span><span class="s3">\n    </span><span class="s1">level: lvl,</span><span class="s3">\n    </span><span class="s1">width: w,</span><span class="s3">\n    </span><span class="s1">height: h,</span><span class="s3">\n    </span><span class="s1">canvas: canvas,</span><span class="s3">\n    </span><span class="s1">context: canvas.getContext('2d'),</span><span class="s3">\n    </span><span class="s1">eles: [],</span><span class="s3">\n    </span><span class="s1">elesQueue: [],</span><span class="s3">\n    </span><span class="s1">reqs: 0</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);</span><span class="s3">\n\n  </span><span class="s1">var cxt = layer.context;</span><span class="s3">\n  </span><span class="s1">var dx = -layer.bb.x1;</span><span class="s3">\n  </span><span class="s1">var dy = -layer.bb.y1;</span><span class="s3">\n\n  </span><span class="s1">// do the transform on creation to save cycles (it's the same for all eles)</span><span class="s3">\n  </span><span class="s1">cxt.scale(scale, scale);</span><span class="s3">\n  </span><span class="s1">cxt.translate(dx, dy);</span><span class="s3">\n  </span><span class="s1">return layer;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.getLayers = function (eles, pxRatio, lvl) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var r = self.renderer;</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n  </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n  </span><span class="s1">var firstGet = self.firstGet;</span><span class="s3">\n  </span><span class="s1">self.firstGet = false;</span><span class="s3">\n\n  </span><span class="s1">// log('--</span><span class="s3">\\</span><span class="s1">nget layers with %s eles', eles.length);</span><span class="s3">\n  </span><span class="s1">//log eles.map(function(ele){ return ele.id() }) );</span><span class="s3">\n\n  </span><span class="s1">if (lvl == null) {</span><span class="s3">\n    </span><span class="s1">lvl = Math.ceil(log2(zoom * pxRatio));</span><span class="s3">\n    </span><span class="s1">if (lvl &lt; minLvl) {</span><span class="s3">\n      </span><span class="s1">lvl = minLvl;</span><span class="s3">\n    </span><span class="s1">} else if (zoom &gt;= maxZoom || lvl &gt; maxLvl) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">self.validateLayersElesOrdering(lvl, eles);</span><span class="s3">\n  </span><span class="s1">var layersByLvl = self.layersByLevel;</span><span class="s3">\n  </span><span class="s1">var scale = Math.pow(2, lvl);</span><span class="s3">\n  </span><span class="s1">var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];</span><span class="s3">\n  </span><span class="s1">var bb;</span><span class="s3">\n  </span><span class="s1">var lvlComplete = self.levelIsComplete(lvl, eles);</span><span class="s3">\n  </span><span class="s1">var tmpLayers;</span><span class="s3">\n  </span><span class="s1">var checkTempLevels = function checkTempLevels() {</span><span class="s3">\n    </span><span class="s1">var canUseAsTmpLvl = function canUseAsTmpLvl(l) {</span><span class="s3">\n      </span><span class="s1">self.validateLayersElesOrdering(l, eles);</span><span class="s3">\n      </span><span class="s1">if (self.levelIsComplete(l, eles)) {</span><span class="s3">\n        </span><span class="s1">tmpLayers = layersByLvl[l];</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var checkLvls = function checkLvls(dir) {</span><span class="s3">\n      </span><span class="s1">if (tmpLayers) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var l = lvl + dir; minLvl &lt;= l &amp;&amp; l &lt;= maxLvl; l += dir) {</span><span class="s3">\n        </span><span class="s1">if (canUseAsTmpLvl(l)) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">checkLvls(1);</span><span class="s3">\n    </span><span class="s1">checkLvls(-1);</span><span class="s3">\n\n    </span><span class="s1">// remove the invalid layers; they will be replaced as needed later in this function</span><span class="s3">\n    </span><span class="s1">for (var i = layers.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">var layer = layers[i];</span><span class="s3">\n      </span><span class="s1">if (layer.invalid) {</span><span class="s3">\n        </span><span class="s1">removeFromArray(layers, layer);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (!lvlComplete) {</span><span class="s3">\n    </span><span class="s1">// if the current level is incomplete, then use the closest, best quality layerset temporarily</span><span class="s3">\n    </span><span class="s1">// and later queue the current layerset so we can get the proper quality level soon</span><span class="s3">\n\n    </span><span class="s1">checkTempLevels();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// log('level complete, using existing layers</span><span class="s3">\\</span><span class="s1">n--');</span><span class="s3">\n    </span><span class="s1">return layers;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var getBb = function getBb() {</span><span class="s3">\n    </span><span class="s1">if (!bb) {</span><span class="s3">\n      </span><span class="s1">bb = makeBoundingBox();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">updateBoundingBox(bb, eles[i].boundingBox());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return bb;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var makeLayer = function makeLayer(opts) {</span><span class="s3">\n    </span><span class="s1">opts = opts || {};</span><span class="s3">\n    </span><span class="s1">var after = opts.after;</span><span class="s3">\n    </span><span class="s1">getBb();</span><span class="s3">\n    </span><span class="s1">var w = Math.ceil(bb.w * scale);</span><span class="s3">\n    </span><span class="s1">var h = Math.ceil(bb.h * scale);</span><span class="s3">\n    </span><span class="s1">if (w &gt; maxLayerDim || h &gt; maxLayerDim) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var area = w * h;</span><span class="s3">\n    </span><span class="s1">if (area &gt; maxLayerArea) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var layer = self.makeLayer(bb, lvl);</span><span class="s3">\n    </span><span class="s1">if (after != null) {</span><span class="s3">\n      </span><span class="s1">var index = layers.indexOf(after) + 1;</span><span class="s3">\n      </span><span class="s1">layers.splice(index, 0, layer);</span><span class="s3">\n    </span><span class="s1">} else if (opts.insert === undefined || opts.insert) {</span><span class="s3">\n      </span><span class="s1">// no after specified =&gt; first layer made so put at start</span><span class="s3">\n      </span><span class="s1">layers.unshift(layer);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if( tmpLayers ){</span><span class="s3">\n    </span><span class="s1">//self.queueLayer( layer );</span><span class="s3">\n    </span><span class="s1">// }</span><span class="s3">\n\n    </span><span class="s1">return layer;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (self.skipping &amp;&amp; !firstGet) {</span><span class="s3">\n    </span><span class="s1">// log('skip layers');</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// log('do layers');</span><span class="s3">\n\n  </span><span class="s1">var layer = null;</span><span class="s3">\n  </span><span class="s1">var maxElesPerLayer = eles.length / defNumLayers;</span><span class="s3">\n  </span><span class="s1">var allowLazyQueueing = !firstGet;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">var rs = ele._private.rscratch;</span><span class="s3">\n    </span><span class="s1">var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};</span><span class="s3">\n\n    </span><span class="s1">// log('look at ele', ele.id());</span><span class="s3">\n\n    </span><span class="s1">var existingLayer = caches[lvl];</span><span class="s3">\n    </span><span class="s1">if (existingLayer) {</span><span class="s3">\n      </span><span class="s1">// reuse layer for later eles</span><span class="s3">\n      </span><span class="s1">// log('reuse layer for', ele.id());</span><span class="s3">\n      </span><span class="s1">layer = existingLayer;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!layer || layer.eles.length &gt;= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {</span><span class="s3">\n      </span><span class="s1">// log('make new layer for ele %s', ele.id());</span><span class="s3">\n\n      </span><span class="s1">layer = makeLayer({</span><span class="s3">\n        </span><span class="s1">insert: true,</span><span class="s3">\n        </span><span class="s1">after: layer</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// if now layer can be built then we can't use layers at this level</span><span class="s3">\n      </span><span class="s1">if (!layer) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// log('new layer with id %s', layer.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (tmpLayers || allowLazyQueueing) {</span><span class="s3">\n      </span><span class="s1">// log('queue ele %s in layer %s', ele.id(), layer.id);</span><span class="s3">\n      </span><span class="s1">self.queueLayer(layer, ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// log('draw ele %s in layer %s', ele.id(), layer.id);</span><span class="s3">\n      </span><span class="s1">self.drawEleInLayer(layer, ele, lvl, pxRatio);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">layer.eles.push(ele);</span><span class="s3">\n    </span><span class="s1">caches[lvl] = layer;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// log('--');</span><span class="s3">\n\n  </span><span class="s1">if (tmpLayers) {</span><span class="s3">\n    </span><span class="s1">// then we only queued the current layerset and can't draw it yet</span><span class="s3">\n    </span><span class="s1">return tmpLayers;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (allowLazyQueueing) {</span><span class="s3">\n    </span><span class="s1">// log('lazy queue level', lvl);</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return layers;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// a layer may want to use an ele cache of a higher level to avoid blurriness</span><span class="s3">\n</span><span class="s1">// so the layer level might not equal the ele level</span><span class="s3">\n</span><span class="s1">LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {</span><span class="s3">\n  </span><span class="s1">return lvl;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var r = this.renderer;</span><span class="s3">\n  </span><span class="s1">var context = layer.context;</span><span class="s3">\n  </span><span class="s1">var bb = ele.boundingBox();</span><span class="s3">\n  </span><span class="s1">if (bb.w === 0 || bb.h === 0 || !ele.visible()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">r.setImgSmoothing(context, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">r.setImgSmoothing(context, true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.levelIsComplete = function (lvl, eles) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var layers = self.layersByLevel[lvl];</span><span class="s3">\n  </span><span class="s1">if (!layers || layers.length === 0) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var numElesInLayers = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layers.length; i++) {</span><span class="s3">\n    </span><span class="s1">var layer = layers[i];</span><span class="s3">\n\n    </span><span class="s1">// if there are any eles needed to be drawn yet, the level is not complete</span><span class="s3">\n    </span><span class="s1">if (layer.reqs &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the layer is invalid, the level is not complete</span><span class="s3">\n    </span><span class="s1">if (layer.invalid) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">numElesInLayers += layer.eles.length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we should have exactly the number of eles passed in to be complete</span><span class="s3">\n  </span><span class="s1">if (numElesInLayers !== eles.length) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.validateLayersElesOrdering = function (lvl, eles) {</span><span class="s3">\n  </span><span class="s1">var layers = this.layersByLevel[lvl];</span><span class="s3">\n  </span><span class="s1">if (!layers) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if in a layer the eles are not in the same order, then the layer is invalid</span><span class="s3">\n  </span><span class="s1">// (i.e. there is an ele in between the eles in the layer)</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; layers.length; i++) {</span><span class="s3">\n    </span><span class="s1">var layer = layers[i];</span><span class="s3">\n    </span><span class="s1">var offset = -1;</span><span class="s3">\n\n    </span><span class="s1">// find the offset</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; eles.length; j++) {</span><span class="s3">\n      </span><span class="s1">if (layer.eles[0] === eles[j]) {</span><span class="s3">\n        </span><span class="s1">offset = j;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (offset &lt; 0) {</span><span class="s3">\n      </span><span class="s1">// then the layer has nonexistent elements and is invalid</span><span class="s3">\n      </span><span class="s1">this.invalidateLayer(layer);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// the eles in the layer must be in the same continuous order, else the layer is invalid</span><span class="s3">\n\n    </span><span class="s1">var o = offset;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; layer.eles.length; j++) {</span><span class="s3">\n      </span><span class="s1">if (layer.eles[j] !== eles[o + j]) {</span><span class="s3">\n        </span><span class="s1">// log('invalidate based on ordering', layer.id);</span><span class="s3">\n\n        </span><span class="s1">this.invalidateLayer(layer);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.updateElementsInLayers = function (eles, update) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var isEles = element(eles[0]);</span><span class="s3">\n\n  </span><span class="s1">// collect udpated elements (cascaded from the layers) and update each</span><span class="s3">\n  </span><span class="s1">// layer itself along the way</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var req = isEles ? null : eles[i];</span><span class="s3">\n    </span><span class="s1">var ele = isEles ? eles[i] : eles[i].ele;</span><span class="s3">\n    </span><span class="s1">var rs = ele._private.rscratch;</span><span class="s3">\n    </span><span class="s1">var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};</span><span class="s3">\n    </span><span class="s1">for (var l = minLvl; l &lt;= maxLvl; l++) {</span><span class="s3">\n      </span><span class="s1">var layer = caches[l];</span><span class="s3">\n      </span><span class="s1">if (!layer) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// if update is a request from the ele cache, then it affects only</span><span class="s3">\n      </span><span class="s1">// the matching level</span><span class="s3">\n      </span><span class="s1">if (req &amp;&amp; self.getEleLevelForLayerLevel(layer.level) !== req.level) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">update(layer, ele, req);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.haveLayers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var haveLayers = false;</span><span class="s3">\n  </span><span class="s1">for (var l = minLvl; l &lt;= maxLvl; l++) {</span><span class="s3">\n    </span><span class="s1">var layers = self.layersByLevel[l];</span><span class="s3">\n    </span><span class="s1">if (layers &amp;&amp; layers.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">haveLayers = true;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return haveLayers;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.invalidateElements = function (eles) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">if (eles.length === 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">self.lastInvalidationTime = performanceNow();</span><span class="s3">\n\n  </span><span class="s1">// log('update invalidate layer time from eles');</span><span class="s3">\n\n  </span><span class="s1">if (eles.length === 0 || !self.haveLayers()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {</span><span class="s3">\n    </span><span class="s1">self.invalidateLayer(layer);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.invalidateLayer = function (layer) {</span><span class="s3">\n  </span><span class="s1">// log('update invalidate layer time');</span><span class="s3">\n\n  </span><span class="s1">this.lastInvalidationTime = performanceNow();</span><span class="s3">\n  </span><span class="s1">if (layer.invalid) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} // save cycles</span><span class="s3">\n\n  </span><span class="s1">var lvl = layer.level;</span><span class="s3">\n  </span><span class="s1">var eles = layer.eles;</span><span class="s3">\n  </span><span class="s1">var layers = this.layersByLevel[lvl];</span><span class="s3">\n\n  </span><span class="s1">// log('invalidate layer', layer.id );</span><span class="s3">\n\n  </span><span class="s1">removeFromArray(layers, layer);</span><span class="s3">\n  </span><span class="s1">// layer.eles = [];</span><span class="s3">\n\n  </span><span class="s1">layer.elesQueue = [];</span><span class="s3">\n  </span><span class="s1">layer.invalid = true;</span><span class="s3">\n  </span><span class="s1">if (layer.replacement) {</span><span class="s3">\n    </span><span class="s1">layer.replacement.invalid = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var caches = eles[i]._private.rscratch.imgLayerCaches;</span><span class="s3">\n    </span><span class="s1">if (caches) {</span><span class="s3">\n      </span><span class="s1">caches[lvl] = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.refineElementTextures = function (eles) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n\n  </span><span class="s1">// log('refine', eles.length);</span><span class="s3">\n\n  </span><span class="s1">self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {</span><span class="s3">\n    </span><span class="s1">var rLyr = layer.replacement;</span><span class="s3">\n    </span><span class="s1">if (!rLyr) {</span><span class="s3">\n      </span><span class="s1">rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);</span><span class="s3">\n      </span><span class="s1">rLyr.replaces = layer;</span><span class="s3">\n      </span><span class="s1">rLyr.eles = layer.eles;</span><span class="s3">\n\n      </span><span class="s1">// log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!rLyr.reqs) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; rLyr.eles.length; i++) {</span><span class="s3">\n        </span><span class="s1">self.queueLayer(rLyr, rLyr.eles[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// log('queue replacement layer refinement', rLyr.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.enqueueElementRefinement = function (ele) {</span><span class="s3">\n  </span><span class="s1">this.eleTxrDeqs.merge(ele);</span><span class="s3">\n  </span><span class="s1">this.scheduleElementRefinement();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.queueLayer = function (layer, ele) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var q = self.layersQueue;</span><span class="s3">\n  </span><span class="s1">var elesQ = layer.elesQueue;</span><span class="s3">\n  </span><span class="s1">var hasId = elesQ.hasId = elesQ.hasId || {};</span><span class="s3">\n\n  </span><span class="s1">// if a layer is going to be replaced, queuing is a waste of time</span><span class="s3">\n  </span><span class="s1">if (layer.replacement) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ele) {</span><span class="s3">\n    </span><span class="s1">if (hasId[ele.id()]) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">elesQ.push(ele);</span><span class="s3">\n    </span><span class="s1">hasId[ele.id()] = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (layer.reqs) {</span><span class="s3">\n    </span><span class="s1">layer.reqs++;</span><span class="s3">\n    </span><span class="s1">q.updateItem(layer);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">layer.reqs = 1;</span><span class="s3">\n    </span><span class="s1">q.push(layer);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.dequeue = function (pxRatio) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var q = self.layersQueue;</span><span class="s3">\n  </span><span class="s1">var deqd = [];</span><span class="s3">\n  </span><span class="s1">var eleDeqs = 0;</span><span class="s3">\n  </span><span class="s1">while (eleDeqs &lt; maxDeqSize) {</span><span class="s3">\n    </span><span class="s1">if (q.size() === 0) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var layer = q.peek();</span><span class="s3">\n\n    </span><span class="s1">// if a layer has been or will be replaced, then don't waste time with it</span><span class="s3">\n    </span><span class="s1">if (layer.replacement) {</span><span class="s3">\n      </span><span class="s1">// log('layer %s in queue skipped b/c it already has a replacement', layer.id);</span><span class="s3">\n      </span><span class="s1">q.pop();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if this is a replacement layer that has been superceded, then forget it</span><span class="s3">\n    </span><span class="s1">if (layer.replaces &amp;&amp; layer !== layer.replaces.replacement) {</span><span class="s3">\n      </span><span class="s1">// log('layer is no longer the most uptodate replacement; dequeued', layer.id)</span><span class="s3">\n      </span><span class="s1">q.pop();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (layer.invalid) {</span><span class="s3">\n      </span><span class="s1">// log('replacement layer %s is invalid; dequeued', layer.id);</span><span class="s3">\n      </span><span class="s1">q.pop();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var ele = layer.elesQueue.shift();</span><span class="s3">\n    </span><span class="s1">if (ele) {</span><span class="s3">\n      </span><span class="s1">// log('dequeue layer %s', layer.id);</span><span class="s3">\n\n      </span><span class="s1">self.drawEleInLayer(layer, ele, layer.level, pxRatio);</span><span class="s3">\n      </span><span class="s1">eleDeqs++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (deqd.length === 0) {</span><span class="s3">\n      </span><span class="s1">// we need only one entry in deqd to queue redrawing etc</span><span class="s3">\n      </span><span class="s1">deqd.push(true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the layer has all its eles done, then remove from the queue</span><span class="s3">\n    </span><span class="s1">if (layer.elesQueue.length === 0) {</span><span class="s3">\n      </span><span class="s1">q.pop();</span><span class="s3">\n      </span><span class="s1">layer.reqs = 0;</span><span class="s3">\n\n      </span><span class="s1">// log('dequeue of layer %s complete', layer.id);</span><span class="s3">\n\n      </span><span class="s1">// when a replacement layer is dequeued, it replaces the old layer in the level</span><span class="s3">\n      </span><span class="s1">if (layer.replaces) {</span><span class="s3">\n        </span><span class="s1">self.applyLayerReplacement(layer);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">self.requestRedraw();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return deqd;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.applyLayerReplacement = function (layer) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var layersInLevel = self.layersByLevel[layer.level];</span><span class="s3">\n  </span><span class="s1">var replaced = layer.replaces;</span><span class="s3">\n  </span><span class="s1">var index = layersInLevel.indexOf(replaced);</span><span class="s3">\n\n  </span><span class="s1">// if the replaced layer is not in the active list for the level, then replacing</span><span class="s3">\n  </span><span class="s1">// refs would be a mistake (i.e. overwriting the true active layer)</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0 || replaced.invalid) {</span><span class="s3">\n    </span><span class="s1">// log('replacement layer would have no effect', layer.id);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">layersInLevel[index] = layer; // replace level ref</span><span class="s3">\n\n  </span><span class="s1">// replace refs in eles</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; layer.eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var _p = layer.eles[i]._private;</span><span class="s3">\n    </span><span class="s1">var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};</span><span class="s3">\n    </span><span class="s1">if (cache) {</span><span class="s3">\n      </span><span class="s1">cache[layer.level] = layer;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// log('apply replacement layer %s over %s', layer.id, replaced.id);</span><span class="s3">\n\n  </span><span class="s1">self.requestRedraw();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">LTCp.requestRedraw = debounce(function () {</span><span class="s3">\n  </span><span class="s1">var r = this.renderer;</span><span class="s3">\n  </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n  </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n  </span><span class="s1">r.redraw();</span><span class="s3">\n</span><span class="s1">}, 100);</span><span class="s3">\n</span><span class="s1">LTCp.setupDequeueing = defs.setupDequeueing({</span><span class="s3">\n  </span><span class="s1">deqRedrawThreshold: deqRedrawThreshold,</span><span class="s3">\n  </span><span class="s1">deqCost: deqCost,</span><span class="s3">\n  </span><span class="s1">deqAvgCost: deqAvgCost,</span><span class="s3">\n  </span><span class="s1">deqNoDrawCost: deqNoDrawCost,</span><span class="s3">\n  </span><span class="s1">deqFastCost: deqFastCost,</span><span class="s3">\n  </span><span class="s1">deq: function deq(self, pxRatio) {</span><span class="s3">\n    </span><span class="s1">return self.dequeue(pxRatio);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">onDeqd: noop$1,</span><span class="s3">\n  </span><span class="s1">shouldRedraw: trueify,</span><span class="s3">\n  </span><span class="s1">priority: function priority(self) {</span><span class="s3">\n    </span><span class="s1">return self.renderer.beforeRenderPriorities.lyrTxrDeq;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var CRp$b = {};</span><span class="s3">\n</span><span class="s1">var impl;</span><span class="s3">\n</span><span class="s1">function polygon(context, points) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; points.length; i++) {</span><span class="s3">\n    </span><span class="s1">var pt = points[i];</span><span class="s3">\n    </span><span class="s1">context.lineTo(pt.x, pt.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function triangleBackcurve(context, points, controlPoint) {</span><span class="s3">\n  </span><span class="s1">var firstPt;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; points.length; i++) {</span><span class="s3">\n    </span><span class="s1">var pt = points[i];</span><span class="s3">\n    </span><span class="s1">if (i === 0) {</span><span class="s3">\n      </span><span class="s1">firstPt = pt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">context.lineTo(pt.x, pt.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function triangleTee(context, trianglePoints, teePoints) {</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var triPts = trianglePoints;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; triPts.length; i++) {</span><span class="s3">\n    </span><span class="s1">var pt = triPts[i];</span><span class="s3">\n    </span><span class="s1">context.lineTo(pt.x, pt.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var teePts = teePoints;</span><span class="s3">\n  </span><span class="s1">var firstTeePt = teePoints[0];</span><span class="s3">\n  </span><span class="s1">context.moveTo(firstTeePt.x, firstTeePt.y);</span><span class="s3">\n  </span><span class="s1">for (var i = 1; i &lt; teePts.length; i++) {</span><span class="s3">\n    </span><span class="s1">var pt = teePts[i];</span><span class="s3">\n    </span><span class="s1">context.lineTo(pt.x, pt.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (context.closePath) {</span><span class="s3">\n    </span><span class="s1">context.closePath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function circleTriangle(context, trianglePoints, rx, ry, r) {</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.arc(rx, ry, r, 0, Math.PI * 2, false);</span><span class="s3">\n  </span><span class="s1">var triPts = trianglePoints;</span><span class="s3">\n  </span><span class="s1">var firstTrPt = triPts[0];</span><span class="s3">\n  </span><span class="s1">context.moveTo(firstTrPt.x, firstTrPt.y);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; triPts.length; i++) {</span><span class="s3">\n    </span><span class="s1">var pt = triPts[i];</span><span class="s3">\n    </span><span class="s1">context.lineTo(pt.x, pt.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (context.closePath) {</span><span class="s3">\n    </span><span class="s1">context.closePath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function circle(context, rx, ry, r) {</span><span class="s3">\n  </span><span class="s1">context.arc(rx, ry, r, 0, Math.PI * 2, false);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">CRp$b.arrowShapeImpl = function (name) {</span><span class="s3">\n  </span><span class="s1">return (impl || (impl = {</span><span class="s3">\n    </span><span class="s1">'polygon': polygon,</span><span class="s3">\n    </span><span class="s1">'triangle-backcurve': triangleBackcurve,</span><span class="s3">\n    </span><span class="s1">'triangle-tee': triangleTee,</span><span class="s3">\n    </span><span class="s1">'circle-triangle': circleTriangle,</span><span class="s3">\n    </span><span class="s1">'triangle-cross': triangleTee,</span><span class="s3">\n    </span><span class="s1">'circle': circle</span><span class="s3">\n  </span><span class="s1">}))[name];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CRp$a = {};</span><span class="s3">\n</span><span class="s1">CRp$a.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n    </span><span class="s1">r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawElementOverlay = function (context, ele) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n    </span><span class="s1">r.drawNodeOverlay(context, ele);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r.drawEdgeOverlay(context, ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawElementUnderlay = function (context, ele) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n    </span><span class="s1">r.drawNodeUnderlay(context, ele);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r.drawEdgeUnderlay(context, ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var bb = eleTxrCache.getBoundingBox(ele);</span><span class="s3">\n  </span><span class="s1">if (bb.w === 0 || bb.h === 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} // ignore zero size case</span><span class="s3">\n\n  </span><span class="s1">var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);</span><span class="s3">\n  </span><span class="s1">if (eleCache != null) {</span><span class="s3">\n    </span><span class="s1">var opacity = getOpacity(r, ele);</span><span class="s3">\n    </span><span class="s1">if (opacity === 0) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var theta = getRotation(r, ele);</span><span class="s3">\n    </span><span class="s1">var x1 = bb.x1,</span><span class="s3">\n      </span><span class="s1">y1 = bb.y1,</span><span class="s3">\n      </span><span class="s1">w = bb.w,</span><span class="s3">\n      </span><span class="s1">h = bb.h;</span><span class="s3">\n    </span><span class="s1">var x, y, sx, sy, smooth;</span><span class="s3">\n    </span><span class="s1">if (theta !== 0) {</span><span class="s3">\n      </span><span class="s1">var rotPt = eleTxrCache.getRotationPoint(ele);</span><span class="s3">\n      </span><span class="s1">sx = rotPt.x;</span><span class="s3">\n      </span><span class="s1">sy = rotPt.y;</span><span class="s3">\n      </span><span class="s1">context.translate(sx, sy);</span><span class="s3">\n      </span><span class="s1">context.rotate(theta);</span><span class="s3">\n      </span><span class="s1">smooth = r.getImgSmoothing(context);</span><span class="s3">\n      </span><span class="s1">if (!smooth) {</span><span class="s3">\n        </span><span class="s1">r.setImgSmoothing(context, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var off = eleTxrCache.getRotationOffset(ele);</span><span class="s3">\n      </span><span class="s1">x = off.x;</span><span class="s3">\n      </span><span class="s1">y = off.y;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">x = x1;</span><span class="s3">\n      </span><span class="s1">y = y1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var oldGlobalAlpha;</span><span class="s3">\n    </span><span class="s1">if (opacity !== 1) {</span><span class="s3">\n      </span><span class="s1">oldGlobalAlpha = context.globalAlpha;</span><span class="s3">\n      </span><span class="s1">context.globalAlpha = oldGlobalAlpha * opacity;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);</span><span class="s3">\n    </span><span class="s1">if (opacity !== 1) {</span><span class="s3">\n      </span><span class="s1">context.globalAlpha = oldGlobalAlpha;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (theta !== 0) {</span><span class="s3">\n      </span><span class="s1">context.rotate(-theta);</span><span class="s3">\n      </span><span class="s1">context.translate(-sx, -sy);</span><span class="s3">\n      </span><span class="s1">if (!smooth) {</span><span class="s3">\n        </span><span class="s1">r.setImgSmoothing(context, false);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">eleTxrCache.drawElement(context, ele); // direct draw fallback</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getZeroRotation = function getZeroRotation() {</span><span class="s3">\n  </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getLabelRotation = function getLabelRotation(r, ele) {</span><span class="s3">\n  </span><span class="s1">return r.getTextAngle(ele, null);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {</span><span class="s3">\n  </span><span class="s1">return r.getTextAngle(ele, 'source');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {</span><span class="s3">\n  </span><span class="s1">return r.getTextAngle(ele, 'target');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getOpacity = function getOpacity(r, ele) {</span><span class="s3">\n  </span><span class="s1">return ele.effectiveOpacity();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getTextOpacity = function getTextOpacity(e, ele) {</span><span class="s3">\n  </span><span class="s1">return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var _r$data = r.data,</span><span class="s3">\n    </span><span class="s1">eleTxrCache = _r$data.eleTxrCache,</span><span class="s3">\n    </span><span class="s1">lblTxrCache = _r$data.lblTxrCache,</span><span class="s3">\n    </span><span class="s1">slbTxrCache = _r$data.slbTxrCache,</span><span class="s3">\n    </span><span class="s1">tlbTxrCache = _r$data.tlbTxrCache;</span><span class="s3">\n  </span><span class="s1">var bb = ele.boundingBox();</span><span class="s3">\n  </span><span class="s1">var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;</span><span class="s3">\n  </span><span class="s1">if (bb.w === 0 || bb.h === 0 || !ele.visible()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!extent || boundingBoxesIntersect(bb, extent)) {</span><span class="s3">\n    </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n    </span><span class="s1">var badLine = ele.element()._private.rscratch.badLine;</span><span class="s3">\n    </span><span class="s1">r.drawElementUnderlay(context, ele);</span><span class="s3">\n    </span><span class="s1">r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);</span><span class="s3">\n    </span><span class="s1">if (!isEdge || !badLine) {</span><span class="s3">\n      </span><span class="s1">r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isEdge &amp;&amp; !badLine) {</span><span class="s3">\n      </span><span class="s1">r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);</span><span class="s3">\n      </span><span class="s1">r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.drawElementOverlay(context, ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawElements = function (context, eles) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">r.drawElement(context, ele);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawCachedElements = function (context, eles, pxRatio, extent) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">r.drawCachedElement(context, ele, pxRatio, extent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawCachedNodes = function (context, eles, pxRatio, extent) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; eles.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ele = eles[i];</span><span class="s3">\n    </span><span class="s1">if (!ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.drawCachedElement(context, ele, pxRatio, extent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$a.drawLayeredElements = function (context, eles, pxRatio, extent) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);</span><span class="s3">\n  </span><span class="s1">if (layers) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; layers.length; i++) {</span><span class="s3">\n      </span><span class="s1">var layer = layers[i];</span><span class="s3">\n      </span><span class="s1">var bb = layer.bb;</span><span class="s3">\n      </span><span class="s1">if (bb.w === 0 || bb.h === 0) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// fall back on plain caching if no layers</span><span class="s3">\n    </span><span class="s1">r.drawCachedElements(context, eles, pxRatio, extent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CRp$9 = {};</span><span class="s3">\n</span><span class="s1">CRp$9.drawEdge = function (context, edge, shiftToOriginWithBb) {</span><span class="s3">\n  </span><span class="s1">var drawLabel = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : true;</span><span class="s3">\n  </span><span class="s1">var shouldDrawOverlay = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true;</span><span class="s3">\n  </span><span class="s1">var shouldDrawOpacity = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : true;</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">if (shouldDrawOpacity &amp;&amp; !edge.visible()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if bezier ctrl pts can not be calculated, then die</span><span class="s3">\n  </span><span class="s1">if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {</span><span class="s3">\n    </span><span class="s1">// isNaN in case edge is impossible and browser bugs (e.g. safari)</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var bb;</span><span class="s3">\n  </span><span class="s1">if (shiftToOriginWithBb) {</span><span class="s3">\n    </span><span class="s1">bb = shiftToOriginWithBb;</span><span class="s3">\n    </span><span class="s1">context.translate(-bb.x1, -bb.y1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;</span><span class="s3">\n  </span><span class="s1">var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;</span><span class="s3">\n  </span><span class="s1">var curveStyle = edge.pstyle('curve-style').value;</span><span class="s3">\n  </span><span class="s1">var lineStyle = edge.pstyle('line-style').value;</span><span class="s3">\n  </span><span class="s1">var edgeWidth = edge.pstyle('width').pfValue;</span><span class="s3">\n  </span><span class="s1">var lineCap = edge.pstyle('line-cap').value;</span><span class="s3">\n  </span><span class="s1">var lineOutlineWidth = edge.pstyle('line-outline-width').value;</span><span class="s3">\n  </span><span class="s1">var lineOutlineColor = edge.pstyle('line-outline-color').value;</span><span class="s3">\n  </span><span class="s1">var effectiveLineOpacity = opacity * lineOpacity;</span><span class="s3">\n  </span><span class="s1">// separate arrow opacity would require arrow-opacity property</span><span class="s3">\n  </span><span class="s1">var effectiveArrowOpacity = opacity * lineOpacity;</span><span class="s3">\n  </span><span class="s1">var drawLine = function drawLine() {</span><span class="s3">\n    </span><span class="s1">var strokeOpacity = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;</span><span class="s3">\n    </span><span class="s1">if (curveStyle === 'straight-triangle') {</span><span class="s3">\n      </span><span class="s1">r.eleStrokeStyle(context, edge, strokeOpacity);</span><span class="s3">\n      </span><span class="s1">r.drawEdgeTrianglePath(edge, context, rs.allpts);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">context.lineWidth = edgeWidth;</span><span class="s3">\n      </span><span class="s1">context.lineCap = lineCap;</span><span class="s3">\n      </span><span class="s1">r.eleStrokeStyle(context, edge, strokeOpacity);</span><span class="s3">\n      </span><span class="s1">r.drawEdgePath(edge, context, rs.allpts, lineStyle);</span><span class="s3">\n      </span><span class="s1">context.lineCap = 'butt'; // reset for other drawing functions</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawLineOutline = function drawLineOutline() {</span><span class="s3">\n    </span><span class="s1">var strokeOpacity = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;</span><span class="s3">\n    </span><span class="s1">context.lineWidth = edgeWidth + lineOutlineWidth;</span><span class="s3">\n    </span><span class="s1">context.lineCap = lineCap;</span><span class="s3">\n    </span><span class="s1">if (lineOutlineWidth &gt; 0) {</span><span class="s3">\n      </span><span class="s1">r.colorStrokeStyle(context, lineOutlineColor[0], lineOutlineColor[1], lineOutlineColor[2], strokeOpacity);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// do not draw any lineOutline</span><span class="s3">\n      </span><span class="s1">context.lineCap = 'butt'; // reset for other drawing functions</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (curveStyle === 'straight-triangle') {</span><span class="s3">\n      </span><span class="s1">r.drawEdgeTrianglePath(edge, context, rs.allpts);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">r.drawEdgePath(edge, context, rs.allpts, lineStyle);</span><span class="s3">\n      </span><span class="s1">context.lineCap = 'butt'; // reset for other drawing functions</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawOverlay = function drawOverlay() {</span><span class="s3">\n    </span><span class="s1">if (!shouldDrawOverlay) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.drawEdgeOverlay(context, edge);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawUnderlay = function drawUnderlay() {</span><span class="s3">\n    </span><span class="s1">if (!shouldDrawOverlay) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.drawEdgeUnderlay(context, edge);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawArrows = function drawArrows() {</span><span class="s3">\n    </span><span class="s1">var arrowOpacity = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;</span><span class="s3">\n    </span><span class="s1">r.drawArrowheads(context, edge, arrowOpacity);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawText = function drawText() {</span><span class="s3">\n    </span><span class="s1">r.drawElementText(context, edge, null, drawLabel);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">context.lineJoin = 'round';</span><span class="s3">\n  </span><span class="s1">var ghost = edge.pstyle('ghost').value === 'yes';</span><span class="s3">\n  </span><span class="s1">if (ghost) {</span><span class="s3">\n    </span><span class="s1">var gx = edge.pstyle('ghost-offset-x').pfValue;</span><span class="s3">\n    </span><span class="s1">var gy = edge.pstyle('ghost-offset-y').pfValue;</span><span class="s3">\n    </span><span class="s1">var ghostOpacity = edge.pstyle('ghost-opacity').value;</span><span class="s3">\n    </span><span class="s1">var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;</span><span class="s3">\n    </span><span class="s1">context.translate(gx, gy);</span><span class="s3">\n    </span><span class="s1">drawLine(effectiveGhostOpacity);</span><span class="s3">\n    </span><span class="s1">drawArrows(effectiveGhostOpacity);</span><span class="s3">\n    </span><span class="s1">context.translate(-gx, -gy);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">drawLineOutline();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">drawUnderlay();</span><span class="s3">\n  </span><span class="s1">drawLine();</span><span class="s3">\n  </span><span class="s1">drawArrows();</span><span class="s3">\n  </span><span class="s1">drawOverlay();</span><span class="s3">\n  </span><span class="s1">drawText();</span><span class="s3">\n  </span><span class="s1">if (shiftToOriginWithBb) {</span><span class="s3">\n    </span><span class="s1">context.translate(bb.x1, bb.y1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {</span><span class="s3">\n  </span><span class="s1">if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Invalid state');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function (context, edge) {</span><span class="s3">\n    </span><span class="s1">if (!edge.visible()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var opacity = edge.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-opacity</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n    </span><span class="s1">if (opacity === 0) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var r = this;</span><span class="s3">\n    </span><span class="s1">var usePaths = r.usePaths();</span><span class="s3">\n    </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n    </span><span class="s1">var padding = edge.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-padding</span><span class="s3">\&quot;</span><span class="s1">)).pfValue;</span><span class="s3">\n    </span><span class="s1">var width = 2 * padding;</span><span class="s3">\n    </span><span class="s1">var color = edge.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-color</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n    </span><span class="s1">context.lineWidth = width;</span><span class="s3">\n    </span><span class="s1">if (rs.edgeType === 'self' &amp;&amp; !usePaths) {</span><span class="s3">\n      </span><span class="s1">context.lineCap = 'butt';</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">context.lineCap = 'round';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);</span><span class="s3">\n    </span><span class="s1">r.drawEdgePath(edge, context, rs.allpts, 'solid');</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$9.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');</span><span class="s3">\n</span><span class="s1">CRp$9.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');</span><span class="s3">\n</span><span class="s1">CRp$9.drawEdgePath = function (edge, context, pts, type) {</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var canvasCxt = context;</span><span class="s3">\n  </span><span class="s1">var path;</span><span class="s3">\n  </span><span class="s1">var pathCacheHit = false;</span><span class="s3">\n  </span><span class="s1">var usePaths = this.usePaths();</span><span class="s3">\n  </span><span class="s1">var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;</span><span class="s3">\n  </span><span class="s1">var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">var pathCacheKey = pts.join('$');</span><span class="s3">\n    </span><span class="s1">var keyMatches = rs.pathCacheKey &amp;&amp; rs.pathCacheKey === pathCacheKey;</span><span class="s3">\n    </span><span class="s1">if (keyMatches) {</span><span class="s3">\n      </span><span class="s1">path = context = rs.pathCache;</span><span class="s3">\n      </span><span class="s1">pathCacheHit = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path = context = new Path2D();</span><span class="s3">\n      </span><span class="s1">rs.pathCacheKey = pathCacheKey;</span><span class="s3">\n      </span><span class="s1">rs.pathCache = path;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (canvasCxt.setLineDash) {</span><span class="s3">\n    </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case 'dotted':</span><span class="s3">\n        </span><span class="s1">canvasCxt.setLineDash([1, 1]);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 'dashed':</span><span class="s3">\n        </span><span class="s1">canvasCxt.setLineDash(lineDashPattern);</span><span class="s3">\n        </span><span class="s1">canvasCxt.lineDashOffset = lineDashOffset;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 'solid':</span><span class="s3">\n        </span><span class="s1">canvasCxt.setLineDash([]);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!pathCacheHit &amp;&amp; !rs.badLine) {</span><span class="s3">\n    </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n      </span><span class="s1">context.beginPath();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">context.moveTo(pts[0], pts[1]);</span><span class="s3">\n    </span><span class="s1">switch (rs.edgeType) {</span><span class="s3">\n      </span><span class="s1">case 'bezier':</span><span class="s3">\n      </span><span class="s1">case 'self':</span><span class="s3">\n      </span><span class="s1">case 'compound':</span><span class="s3">\n      </span><span class="s1">case 'multibezier':</span><span class="s3">\n        </span><span class="s1">for (var i = 2; i + 3 &lt; pts.length; i += 4) {</span><span class="s3">\n          </span><span class="s1">context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 'straight':</span><span class="s3">\n      </span><span class="s1">case 'haystack':</span><span class="s3">\n        </span><span class="s1">for (var _i = 2; _i + 1 &lt; pts.length; _i += 2) {</span><span class="s3">\n          </span><span class="s1">context.lineTo(pts[_i], pts[_i + 1]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 'segments':</span><span class="s3">\n        </span><span class="s1">if (rs.isRound) {</span><span class="s3">\n          </span><span class="s1">var _iterator = _createForOfIteratorHelper(rs.roundCorners),</span><span class="s3">\n            </span><span class="s1">_step;</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">for (_iterator.s(); !(_step = _iterator.n()).done;) {</span><span class="s3">\n              </span><span class="s1">var corner = _step.value;</span><span class="s3">\n              </span><span class="s1">drawPreparedRoundCorner(context, corner);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">_iterator.e(err);</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">_iterator.f();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">context.lineTo(pts[pts.length - 2], pts[pts.length - 1]);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">for (var _i2 = 2; _i2 + 1 &lt; pts.length; _i2 += 2) {</span><span class="s3">\n            </span><span class="s1">context.lineTo(pts[_i2], pts[_i2 + 1]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context = canvasCxt;</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">context.stroke(path);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">context.stroke();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// reset any line dashes</span><span class="s3">\n  </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n    </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n    </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$9.drawEdgeTrianglePath = function (edge, context, pts) {</span><span class="s3">\n  </span><span class="s1">// use line stroke style for triangle fill style</span><span class="s3">\n  </span><span class="s1">context.fillStyle = context.strokeStyle;</span><span class="s3">\n  </span><span class="s1">var edgeWidth = edge.pstyle('width').pfValue;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i + 1 &lt; pts.length; i += 2) {</span><span class="s3">\n    </span><span class="s1">var vector = [pts[i + 2] - pts[i], pts[i + 3] - pts[i + 1]];</span><span class="s3">\n    </span><span class="s1">var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);</span><span class="s3">\n    </span><span class="s1">var normal = [vector[1] / length, -vector[0] / length];</span><span class="s3">\n    </span><span class="s1">var triangleHead = [normal[0] * edgeWidth / 2, normal[1] * edgeWidth / 2];</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n    </span><span class="s1">context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);</span><span class="s3">\n    </span><span class="s1">context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);</span><span class="s3">\n    </span><span class="s1">context.lineTo(pts[i + 2], pts[i + 3]);</span><span class="s3">\n    </span><span class="s1">context.closePath();</span><span class="s3">\n    </span><span class="s1">context.fill();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$9.drawArrowheads = function (context, edge, opacity) {</span><span class="s3">\n  </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var isHaystack = rs.edgeType === 'haystack';</span><span class="s3">\n  </span><span class="s1">if (!isHaystack) {</span><span class="s3">\n    </span><span class="s1">this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);</span><span class="s3">\n  </span><span class="s1">this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);</span><span class="s3">\n  </span><span class="s1">if (!isHaystack) {</span><span class="s3">\n    </span><span class="s1">this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$9.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {</span><span class="s3">\n  </span><span class="s1">if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;</span><span class="s3">\n  </span><span class="s1">if (arrowShape === 'none') {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';</span><span class="s3">\n  </span><span class="s1">var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;</span><span class="s3">\n  </span><span class="s1">var edgeWidth = edge.pstyle('width').pfValue;</span><span class="s3">\n  </span><span class="s1">var pArrowWidth = edge.pstyle(prefix + '-arrow-width');</span><span class="s3">\n  </span><span class="s1">var arrowWidth = pArrowWidth.value === 'match-line' ? edgeWidth : pArrowWidth.pfValue;</span><span class="s3">\n  </span><span class="s1">if (pArrowWidth.units === '%') arrowWidth *= edgeWidth;</span><span class="s3">\n  </span><span class="s1">var edgeOpacity = edge.pstyle('opacity').value;</span><span class="s3">\n  </span><span class="s1">if (opacity === undefined) {</span><span class="s3">\n    </span><span class="s1">opacity = edgeOpacity;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var gco = context.globalCompositeOperation;</span><span class="s3">\n  </span><span class="s1">if (opacity !== 1 || arrowFill === 'hollow') {</span><span class="s3">\n    </span><span class="s1">// then extra clear is needed</span><span class="s3">\n    </span><span class="s1">context.globalCompositeOperation = 'destination-out';</span><span class="s3">\n    </span><span class="s1">self.colorFillStyle(context, 255, 255, 255, 1);</span><span class="s3">\n    </span><span class="s1">self.colorStrokeStyle(context, 255, 255, 255, 1);</span><span class="s3">\n    </span><span class="s1">self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);</span><span class="s3">\n    </span><span class="s1">context.globalCompositeOperation = gco;</span><span class="s3">\n  </span><span class="s1">} // otherwise, the opaque arrow clears it for free :)</span><span class="s3">\n\n  </span><span class="s1">var color = edge.pstyle(prefix + '-arrow-color').value;</span><span class="s3">\n  </span><span class="s1">self.colorFillStyle(context, color[0], color[1], color[2], opacity);</span><span class="s3">\n  </span><span class="s1">self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);</span><span class="s3">\n  </span><span class="s1">self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$9.drawArrowShape = function (edge, context, fill, edgeWidth, shape, shapeWidth, x, y, angle) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var usePaths = this.usePaths() &amp;&amp; shape !== 'triangle-cross';</span><span class="s3">\n  </span><span class="s1">var pathCacheHit = false;</span><span class="s3">\n  </span><span class="s1">var path;</span><span class="s3">\n  </span><span class="s1">var canvasContext = context;</span><span class="s3">\n  </span><span class="s1">var translation = {</span><span class="s3">\n    </span><span class="s1">x: x,</span><span class="s3">\n    </span><span class="s1">y: y</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var scale = edge.pstyle('arrow-scale').value;</span><span class="s3">\n  </span><span class="s1">var size = this.getArrowWidth(edgeWidth, scale);</span><span class="s3">\n  </span><span class="s1">var shapeImpl = r.arrowShapes[shape];</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">var cache = r.arrowPathCache = r.arrowPathCache || [];</span><span class="s3">\n    </span><span class="s1">var key = hashString(shape);</span><span class="s3">\n    </span><span class="s1">var cachedPath = cache[key];</span><span class="s3">\n    </span><span class="s1">if (cachedPath != null) {</span><span class="s3">\n      </span><span class="s1">path = context = cachedPath;</span><span class="s3">\n      </span><span class="s1">pathCacheHit = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path = context = new Path2D();</span><span class="s3">\n      </span><span class="s1">cache[key] = path;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!pathCacheHit) {</span><span class="s3">\n    </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n      </span><span class="s1">context.beginPath();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (usePaths) {</span><span class="s3">\n      </span><span class="s1">// store in the path cache with values easily manipulated later</span><span class="s3">\n      </span><span class="s1">shapeImpl.draw(context, 1, 0, {</span><span class="s3">\n        </span><span class="s1">x: 0,</span><span class="s3">\n        </span><span class="s1">y: 0</span><span class="s3">\n      </span><span class="s1">}, 1);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">shapeImpl.draw(context, size, angle, translation, edgeWidth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (context.closePath) {</span><span class="s3">\n      </span><span class="s1">context.closePath();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context = canvasContext;</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">// set transform to arrow position/orientation</span><span class="s3">\n    </span><span class="s1">context.translate(x, y);</span><span class="s3">\n    </span><span class="s1">context.rotate(angle);</span><span class="s3">\n    </span><span class="s1">context.scale(size, size);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (fill === 'filled' || fill === 'both') {</span><span class="s3">\n    </span><span class="s1">if (usePaths) {</span><span class="s3">\n      </span><span class="s1">context.fill(path);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">context.fill();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (fill === 'hollow' || fill === 'both') {</span><span class="s3">\n    </span><span class="s1">context.lineWidth = shapeWidth / (usePaths ? size : 1);</span><span class="s3">\n    </span><span class="s1">context.lineJoin = 'miter';</span><span class="s3">\n    </span><span class="s1">if (usePaths) {</span><span class="s3">\n      </span><span class="s1">context.stroke(path);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">context.stroke();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">// reset transform by applying inverse</span><span class="s3">\n    </span><span class="s1">context.scale(1 / size, 1 / size);</span><span class="s3">\n    </span><span class="s1">context.rotate(-angle);</span><span class="s3">\n    </span><span class="s1">context.translate(-x, -y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CRp$8 = {};</span><span class="s3">\n</span><span class="s1">CRp$8.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {</span><span class="s3">\n  </span><span class="s1">// detect problematic cases for old browsers with bad images (cheaper than try-catch)</span><span class="s3">\n  </span><span class="s1">if (iw &lt;= 0 || ih &lt;= 0 || w &lt;= 0 || h &lt;= 0) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">context.drawImage(img, ix, iy, iw, ih, x, y, w, h);</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">warn(e);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$8.drawInscribedImage = function (context, img, node, index, nodeOpacity) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var pos = node.position();</span><span class="s3">\n  </span><span class="s1">var nodeX = pos.x;</span><span class="s3">\n  </span><span class="s1">var nodeY = pos.y;</span><span class="s3">\n  </span><span class="s1">var styleObj = node.cy().style();</span><span class="s3">\n  </span><span class="s1">var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);</span><span class="s3">\n  </span><span class="s1">var fit = getIndexedStyle(node, 'background-fit', 'value', index);</span><span class="s3">\n  </span><span class="s1">var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);</span><span class="s3">\n  </span><span class="s1">var nodeW = node.width();</span><span class="s3">\n  </span><span class="s1">var nodeH = node.height();</span><span class="s3">\n  </span><span class="s1">var paddingX2 = node.padding() * 2;</span><span class="s3">\n  </span><span class="s1">var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);</span><span class="s3">\n  </span><span class="s1">var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);</span><span class="s3">\n  </span><span class="s1">var rs = node._private.rscratch;</span><span class="s3">\n  </span><span class="s1">var clip = getIndexedStyle(node, 'background-clip', 'value', index);</span><span class="s3">\n  </span><span class="s1">var shouldClip = clip === 'node';</span><span class="s3">\n  </span><span class="s1">var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;</span><span class="s3">\n  </span><span class="s1">var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);</span><span class="s3">\n  </span><span class="s1">var cornerRadius = node.pstyle('corner-radius').value;</span><span class="s3">\n  </span><span class="s1">if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;</span><span class="s3">\n  </span><span class="s1">var imgW = img.width || img.cachedW;</span><span class="s3">\n  </span><span class="s1">var imgH = img.height || img.cachedH;</span><span class="s3">\n\n  </span><span class="s1">// workaround for broken browsers like ie</span><span class="s3">\n  </span><span class="s1">if (null == imgW || null == imgH) {</span><span class="s3">\n    </span><span class="s1">document.body.appendChild(img); // eslint-disable-line no-undef</span><span class="s3">\n\n    </span><span class="s1">imgW = img.cachedW = img.width || img.offsetWidth;</span><span class="s3">\n    </span><span class="s1">imgH = img.cachedH = img.height || img.offsetHeight;</span><span class="s3">\n    </span><span class="s1">document.body.removeChild(img); // eslint-disable-line no-undef</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var w = imgW;</span><span class="s3">\n  </span><span class="s1">var h = imgH;</span><span class="s3">\n  </span><span class="s1">if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {</span><span class="s3">\n    </span><span class="s1">if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {</span><span class="s3">\n      </span><span class="s1">w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">w = getIndexedStyle(node, 'background-width', 'pfValue', index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {</span><span class="s3">\n    </span><span class="s1">if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {</span><span class="s3">\n      </span><span class="s1">h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">h = getIndexedStyle(node, 'background-height', 'pfValue', index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (w === 0 || h === 0) {</span><span class="s3">\n    </span><span class="s1">return; // no point in drawing empty image (and chrome is broken in this case)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (fit === 'contain') {</span><span class="s3">\n    </span><span class="s1">var scale = Math.min(nodeTW / w, nodeTH / h);</span><span class="s3">\n    </span><span class="s1">w *= scale;</span><span class="s3">\n    </span><span class="s1">h *= scale;</span><span class="s3">\n  </span><span class="s1">} else if (fit === 'cover') {</span><span class="s3">\n    </span><span class="s1">var scale = Math.max(nodeTW / w, nodeTH / h);</span><span class="s3">\n    </span><span class="s1">w *= scale;</span><span class="s3">\n    </span><span class="s1">h *= scale;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var x = nodeX - nodeTW / 2; // left</span><span class="s3">\n  </span><span class="s1">var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);</span><span class="s3">\n  </span><span class="s1">var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);</span><span class="s3">\n  </span><span class="s1">if (posXUnits === '%') {</span><span class="s3">\n    </span><span class="s1">x += (nodeTW - w) * posXPfVal;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">x += posXPfVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);</span><span class="s3">\n  </span><span class="s1">var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);</span><span class="s3">\n  </span><span class="s1">if (offXUnits === '%') {</span><span class="s3">\n    </span><span class="s1">x += (nodeTW - w) * offXPfVal;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">x += offXPfVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var y = nodeY - nodeTH / 2; // top</span><span class="s3">\n  </span><span class="s1">var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);</span><span class="s3">\n  </span><span class="s1">var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);</span><span class="s3">\n  </span><span class="s1">if (posYUnits === '%') {</span><span class="s3">\n    </span><span class="s1">y += (nodeTH - h) * posYPfVal;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">y += posYPfVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);</span><span class="s3">\n  </span><span class="s1">var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);</span><span class="s3">\n  </span><span class="s1">if (offYUnits === '%') {</span><span class="s3">\n    </span><span class="s1">y += (nodeTH - h) * offYPfVal;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">y += offYPfVal;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rs.pathCache) {</span><span class="s3">\n    </span><span class="s1">x -= nodeX;</span><span class="s3">\n    </span><span class="s1">y -= nodeY;</span><span class="s3">\n    </span><span class="s1">nodeX = 0;</span><span class="s3">\n    </span><span class="s1">nodeY = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var gAlpha = context.globalAlpha;</span><span class="s3">\n  </span><span class="s1">context.globalAlpha = imgOpacity;</span><span class="s3">\n  </span><span class="s1">var smoothingEnabled = r.getImgSmoothing(context);</span><span class="s3">\n  </span><span class="s1">var isSmoothingSwitched = false;</span><span class="s3">\n  </span><span class="s1">if (smooth === 'no' &amp;&amp; smoothingEnabled) {</span><span class="s3">\n    </span><span class="s1">r.setImgSmoothing(context, false);</span><span class="s3">\n    </span><span class="s1">isSmoothingSwitched = true;</span><span class="s3">\n  </span><span class="s1">} else if (smooth === 'yes' &amp;&amp; !smoothingEnabled) {</span><span class="s3">\n    </span><span class="s1">r.setImgSmoothing(context, true);</span><span class="s3">\n    </span><span class="s1">isSmoothingSwitched = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (repeat === 'no-repeat') {</span><span class="s3">\n    </span><span class="s1">if (shouldClip) {</span><span class="s3">\n      </span><span class="s1">context.save();</span><span class="s3">\n      </span><span class="s1">if (rs.pathCache) {</span><span class="s3">\n        </span><span class="s1">context.clip(rs.pathCache);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);</span><span class="s3">\n        </span><span class="s1">context.clip();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);</span><span class="s3">\n    </span><span class="s1">if (shouldClip) {</span><span class="s3">\n      </span><span class="s1">context.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var pattern = context.createPattern(img, repeat);</span><span class="s3">\n    </span><span class="s1">context.fillStyle = pattern;</span><span class="s3">\n    </span><span class="s1">r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);</span><span class="s3">\n    </span><span class="s1">context.translate(x, y);</span><span class="s3">\n    </span><span class="s1">context.fill();</span><span class="s3">\n    </span><span class="s1">context.translate(-x, -y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.globalAlpha = gAlpha;</span><span class="s3">\n  </span><span class="s1">if (isSmoothingSwitched) {</span><span class="s3">\n    </span><span class="s1">r.setImgSmoothing(context, smoothingEnabled);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CRp$7 = {};</span><span class="s3">\n</span><span class="s1">CRp$7.eleTextBiggerThanMin = function (ele, scale) {</span><span class="s3">\n  </span><span class="s1">if (!scale) {</span><span class="s3">\n    </span><span class="s1">var zoom = ele.cy().zoom();</span><span class="s3">\n    </span><span class="s1">var pxRatio = this.getPixelRatio();</span><span class="s3">\n    </span><span class="s1">var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level</span><span class="s3">\n\n    </span><span class="s1">scale = Math.pow(2, lvl);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var computedSize = ele.pstyle('font-size').pfValue * scale;</span><span class="s3">\n  </span><span class="s1">var minSize = ele.pstyle('min-zoomed-font-size').pfValue;</span><span class="s3">\n  </span><span class="s1">if (computedSize &lt; minSize) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$7.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {</span><span class="s3">\n  </span><span class="s1">var useEleOpacity = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : true;</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">if (force == null) {</span><span class="s3">\n    </span><span class="s1">if (useEleOpacity &amp;&amp; !r.eleTextBiggerThanMin(ele)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (force === false) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n    </span><span class="s1">var label = ele.pstyle('label');</span><span class="s3">\n    </span><span class="s1">if (!label || !label.value) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var justification = r.getLabelJustification(ele);</span><span class="s3">\n    </span><span class="s1">context.textAlign = justification;</span><span class="s3">\n    </span><span class="s1">context.textBaseline = 'bottom';</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var badLine = ele.element()._private.rscratch.badLine;</span><span class="s3">\n    </span><span class="s1">var _label = ele.pstyle('label');</span><span class="s3">\n    </span><span class="s1">var srcLabel = ele.pstyle('source-label');</span><span class="s3">\n    </span><span class="s1">var tgtLabel = ele.pstyle('target-label');</span><span class="s3">\n    </span><span class="s1">if (badLine || (!_label || !_label.value) &amp;&amp; (!srcLabel || !srcLabel.value) &amp;&amp; (!tgtLabel || !tgtLabel.value)) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">context.textAlign = 'center';</span><span class="s3">\n    </span><span class="s1">context.textBaseline = 'bottom';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var applyRotation = !shiftToOriginWithBb;</span><span class="s3">\n  </span><span class="s1">var bb;</span><span class="s3">\n  </span><span class="s1">if (shiftToOriginWithBb) {</span><span class="s3">\n    </span><span class="s1">bb = shiftToOriginWithBb;</span><span class="s3">\n    </span><span class="s1">context.translate(-bb.x1, -bb.y1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (prefix == null) {</span><span class="s3">\n    </span><span class="s1">r.drawText(context, ele, null, applyRotation, useEleOpacity);</span><span class="s3">\n    </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n      </span><span class="s1">r.drawText(context, ele, 'source', applyRotation, useEleOpacity);</span><span class="s3">\n      </span><span class="s1">r.drawText(context, ele, 'target', applyRotation, useEleOpacity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r.drawText(context, ele, prefix, applyRotation, useEleOpacity);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (shiftToOriginWithBb) {</span><span class="s3">\n    </span><span class="s1">context.translate(bb.x1, bb.y1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$7.getFontCache = function (context) {</span><span class="s3">\n  </span><span class="s1">var cache;</span><span class="s3">\n  </span><span class="s1">this.fontCaches = this.fontCaches || [];</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.fontCaches.length; i++) {</span><span class="s3">\n    </span><span class="s1">cache = this.fontCaches[i];</span><span class="s3">\n    </span><span class="s1">if (cache.context === context) {</span><span class="s3">\n      </span><span class="s1">return cache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">cache = {</span><span class="s3">\n    </span><span class="s1">context: context</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">this.fontCaches.push(cache);</span><span class="s3">\n  </span><span class="s1">return cache;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// set up canvas context with font</span><span class="s3">\n</span><span class="s1">// returns transformed text string</span><span class="s3">\n</span><span class="s1">CRp$7.setupTextStyle = function (context, ele) {</span><span class="s3">\n  </span><span class="s1">var useEleOpacity = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : true;</span><span class="s3">\n  </span><span class="s1">// Font style</span><span class="s3">\n  </span><span class="s1">var labelStyle = ele.pstyle('font-style').strValue;</span><span class="s3">\n  </span><span class="s1">var labelSize = ele.pstyle('font-size').pfValue + 'px';</span><span class="s3">\n  </span><span class="s1">var labelFamily = ele.pstyle('font-family').strValue;</span><span class="s3">\n  </span><span class="s1">var labelWeight = ele.pstyle('font-weight').strValue;</span><span class="s3">\n  </span><span class="s1">var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;</span><span class="s3">\n  </span><span class="s1">var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;</span><span class="s3">\n  </span><span class="s1">var color = ele.pstyle('color').value;</span><span class="s3">\n  </span><span class="s1">var outlineColor = ele.pstyle('text-outline-color').value;</span><span class="s3">\n  </span><span class="s1">context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;</span><span class="s3">\n  </span><span class="s1">context.lineJoin = 'round'; // so text outlines aren't jagged</span><span class="s3">\n\n  </span><span class="s1">this.colorFillStyle(context, color[0], color[1], color[2], opacity);</span><span class="s3">\n  </span><span class="s1">this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// TODO ensure re-used</span><span class="s3">\n</span><span class="s1">function roundRect(ctx, x, y, width, height) {</span><span class="s3">\n  </span><span class="s1">var radius = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : 5;</span><span class="s3">\n  </span><span class="s1">var stroke = arguments.length &gt; 6 ? arguments[6] : undefined;</span><span class="s3">\n  </span><span class="s1">ctx.beginPath();</span><span class="s3">\n  </span><span class="s1">ctx.moveTo(x + radius, y);</span><span class="s3">\n  </span><span class="s1">ctx.lineTo(x + width - radius, y);</span><span class="s3">\n  </span><span class="s1">ctx.quadraticCurveTo(x + width, y, x + width, y + radius);</span><span class="s3">\n  </span><span class="s1">ctx.lineTo(x + width, y + height - radius);</span><span class="s3">\n  </span><span class="s1">ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);</span><span class="s3">\n  </span><span class="s1">ctx.lineTo(x + radius, y + height);</span><span class="s3">\n  </span><span class="s1">ctx.quadraticCurveTo(x, y + height, x, y + height - radius);</span><span class="s3">\n  </span><span class="s1">ctx.lineTo(x, y + radius);</span><span class="s3">\n  </span><span class="s1">ctx.quadraticCurveTo(x, y, x + radius, y);</span><span class="s3">\n  </span><span class="s1">ctx.closePath();</span><span class="s3">\n  </span><span class="s1">if (stroke) ctx.stroke();else ctx.fill();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">CRp$7.getTextAngle = function (ele, prefix) {</span><span class="s3">\n  </span><span class="s1">var theta;</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var rscratch = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var pdash = prefix ? prefix + '-' : '';</span><span class="s3">\n  </span><span class="s1">var rotation = ele.pstyle(pdash + 'text-rotation');</span><span class="s3">\n  </span><span class="s1">if (rotation.strValue === 'autorotate') {</span><span class="s3">\n    </span><span class="s1">var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);</span><span class="s3">\n    </span><span class="s1">theta = ele.isEdge() ? textAngle : 0;</span><span class="s3">\n  </span><span class="s1">} else if (rotation.strValue === 'none') {</span><span class="s3">\n    </span><span class="s1">theta = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">theta = rotation.pfValue;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return theta;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$7.drawText = function (context, ele, prefix) {</span><span class="s3">\n  </span><span class="s1">var applyRotation = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : true;</span><span class="s3">\n  </span><span class="s1">var useEleOpacity = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true;</span><span class="s3">\n  </span><span class="s1">var _p = ele._private;</span><span class="s3">\n  </span><span class="s1">var rscratch = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;</span><span class="s3">\n  </span><span class="s1">if (useEleOpacity &amp;&amp; (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// use 'main' as an alias for the main label (i.e. null prefix)</span><span class="s3">\n  </span><span class="s1">if (prefix === 'main') {</span><span class="s3">\n    </span><span class="s1">prefix = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var textX = getPrefixedProperty(rscratch, 'labelX', prefix);</span><span class="s3">\n  </span><span class="s1">var textY = getPrefixedProperty(rscratch, 'labelY', prefix);</span><span class="s3">\n  </span><span class="s1">var orgTextX, orgTextY; // used for rotation</span><span class="s3">\n  </span><span class="s1">var text = this.getLabelText(ele, prefix);</span><span class="s3">\n  </span><span class="s1">if (text != null &amp;&amp; text !== '' &amp;&amp; !isNaN(textX) &amp;&amp; !isNaN(textY)) {</span><span class="s3">\n    </span><span class="s1">this.setupTextStyle(context, ele, useEleOpacity);</span><span class="s3">\n    </span><span class="s1">var pdash = prefix ? prefix + '-' : '';</span><span class="s3">\n    </span><span class="s1">var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);</span><span class="s3">\n    </span><span class="s1">var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);</span><span class="s3">\n    </span><span class="s1">var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;</span><span class="s3">\n    </span><span class="s1">var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;</span><span class="s3">\n    </span><span class="s1">var isEdge = ele.isEdge();</span><span class="s3">\n    </span><span class="s1">var halign = ele.pstyle('text-halign').value;</span><span class="s3">\n    </span><span class="s1">var valign = ele.pstyle('text-valign').value;</span><span class="s3">\n    </span><span class="s1">if (isEdge) {</span><span class="s3">\n      </span><span class="s1">halign = 'center';</span><span class="s3">\n      </span><span class="s1">valign = 'center';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">textX += marginX;</span><span class="s3">\n    </span><span class="s1">textY += marginY;</span><span class="s3">\n    </span><span class="s1">var theta;</span><span class="s3">\n    </span><span class="s1">if (!applyRotation) {</span><span class="s3">\n      </span><span class="s1">theta = 0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">theta = this.getTextAngle(ele, prefix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (theta !== 0) {</span><span class="s3">\n      </span><span class="s1">orgTextX = textX;</span><span class="s3">\n      </span><span class="s1">orgTextY = textY;</span><span class="s3">\n      </span><span class="s1">context.translate(orgTextX, orgTextY);</span><span class="s3">\n      </span><span class="s1">context.rotate(theta);</span><span class="s3">\n      </span><span class="s1">textX = 0;</span><span class="s3">\n      </span><span class="s1">textY = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">switch (valign) {</span><span class="s3">\n      </span><span class="s1">case 'top':</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 'center':</span><span class="s3">\n        </span><span class="s1">textY += textH / 2;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 'bottom':</span><span class="s3">\n        </span><span class="s1">textY += textH;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var backgroundOpacity = ele.pstyle('text-background-opacity').value;</span><span class="s3">\n    </span><span class="s1">var borderOpacity = ele.pstyle('text-border-opacity').value;</span><span class="s3">\n    </span><span class="s1">var textBorderWidth = ele.pstyle('text-border-width').pfValue;</span><span class="s3">\n    </span><span class="s1">var backgroundPadding = ele.pstyle('text-background-padding').pfValue;</span><span class="s3">\n    </span><span class="s1">var styleShape = ele.pstyle('text-background-shape').strValue;</span><span class="s3">\n    </span><span class="s1">var rounded = styleShape.indexOf('round') === 0;</span><span class="s3">\n    </span><span class="s1">var roundRadius = 2;</span><span class="s3">\n    </span><span class="s1">if (backgroundOpacity &gt; 0 || textBorderWidth &gt; 0 &amp;&amp; borderOpacity &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var bgX = textX - backgroundPadding;</span><span class="s3">\n      </span><span class="s1">switch (halign) {</span><span class="s3">\n        </span><span class="s1">case 'left':</span><span class="s3">\n          </span><span class="s1">bgX -= textW;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'center':</span><span class="s3">\n          </span><span class="s1">bgX -= textW / 2;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var bgY = textY - textH - backgroundPadding;</span><span class="s3">\n      </span><span class="s1">var bgW = textW + 2 * backgroundPadding;</span><span class="s3">\n      </span><span class="s1">var bgH = textH + 2 * backgroundPadding;</span><span class="s3">\n      </span><span class="s1">if (backgroundOpacity &gt; 0) {</span><span class="s3">\n        </span><span class="s1">var textFill = context.fillStyle;</span><span class="s3">\n        </span><span class="s1">var textBackgroundColor = ele.pstyle('text-background-color').value;</span><span class="s3">\n        </span><span class="s1">context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';</span><span class="s3">\n        </span><span class="s1">if (rounded) {</span><span class="s3">\n          </span><span class="s1">roundRect(context, bgX, bgY, bgW, bgH, roundRadius);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">context.fillRect(bgX, bgY, bgW, bgH);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">context.fillStyle = textFill;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (textBorderWidth &gt; 0 &amp;&amp; borderOpacity &gt; 0) {</span><span class="s3">\n        </span><span class="s1">var textStroke = context.strokeStyle;</span><span class="s3">\n        </span><span class="s1">var textLineWidth = context.lineWidth;</span><span class="s3">\n        </span><span class="s1">var textBorderColor = ele.pstyle('text-border-color').value;</span><span class="s3">\n        </span><span class="s1">var textBorderStyle = ele.pstyle('text-border-style').value;</span><span class="s3">\n        </span><span class="s1">context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';</span><span class="s3">\n        </span><span class="s1">context.lineWidth = textBorderWidth;</span><span class="s3">\n        </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n          </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n          </span><span class="s1">switch (textBorderStyle) {</span><span class="s3">\n            </span><span class="s1">case 'dotted':</span><span class="s3">\n              </span><span class="s1">context.setLineDash([1, 1]);</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'dashed':</span><span class="s3">\n              </span><span class="s1">context.setLineDash([4, 2]);</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'double':</span><span class="s3">\n              </span><span class="s1">context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders</span><span class="s3">\n              </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'solid':</span><span class="s3">\n              </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (rounded) {</span><span class="s3">\n          </span><span class="s1">roundRect(context, bgX, bgY, bgW, bgH, roundRadius, 'stroke');</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">context.strokeRect(bgX, bgY, bgW, bgH);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (textBorderStyle === 'double') {</span><span class="s3">\n          </span><span class="s1">var whiteWidth = textBorderWidth / 2;</span><span class="s3">\n          </span><span class="s1">if (rounded) {</span><span class="s3">\n            </span><span class="s1">roundRect(context, bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2, roundRadius, 'stroke');</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n          </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n          </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">context.lineWidth = textLineWidth;</span><span class="s3">\n        </span><span class="s1">context.strokeStyle = textStroke;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle</span><span class="s3">\n\n    </span><span class="s1">if (lineWidth &gt; 0) {</span><span class="s3">\n      </span><span class="s1">context.lineWidth = lineWidth;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ele.pstyle('text-wrap').value === 'wrap') {</span><span class="s3">\n      </span><span class="s1">var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);</span><span class="s3">\n      </span><span class="s1">var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);</span><span class="s3">\n      </span><span class="s1">var halfTextW = textW / 2;</span><span class="s3">\n      </span><span class="s1">var justification = this.getLabelJustification(ele);</span><span class="s3">\n      </span><span class="s1">if (justification === 'auto') ; else if (halign === 'left') {</span><span class="s3">\n        </span><span class="s1">// auto justification : right</span><span class="s3">\n        </span><span class="s1">if (justification === 'left') {</span><span class="s3">\n          </span><span class="s1">textX += -textW;</span><span class="s3">\n        </span><span class="s1">} else if (justification === 'center') {</span><span class="s3">\n          </span><span class="s1">textX += -halfTextW;</span><span class="s3">\n        </span><span class="s1">} // else same as auto</span><span class="s3">\n      </span><span class="s1">} else if (halign === 'center') {</span><span class="s3">\n        </span><span class="s1">// auto justfication : center</span><span class="s3">\n        </span><span class="s1">if (justification === 'left') {</span><span class="s3">\n          </span><span class="s1">textX += -halfTextW;</span><span class="s3">\n        </span><span class="s1">} else if (justification === 'right') {</span><span class="s3">\n          </span><span class="s1">textX += halfTextW;</span><span class="s3">\n        </span><span class="s1">} // else same as auto</span><span class="s3">\n      </span><span class="s1">} else if (halign === 'right') {</span><span class="s3">\n        </span><span class="s1">// auto justification : left</span><span class="s3">\n        </span><span class="s1">if (justification === 'center') {</span><span class="s3">\n          </span><span class="s1">textX += halfTextW;</span><span class="s3">\n        </span><span class="s1">} else if (justification === 'right') {</span><span class="s3">\n          </span><span class="s1">textX += textW;</span><span class="s3">\n        </span><span class="s1">} // else same as auto</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">switch (valign) {</span><span class="s3">\n        </span><span class="s1">case 'top':</span><span class="s3">\n          </span><span class="s1">textY -= (lines.length - 1) * lineHeight;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'center':</span><span class="s3">\n        </span><span class="s1">case 'bottom':</span><span class="s3">\n          </span><span class="s1">textY -= (lines.length - 1) * lineHeight;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var l = 0; l &lt; lines.length; l++) {</span><span class="s3">\n        </span><span class="s1">if (lineWidth &gt; 0) {</span><span class="s3">\n          </span><span class="s1">context.strokeText(lines[l], textX, textY);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">context.fillText(lines[l], textX, textY);</span><span class="s3">\n        </span><span class="s1">textY += lineHeight;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (lineWidth &gt; 0) {</span><span class="s3">\n        </span><span class="s1">context.strokeText(text, textX, textY);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">context.fillText(text, textX, textY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (theta !== 0) {</span><span class="s3">\n      </span><span class="s1">context.rotate(-theta);</span><span class="s3">\n      </span><span class="s1">context.translate(-orgTextX, -orgTextY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* global Path2D */</span><span class="s3">\n\n</span><span class="s1">var CRp$6 = {};</span><span class="s3">\n</span><span class="s1">CRp$6.drawNode = function (context, node, shiftToOriginWithBb) {</span><span class="s3">\n  </span><span class="s1">var drawLabel = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : true;</span><span class="s3">\n  </span><span class="s1">var shouldDrawOverlay = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true;</span><span class="s3">\n  </span><span class="s1">var shouldDrawOpacity = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : true;</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var nodeWidth, nodeHeight;</span><span class="s3">\n  </span><span class="s1">var _p = node._private;</span><span class="s3">\n  </span><span class="s1">var rs = _p.rscratch;</span><span class="s3">\n  </span><span class="s1">var pos = node.position();</span><span class="s3">\n  </span><span class="s1">if (!number$1(pos.x) || !number$1(pos.y)) {</span><span class="s3">\n    </span><span class="s1">return; // can't draw node with undefined position</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (shouldDrawOpacity &amp;&amp; !node.visible()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;</span><span class="s3">\n  </span><span class="s1">var usePaths = r.usePaths();</span><span class="s3">\n  </span><span class="s1">var path;</span><span class="s3">\n  </span><span class="s1">var pathCacheHit = false;</span><span class="s3">\n  </span><span class="s1">var padding = node.padding();</span><span class="s3">\n  </span><span class="s1">nodeWidth = node.width() + 2 * padding;</span><span class="s3">\n  </span><span class="s1">nodeHeight = node.height() + 2 * padding;</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// setup shift</span><span class="s3">\n\n  </span><span class="s1">var bb;</span><span class="s3">\n  </span><span class="s1">if (shiftToOriginWithBb) {</span><span class="s3">\n    </span><span class="s1">bb = shiftToOriginWithBb;</span><span class="s3">\n    </span><span class="s1">context.translate(-bb.x1, -bb.y1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// load bg image</span><span class="s3">\n\n  </span><span class="s1">var bgImgProp = node.pstyle('background-image');</span><span class="s3">\n  </span><span class="s1">var urls = bgImgProp.value;</span><span class="s3">\n  </span><span class="s1">var urlDefined = new Array(urls.length);</span><span class="s3">\n  </span><span class="s1">var image = new Array(urls.length);</span><span class="s3">\n  </span><span class="s1">var numImages = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; urls.length; i++) {</span><span class="s3">\n    </span><span class="s1">var url = urls[i];</span><span class="s3">\n    </span><span class="s1">var defd = urlDefined[i] = url != null &amp;&amp; url !== 'none';</span><span class="s3">\n    </span><span class="s1">if (defd) {</span><span class="s3">\n      </span><span class="s1">var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);</span><span class="s3">\n      </span><span class="s1">numImages++;</span><span class="s3">\n\n      </span><span class="s1">// get image, and if not loaded then ask to redraw when later loaded</span><span class="s3">\n      </span><span class="s1">image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {</span><span class="s3">\n        </span><span class="s1">_p.backgroundTimestamp = Date.now();</span><span class="s3">\n        </span><span class="s1">node.emitAndNotify('background');</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// setup styles</span><span class="s3">\n\n  </span><span class="s1">var darkness = node.pstyle('background-blacken').value;</span><span class="s3">\n  </span><span class="s1">var borderWidth = node.pstyle('border-width').pfValue;</span><span class="s3">\n  </span><span class="s1">var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;</span><span class="s3">\n  </span><span class="s1">var borderColor = node.pstyle('border-color').value;</span><span class="s3">\n  </span><span class="s1">var borderStyle = node.pstyle('border-style').value;</span><span class="s3">\n  </span><span class="s1">var borderJoin = node.pstyle('border-join').value;</span><span class="s3">\n  </span><span class="s1">var borderCap = node.pstyle('border-cap').value;</span><span class="s3">\n  </span><span class="s1">var borderPosition = node.pstyle('border-position').value;</span><span class="s3">\n  </span><span class="s1">var borderPattern = node.pstyle('border-dash-pattern').pfValue;</span><span class="s3">\n  </span><span class="s1">var borderOffset = node.pstyle('border-dash-offset').pfValue;</span><span class="s3">\n  </span><span class="s1">var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;</span><span class="s3">\n  </span><span class="s1">var outlineWidth = node.pstyle('outline-width').pfValue;</span><span class="s3">\n  </span><span class="s1">var outlineColor = node.pstyle('outline-color').value;</span><span class="s3">\n  </span><span class="s1">var outlineStyle = node.pstyle('outline-style').value;</span><span class="s3">\n  </span><span class="s1">var outlineOpacity = node.pstyle('outline-opacity').value * eleOpacity;</span><span class="s3">\n  </span><span class="s1">var outlineOffset = node.pstyle('outline-offset').value;</span><span class="s3">\n  </span><span class="s1">var cornerRadius = node.pstyle('corner-radius').value;</span><span class="s3">\n  </span><span class="s1">if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;</span><span class="s3">\n  </span><span class="s1">var setupShapeColor = function setupShapeColor() {</span><span class="s3">\n    </span><span class="s1">var bgOpy = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : bgOpacity;</span><span class="s3">\n    </span><span class="s1">r.eleFillStyle(context, node, bgOpy);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setupBorderColor = function setupBorderColor() {</span><span class="s3">\n    </span><span class="s1">var bdrOpy = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : borderOpacity;</span><span class="s3">\n    </span><span class="s1">r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var setupOutlineColor = function setupOutlineColor() {</span><span class="s3">\n    </span><span class="s1">var otlnOpy = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : outlineOpacity;</span><span class="s3">\n    </span><span class="s1">r.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], otlnOpy);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// setup shape</span><span class="s3">\n\n  </span><span class="s1">var getPath = function getPath(width, height, shape, points) {</span><span class="s3">\n    </span><span class="s1">var pathCache = r.nodePathCache = r.nodePathCache || [];</span><span class="s3">\n    </span><span class="s1">var key = hashStrings(shape === 'polygon' ? shape + ',' + points.join(',') : shape, '' + height, '' + width, '' + cornerRadius);</span><span class="s3">\n    </span><span class="s1">var cachedPath = pathCache[key];</span><span class="s3">\n    </span><span class="s1">var path;</span><span class="s3">\n    </span><span class="s1">var cacheHit = false;</span><span class="s3">\n    </span><span class="s1">if (cachedPath != null) {</span><span class="s3">\n      </span><span class="s1">path = cachedPath;</span><span class="s3">\n      </span><span class="s1">cacheHit = true;</span><span class="s3">\n      </span><span class="s1">rs.pathCache = path;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path = new Path2D();</span><span class="s3">\n      </span><span class="s1">pathCache[key] = rs.pathCache = path;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">path: path,</span><span class="s3">\n      </span><span class="s1">cacheHit: cacheHit</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var styleShape = node.pstyle('shape').strValue;</span><span class="s3">\n  </span><span class="s1">var shapePts = node.pstyle('shape-polygon-points').pfValue;</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">context.translate(pos.x, pos.y);</span><span class="s3">\n    </span><span class="s1">var shapePath = getPath(nodeWidth, nodeHeight, styleShape, shapePts);</span><span class="s3">\n    </span><span class="s1">path = shapePath.path;</span><span class="s3">\n    </span><span class="s1">pathCacheHit = shapePath.cacheHit;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var drawShape = function drawShape() {</span><span class="s3">\n    </span><span class="s1">if (!pathCacheHit) {</span><span class="s3">\n      </span><span class="s1">var npos = pos;</span><span class="s3">\n      </span><span class="s1">if (usePaths) {</span><span class="s3">\n        </span><span class="s1">npos = {</span><span class="s3">\n          </span><span class="s1">x: 0,</span><span class="s3">\n          </span><span class="s1">y: 0</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight, cornerRadius, rs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (usePaths) {</span><span class="s3">\n      </span><span class="s1">context.fill(path);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">context.fill();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawImages = function drawImages() {</span><span class="s3">\n    </span><span class="s1">var nodeOpacity = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : eleOpacity;</span><span class="s3">\n    </span><span class="s1">var inside = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;</span><span class="s3">\n    </span><span class="s1">var prevBging = _p.backgrounding;</span><span class="s3">\n    </span><span class="s1">var totalCompleted = 0;</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; image.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);</span><span class="s3">\n      </span><span class="s1">if (inside &amp;&amp; bgContainment === 'over' || !inside &amp;&amp; bgContainment === 'inside') {</span><span class="s3">\n        </span><span class="s1">totalCompleted++;</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (urlDefined[_i] &amp;&amp; image[_i].complete &amp;&amp; !image[_i].error) {</span><span class="s3">\n        </span><span class="s1">totalCompleted++;</span><span class="s3">\n        </span><span class="s1">r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_p.backgrounding = !(totalCompleted === numImages);</span><span class="s3">\n    </span><span class="s1">if (prevBging !== _p.backgrounding) {</span><span class="s3">\n      </span><span class="s1">// update style b/c :backgrounding state changed</span><span class="s3">\n      </span><span class="s1">node.updateStyle(false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawPie = function drawPie() {</span><span class="s3">\n    </span><span class="s1">var redrawShape = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : false;</span><span class="s3">\n    </span><span class="s1">var pieOpacity = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : eleOpacity;</span><span class="s3">\n    </span><span class="s1">if (r.hasPie(node)) {</span><span class="s3">\n      </span><span class="s1">r.drawPie(context, node, pieOpacity);</span><span class="s3">\n\n      </span><span class="s1">// redraw/restore path if steps after pie need it</span><span class="s3">\n      </span><span class="s1">if (redrawShape) {</span><span class="s3">\n        </span><span class="s1">if (!usePaths) {</span><span class="s3">\n          </span><span class="s1">r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var darken = function darken() {</span><span class="s3">\n    </span><span class="s1">var darkenOpacity = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : eleOpacity;</span><span class="s3">\n    </span><span class="s1">var opacity = (darkness &gt; 0 ? darkness : -darkness) * darkenOpacity;</span><span class="s3">\n    </span><span class="s1">var c = darkness &gt; 0 ? 0 : 255;</span><span class="s3">\n    </span><span class="s1">if (darkness !== 0) {</span><span class="s3">\n      </span><span class="s1">r.colorFillStyle(context, c, c, c, opacity);</span><span class="s3">\n      </span><span class="s1">if (usePaths) {</span><span class="s3">\n        </span><span class="s1">context.fill(path);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">context.fill();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawBorder = function drawBorder() {</span><span class="s3">\n    </span><span class="s1">if (borderWidth &gt; 0) {</span><span class="s3">\n      </span><span class="s1">context.lineWidth = borderWidth;</span><span class="s3">\n      </span><span class="s1">context.lineCap = borderCap;</span><span class="s3">\n      </span><span class="s1">context.lineJoin = borderJoin;</span><span class="s3">\n      </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n        </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n        </span><span class="s1">switch (borderStyle) {</span><span class="s3">\n          </span><span class="s1">case 'dotted':</span><span class="s3">\n            </span><span class="s1">context.setLineDash([1, 1]);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 'dashed':</span><span class="s3">\n            </span><span class="s1">context.setLineDash(borderPattern);</span><span class="s3">\n            </span><span class="s1">context.lineDashOffset = borderOffset;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 'solid':</span><span class="s3">\n          </span><span class="s1">case 'double':</span><span class="s3">\n            </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (borderPosition !== 'center') {</span><span class="s3">\n        </span><span class="s1">context.save();</span><span class="s3">\n        </span><span class="s1">context.lineWidth *= 2;</span><span class="s3">\n        </span><span class="s1">if (borderPosition === 'inside') {</span><span class="s3">\n          </span><span class="s1">usePaths ? context.clip(path) : context.clip();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var region = new Path2D();</span><span class="s3">\n          </span><span class="s1">region.rect(-nodeWidth / 2 - borderWidth, -nodeHeight / 2 - borderWidth, nodeWidth + 2 * borderWidth, nodeHeight + 2 * borderWidth);</span><span class="s3">\n          </span><span class="s1">region.addPath(path);</span><span class="s3">\n          </span><span class="s1">context.clip(region, 'evenodd');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">usePaths ? context.stroke(path) : context.stroke();</span><span class="s3">\n        </span><span class="s1">context.restore();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">usePaths ? context.stroke(path) : context.stroke();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (borderStyle === 'double') {</span><span class="s3">\n        </span><span class="s1">context.lineWidth = borderWidth / 3;</span><span class="s3">\n        </span><span class="s1">var gco = context.globalCompositeOperation;</span><span class="s3">\n        </span><span class="s1">context.globalCompositeOperation = 'destination-out';</span><span class="s3">\n        </span><span class="s1">if (usePaths) {</span><span class="s3">\n          </span><span class="s1">context.stroke(path);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">context.stroke();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">context.globalCompositeOperation = gco;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// reset in case we changed the border style</span><span class="s3">\n      </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n        </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n        </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawOutline = function drawOutline() {</span><span class="s3">\n    </span><span class="s1">if (outlineWidth &gt; 0) {</span><span class="s3">\n      </span><span class="s1">context.lineWidth = outlineWidth;</span><span class="s3">\n      </span><span class="s1">context.lineCap = 'butt';</span><span class="s3">\n      </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n        </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n        </span><span class="s1">switch (outlineStyle) {</span><span class="s3">\n          </span><span class="s1">case 'dotted':</span><span class="s3">\n            </span><span class="s1">context.setLineDash([1, 1]);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 'dashed':</span><span class="s3">\n            </span><span class="s1">context.setLineDash([4, 2]);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 'solid':</span><span class="s3">\n          </span><span class="s1">case 'double':</span><span class="s3">\n            </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var npos = pos;</span><span class="s3">\n      </span><span class="s1">if (usePaths) {</span><span class="s3">\n        </span><span class="s1">npos = {</span><span class="s3">\n          </span><span class="s1">x: 0,</span><span class="s3">\n          </span><span class="s1">y: 0</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var shape = r.getNodeShape(node);</span><span class="s3">\n      </span><span class="s1">var bWidth = borderWidth;</span><span class="s3">\n      </span><span class="s1">if (borderPosition === 'inside') bWidth = 0;</span><span class="s3">\n      </span><span class="s1">if (borderPosition === 'outside') bWidth *= 2;</span><span class="s3">\n      </span><span class="s1">var scaleX = (nodeWidth + bWidth + (outlineWidth + outlineOffset)) / nodeWidth;</span><span class="s3">\n      </span><span class="s1">var scaleY = (nodeHeight + bWidth + (outlineWidth + outlineOffset)) / nodeHeight;</span><span class="s3">\n      </span><span class="s1">var sWidth = nodeWidth * scaleX;</span><span class="s3">\n      </span><span class="s1">var sHeight = nodeHeight * scaleY;</span><span class="s3">\n      </span><span class="s1">var points = r.nodeShapes[shape].points;</span><span class="s3">\n      </span><span class="s1">var _path;</span><span class="s3">\n      </span><span class="s1">if (usePaths) {</span><span class="s3">\n        </span><span class="s1">var outlinePath = getPath(sWidth, sHeight, shape, points);</span><span class="s3">\n        </span><span class="s1">_path = outlinePath.path;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// draw the outline path, either by using expanded points or by scaling </span><span class="s3">\n      </span><span class="s1">// the dimensions, depending on shape</span><span class="s3">\n      </span><span class="s1">if (shape === </span><span class="s3">\&quot;</span><span class="s1">ellipse</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">r.drawEllipsePath(_path || context, npos.x, npos.y, sWidth, sHeight);</span><span class="s3">\n      </span><span class="s1">} else if (['round-diamond', 'round-heptagon', 'round-hexagon', 'round-octagon', 'round-pentagon', 'round-polygon', 'round-triangle', 'round-tag'].includes(shape)) {</span><span class="s3">\n        </span><span class="s1">var sMult = 0;</span><span class="s3">\n        </span><span class="s1">var offsetX = 0;</span><span class="s3">\n        </span><span class="s1">var offsetY = 0;</span><span class="s3">\n        </span><span class="s1">if (shape === 'round-diamond') {</span><span class="s3">\n          </span><span class="s1">sMult = (bWidth + outlineOffset + outlineWidth) * 1.4;</span><span class="s3">\n        </span><span class="s1">} else if (shape === 'round-heptagon') {</span><span class="s3">\n          </span><span class="s1">sMult = (bWidth + outlineOffset + outlineWidth) * 1.075;</span><span class="s3">\n          </span><span class="s1">offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 35;</span><span class="s3">\n        </span><span class="s1">} else if (shape === 'round-hexagon') {</span><span class="s3">\n          </span><span class="s1">sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;</span><span class="s3">\n        </span><span class="s1">} else if (shape === 'round-pentagon') {</span><span class="s3">\n          </span><span class="s1">sMult = (bWidth + outlineOffset + outlineWidth) * 1.13;</span><span class="s3">\n          </span><span class="s1">offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 15;</span><span class="s3">\n        </span><span class="s1">} else if (shape === 'round-tag') {</span><span class="s3">\n          </span><span class="s1">sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;</span><span class="s3">\n          </span><span class="s1">offsetX = (bWidth / 2 + outlineWidth + outlineOffset) * .07;</span><span class="s3">\n        </span><span class="s1">} else if (shape === 'round-triangle') {</span><span class="s3">\n          </span><span class="s1">sMult = (bWidth + outlineOffset + outlineWidth) * (Math.PI / 2);</span><span class="s3">\n          </span><span class="s1">offsetY = -(bWidth + outlineOffset / 2 + outlineWidth) / Math.PI;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (sMult !== 0) {</span><span class="s3">\n          </span><span class="s1">scaleX = (nodeWidth + sMult) / nodeWidth;</span><span class="s3">\n          </span><span class="s1">sWidth = nodeWidth * scaleX;</span><span class="s3">\n          </span><span class="s1">if (!['round-hexagon', 'round-tag'].includes(shape)) {</span><span class="s3">\n            </span><span class="s1">scaleY = (nodeHeight + sMult) / nodeHeight;</span><span class="s3">\n            </span><span class="s1">sHeight = nodeHeight * scaleY;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(sWidth, sHeight) : cornerRadius;</span><span class="s3">\n        </span><span class="s1">var halfW = sWidth / 2;</span><span class="s3">\n        </span><span class="s1">var halfH = sHeight / 2;</span><span class="s3">\n        </span><span class="s1">var radius = cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2;</span><span class="s3">\n        </span><span class="s1">var p = new Array(points.length / 2);</span><span class="s3">\n        </span><span class="s1">var corners = new Array(points.length / 2);</span><span class="s3">\n        </span><span class="s1">for (var _i2 = 0; _i2 &lt; points.length / 2; _i2++) {</span><span class="s3">\n          </span><span class="s1">p[_i2] = {</span><span class="s3">\n            </span><span class="s1">x: npos.x + offsetX + halfW * points[_i2 * 2],</span><span class="s3">\n            </span><span class="s1">y: npos.y + offsetY + halfH * points[_i2 * 2 + 1]</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var _i3,</span><span class="s3">\n          </span><span class="s1">p1,</span><span class="s3">\n          </span><span class="s1">p2,</span><span class="s3">\n          </span><span class="s1">p3,</span><span class="s3">\n          </span><span class="s1">len = p.length;</span><span class="s3">\n        </span><span class="s1">p1 = p[len - 1];</span><span class="s3">\n        </span><span class="s1">// for each point</span><span class="s3">\n        </span><span class="s1">for (_i3 = 0; _i3 &lt; len; _i3++) {</span><span class="s3">\n          </span><span class="s1">p2 = p[_i3 % len];</span><span class="s3">\n          </span><span class="s1">p3 = p[(_i3 + 1) % len];</span><span class="s3">\n          </span><span class="s1">corners[_i3] = getRoundCorner(p1, p2, p3, radius);</span><span class="s3">\n          </span><span class="s1">p1 = p2;</span><span class="s3">\n          </span><span class="s1">p2 = p3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">r.drawRoundPolygonPath(_path || context, npos.x + offsetX, npos.y + offsetY, nodeWidth * scaleX, nodeHeight * scaleY, points, corners);</span><span class="s3">\n      </span><span class="s1">} else if (['roundrectangle', 'round-rectangle'].includes(shape)) {</span><span class="s3">\n        </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;</span><span class="s3">\n        </span><span class="s1">r.drawRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);</span><span class="s3">\n      </span><span class="s1">} else if (['cutrectangle', 'cut-rectangle'].includes(shape)) {</span><span class="s3">\n        </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getCutRectangleCornerLength() : cornerRadius;</span><span class="s3">\n        </span><span class="s1">r.drawCutRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, null, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 4);</span><span class="s3">\n      </span><span class="s1">} else if (['bottomroundrectangle', 'bottom-round-rectangle'].includes(shape)) {</span><span class="s3">\n        </span><span class="s1">cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;</span><span class="s3">\n        </span><span class="s1">r.drawBottomRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);</span><span class="s3">\n      </span><span class="s1">} else if (shape === </span><span class="s3">\&quot;</span><span class="s1">barrel</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">r.drawBarrelPath(_path || context, npos.x, npos.y, sWidth, sHeight);</span><span class="s3">\n      </span><span class="s1">} else if (shape.startsWith(</span><span class="s3">\&quot;</span><span class="s1">polygon</span><span class="s3">\&quot;</span><span class="s1">) || ['rhomboid', 'right-rhomboid', 'round-tag', 'tag', 'vee'].includes(shape)) {</span><span class="s3">\n        </span><span class="s1">var pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;</span><span class="s3">\n        </span><span class="s1">points = joinLines(expandPolygon(points, pad));</span><span class="s3">\n        </span><span class="s1">r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var _pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;</span><span class="s3">\n        </span><span class="s1">points = joinLines(expandPolygon(points, -_pad));</span><span class="s3">\n        </span><span class="s1">r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (usePaths) {</span><span class="s3">\n        </span><span class="s1">context.stroke(_path);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">context.stroke();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (outlineStyle === 'double') {</span><span class="s3">\n        </span><span class="s1">context.lineWidth = bWidth / 3;</span><span class="s3">\n        </span><span class="s1">var gco = context.globalCompositeOperation;</span><span class="s3">\n        </span><span class="s1">context.globalCompositeOperation = 'destination-out';</span><span class="s3">\n        </span><span class="s1">if (usePaths) {</span><span class="s3">\n          </span><span class="s1">context.stroke(_path);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">context.stroke();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">context.globalCompositeOperation = gco;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// reset in case we changed the border style</span><span class="s3">\n      </span><span class="s1">if (context.setLineDash) {</span><span class="s3">\n        </span><span class="s1">// for very outofdate browsers</span><span class="s3">\n        </span><span class="s1">context.setLineDash([]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawOverlay = function drawOverlay() {</span><span class="s3">\n    </span><span class="s1">if (shouldDrawOverlay) {</span><span class="s3">\n      </span><span class="s1">r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawUnderlay = function drawUnderlay() {</span><span class="s3">\n    </span><span class="s1">if (shouldDrawOverlay) {</span><span class="s3">\n      </span><span class="s1">r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawText = function drawText() {</span><span class="s3">\n    </span><span class="s1">r.drawElementText(context, node, null, drawLabel);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var ghost = node.pstyle('ghost').value === 'yes';</span><span class="s3">\n  </span><span class="s1">if (ghost) {</span><span class="s3">\n    </span><span class="s1">var gx = node.pstyle('ghost-offset-x').pfValue;</span><span class="s3">\n    </span><span class="s1">var gy = node.pstyle('ghost-offset-y').pfValue;</span><span class="s3">\n    </span><span class="s1">var ghostOpacity = node.pstyle('ghost-opacity').value;</span><span class="s3">\n    </span><span class="s1">var effGhostOpacity = ghostOpacity * eleOpacity;</span><span class="s3">\n    </span><span class="s1">context.translate(gx, gy);</span><span class="s3">\n    </span><span class="s1">setupOutlineColor();</span><span class="s3">\n    </span><span class="s1">drawOutline();</span><span class="s3">\n    </span><span class="s1">setupShapeColor(ghostOpacity * bgOpacity);</span><span class="s3">\n    </span><span class="s1">drawShape();</span><span class="s3">\n    </span><span class="s1">drawImages(effGhostOpacity, true);</span><span class="s3">\n    </span><span class="s1">setupBorderColor(ghostOpacity * borderOpacity);</span><span class="s3">\n    </span><span class="s1">drawBorder();</span><span class="s3">\n    </span><span class="s1">drawPie(darkness !== 0 || borderWidth !== 0);</span><span class="s3">\n    </span><span class="s1">drawImages(effGhostOpacity, false);</span><span class="s3">\n    </span><span class="s1">darken(effGhostOpacity);</span><span class="s3">\n    </span><span class="s1">context.translate(-gx, -gy);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">context.translate(-pos.x, -pos.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">drawUnderlay();</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">context.translate(pos.x, pos.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">setupOutlineColor();</span><span class="s3">\n  </span><span class="s1">drawOutline();</span><span class="s3">\n  </span><span class="s1">setupShapeColor();</span><span class="s3">\n  </span><span class="s1">drawShape();</span><span class="s3">\n  </span><span class="s1">drawImages(eleOpacity, true);</span><span class="s3">\n  </span><span class="s1">setupBorderColor();</span><span class="s3">\n  </span><span class="s1">drawBorder();</span><span class="s3">\n  </span><span class="s1">drawPie(darkness !== 0 || borderWidth !== 0);</span><span class="s3">\n  </span><span class="s1">drawImages(eleOpacity, false);</span><span class="s3">\n  </span><span class="s1">darken();</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">context.translate(-pos.x, -pos.y);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">drawText();</span><span class="s3">\n  </span><span class="s1">drawOverlay();</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// clean up shift</span><span class="s3">\n\n  </span><span class="s1">if (shiftToOriginWithBb) {</span><span class="s3">\n    </span><span class="s1">context.translate(bb.x1, bb.y1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {</span><span class="s3">\n  </span><span class="s1">if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Invalid state');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function (context, node, pos, nodeWidth, nodeHeight) {</span><span class="s3">\n    </span><span class="s1">var r = this;</span><span class="s3">\n    </span><span class="s1">if (!node.visible()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var padding = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-padding</span><span class="s3">\&quot;</span><span class="s1">)).pfValue;</span><span class="s3">\n    </span><span class="s1">var opacity = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-opacity</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n    </span><span class="s1">var color = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-color</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n    </span><span class="s1">var shape = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-shape</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n    </span><span class="s1">var radius = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(overlayOrUnderlay, </span><span class="s3">\&quot;</span><span class="s1">-corner-radius</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n    </span><span class="s1">if (opacity &gt; 0) {</span><span class="s3">\n      </span><span class="s1">pos = pos || node.position();</span><span class="s3">\n      </span><span class="s1">if (nodeWidth == null || nodeHeight == null) {</span><span class="s3">\n        </span><span class="s1">var _padding = node.padding();</span><span class="s3">\n        </span><span class="s1">nodeWidth = node.width() + 2 * _padding;</span><span class="s3">\n        </span><span class="s1">nodeHeight = node.height() + 2 * _padding;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">r.colorFillStyle(context, color[0], color[1], color[2], opacity);</span><span class="s3">\n      </span><span class="s1">r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2, radius);</span><span class="s3">\n      </span><span class="s1">context.fill();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$6.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');</span><span class="s3">\n</span><span class="s1">CRp$6.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay');</span><span class="s3">\n\n</span><span class="s1">// does the node have at least one pie piece?</span><span class="s3">\n</span><span class="s1">CRp$6.hasPie = function (node) {</span><span class="s3">\n  </span><span class="s1">node = node[0]; // ensure ele ref</span><span class="s3">\n\n  </span><span class="s1">return node._private.hasPie;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$6.drawPie = function (context, node, nodeOpacity, pos) {</span><span class="s3">\n  </span><span class="s1">node = node[0]; // ensure ele ref</span><span class="s3">\n  </span><span class="s1">pos = pos || node.position();</span><span class="s3">\n  </span><span class="s1">var cyStyle = node.cy().style();</span><span class="s3">\n  </span><span class="s1">var pieSize = node.pstyle('pie-size');</span><span class="s3">\n  </span><span class="s1">var x = pos.x;</span><span class="s3">\n  </span><span class="s1">var y = pos.y;</span><span class="s3">\n  </span><span class="s1">var nodeW = node.width();</span><span class="s3">\n  </span><span class="s1">var nodeH = node.height();</span><span class="s3">\n  </span><span class="s1">var radius = Math.min(nodeW, nodeH) / 2; // must fit in node</span><span class="s3">\n  </span><span class="s1">var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]</span><span class="s3">\n  </span><span class="s1">var usePaths = this.usePaths();</span><span class="s3">\n  </span><span class="s1">if (usePaths) {</span><span class="s3">\n    </span><span class="s1">x = 0;</span><span class="s3">\n    </span><span class="s1">y = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (pieSize.units === '%') {</span><span class="s3">\n    </span><span class="s1">radius = radius * pieSize.pfValue;</span><span class="s3">\n  </span><span class="s1">} else if (pieSize.pfValue !== undefined) {</span><span class="s3">\n    </span><span class="s1">radius = pieSize.pfValue / 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 1; i &lt;= cyStyle.pieBackgroundN; i++) {</span><span class="s3">\n    </span><span class="s1">// 1..N</span><span class="s3">\n    </span><span class="s1">var size = node.pstyle('pie-' + i + '-background-size').value;</span><span class="s3">\n    </span><span class="s1">var color = node.pstyle('pie-' + i + '-background-color').value;</span><span class="s3">\n    </span><span class="s1">var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;</span><span class="s3">\n    </span><span class="s1">var percent = size / 100; // map integer range [0, 100] to [0, 1]</span><span class="s3">\n\n    </span><span class="s1">// percent can't push beyond 1</span><span class="s3">\n    </span><span class="s1">if (percent + lastPercent &gt; 1) {</span><span class="s3">\n      </span><span class="s1">percent = 1 - lastPercent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise</span><span class="s3">\n    </span><span class="s1">var angleDelta = 2 * Math.PI * percent;</span><span class="s3">\n    </span><span class="s1">var angleEnd = angleStart + angleDelta;</span><span class="s3">\n\n    </span><span class="s1">// ignore if</span><span class="s3">\n    </span><span class="s1">// - zero size</span><span class="s3">\n    </span><span class="s1">// - we're already beyond the full circle</span><span class="s3">\n    </span><span class="s1">// - adding the current slice would go beyond the full circle</span><span class="s3">\n    </span><span class="s1">if (size === 0 || lastPercent &gt;= 1 || lastPercent + percent &gt; 1) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n    </span><span class="s1">context.moveTo(x, y);</span><span class="s3">\n    </span><span class="s1">context.arc(x, y, radius, angleStart, angleEnd);</span><span class="s3">\n    </span><span class="s1">context.closePath();</span><span class="s3">\n    </span><span class="s1">this.colorFillStyle(context, color[0], color[1], color[2], opacity);</span><span class="s3">\n    </span><span class="s1">context.fill();</span><span class="s3">\n    </span><span class="s1">lastPercent += percent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CRp$5 = {};</span><span class="s3">\n</span><span class="s1">var motionBlurDelay = 100;</span><span class="s3">\n\n</span><span class="s1">// var isFirefox = typeof InstallTrigger !== 'undefined';</span><span class="s3">\n\n</span><span class="s1">CRp$5.getPixelRatio = function () {</span><span class="s3">\n  </span><span class="s1">var context = this.data.contexts[0];</span><span class="s3">\n  </span><span class="s1">if (this.forcedPixelRatio != null) {</span><span class="s3">\n    </span><span class="s1">return this.forcedPixelRatio;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var containerWindow = this.cy.window();</span><span class="s3">\n  </span><span class="s1">var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;</span><span class="s3">\n  </span><span class="s1">return (containerWindow.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.paintCache = function (context) {</span><span class="s3">\n  </span><span class="s1">var caches = this.paintCaches = this.paintCaches || [];</span><span class="s3">\n  </span><span class="s1">var needToCreateCache = true;</span><span class="s3">\n  </span><span class="s1">var cache;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; caches.length; i++) {</span><span class="s3">\n    </span><span class="s1">cache = caches[i];</span><span class="s3">\n    </span><span class="s1">if (cache.context === context) {</span><span class="s3">\n      </span><span class="s1">needToCreateCache = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (needToCreateCache) {</span><span class="s3">\n    </span><span class="s1">cache = {</span><span class="s3">\n      </span><span class="s1">context: context</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">caches.push(cache);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cache;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {</span><span class="s3">\n  </span><span class="s1">var gradientStyle;</span><span class="s3">\n  </span><span class="s1">var usePaths = this.usePaths();</span><span class="s3">\n  </span><span class="s1">var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,</span><span class="s3">\n    </span><span class="s1">positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;</span><span class="s3">\n  </span><span class="s1">if (fill === 'radial-gradient') {</span><span class="s3">\n    </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n      </span><span class="s1">var start = ele.sourceEndpoint(),</span><span class="s3">\n        </span><span class="s1">end = ele.targetEndpoint(),</span><span class="s3">\n        </span><span class="s1">mid = ele.midpoint();</span><span class="s3">\n      </span><span class="s1">var d1 = dist(start, mid);</span><span class="s3">\n      </span><span class="s1">var d2 = dist(end, mid);</span><span class="s3">\n      </span><span class="s1">gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var pos = usePaths ? {</span><span class="s3">\n          </span><span class="s1">x: 0,</span><span class="s3">\n          </span><span class="s1">y: 0</span><span class="s3">\n        </span><span class="s1">} : ele.position(),</span><span class="s3">\n        </span><span class="s1">width = ele.paddedWidth(),</span><span class="s3">\n        </span><span class="s1">height = ele.paddedHeight();</span><span class="s3">\n      </span><span class="s1">gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (ele.isEdge()) {</span><span class="s3">\n      </span><span class="s1">var _start = ele.sourceEndpoint(),</span><span class="s3">\n        </span><span class="s1">_end = ele.targetEndpoint();</span><span class="s3">\n      </span><span class="s1">gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var _pos = usePaths ? {</span><span class="s3">\n          </span><span class="s1">x: 0,</span><span class="s3">\n          </span><span class="s1">y: 0</span><span class="s3">\n        </span><span class="s1">} : ele.position(),</span><span class="s3">\n        </span><span class="s1">_width = ele.paddedWidth(),</span><span class="s3">\n        </span><span class="s1">_height = ele.paddedHeight(),</span><span class="s3">\n        </span><span class="s1">halfWidth = _width / 2,</span><span class="s3">\n        </span><span class="s1">halfHeight = _height / 2;</span><span class="s3">\n      </span><span class="s1">var direction = ele.pstyle('background-gradient-direction').value;</span><span class="s3">\n      </span><span class="s1">switch (direction) {</span><span class="s3">\n        </span><span class="s1">case 'to-bottom':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-top':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-left':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-right':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-bottom-right':</span><span class="s3">\n        </span><span class="s1">case 'to-right-bottom':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-top-right':</span><span class="s3">\n        </span><span class="s1">case 'to-right-top':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-bottom-left':</span><span class="s3">\n        </span><span class="s1">case 'to-left-bottom':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'to-top-left':</span><span class="s3">\n        </span><span class="s1">case 'to-left-top':</span><span class="s3">\n          </span><span class="s1">gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!gradientStyle) return null; // invalid gradient style</span><span class="s3">\n\n  </span><span class="s1">var hasPositions = positions.length === colors.length;</span><span class="s3">\n  </span><span class="s1">var length = colors.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; length; i++) {</span><span class="s3">\n    </span><span class="s1">gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return gradientStyle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.gradientFillStyle = function (context, ele, fill, opacity) {</span><span class="s3">\n  </span><span class="s1">var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);</span><span class="s3">\n  </span><span class="s1">if (!gradientStyle) return null; // error</span><span class="s3">\n  </span><span class="s1">context.fillStyle = gradientStyle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.colorFillStyle = function (context, r, g, b, a) {</span><span class="s3">\n  </span><span class="s1">context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';</span><span class="s3">\n  </span><span class="s1">// turn off for now, seems context does its own caching</span><span class="s3">\n\n  </span><span class="s1">// var cache = this.paintCache(context);</span><span class="s3">\n\n  </span><span class="s1">// var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';</span><span class="s3">\n\n  </span><span class="s1">// if( cache.fillStyle !== fillStyle ){</span><span class="s3">\n  </span><span class="s1">//   context.fillStyle = cache.fillStyle = fillStyle;</span><span class="s3">\n  </span><span class="s1">// }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.eleFillStyle = function (context, ele, opacity) {</span><span class="s3">\n  </span><span class="s1">var backgroundFill = ele.pstyle('background-fill').value;</span><span class="s3">\n  </span><span class="s1">if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {</span><span class="s3">\n    </span><span class="s1">this.gradientFillStyle(context, ele, backgroundFill, opacity);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var backgroundColor = ele.pstyle('background-color').value;</span><span class="s3">\n    </span><span class="s1">this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.gradientStrokeStyle = function (context, ele, fill, opacity) {</span><span class="s3">\n  </span><span class="s1">var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);</span><span class="s3">\n  </span><span class="s1">if (!gradientStyle) return null; // error</span><span class="s3">\n  </span><span class="s1">context.strokeStyle = gradientStyle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.colorStrokeStyle = function (context, r, g, b, a) {</span><span class="s3">\n  </span><span class="s1">context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';</span><span class="s3">\n  </span><span class="s1">// turn off for now, seems context does its own caching</span><span class="s3">\n\n  </span><span class="s1">// var cache = this.paintCache(context);</span><span class="s3">\n\n  </span><span class="s1">// var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';</span><span class="s3">\n\n  </span><span class="s1">// if( cache.strokeStyle !== strokeStyle ){</span><span class="s3">\n  </span><span class="s1">//   context.strokeStyle = cache.strokeStyle = strokeStyle;</span><span class="s3">\n  </span><span class="s1">// }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.eleStrokeStyle = function (context, ele, opacity) {</span><span class="s3">\n  </span><span class="s1">var lineFill = ele.pstyle('line-fill').value;</span><span class="s3">\n  </span><span class="s1">if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {</span><span class="s3">\n    </span><span class="s1">this.gradientStrokeStyle(context, ele, lineFill, opacity);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var lineColor = ele.pstyle('line-color').value;</span><span class="s3">\n    </span><span class="s1">this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Resize canvas</span><span class="s3">\n</span><span class="s1">CRp$5.matchCanvasSize = function (container) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var data = r.data;</span><span class="s3">\n  </span><span class="s1">var bb = r.findContainerClientCoords();</span><span class="s3">\n  </span><span class="s1">var width = bb[2];</span><span class="s3">\n  </span><span class="s1">var height = bb[3];</span><span class="s3">\n  </span><span class="s1">var pixelRatio = r.getPixelRatio();</span><span class="s3">\n  </span><span class="s1">var mbPxRatio = r.motionBlurPxRatio;</span><span class="s3">\n  </span><span class="s1">if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {</span><span class="s3">\n    </span><span class="s1">pixelRatio = mbPxRatio;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var canvasWidth = width * pixelRatio;</span><span class="s3">\n  </span><span class="s1">var canvasHeight = height * pixelRatio;</span><span class="s3">\n  </span><span class="s1">var canvas;</span><span class="s3">\n  </span><span class="s1">if (canvasWidth === r.canvasWidth &amp;&amp; canvasHeight === r.canvasHeight) {</span><span class="s3">\n    </span><span class="s1">return; // save cycles if same</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.fontCaches = null; // resizing resets the style</span><span class="s3">\n\n  </span><span class="s1">var canvasContainer = data.canvasContainer;</span><span class="s3">\n  </span><span class="s1">canvasContainer.style.width = width + 'px';</span><span class="s3">\n  </span><span class="s1">canvasContainer.style.height = height + 'px';</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; r.CANVAS_LAYERS; i++) {</span><span class="s3">\n    </span><span class="s1">canvas = data.canvases[i];</span><span class="s3">\n    </span><span class="s1">canvas.width = canvasWidth;</span><span class="s3">\n    </span><span class="s1">canvas.height = canvasHeight;</span><span class="s3">\n    </span><span class="s1">canvas.style.width = width + 'px';</span><span class="s3">\n    </span><span class="s1">canvas.style.height = height + 'px';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; r.BUFFER_COUNT; i++) {</span><span class="s3">\n    </span><span class="s1">canvas = data.bufferCanvases[i];</span><span class="s3">\n    </span><span class="s1">canvas.width = canvasWidth;</span><span class="s3">\n    </span><span class="s1">canvas.height = canvasHeight;</span><span class="s3">\n    </span><span class="s1">canvas.style.width = width + 'px';</span><span class="s3">\n    </span><span class="s1">canvas.style.height = height + 'px';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.textureMult = 1;</span><span class="s3">\n  </span><span class="s1">if (pixelRatio &lt;= 1) {</span><span class="s3">\n    </span><span class="s1">canvas = data.bufferCanvases[r.TEXTURE_BUFFER];</span><span class="s3">\n    </span><span class="s1">r.textureMult = 2;</span><span class="s3">\n    </span><span class="s1">canvas.width = canvasWidth * r.textureMult;</span><span class="s3">\n    </span><span class="s1">canvas.height = canvasHeight * r.textureMult;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.canvasWidth = canvasWidth;</span><span class="s3">\n  </span><span class="s1">r.canvasHeight = canvasHeight;</span><span class="s3">\n  </span><span class="s1">r.pixelRatio = pixelRatio;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.renderTo = function (cxt, zoom, pan, pxRatio) {</span><span class="s3">\n  </span><span class="s1">this.render({</span><span class="s3">\n    </span><span class="s1">forcedContext: cxt,</span><span class="s3">\n    </span><span class="s1">forcedZoom: zoom,</span><span class="s3">\n    </span><span class="s1">forcedPan: pan,</span><span class="s3">\n    </span><span class="s1">drawAllLayers: true,</span><span class="s3">\n    </span><span class="s1">forcedPxRatio: pxRatio</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.clearCanvas = function () {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var data = r.data;</span><span class="s3">\n  </span><span class="s1">function clear(context) {</span><span class="s3">\n    </span><span class="s1">context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">clear(data.contexts[r.NODE]);</span><span class="s3">\n  </span><span class="s1">clear(data.contexts[r.DRAG]);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$5.render = function (options) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">options = options || staticEmptyObject();</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n  </span><span class="s1">var forcedContext = options.forcedContext;</span><span class="s3">\n  </span><span class="s1">var drawAllLayers = options.drawAllLayers;</span><span class="s3">\n  </span><span class="s1">var drawOnlyNodeLayer = options.drawOnlyNodeLayer;</span><span class="s3">\n  </span><span class="s1">var forcedZoom = options.forcedZoom;</span><span class="s3">\n  </span><span class="s1">var forcedPan = options.forcedPan;</span><span class="s3">\n  </span><span class="s1">var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;</span><span class="s3">\n  </span><span class="s1">var data = r.data;</span><span class="s3">\n  </span><span class="s1">var needDraw = data.canvasNeedsRedraw;</span><span class="s3">\n  </span><span class="s1">var textureDraw = r.textureOnViewport &amp;&amp; !forcedContext &amp;&amp; (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);</span><span class="s3">\n  </span><span class="s1">var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;</span><span class="s3">\n  </span><span class="s1">var mbPxRatio = r.motionBlurPxRatio;</span><span class="s3">\n  </span><span class="s1">var hasCompoundNodes = cy.hasCompoundNodes();</span><span class="s3">\n  </span><span class="s1">var inNodeDragGesture = r.hoverData.draggingEles;</span><span class="s3">\n  </span><span class="s1">var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;</span><span class="s3">\n  </span><span class="s1">motionBlur = motionBlur &amp;&amp; !forcedContext &amp;&amp; r.motionBlurEnabled &amp;&amp; !inBoxSelection;</span><span class="s3">\n  </span><span class="s1">var motionBlurFadeEffect = motionBlur;</span><span class="s3">\n  </span><span class="s1">if (!forcedContext) {</span><span class="s3">\n    </span><span class="s1">if (r.prevPxRatio !== pixelRatio) {</span><span class="s3">\n      </span><span class="s1">r.invalidateContainerClientCoordsCache();</span><span class="s3">\n      </span><span class="s1">r.matchCanvasSize(r.container);</span><span class="s3">\n      </span><span class="s1">r.redrawHint('eles', true);</span><span class="s3">\n      </span><span class="s1">r.redrawHint('drag', true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.prevPxRatio = pixelRatio;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!forcedContext &amp;&amp; r.motionBlurTimeout) {</span><span class="s3">\n    </span><span class="s1">clearTimeout(r.motionBlurTimeout);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (motionBlur) {</span><span class="s3">\n    </span><span class="s1">if (r.mbFrames == null) {</span><span class="s3">\n      </span><span class="s1">r.mbFrames = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.mbFrames++;</span><span class="s3">\n    </span><span class="s1">if (r.mbFrames &lt; 3) {</span><span class="s3">\n      </span><span class="s1">// need several frames before even high quality motionblur</span><span class="s3">\n      </span><span class="s1">motionBlurFadeEffect = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)</span><span class="s3">\n    </span><span class="s1">if (r.mbFrames &gt; r.minMbLowQualFrames) {</span><span class="s3">\n      </span><span class="s1">//r.fullQualityMb = false;</span><span class="s3">\n      </span><span class="s1">r.motionBlurPxRatio = r.mbPxRBlurry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.clearingMotionBlur) {</span><span class="s3">\n    </span><span class="s1">r.motionBlurPxRatio = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame</span><span class="s3">\n  </span><span class="s1">// because a rogue async texture frame would clear needDraw</span><span class="s3">\n  </span><span class="s1">if (r.textureDrawLastFrame &amp;&amp; !textureDraw) {</span><span class="s3">\n    </span><span class="s1">needDraw[r.NODE] = true;</span><span class="s3">\n    </span><span class="s1">needDraw[r.SELECT_BOX] = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var style = cy.style();</span><span class="s3">\n  </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n  </span><span class="s1">var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;</span><span class="s3">\n  </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n  </span><span class="s1">var effectivePan = {</span><span class="s3">\n    </span><span class="s1">x: pan.x,</span><span class="s3">\n    </span><span class="s1">y: pan.y</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var vp = {</span><span class="s3">\n    </span><span class="s1">zoom: zoom,</span><span class="s3">\n    </span><span class="s1">pan: {</span><span class="s3">\n      </span><span class="s1">x: pan.x,</span><span class="s3">\n      </span><span class="s1">y: pan.y</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var prevVp = r.prevViewport;</span><span class="s3">\n  </span><span class="s1">var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;</span><span class="s3">\n\n  </span><span class="s1">// we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)</span><span class="s3">\n  </span><span class="s1">if (!viewportIsDiff &amp;&amp; !(inNodeDragGesture &amp;&amp; !hasCompoundNodes)) {</span><span class="s3">\n    </span><span class="s1">r.motionBlurPxRatio = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (forcedPan) {</span><span class="s3">\n    </span><span class="s1">effectivePan = forcedPan;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// apply pixel ratio</span><span class="s3">\n\n  </span><span class="s1">effectiveZoom *= pixelRatio;</span><span class="s3">\n  </span><span class="s1">effectivePan.x *= pixelRatio;</span><span class="s3">\n  </span><span class="s1">effectivePan.y *= pixelRatio;</span><span class="s3">\n  </span><span class="s1">var eles = r.getCachedZSortedEles();</span><span class="s3">\n  </span><span class="s1">function mbclear(context, x, y, w, h) {</span><span class="s3">\n    </span><span class="s1">var gco = context.globalCompositeOperation;</span><span class="s3">\n    </span><span class="s1">context.globalCompositeOperation = 'destination-out';</span><span class="s3">\n    </span><span class="s1">r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);</span><span class="s3">\n    </span><span class="s1">context.fillRect(x, y, w, h);</span><span class="s3">\n    </span><span class="s1">context.globalCompositeOperation = gco;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function setContextTransform(context, clear) {</span><span class="s3">\n    </span><span class="s1">var ePan, eZoom, w, h;</span><span class="s3">\n    </span><span class="s1">if (!r.clearingMotionBlur &amp;&amp; (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {</span><span class="s3">\n      </span><span class="s1">ePan = {</span><span class="s3">\n        </span><span class="s1">x: pan.x * mbPxRatio,</span><span class="s3">\n        </span><span class="s1">y: pan.y * mbPxRatio</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">eZoom = zoom * mbPxRatio;</span><span class="s3">\n      </span><span class="s1">w = r.canvasWidth * mbPxRatio;</span><span class="s3">\n      </span><span class="s1">h = r.canvasHeight * mbPxRatio;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">ePan = effectivePan;</span><span class="s3">\n      </span><span class="s1">eZoom = effectiveZoom;</span><span class="s3">\n      </span><span class="s1">w = r.canvasWidth;</span><span class="s3">\n      </span><span class="s1">h = r.canvasHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n    </span><span class="s1">if (clear === 'motionBlur') {</span><span class="s3">\n      </span><span class="s1">mbclear(context, 0, 0, w, h);</span><span class="s3">\n    </span><span class="s1">} else if (!forcedContext &amp;&amp; (clear === undefined || clear)) {</span><span class="s3">\n      </span><span class="s1">context.clearRect(0, 0, w, h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!drawAllLayers) {</span><span class="s3">\n      </span><span class="s1">context.translate(ePan.x, ePan.y);</span><span class="s3">\n      </span><span class="s1">context.scale(eZoom, eZoom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (forcedPan) {</span><span class="s3">\n      </span><span class="s1">context.translate(forcedPan.x, forcedPan.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (forcedZoom) {</span><span class="s3">\n      </span><span class="s1">context.scale(forcedZoom, forcedZoom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!textureDraw) {</span><span class="s3">\n    </span><span class="s1">r.textureDrawLastFrame = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (textureDraw) {</span><span class="s3">\n    </span><span class="s1">r.textureDrawLastFrame = true;</span><span class="s3">\n    </span><span class="s1">if (!r.textureCache) {</span><span class="s3">\n      </span><span class="s1">r.textureCache = {};</span><span class="s3">\n      </span><span class="s1">r.textureCache.bb = cy.mutableElements().boundingBox();</span><span class="s3">\n      </span><span class="s1">r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];</span><span class="s3">\n      </span><span class="s1">var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];</span><span class="s3">\n      </span><span class="s1">cxt.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n      </span><span class="s1">cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);</span><span class="s3">\n      </span><span class="s1">r.render({</span><span class="s3">\n        </span><span class="s1">forcedContext: cxt,</span><span class="s3">\n        </span><span class="s1">drawOnlyNodeLayer: true,</span><span class="s3">\n        </span><span class="s1">forcedPxRatio: pixelRatio * r.textureMult</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">var vp = r.textureCache.viewport = {</span><span class="s3">\n        </span><span class="s1">zoom: cy.zoom(),</span><span class="s3">\n        </span><span class="s1">pan: cy.pan(),</span><span class="s3">\n        </span><span class="s1">width: r.canvasWidth,</span><span class="s3">\n        </span><span class="s1">height: r.canvasHeight</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">vp.mpan = {</span><span class="s3">\n        </span><span class="s1">x: (0 - vp.pan.x) / vp.zoom,</span><span class="s3">\n        </span><span class="s1">y: (0 - vp.pan.y) / vp.zoom</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">needDraw[r.DRAG] = false;</span><span class="s3">\n    </span><span class="s1">needDraw[r.NODE] = false;</span><span class="s3">\n    </span><span class="s1">var context = data.contexts[r.NODE];</span><span class="s3">\n    </span><span class="s1">var texture = r.textureCache.texture;</span><span class="s3">\n    </span><span class="s1">var vp = r.textureCache.viewport;</span><span class="s3">\n    </span><span class="s1">context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n    </span><span class="s1">if (motionBlur) {</span><span class="s3">\n      </span><span class="s1">mbclear(context, 0, 0, vp.width, vp.height);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">context.clearRect(0, 0, vp.width, vp.height);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var outsideBgColor = style.core('outside-texture-bg-color').value;</span><span class="s3">\n    </span><span class="s1">var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;</span><span class="s3">\n    </span><span class="s1">r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);</span><span class="s3">\n    </span><span class="s1">context.fillRect(0, 0, vp.width, vp.height);</span><span class="s3">\n    </span><span class="s1">var zoom = cy.zoom();</span><span class="s3">\n    </span><span class="s1">setContextTransform(context, false);</span><span class="s3">\n    </span><span class="s1">context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);</span><span class="s3">\n    </span><span class="s1">context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);</span><span class="s3">\n  </span><span class="s1">} else if (r.textureOnViewport &amp;&amp; !forcedContext) {</span><span class="s3">\n    </span><span class="s1">// clear the cache since we don't need it</span><span class="s3">\n    </span><span class="s1">r.textureCache = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var extent = cy.extent();</span><span class="s3">\n  </span><span class="s1">var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();</span><span class="s3">\n  </span><span class="s1">var hideEdges = r.hideEdgesOnViewport &amp;&amp; vpManip;</span><span class="s3">\n  </span><span class="s1">var needMbClear = [];</span><span class="s3">\n  </span><span class="s1">needMbClear[r.NODE] = !needDraw[r.NODE] &amp;&amp; motionBlur &amp;&amp; !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;</span><span class="s3">\n  </span><span class="s1">if (needMbClear[r.NODE]) {</span><span class="s3">\n    </span><span class="s1">r.clearedForMotionBlur[r.NODE] = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">needMbClear[r.DRAG] = !needDraw[r.DRAG] &amp;&amp; motionBlur &amp;&amp; !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;</span><span class="s3">\n  </span><span class="s1">if (needMbClear[r.DRAG]) {</span><span class="s3">\n    </span><span class="s1">r.clearedForMotionBlur[r.DRAG] = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {</span><span class="s3">\n    </span><span class="s1">var useBuffer = motionBlur &amp;&amp; !needMbClear[r.NODE] &amp;&amp; mbPxRatio !== 1;</span><span class="s3">\n    </span><span class="s1">var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);</span><span class="s3">\n    </span><span class="s1">var clear = motionBlur &amp;&amp; !useBuffer ? 'motionBlur' : undefined;</span><span class="s3">\n    </span><span class="s1">setContextTransform(context, clear);</span><span class="s3">\n    </span><span class="s1">if (hideEdges) {</span><span class="s3">\n      </span><span class="s1">r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (r.debug) {</span><span class="s3">\n      </span><span class="s1">r.drawDebugPoints(context, eles.nondrag);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!drawAllLayers &amp;&amp; !motionBlur) {</span><span class="s3">\n      </span><span class="s1">needDraw[r.NODE] = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!drawOnlyNodeLayer &amp;&amp; (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {</span><span class="s3">\n    </span><span class="s1">var useBuffer = motionBlur &amp;&amp; !needMbClear[r.DRAG] &amp;&amp; mbPxRatio !== 1;</span><span class="s3">\n    </span><span class="s1">var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);</span><span class="s3">\n    </span><span class="s1">setContextTransform(context, motionBlur &amp;&amp; !useBuffer ? 'motionBlur' : undefined);</span><span class="s3">\n    </span><span class="s1">if (hideEdges) {</span><span class="s3">\n      </span><span class="s1">r.drawCachedNodes(context, eles.drag, pixelRatio, extent);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">r.drawCachedElements(context, eles.drag, pixelRatio, extent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (r.debug) {</span><span class="s3">\n      </span><span class="s1">r.drawDebugPoints(context, eles.drag);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!drawAllLayers &amp;&amp; !motionBlur) {</span><span class="s3">\n      </span><span class="s1">needDraw[r.DRAG] = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.drawSelectionRectangle(options, setContextTransform);</span><span class="s3">\n\n  </span><span class="s1">// motionblur: blit rendered blurry frames</span><span class="s3">\n  </span><span class="s1">if (motionBlur &amp;&amp; mbPxRatio !== 1) {</span><span class="s3">\n    </span><span class="s1">var cxtNode = data.contexts[r.NODE];</span><span class="s3">\n    </span><span class="s1">var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];</span><span class="s3">\n    </span><span class="s1">var cxtDrag = data.contexts[r.DRAG];</span><span class="s3">\n    </span><span class="s1">var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];</span><span class="s3">\n    </span><span class="s1">var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {</span><span class="s3">\n      </span><span class="s1">cxt.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n      </span><span class="s1">if (needClear || !motionBlurFadeEffect) {</span><span class="s3">\n        </span><span class="s1">cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var pxr = mbPxRatio;</span><span class="s3">\n      </span><span class="s1">cxt.drawImage(txt,</span><span class="s3">\n      </span><span class="s1">// img</span><span class="s3">\n      </span><span class="s1">0, 0,</span><span class="s3">\n      </span><span class="s1">// sx, sy</span><span class="s3">\n      </span><span class="s1">r.canvasWidth * pxr, r.canvasHeight * pxr,</span><span class="s3">\n      </span><span class="s1">// sw, sh</span><span class="s3">\n      </span><span class="s1">0, 0,</span><span class="s3">\n      </span><span class="s1">// x, y</span><span class="s3">\n      </span><span class="s1">r.canvasWidth, r.canvasHeight // w, h</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (needDraw[r.NODE] || needMbClear[r.NODE]) {</span><span class="s3">\n      </span><span class="s1">drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);</span><span class="s3">\n      </span><span class="s1">needDraw[r.NODE] = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {</span><span class="s3">\n      </span><span class="s1">drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);</span><span class="s3">\n      </span><span class="s1">needDraw[r.DRAG] = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.prevViewport = vp;</span><span class="s3">\n  </span><span class="s1">if (r.clearingMotionBlur) {</span><span class="s3">\n    </span><span class="s1">r.clearingMotionBlur = false;</span><span class="s3">\n    </span><span class="s1">r.motionBlurCleared = true;</span><span class="s3">\n    </span><span class="s1">r.motionBlur = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (motionBlur) {</span><span class="s3">\n    </span><span class="s1">r.motionBlurTimeout = setTimeout(function () {</span><span class="s3">\n      </span><span class="s1">r.motionBlurTimeout = null;</span><span class="s3">\n      </span><span class="s1">r.clearedForMotionBlur[r.NODE] = false;</span><span class="s3">\n      </span><span class="s1">r.clearedForMotionBlur[r.DRAG] = false;</span><span class="s3">\n      </span><span class="s1">r.motionBlur = false;</span><span class="s3">\n      </span><span class="s1">r.clearingMotionBlur = !textureDraw;</span><span class="s3">\n      </span><span class="s1">r.mbFrames = 0;</span><span class="s3">\n      </span><span class="s1">needDraw[r.NODE] = true;</span><span class="s3">\n      </span><span class="s1">needDraw[r.DRAG] = true;</span><span class="s3">\n      </span><span class="s1">r.redraw();</span><span class="s3">\n    </span><span class="s1">}, motionBlurDelay);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!forcedContext) {</span><span class="s3">\n    </span><span class="s1">cy.emit('render');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var fpsHeight;</span><span class="s3">\n</span><span class="s1">CRp$5.drawSelectionRectangle = function (options, setContextTransform) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var cy = r.cy;</span><span class="s3">\n  </span><span class="s1">var data = r.data;</span><span class="s3">\n  </span><span class="s1">var style = cy.style();</span><span class="s3">\n  </span><span class="s1">var drawOnlyNodeLayer = options.drawOnlyNodeLayer;</span><span class="s3">\n  </span><span class="s1">var drawAllLayers = options.drawAllLayers;</span><span class="s3">\n  </span><span class="s1">var needDraw = data.canvasNeedsRedraw;</span><span class="s3">\n  </span><span class="s1">var forcedContext = options.forcedContext;</span><span class="s3">\n  </span><span class="s1">if (r.showFps || !drawOnlyNodeLayer &amp;&amp; needDraw[r.SELECT_BOX] &amp;&amp; !drawAllLayers) {</span><span class="s3">\n    </span><span class="s1">var context = forcedContext || data.contexts[r.SELECT_BOX];</span><span class="s3">\n    </span><span class="s1">setContextTransform(context);</span><span class="s3">\n    </span><span class="s1">if (r.selection[4] == 1 &amp;&amp; (r.hoverData.selecting || r.touchData.selecting)) {</span><span class="s3">\n      </span><span class="s1">var zoom = r.cy.zoom();</span><span class="s3">\n      </span><span class="s1">var borderWidth = style.core('selection-box-border-width').value / zoom;</span><span class="s3">\n      </span><span class="s1">context.lineWidth = borderWidth;</span><span class="s3">\n      </span><span class="s1">context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';</span><span class="s3">\n      </span><span class="s1">context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);</span><span class="s3">\n      </span><span class="s1">if (borderWidth &gt; 0) {</span><span class="s3">\n        </span><span class="s1">context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';</span><span class="s3">\n        </span><span class="s1">context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (data.bgActivePosistion &amp;&amp; !r.hoverData.selecting) {</span><span class="s3">\n      </span><span class="s1">var zoom = r.cy.zoom();</span><span class="s3">\n      </span><span class="s1">var pos = data.bgActivePosistion;</span><span class="s3">\n      </span><span class="s1">context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';</span><span class="s3">\n      </span><span class="s1">context.beginPath();</span><span class="s3">\n      </span><span class="s1">context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);</span><span class="s3">\n      </span><span class="s1">context.fill();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var timeToRender = r.lastRedrawTime;</span><span class="s3">\n    </span><span class="s1">if (r.showFps &amp;&amp; timeToRender) {</span><span class="s3">\n      </span><span class="s1">timeToRender = Math.round(timeToRender);</span><span class="s3">\n      </span><span class="s1">var fps = Math.round(1000 / timeToRender);</span><span class="s3">\n      </span><span class="s1">var text = '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps';</span><span class="s3">\n      </span><span class="s1">context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n      </span><span class="s1">context.fillStyle = 'rgba(255, 0, 0, 0.75)';</span><span class="s3">\n      </span><span class="s1">context.strokeStyle = 'rgba(255, 0, 0, 0.75)';</span><span class="s3">\n      </span><span class="s1">// context.lineWidth = 1;</span><span class="s3">\n      </span><span class="s1">context.font = '30px Arial';</span><span class="s3">\n      </span><span class="s1">if (!fpsHeight) {</span><span class="s3">\n        </span><span class="s1">var dims = context.measureText(text);</span><span class="s3">\n        </span><span class="s1">fpsHeight = dims.actualBoundingBoxAscent;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">context.fillText(text, 0, fpsHeight);</span><span class="s3">\n      </span><span class="s1">var maxFps = 60;</span><span class="s3">\n      </span><span class="s1">context.strokeRect(0, fpsHeight + 10, 250, 20);</span><span class="s3">\n      </span><span class="s1">context.fillRect(0, fpsHeight + 10, 250 * Math.min(fps / maxFps, 1), 20);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!drawAllLayers) {</span><span class="s3">\n      </span><span class="s1">needDraw[r.SELECT_BOX] = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Notes:</span><span class="s3">\n </span><span class="s1">* - All colors have premultiplied alpha. Very important for textues and </span><span class="s3">\n </span><span class="s1">*   blending to work correctly.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function compileShader(gl, type, source) {</span><span class="s3">\n  </span><span class="s1">var shader = gl.createShader(type);</span><span class="s3">\n  </span><span class="s1">gl.shaderSource(shader, source);</span><span class="s3">\n  </span><span class="s1">gl.compileShader(shader);</span><span class="s3">\n  </span><span class="s1">if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(gl.getShaderInfoLog(shader));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// console.log(gl.getShaderInfoLog(shader));</span><span class="s3">\n  </span><span class="s1">return shader;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createProgram(gl, vertexSource, fragementSource) {</span><span class="s3">\n  </span><span class="s1">var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);</span><span class="s3">\n  </span><span class="s1">var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragementSource);</span><span class="s3">\n  </span><span class="s1">var program = gl.createProgram();</span><span class="s3">\n  </span><span class="s1">gl.attachShader(program, vertexShader);</span><span class="s3">\n  </span><span class="s1">gl.attachShader(program, fragmentShader);</span><span class="s3">\n  </span><span class="s1">gl.linkProgram(program);</span><span class="s3">\n  </span><span class="s1">if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Could not initialize shaders');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return program;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an offscren canvas with a 2D context, for the</span><span class="s3">\n </span><span class="s1">* canvas renderer to use for drawing textures.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createTextureCanvas(r, width, height) {</span><span class="s3">\n  </span><span class="s1">if (height === undefined) {</span><span class="s3">\n    </span><span class="s1">height = width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var canvas = r.makeOffscreenCanvas(width, height);</span><span class="s3">\n  </span><span class="s1">var ctx = canvas.context = canvas.getContext('2d');</span><span class="s3">\n  </span><span class="s1">canvas.clear = function () {</span><span class="s3">\n    </span><span class="s1">return ctx.clearRect(0, 0, canvas.width, canvas.height);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">canvas.clear();</span><span class="s3">\n  </span><span class="s1">return canvas;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the current pan &amp; zoom values, scaled by the pixel ratio.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getEffectivePanZoom(r) {</span><span class="s3">\n  </span><span class="s1">var pixelRatio = r.pixelRatio;</span><span class="s3">\n  </span><span class="s1">var zoom = r.cy.zoom();</span><span class="s3">\n  </span><span class="s1">var pan = r.cy.pan();</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">zoom: zoom * pixelRatio,</span><span class="s3">\n    </span><span class="s1">pan: {</span><span class="s3">\n      </span><span class="s1">x: pan.x * pixelRatio,</span><span class="s3">\n      </span><span class="s1">y: pan.y * pixelRatio</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function modelToRenderedPosition(r, pan, zoom, x, y) {</span><span class="s3">\n  </span><span class="s1">var rx = x * zoom + pan.x;</span><span class="s3">\n  </span><span class="s1">var ry = y * zoom + pan.y;</span><span class="s3">\n  </span><span class="s1">ry = Math.round(r.canvasHeight - ry); // adjust for webgl</span><span class="s3">\n  </span><span class="s1">return [rx, ry];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes color &amp; opacity style values and converts them to WebGL format. </span><span class="s3">\n </span><span class="s1">* Alpha is premultiplied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toWebGLColor(color, opacity, outArray) {</span><span class="s3">\n  </span><span class="s1">var r = color[0] / 255;</span><span class="s3">\n  </span><span class="s1">var g = color[1] / 255;</span><span class="s3">\n  </span><span class="s1">var b = color[2] / 255;</span><span class="s3">\n  </span><span class="s1">var a = opacity;</span><span class="s3">\n  </span><span class="s1">var arr = outArray || new Array(4);</span><span class="s3">\n  </span><span class="s1">arr[0] = r * a;</span><span class="s3">\n  </span><span class="s1">arr[1] = g * a;</span><span class="s3">\n  </span><span class="s1">arr[2] = b * a;</span><span class="s3">\n  </span><span class="s1">arr[3] = a;</span><span class="s3">\n  </span><span class="s1">return arr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function indexToVec4(index, outArray) {</span><span class="s3">\n  </span><span class="s1">var arr = outArray || new Array(4);</span><span class="s3">\n  </span><span class="s1">arr[0] = (index &gt;&gt; 0 &amp; 0xFF) / 0xFF;</span><span class="s3">\n  </span><span class="s1">arr[1] = (index &gt;&gt; 8 &amp; 0xFF) / 0xFF;</span><span class="s3">\n  </span><span class="s1">arr[2] = (index &gt;&gt; 16 &amp; 0xFF) / 0xFF;</span><span class="s3">\n  </span><span class="s1">arr[3] = (index &gt;&gt; 24 &amp; 0xFF) / 0xFF;</span><span class="s3">\n  </span><span class="s1">return arr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function vec4ToIndex(vec4) {</span><span class="s3">\n  </span><span class="s1">return vec4[0] + (vec4[1] &lt;&lt; 8) + (vec4[2] &lt;&lt; 16) + (vec4[3] &lt;&lt; 24);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createTexture(gl, debugID) {</span><span class="s3">\n  </span><span class="s1">var texture = gl.createTexture();</span><span class="s3">\n  </span><span class="s1">texture.buffer = function (offscreenCanvas) {</span><span class="s3">\n    </span><span class="s1">gl.bindTexture(gl.TEXTURE_2D, texture);</span><span class="s3">\n    </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><span class="s3">\n    </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><span class="s3">\n    </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);</span><span class="s3">\n    </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);</span><span class="s3">\n\n    </span><span class="s1">// very important, this tells webgl to premultiply colors by the alpha channel</span><span class="s3">\n    </span><span class="s1">gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);</span><span class="s3">\n    </span><span class="s1">gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreenCanvas);</span><span class="s3">\n    </span><span class="s1">gl.generateMipmap(gl.TEXTURE_2D);</span><span class="s3">\n    </span><span class="s1">gl.bindTexture(gl.TEXTURE_2D, null);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">texture.deleteTexture = function () {</span><span class="s3">\n    </span><span class="s1">gl.deleteTexture(texture);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return texture;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getTypeInfo(gl, glslType) {</span><span class="s3">\n  </span><span class="s1">switch (glslType) {</span><span class="s3">\n    </span><span class="s1">case 'float':</span><span class="s3">\n      </span><span class="s1">return [1, gl.FLOAT, 4];</span><span class="s3">\n    </span><span class="s1">case 'vec2':</span><span class="s3">\n      </span><span class="s1">return [2, gl.FLOAT, 4];</span><span class="s3">\n    </span><span class="s1">case 'vec3':</span><span class="s3">\n      </span><span class="s1">return [3, gl.FLOAT, 4];</span><span class="s3">\n    </span><span class="s1">case 'vec4':</span><span class="s3">\n      </span><span class="s1">return [4, gl.FLOAT, 4];</span><span class="s3">\n    </span><span class="s1">case 'int':</span><span class="s3">\n      </span><span class="s1">return [1, gl.INT, 4];</span><span class="s3">\n    </span><span class="s1">case 'ivec2':</span><span class="s3">\n      </span><span class="s1">return [2, gl.INT, 4];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createTypedArray(gl, glType, dataOrSize) {</span><span class="s3">\n  </span><span class="s1">switch (glType) {</span><span class="s3">\n    </span><span class="s1">case gl.FLOAT:</span><span class="s3">\n      </span><span class="s1">return new Float32Array(dataOrSize);</span><span class="s3">\n    </span><span class="s1">case gl.INT:</span><span class="s3">\n      </span><span class="s1">return new Int32Array(dataOrSize);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createTypedArrayView(gl, glType, array, stride, size, i) {</span><span class="s3">\n  </span><span class="s1">switch (glType) {</span><span class="s3">\n    </span><span class="s1">case gl.FLOAT:</span><span class="s3">\n      </span><span class="s1">return new Float32Array(array.buffer, i * stride, size);</span><span class="s3">\n    </span><span class="s1">case gl.INT:</span><span class="s3">\n      </span><span class="s1">return new Int32Array(array.buffer, i * stride, size);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** @param {WebGLRenderingContext} gl */</span><span class="s3">\n</span><span class="s1">function createBufferStaticDraw(gl, type, attributeLoc, dataArray) {</span><span class="s3">\n  </span><span class="s1">var _getTypeInfo = getTypeInfo(gl, type),</span><span class="s3">\n    </span><span class="s1">_getTypeInfo2 = _slicedToArray(_getTypeInfo, 2),</span><span class="s3">\n    </span><span class="s1">size = _getTypeInfo2[0],</span><span class="s3">\n    </span><span class="s1">glType = _getTypeInfo2[1];</span><span class="s3">\n  </span><span class="s1">var data = createTypedArray(gl, glType, dataArray);</span><span class="s3">\n  </span><span class="s1">var buffer = gl.createBuffer();</span><span class="s3">\n  </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><span class="s3">\n  </span><span class="s1">gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><span class="s3">\n  </span><span class="s1">if (glType === gl.FLOAT) {</span><span class="s3">\n    </span><span class="s1">gl.vertexAttribPointer(attributeLoc, size, glType, false, 0, 0);</span><span class="s3">\n  </span><span class="s1">} else if (glType === gl.INT) {</span><span class="s3">\n    </span><span class="s1">gl.vertexAttribIPointer(attributeLoc, size, glType, 0, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gl.enableVertexAttribArray(attributeLoc);</span><span class="s3">\n  </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, null);</span><span class="s3">\n  </span><span class="s1">return buffer;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** </span><span class="s3">\n </span><span class="s1">* Creates a float buffer with gl.DYNAMIC_DRAW.</span><span class="s3">\n </span><span class="s1">* The returned buffer object contains functions to easily set instance data and buffer the data before a draw call.</span><span class="s3">\n </span><span class="s1">* @param {WebGLRenderingContext} gl </span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createBufferDynamicDraw(gl, instances, type, attributeLoc) {</span><span class="s3">\n  </span><span class="s1">var _getTypeInfo3 = getTypeInfo(gl, type),</span><span class="s3">\n    </span><span class="s1">_getTypeInfo4 = _slicedToArray(_getTypeInfo3, 3),</span><span class="s3">\n    </span><span class="s1">size = _getTypeInfo4[0],</span><span class="s3">\n    </span><span class="s1">glType = _getTypeInfo4[1],</span><span class="s3">\n    </span><span class="s1">bytes = _getTypeInfo4[2];</span><span class="s3">\n  </span><span class="s1">var dataArray = createTypedArray(gl, glType, instances * size);</span><span class="s3">\n  </span><span class="s1">var stride = size * bytes;</span><span class="s3">\n  </span><span class="s1">var buffer = gl.createBuffer();</span><span class="s3">\n  </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><span class="s3">\n  </span><span class="s1">gl.bufferData(gl.ARRAY_BUFFER, instances * stride, gl.DYNAMIC_DRAW);</span><span class="s3">\n  </span><span class="s1">gl.enableVertexAttribArray(attributeLoc);</span><span class="s3">\n  </span><span class="s1">if (glType === gl.FLOAT) {</span><span class="s3">\n    </span><span class="s1">gl.vertexAttribPointer(attributeLoc, size, glType, false, stride, 0);</span><span class="s3">\n  </span><span class="s1">} else if (glType === gl.INT) {</span><span class="s3">\n    </span><span class="s1">gl.vertexAttribIPointer(attributeLoc, size, glType, stride, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gl.vertexAttribDivisor(attributeLoc, 1);</span><span class="s3">\n  </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, null);</span><span class="s3">\n\n  </span><span class="s1">// use array views to set values directly into the buffer array</span><span class="s3">\n  </span><span class="s1">var views = new Array(instances);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; instances; i++) {</span><span class="s3">\n    </span><span class="s1">views[i] = createTypedArrayView(gl, glType, dataArray, stride, size, i);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">buffer.dataArray = dataArray;</span><span class="s3">\n  </span><span class="s1">buffer.stride = stride;</span><span class="s3">\n  </span><span class="s1">buffer.size = size;</span><span class="s3">\n  </span><span class="s1">buffer.getView = function (i) {</span><span class="s3">\n    </span><span class="s1">return views[i];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">buffer.setPoint = function (i, x, y) {</span><span class="s3">\n    </span><span class="s1">var view = views[i];</span><span class="s3">\n    </span><span class="s1">view[0] = x;</span><span class="s3">\n    </span><span class="s1">view[1] = y;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">buffer.bufferSubData = function (count) {</span><span class="s3">\n    </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><span class="s3">\n    </span><span class="s1">if (count) {</span><span class="s3">\n      </span><span class="s1">gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray, 0, count * size);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return buffer;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** </span><span class="s3">\n </span><span class="s1">* Creates a buffer of 3x3 matrix data for use as attribute data.</span><span class="s3">\n </span><span class="s1">* @param {WebGLRenderingContext} gl </span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function create3x3MatrixBufferDynamicDraw(gl, instances, attributeLoc) {</span><span class="s3">\n  </span><span class="s1">var matrixSize = 9; // 3x3 matrix</span><span class="s3">\n  </span><span class="s1">var matrixData = new Float32Array(instances * matrixSize);</span><span class="s3">\n\n  </span><span class="s1">// use matrix views to set values directly into the matrixData array</span><span class="s3">\n  </span><span class="s1">var matrixViews = new Array(instances);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; instances; i++) {</span><span class="s3">\n    </span><span class="s1">var byteOffset = i * matrixSize * 4; // 4 bytes per float</span><span class="s3">\n    </span><span class="s1">matrixViews[i] = new Float32Array(matrixData.buffer, byteOffset, matrixSize); // array view</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var buffer = gl.createBuffer();</span><span class="s3">\n  </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><span class="s3">\n  </span><span class="s1">gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);</span><span class="s3">\n\n  </span><span class="s1">// each row of the matrix needs to be a separate attribute</span><span class="s3">\n  </span><span class="s1">for (var _i = 0; _i &lt; 3; _i++) {</span><span class="s3">\n    </span><span class="s1">var loc = attributeLoc + _i;</span><span class="s3">\n    </span><span class="s1">gl.enableVertexAttribArray(loc);</span><span class="s3">\n    </span><span class="s1">gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 3 * 12, _i * 12);</span><span class="s3">\n    </span><span class="s1">gl.vertexAttribDivisor(loc, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, null);</span><span class="s3">\n  </span><span class="s1">buffer.getMatrixView = function (i) {</span><span class="s3">\n    </span><span class="s1">return matrixViews[i];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// TODO this is too slow, use getMatrixView and pass the view directly to the glmatrix library</span><span class="s3">\n  </span><span class="s1">buffer.setData = function (matrix, i) {</span><span class="s3">\n    </span><span class="s1">matrixViews[i].set(matrix, 0);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">buffer.bufferSubData = function () {</span><span class="s3">\n    </span><span class="s1">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><span class="s3">\n    </span><span class="s1">gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return buffer;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** </span><span class="s3">\n </span><span class="s1">* Creates a Frame Buffer to use for offscreen rendering.</span><span class="s3">\n </span><span class="s1">* @param {WebGLRenderingContext} gl </span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createPickingFrameBuffer(gl) {</span><span class="s3">\n  </span><span class="s1">// Create and bind the framebuffer</span><span class="s3">\n  </span><span class="s1">var fb = gl.createFramebuffer();</span><span class="s3">\n  </span><span class="s1">gl.bindFramebuffer(gl.FRAMEBUFFER, fb);</span><span class="s3">\n\n  </span><span class="s1">// Create a texture to render to</span><span class="s3">\n  </span><span class="s1">var targetTexture = gl.createTexture();</span><span class="s3">\n  </span><span class="s1">gl.bindTexture(gl.TEXTURE_2D, targetTexture);</span><span class="s3">\n  </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);</span><span class="s3">\n  </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><span class="s3">\n  </span><span class="s1">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><span class="s3">\n\n  </span><span class="s1">// attach the texture as the first color attachment</span><span class="s3">\n  </span><span class="s1">gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);</span><span class="s3">\n  </span><span class="s1">gl.bindFramebuffer(gl.FRAMEBUFFER, null);</span><span class="s3">\n  </span><span class="s1">fb.setFramebufferAttachmentSizes = function (width, height) {</span><span class="s3">\n    </span><span class="s1">gl.bindTexture(gl.TEXTURE_2D, targetTexture);</span><span class="s3">\n    </span><span class="s1">gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return fb;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Common utilities</span><span class="s3">\n </span><span class="s1">* @module glMatrix</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Configuration Constants</span><span class="s3">\n</span><span class="s1">var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;</span><span class="s3">\n</span><span class="s1">if (!Math.hypot) Math.hypot = function () {</span><span class="s3">\n  </span><span class="s1">var y = 0,</span><span class="s3">\n      </span><span class="s1">i = arguments.length;</span><span class="s3">\n\n  </span><span class="s1">while (i--) {</span><span class="s3">\n    </span><span class="s1">y += arguments[i] * arguments[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Math.sqrt(y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* 3x3 Matrix</span><span class="s3">\n </span><span class="s1">* @module mat3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a new identity mat3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns {mat3} a new 3x3 matrix</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function create() {</span><span class="s3">\n  </span><span class="s1">var out = new ARRAY_TYPE(9);</span><span class="s3">\n\n  </span><span class="s1">if (ARRAY_TYPE != Float32Array) {</span><span class="s3">\n    </span><span class="s1">out[1] = 0;</span><span class="s3">\n    </span><span class="s1">out[2] = 0;</span><span class="s3">\n    </span><span class="s1">out[3] = 0;</span><span class="s3">\n    </span><span class="s1">out[5] = 0;</span><span class="s3">\n    </span><span class="s1">out[6] = 0;</span><span class="s3">\n    </span><span class="s1">out[7] = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">out[0] = 1;</span><span class="s3">\n  </span><span class="s1">out[4] = 1;</span><span class="s3">\n  </span><span class="s1">out[8] = 1;</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set a mat3 to the identity matrix</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {mat3} out the receiving matrix</span><span class="s3">\n </span><span class="s1">* @returns {mat3} out</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function identity(out) {</span><span class="s3">\n  </span><span class="s1">out[0] = 1;</span><span class="s3">\n  </span><span class="s1">out[1] = 0;</span><span class="s3">\n  </span><span class="s1">out[2] = 0;</span><span class="s3">\n  </span><span class="s1">out[3] = 0;</span><span class="s3">\n  </span><span class="s1">out[4] = 1;</span><span class="s3">\n  </span><span class="s1">out[5] = 0;</span><span class="s3">\n  </span><span class="s1">out[6] = 0;</span><span class="s3">\n  </span><span class="s1">out[7] = 0;</span><span class="s3">\n  </span><span class="s1">out[8] = 1;</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Multiplies two mat3's</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {mat3} out the receiving matrix</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyMat3} a the first operand</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyMat3} b the second operand</span><span class="s3">\n </span><span class="s1">* @returns {mat3} out</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function multiply(out, a, b) {</span><span class="s3">\n  </span><span class="s1">var a00 = a[0],</span><span class="s3">\n      </span><span class="s1">a01 = a[1],</span><span class="s3">\n      </span><span class="s1">a02 = a[2];</span><span class="s3">\n  </span><span class="s1">var a10 = a[3],</span><span class="s3">\n      </span><span class="s1">a11 = a[4],</span><span class="s3">\n      </span><span class="s1">a12 = a[5];</span><span class="s3">\n  </span><span class="s1">var a20 = a[6],</span><span class="s3">\n      </span><span class="s1">a21 = a[7],</span><span class="s3">\n      </span><span class="s1">a22 = a[8];</span><span class="s3">\n  </span><span class="s1">var b00 = b[0],</span><span class="s3">\n      </span><span class="s1">b01 = b[1],</span><span class="s3">\n      </span><span class="s1">b02 = b[2];</span><span class="s3">\n  </span><span class="s1">var b10 = b[3],</span><span class="s3">\n      </span><span class="s1">b11 = b[4],</span><span class="s3">\n      </span><span class="s1">b12 = b[5];</span><span class="s3">\n  </span><span class="s1">var b20 = b[6],</span><span class="s3">\n      </span><span class="s1">b21 = b[7],</span><span class="s3">\n      </span><span class="s1">b22 = b[8];</span><span class="s3">\n  </span><span class="s1">out[0] = b00 * a00 + b01 * a10 + b02 * a20;</span><span class="s3">\n  </span><span class="s1">out[1] = b00 * a01 + b01 * a11 + b02 * a21;</span><span class="s3">\n  </span><span class="s1">out[2] = b00 * a02 + b01 * a12 + b02 * a22;</span><span class="s3">\n  </span><span class="s1">out[3] = b10 * a00 + b11 * a10 + b12 * a20;</span><span class="s3">\n  </span><span class="s1">out[4] = b10 * a01 + b11 * a11 + b12 * a21;</span><span class="s3">\n  </span><span class="s1">out[5] = b10 * a02 + b11 * a12 + b12 * a22;</span><span class="s3">\n  </span><span class="s1">out[6] = b20 * a00 + b21 * a10 + b22 * a20;</span><span class="s3">\n  </span><span class="s1">out[7] = b20 * a01 + b21 * a11 + b22 * a21;</span><span class="s3">\n  </span><span class="s1">out[8] = b20 * a02 + b21 * a12 + b22 * a22;</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Translate a mat3 by the given vector</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {mat3} out the receiving matrix</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyMat3} a the matrix to translate</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyVec2} v vector to translate by</span><span class="s3">\n </span><span class="s1">* @returns {mat3} out</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function translate(out, a, v) {</span><span class="s3">\n  </span><span class="s1">var a00 = a[0],</span><span class="s3">\n      </span><span class="s1">a01 = a[1],</span><span class="s3">\n      </span><span class="s1">a02 = a[2],</span><span class="s3">\n      </span><span class="s1">a10 = a[3],</span><span class="s3">\n      </span><span class="s1">a11 = a[4],</span><span class="s3">\n      </span><span class="s1">a12 = a[5],</span><span class="s3">\n      </span><span class="s1">a20 = a[6],</span><span class="s3">\n      </span><span class="s1">a21 = a[7],</span><span class="s3">\n      </span><span class="s1">a22 = a[8],</span><span class="s3">\n      </span><span class="s1">x = v[0],</span><span class="s3">\n      </span><span class="s1">y = v[1];</span><span class="s3">\n  </span><span class="s1">out[0] = a00;</span><span class="s3">\n  </span><span class="s1">out[1] = a01;</span><span class="s3">\n  </span><span class="s1">out[2] = a02;</span><span class="s3">\n  </span><span class="s1">out[3] = a10;</span><span class="s3">\n  </span><span class="s1">out[4] = a11;</span><span class="s3">\n  </span><span class="s1">out[5] = a12;</span><span class="s3">\n  </span><span class="s1">out[6] = x * a00 + y * a10 + a20;</span><span class="s3">\n  </span><span class="s1">out[7] = x * a01 + y * a11 + a21;</span><span class="s3">\n  </span><span class="s1">out[8] = x * a02 + y * a12 + a22;</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Rotates a mat3 by the given angle</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {mat3} out the receiving matrix</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyMat3} a the matrix to rotate</span><span class="s3">\n </span><span class="s1">* @param {Number} rad the angle to rotate the matrix by</span><span class="s3">\n </span><span class="s1">* @returns {mat3} out</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function rotate(out, a, rad) {</span><span class="s3">\n  </span><span class="s1">var a00 = a[0],</span><span class="s3">\n      </span><span class="s1">a01 = a[1],</span><span class="s3">\n      </span><span class="s1">a02 = a[2],</span><span class="s3">\n      </span><span class="s1">a10 = a[3],</span><span class="s3">\n      </span><span class="s1">a11 = a[4],</span><span class="s3">\n      </span><span class="s1">a12 = a[5],</span><span class="s3">\n      </span><span class="s1">a20 = a[6],</span><span class="s3">\n      </span><span class="s1">a21 = a[7],</span><span class="s3">\n      </span><span class="s1">a22 = a[8],</span><span class="s3">\n      </span><span class="s1">s = Math.sin(rad),</span><span class="s3">\n      </span><span class="s1">c = Math.cos(rad);</span><span class="s3">\n  </span><span class="s1">out[0] = c * a00 + s * a10;</span><span class="s3">\n  </span><span class="s1">out[1] = c * a01 + s * a11;</span><span class="s3">\n  </span><span class="s1">out[2] = c * a02 + s * a12;</span><span class="s3">\n  </span><span class="s1">out[3] = c * a10 - s * a00;</span><span class="s3">\n  </span><span class="s1">out[4] = c * a11 - s * a01;</span><span class="s3">\n  </span><span class="s1">out[5] = c * a12 - s * a02;</span><span class="s3">\n  </span><span class="s1">out[6] = a20;</span><span class="s3">\n  </span><span class="s1">out[7] = a21;</span><span class="s3">\n  </span><span class="s1">out[8] = a22;</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Scales the mat3 by the dimensions in the given vec2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {mat3} out the receiving matrix</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyMat3} a the matrix to rotate</span><span class="s3">\n </span><span class="s1">* @param {ReadonlyVec2} v the vec2 to scale the matrix by</span><span class="s3">\n </span><span class="s1">* @returns {mat3} out</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n\n</span><span class="s1">function scale(out, a, v) {</span><span class="s3">\n  </span><span class="s1">var x = v[0],</span><span class="s3">\n      </span><span class="s1">y = v[1];</span><span class="s3">\n  </span><span class="s1">out[0] = x * a[0];</span><span class="s3">\n  </span><span class="s1">out[1] = x * a[1];</span><span class="s3">\n  </span><span class="s1">out[2] = x * a[2];</span><span class="s3">\n  </span><span class="s1">out[3] = y * a[3];</span><span class="s3">\n  </span><span class="s1">out[4] = y * a[4];</span><span class="s3">\n  </span><span class="s1">out[5] = y * a[5];</span><span class="s3">\n  </span><span class="s1">out[6] = a[6];</span><span class="s3">\n  </span><span class="s1">out[7] = a[7];</span><span class="s3">\n  </span><span class="s1">out[8] = a[8];</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a 2D projection matrix with the given bounds</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {mat3} out mat3 frustum matrix will be written into</span><span class="s3">\n </span><span class="s1">* @param {number} width Width of your gl context</span><span class="s3">\n </span><span class="s1">* @param {number} height Height of gl context</span><span class="s3">\n </span><span class="s1">* @returns {mat3} out</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function projection(out, width, height) {</span><span class="s3">\n  </span><span class="s1">out[0] = 2 / width;</span><span class="s3">\n  </span><span class="s1">out[1] = 0;</span><span class="s3">\n  </span><span class="s1">out[2] = 0;</span><span class="s3">\n  </span><span class="s1">out[3] = 0;</span><span class="s3">\n  </span><span class="s1">out[4] = -2 / height;</span><span class="s3">\n  </span><span class="s1">out[5] = 0;</span><span class="s3">\n  </span><span class="s1">out[6] = -1;</span><span class="s3">\n  </span><span class="s1">out[7] = 1;</span><span class="s3">\n  </span><span class="s1">out[8] = 1;</span><span class="s3">\n  </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var RENDER_TARGET = {</span><span class="s3">\n  </span><span class="s1">SCREEN: {</span><span class="s3">\n    </span><span class="s1">name: 'screen',</span><span class="s3">\n    </span><span class="s1">screen: true</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">PICKING: {</span><span class="s3">\n    </span><span class="s1">name: 'picking',</span><span class="s3">\n    </span><span class="s1">picking: true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var atlasCollectionDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">texRows: 24</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var renderDefaults = defaults$g({</span><span class="s3">\n  </span><span class="s1">collection: 'default',</span><span class="s3">\n  </span><span class="s1">getKey: null,</span><span class="s3">\n  </span><span class="s1">// since render types (eg node-body, node-overlay) can share an atlas collection, its importeant their style keys don't collide</span><span class="s3">\n  </span><span class="s1">drawElement: null,</span><span class="s3">\n  </span><span class="s1">getBoundingBox: null,</span><span class="s3">\n  </span><span class="s1">getRotation: null,</span><span class="s3">\n  </span><span class="s1">getRotationPoint: null,</span><span class="s3">\n  </span><span class="s1">getRotationOffset: null,</span><span class="s3">\n  </span><span class="s1">isVisible: function isVisible() {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// this is an extra check for visibility in addition to ele.visible()</span><span class="s3">\n  </span><span class="s1">getPadding: 0</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// A </span><span class="s3">\&quot;</span><span class="s1">texture atlas</span><span class="s3">\&quot; </span><span class="s1">is a big image/canvas, and sections of it are used as textures for nodes/labels.</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A single square texture atlas (also known as a </span><span class="s3">\&quot;</span><span class="s1">sprite sheet</span><span class="s3">\&quot;</span><span class="s1">).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Atlas = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function Atlas(r, texSize, texRows, createTextureCanvas) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, Atlas);</span><span class="s3">\n    </span><span class="s1">this.debugID = Math.floor(Math.random() * 10000);</span><span class="s3">\n    </span><span class="s1">this.r = r;</span><span class="s3">\n    </span><span class="s1">this.texSize = texSize;</span><span class="s3">\n    </span><span class="s1">this.texRows = texRows;</span><span class="s3">\n    </span><span class="s1">this.texHeight = Math.floor(texSize / texRows);</span><span class="s3">\n    </span><span class="s1">this.enableWrapping = true; // hardcoded for now, can be made an option</span><span class="s3">\n\n    </span><span class="s1">this.locked = false; // once an atlas is locked it can no longer be drawn to</span><span class="s3">\n    </span><span class="s1">this.texture = null; // WebGLTexture object</span><span class="s3">\n    </span><span class="s1">this.needsBuffer = true;</span><span class="s3">\n\n    </span><span class="s1">// a </span><span class="s3">\&quot;</span><span class="s1">location</span><span class="s3">\&quot; </span><span class="s1">is an object with a 'row' and 'x' fields</span><span class="s3">\n    </span><span class="s1">this.freePointer = {</span><span class="s3">\n      </span><span class="s1">x: 0,</span><span class="s3">\n      </span><span class="s1">row: 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// map from the style key to the row/x where the texture starts</span><span class="s3">\n    </span><span class="s1">// if the texture wraps then there's a second location</span><span class="s3">\n    </span><span class="s1">this.keyToLocation = new Map(); // styleKey -&gt; [ location, location ]</span><span class="s3">\n\n    </span><span class="s1">this.canvas = createTextureCanvas(r, texSize, texSize);</span><span class="s3">\n    </span><span class="s1">this.scratch = createTextureCanvas(r, texSize, this.texHeight, 'scratch');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(Atlas, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">lock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function lock() {</span><span class="s3">\n      </span><span class="s1">this.locked = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getKeys</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getKeys() {</span><span class="s3">\n      </span><span class="s1">return new Set(this.keyToLocation.keys());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getScale</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getScale(_ref) {</span><span class="s3">\n      </span><span class="s1">var w = _ref.w,</span><span class="s3">\n        </span><span class="s1">h = _ref.h;</span><span class="s3">\n      </span><span class="s1">var texHeight = this.texHeight,</span><span class="s3">\n        </span><span class="s1">maxTexWidth = this.texSize;</span><span class="s3">\n      </span><span class="s1">// try to fit to the height of a row</span><span class="s3">\n      </span><span class="s1">var scale = texHeight / h; // TODO what about pixelRatio?</span><span class="s3">\n      </span><span class="s1">var texW = w * scale;</span><span class="s3">\n      </span><span class="s1">var texH = h * scale;</span><span class="s3">\n      </span><span class="s1">// if the scaled width is too wide then scale to fit max width instead</span><span class="s3">\n      </span><span class="s1">if (texW &gt; maxTexWidth) {</span><span class="s3">\n        </span><span class="s1">scale = maxTexWidth / w;</span><span class="s3">\n        </span><span class="s1">texW = w * scale;</span><span class="s3">\n        </span><span class="s1">texH = h * scale;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">scale: scale,</span><span class="s3">\n        </span><span class="s1">texW: texW,</span><span class="s3">\n        </span><span class="s1">texH: texH</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">draw</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function draw(key, bb, doDrawing) {</span><span class="s3">\n      </span><span class="s1">var _this = this;</span><span class="s3">\n      </span><span class="s1">if (this.locked) throw new Error('can</span><span class="s3">\\</span><span class="s1">'t draw, atlas is locked');</span><span class="s3">\n      </span><span class="s1">var texSize = this.texSize,</span><span class="s3">\n        </span><span class="s1">texRows = this.texRows,</span><span class="s3">\n        </span><span class="s1">texHeight = this.texHeight;</span><span class="s3">\n      </span><span class="s1">var _this$getScale = this.getScale(bb),</span><span class="s3">\n        </span><span class="s1">scale = _this$getScale.scale,</span><span class="s3">\n        </span><span class="s1">texW = _this$getScale.texW,</span><span class="s3">\n        </span><span class="s1">texH = _this$getScale.texH;</span><span class="s3">\n      </span><span class="s1">var locations = [null, null];</span><span class="s3">\n      </span><span class="s1">var drawAt = function drawAt(location, canvas) {</span><span class="s3">\n        </span><span class="s1">if (doDrawing &amp;&amp; canvas) {</span><span class="s3">\n          </span><span class="s1">var context = canvas.context;</span><span class="s3">\n          </span><span class="s1">var x = location.x,</span><span class="s3">\n            </span><span class="s1">row = location.row;</span><span class="s3">\n          </span><span class="s1">var xOffset = x;</span><span class="s3">\n          </span><span class="s1">var yOffset = texHeight * row;</span><span class="s3">\n          </span><span class="s1">context.save();</span><span class="s3">\n          </span><span class="s1">context.translate(xOffset, yOffset);</span><span class="s3">\n          </span><span class="s1">context.scale(scale, scale);</span><span class="s3">\n          </span><span class="s1">doDrawing(context, bb);</span><span class="s3">\n          </span><span class="s1">context.restore();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var drawNormal = function drawNormal() {</span><span class="s3">\n        </span><span class="s1">// don't need to wrap, draw directly on the canvas</span><span class="s3">\n        </span><span class="s1">drawAt(_this.freePointer, _this.canvas);</span><span class="s3">\n        </span><span class="s1">locations[0] = {</span><span class="s3">\n          </span><span class="s1">x: _this.freePointer.x,</span><span class="s3">\n          </span><span class="s1">y: _this.freePointer.row * texHeight,</span><span class="s3">\n          </span><span class="s1">w: texW,</span><span class="s3">\n          </span><span class="s1">h: texH</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">locations[1] = {</span><span class="s3">\n          </span><span class="s1">// indlude a second location with a width of 0, for convenience</span><span class="s3">\n          </span><span class="s1">x: _this.freePointer.x + texW,</span><span class="s3">\n          </span><span class="s1">y: _this.freePointer.row * texHeight,</span><span class="s3">\n          </span><span class="s1">w: 0,</span><span class="s3">\n          </span><span class="s1">h: texH</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">// move the pointer to the end of the texture</span><span class="s3">\n        </span><span class="s1">_this.freePointer.x += texW;</span><span class="s3">\n        </span><span class="s1">if (_this.freePointer.x == texSize) {</span><span class="s3">\n          </span><span class="s1">// move to the next row</span><span class="s3">\n          </span><span class="s1">// TODO what if there is no next row???</span><span class="s3">\n          </span><span class="s1">_this.freePointer.x = 0;</span><span class="s3">\n          </span><span class="s1">_this.freePointer.row++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var drawWrapped = function drawWrapped() {</span><span class="s3">\n        </span><span class="s1">var scratch = _this.scratch,</span><span class="s3">\n          </span><span class="s1">canvas = _this.canvas;</span><span class="s3">\n\n        </span><span class="s1">// Draw to the scratch canvas</span><span class="s3">\n        </span><span class="s1">scratch.clear();</span><span class="s3">\n        </span><span class="s1">drawAt({</span><span class="s3">\n          </span><span class="s1">x: 0,</span><span class="s3">\n          </span><span class="s1">row: 0</span><span class="s3">\n        </span><span class="s1">}, scratch);</span><span class="s3">\n        </span><span class="s1">var firstTexW = texSize - _this.freePointer.x;</span><span class="s3">\n        </span><span class="s1">var secondTexW = texW - firstTexW;</span><span class="s3">\n        </span><span class="s1">var h = texHeight;</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">// copy first part of scratch to the first texture</span><span class="s3">\n          </span><span class="s1">var dx = _this.freePointer.x;</span><span class="s3">\n          </span><span class="s1">var dy = _this.freePointer.row * texHeight;</span><span class="s3">\n          </span><span class="s1">var w = firstTexW;</span><span class="s3">\n          </span><span class="s1">canvas.context.drawImage(scratch, 0, 0, w, h, dx, dy, w, h);</span><span class="s3">\n          </span><span class="s1">locations[0] = {</span><span class="s3">\n            </span><span class="s1">x: dx,</span><span class="s3">\n            </span><span class="s1">y: dy,</span><span class="s3">\n            </span><span class="s1">w: w,</span><span class="s3">\n            </span><span class="s1">h: texH</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">// copy second part of scratch to the second texture</span><span class="s3">\n          </span><span class="s1">var sx = firstTexW;</span><span class="s3">\n          </span><span class="s1">var _dy = (_this.freePointer.row + 1) * texHeight;</span><span class="s3">\n          </span><span class="s1">var _w = secondTexW;</span><span class="s3">\n          </span><span class="s1">if (canvas) {</span><span class="s3">\n            </span><span class="s1">canvas.context.drawImage(scratch, sx, 0, _w, h, 0, _dy, _w, h);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">locations[1] = {</span><span class="s3">\n            </span><span class="s1">x: 0,</span><span class="s3">\n            </span><span class="s1">y: _dy,</span><span class="s3">\n            </span><span class="s1">w: _w,</span><span class="s3">\n            </span><span class="s1">h: texH</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">_this.freePointer.x = secondTexW;</span><span class="s3">\n        </span><span class="s1">_this.freePointer.row++;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">var moveToStartOfNextRow = function moveToStartOfNextRow() {</span><span class="s3">\n        </span><span class="s1">_this.freePointer.x = 0;</span><span class="s3">\n        </span><span class="s1">_this.freePointer.row++;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (this.freePointer.x + texW &lt;= texSize) {</span><span class="s3">\n        </span><span class="s1">// There's enough space in the current row</span><span class="s3">\n        </span><span class="s1">drawNormal();</span><span class="s3">\n      </span><span class="s1">} else if (this.freePointer.row &gt;= texRows - 1) {</span><span class="s3">\n        </span><span class="s1">// Need to move to the next row, but there are no more rows, atlas is full.</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} else if (this.freePointer.x === texSize) {</span><span class="s3">\n        </span><span class="s1">// happen to be right at end of current row</span><span class="s3">\n        </span><span class="s1">moveToStartOfNextRow();</span><span class="s3">\n        </span><span class="s1">drawNormal();</span><span class="s3">\n      </span><span class="s1">} else if (this.enableWrapping) {</span><span class="s3">\n        </span><span class="s1">// draw part of the texture to the end of the curent row, then wrap to the next row</span><span class="s3">\n        </span><span class="s1">drawWrapped();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// move to the start of the next row, then draw normally</span><span class="s3">\n        </span><span class="s1">moveToStartOfNextRow();</span><span class="s3">\n        </span><span class="s1">drawNormal();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.keyToLocation.set(key, locations);</span><span class="s3">\n      </span><span class="s1">this.needsBuffer = true;</span><span class="s3">\n      </span><span class="s1">return locations;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getOffsets</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getOffsets(key) {</span><span class="s3">\n      </span><span class="s1">return this.keyToLocation.get(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">isEmpty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function isEmpty() {</span><span class="s3">\n      </span><span class="s1">return this.freePointer.x === 0 &amp;&amp; this.freePointer.row === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">canFit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function canFit(bb) {</span><span class="s3">\n      </span><span class="s1">if (this.locked) return false;</span><span class="s3">\n      </span><span class="s1">var texSize = this.texSize,</span><span class="s3">\n        </span><span class="s1">texRows = this.texRows;</span><span class="s3">\n      </span><span class="s1">var _this$getScale2 = this.getScale(bb),</span><span class="s3">\n        </span><span class="s1">texW = _this$getScale2.texW;</span><span class="s3">\n      </span><span class="s1">if (this.freePointer.x + texW &gt; texSize) {</span><span class="s3">\n        </span><span class="s1">// need to wrap</span><span class="s3">\n        </span><span class="s1">return this.freePointer.row &lt; texRows - 1; // return true if there's a row to wrap to</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// called on every frame</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">bufferIfNeeded</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function bufferIfNeeded(gl) {</span><span class="s3">\n      </span><span class="s1">if (!this.texture) {</span><span class="s3">\n        </span><span class="s1">this.texture = createTexture(gl, this.debugID);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.needsBuffer) {</span><span class="s3">\n        </span><span class="s1">this.texture.buffer(this.canvas);</span><span class="s3">\n        </span><span class="s1">this.needsBuffer = false;</span><span class="s3">\n        </span><span class="s1">if (this.locked) {</span><span class="s3">\n          </span><span class="s1">this.canvas = null;</span><span class="s3">\n          </span><span class="s1">this.scratch = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">dispose</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function dispose() {</span><span class="s3">\n      </span><span class="s1">if (this.texture) {</span><span class="s3">\n        </span><span class="s1">this.texture.deleteTexture();</span><span class="s3">\n        </span><span class="s1">this.texture = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.canvas = null;</span><span class="s3">\n      </span><span class="s1">this.scratch = null;</span><span class="s3">\n      </span><span class="s1">this.locked = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A collection of texture atlases, all of the same </span><span class="s3">\&quot;</span><span class="s1">render type</span><span class="s3">\&quot;</span><span class="s1">. </span><span class="s3">\n </span><span class="s1">* (Node body is an example of a render type.)</span><span class="s3">\n </span><span class="s1">* An AtlasCollection can also be notified when a texture is no longer needed, </span><span class="s3">\n </span><span class="s1">* and it can garbage collect the unused textures.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var AtlasCollection = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function AtlasCollection(r, texSize, texRows, createTextureCanvas) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, AtlasCollection);</span><span class="s3">\n    </span><span class="s1">this.r = r;</span><span class="s3">\n    </span><span class="s1">this.texSize = texSize;</span><span class="s3">\n    </span><span class="s1">this.texRows = texRows;</span><span class="s3">\n    </span><span class="s1">this.createTextureCanvas = createTextureCanvas;</span><span class="s3">\n    </span><span class="s1">this.atlases = [];</span><span class="s3">\n    </span><span class="s1">this.styleKeyToAtlas = new Map();</span><span class="s3">\n    </span><span class="s1">this.markedKeys = new Set(); // marked for garbage collection</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(AtlasCollection, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getKeys</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getKeys() {</span><span class="s3">\n      </span><span class="s1">return new Set(this.styleKeyToAtlas.keys());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">_createAtlas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _createAtlas() {</span><span class="s3">\n      </span><span class="s1">var r = this.r,</span><span class="s3">\n        </span><span class="s1">texSize = this.texSize,</span><span class="s3">\n        </span><span class="s1">texRows = this.texRows,</span><span class="s3">\n        </span><span class="s1">createTextureCanvas = this.createTextureCanvas;</span><span class="s3">\n      </span><span class="s1">return new Atlas(r, texSize, texRows, createTextureCanvas);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">_getScratchCanvas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _getScratchCanvas() {</span><span class="s3">\n      </span><span class="s1">if (!this.scratch) {</span><span class="s3">\n        </span><span class="s1">var r = this.r,</span><span class="s3">\n          </span><span class="s1">texSize = this.texSize,</span><span class="s3">\n          </span><span class="s1">texRows = this.texRows,</span><span class="s3">\n          </span><span class="s1">createTextureCanvas = this.createTextureCanvas;</span><span class="s3">\n        </span><span class="s1">var texHeight = Math.floor(texSize / texRows);</span><span class="s3">\n        </span><span class="s1">this.scratch = createTextureCanvas(r, texSize, texHeight, 'scratch');</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this.scratch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">draw</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function draw(key, bb, doDrawing) {</span><span class="s3">\n      </span><span class="s1">var atlas = this.styleKeyToAtlas.get(key);</span><span class="s3">\n      </span><span class="s1">if (!atlas) {</span><span class="s3">\n        </span><span class="s1">// check for space at the end of the last atlas</span><span class="s3">\n        </span><span class="s1">atlas = this.atlases[this.atlases.length - 1];</span><span class="s3">\n        </span><span class="s1">if (!atlas || !atlas.canFit(bb)) {</span><span class="s3">\n          </span><span class="s1">if (atlas) atlas.lock();</span><span class="s3">\n          </span><span class="s1">// create a new atlas</span><span class="s3">\n          </span><span class="s1">atlas = this._createAtlas();</span><span class="s3">\n          </span><span class="s1">this.atlases.push(atlas);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">atlas.draw(key, bb, doDrawing);</span><span class="s3">\n        </span><span class="s1">this.styleKeyToAtlas.set(key, atlas);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return atlas;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlas(key) {</span><span class="s3">\n      </span><span class="s1">return this.styleKeyToAtlas.get(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">hasAtlas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function hasAtlas(key) {</span><span class="s3">\n      </span><span class="s1">return this.styleKeyToAtlas.has(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">markKeyForGC</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function markKeyForGC(key) {</span><span class="s3">\n      </span><span class="s1">this.markedKeys.add(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">gc</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function gc() {</span><span class="s3">\n      </span><span class="s1">var _this2 = this;</span><span class="s3">\n      </span><span class="s1">var markedKeys = this.markedKeys;</span><span class="s3">\n      </span><span class="s1">if (markedKeys.size === 0) {</span><span class="s3">\n        </span><span class="s1">console.log('nothing to garbage collect');</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var newAtlases = [];</span><span class="s3">\n      </span><span class="s1">var newStyleKeyToAtlas = new Map();</span><span class="s3">\n      </span><span class="s1">var newAtlas = null;</span><span class="s3">\n      </span><span class="s1">var _iterator = _createForOfIteratorHelper(this.atlases),</span><span class="s3">\n        </span><span class="s1">_step;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n          </span><span class="s1">var atlas = _step.value;</span><span class="s3">\n          </span><span class="s1">var keys = atlas.getKeys();</span><span class="s3">\n          </span><span class="s1">var keysToCollect = intersection(markedKeys, keys);</span><span class="s3">\n          </span><span class="s1">if (keysToCollect.size === 0) {</span><span class="s3">\n            </span><span class="s1">// this atlas can still be used</span><span class="s3">\n            </span><span class="s1">newAtlases.push(atlas);</span><span class="s3">\n            </span><span class="s1">keys.forEach(function (k) {</span><span class="s3">\n              </span><span class="s1">return newStyleKeyToAtlas.set(k, atlas);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return 1; // continue</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!newAtlas) {</span><span class="s3">\n            </span><span class="s1">newAtlas = _this2._createAtlas();</span><span class="s3">\n            </span><span class="s1">newAtlases.push(newAtlas);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var _iterator2 = _createForOfIteratorHelper(keys),</span><span class="s3">\n            </span><span class="s1">_step2;</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {</span><span class="s3">\n              </span><span class="s1">var key = _step2.value;</span><span class="s3">\n              </span><span class="s1">if (!keysToCollect.has(key)) {</span><span class="s3">\n                </span><span class="s1">var _atlas$getOffsets = atlas.getOffsets(key),</span><span class="s3">\n                  </span><span class="s1">_atlas$getOffsets2 = _slicedToArray(_atlas$getOffsets, 2),</span><span class="s3">\n                  </span><span class="s1">s1 = _atlas$getOffsets2[0],</span><span class="s3">\n                  </span><span class="s1">s2 = _atlas$getOffsets2[1];</span><span class="s3">\n                </span><span class="s1">if (!newAtlas.canFit({</span><span class="s3">\n                  </span><span class="s1">w: s1.w + s2.w,</span><span class="s3">\n                  </span><span class="s1">h: s1.h</span><span class="s3">\n                </span><span class="s1">})) {</span><span class="s3">\n                  </span><span class="s1">newAtlas.lock();</span><span class="s3">\n                  </span><span class="s1">newAtlas = _this2._createAtlas();</span><span class="s3">\n                  </span><span class="s1">newAtlases.push(newAtlas);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">_this2._copyTextureToNewAtlas(key, atlas, newAtlas);</span><span class="s3">\n                </span><span class="s1">newStyleKeyToAtlas.set(key, newAtlas);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">_iterator2.e(err);</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">_iterator2.f();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">atlas.dispose();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (_iterator.s(); !(_step = _iterator.n()).done;) {</span><span class="s3">\n          </span><span class="s1">if (_loop()) continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_iterator.e(err);</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">_iterator.f();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.atlases = newAtlases;</span><span class="s3">\n      </span><span class="s1">this.styleKeyToAtlas = newStyleKeyToAtlas;</span><span class="s3">\n      </span><span class="s1">this.markedKeys = new Set();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">_copyTextureToNewAtlas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _copyTextureToNewAtlas(key, oldAtlas, newAtlas) {</span><span class="s3">\n      </span><span class="s1">var _oldAtlas$getOffsets = oldAtlas.getOffsets(key),</span><span class="s3">\n        </span><span class="s1">_oldAtlas$getOffsets2 = _slicedToArray(_oldAtlas$getOffsets, 2),</span><span class="s3">\n        </span><span class="s1">s1 = _oldAtlas$getOffsets2[0],</span><span class="s3">\n        </span><span class="s1">s2 = _oldAtlas$getOffsets2[1];</span><span class="s3">\n      </span><span class="s1">if (s2.w === 0) {</span><span class="s3">\n        </span><span class="s1">// the texture does not wrap, draw directly to new atlas</span><span class="s3">\n        </span><span class="s1">newAtlas.draw(key, s1, function (context) {</span><span class="s3">\n          </span><span class="s1">context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// the texture wraps, first draw both parts to a scratch canvas</span><span class="s3">\n        </span><span class="s1">var scratch = this._getScratchCanvas();</span><span class="s3">\n        </span><span class="s1">scratch.clear();</span><span class="s3">\n        </span><span class="s1">scratch.context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);</span><span class="s3">\n        </span><span class="s1">scratch.context.drawImage(oldAtlas.canvas, s2.x, s2.y, s2.w, s2.h, s1.w, 0, s2.w, s2.h);</span><span class="s3">\n\n        </span><span class="s1">// now draw the scratch to the new atlas</span><span class="s3">\n        </span><span class="s1">var w = s1.w + s2.w;</span><span class="s3">\n        </span><span class="s1">var h = s1.h;</span><span class="s3">\n        </span><span class="s1">newAtlas.draw(key, {</span><span class="s3">\n          </span><span class="s1">w: w,</span><span class="s3">\n          </span><span class="s1">h: h</span><span class="s3">\n        </span><span class="s1">}, function (context) {</span><span class="s3">\n          </span><span class="s1">context.drawImage(scratch, 0, 0, w, h, 0, 0, w, h // the destination context has already been translated to the correct position</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getCounts</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getCounts() {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">keyCount: this.styleKeyToAtlas.size,</span><span class="s3">\n        </span><span class="s1">atlasCount: new Set(this.styleKeyToAtlas.values()).size</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">function intersection(set1, set2) {</span><span class="s3">\n  </span><span class="s1">// TODO why no Set.intersection in node 16???</span><span class="s3">\n  </span><span class="s1">if (set1.intersection) return set1.intersection(set2);else return new Set(_toConsumableArray(set1).filter(function (x) {</span><span class="s3">\n    </span><span class="s1">return set2.has(x);</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used to manage batches of Atlases for drawing nodes and labels.</span><span class="s3">\n </span><span class="s1">* Supports different types of AtlasCollections for different render types (or 'texture groups'),</span><span class="s3">\n </span><span class="s1">* for example 'node body' and 'node label' would be different render types.</span><span class="s3">\n </span><span class="s1">* Render types are kept separate because they will likely need to be garbage collected</span><span class="s3">\n </span><span class="s1">* separately and its not entierly guaranteed that their style keys won't collide.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var AtlasManager = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function AtlasManager(r, globalOptions) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, AtlasManager);</span><span class="s3">\n    </span><span class="s1">this.r = r;</span><span class="s3">\n    </span><span class="s1">this.globalOptions = globalOptions;</span><span class="s3">\n    </span><span class="s1">this.atlasSize = globalOptions.webglTexSize;</span><span class="s3">\n    </span><span class="s1">this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;</span><span class="s3">\n    </span><span class="s1">this.renderTypes = new Map(); // renderType:string -&gt; renderTypeOptions</span><span class="s3">\n    </span><span class="s1">this.collections = new Map(); // collectionName:string -&gt; AtlasCollection</span><span class="s3">\n\n    </span><span class="s1">this.typeAndIdToKey = new Map(); // [renderType,id] =&gt; style key</span><span class="s3">\n\n    </span><span class="s1">this.batchAtlases = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(AtlasManager, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlasSize</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlasSize() {</span><span class="s3">\n      </span><span class="s1">return this.atlasSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getMaxAtlasesPerBatch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getMaxAtlasesPerBatch() {</span><span class="s3">\n      </span><span class="s1">return this.maxAtlasesPerBatch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">addAtlasCollection</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function addAtlasCollection(collectionName, atlasCollectionOptions) {</span><span class="s3">\n      </span><span class="s1">var _this$globalOptions = this.globalOptions,</span><span class="s3">\n        </span><span class="s1">webglTexSize = _this$globalOptions.webglTexSize,</span><span class="s3">\n        </span><span class="s1">createTextureCanvas = _this$globalOptions.createTextureCanvas;</span><span class="s3">\n      </span><span class="s1">var texRows = atlasCollectionOptions.texRows;</span><span class="s3">\n      </span><span class="s1">var cachedCreateTextureCanvas = this._cacheScratchCanvas(createTextureCanvas);</span><span class="s3">\n      </span><span class="s1">var atlasCollection = new AtlasCollection(this.r, webglTexSize, texRows, cachedCreateTextureCanvas);</span><span class="s3">\n      </span><span class="s1">this.collections.set(collectionName, atlasCollection);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">addRenderType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function addRenderType(type, renderTypeOptions) {</span><span class="s3">\n      </span><span class="s1">var collection = renderTypeOptions.collection;</span><span class="s3">\n      </span><span class="s1">if (!this.collections.has(collection)) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">invalid atlas collection name '</span><span class="s3">\&quot;</span><span class="s1">.concat(collection, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">var atlasCollection = this.collections.get(collection);</span><span class="s3">\n      </span><span class="s1">var opts = extend({</span><span class="s3">\n        </span><span class="s1">type: type,</span><span class="s3">\n        </span><span class="s1">atlasCollection: atlasCollection</span><span class="s3">\n      </span><span class="s1">}, renderTypeOptions);</span><span class="s3">\n      </span><span class="s1">this.renderTypes.set(type, opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getRenderTypeOpts</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getRenderTypeOpts(type) {</span><span class="s3">\n      </span><span class="s1">return this.renderTypes.get(type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlasCollection</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlasCollection(name) {</span><span class="s3">\n      </span><span class="s1">return this.collections.get(name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">_cacheScratchCanvas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _cacheScratchCanvas(createTextureCanvas) {</span><span class="s3">\n      </span><span class="s1">// all scratch canvases for the same render type will have the same width and height (ie webglTexRows option)</span><span class="s3">\n      </span><span class="s1">// but we'll keep track of the width and height just to be safe</span><span class="s3">\n      </span><span class="s1">var prevW = -1;</span><span class="s3">\n      </span><span class="s1">var prevH = -1;</span><span class="s3">\n      </span><span class="s1">var scratchCanvas = null;</span><span class="s3">\n      </span><span class="s1">return function (r, w, h, scratch) {</span><span class="s3">\n        </span><span class="s1">if (scratch) {</span><span class="s3">\n          </span><span class="s1">if (!scratchCanvas || w != prevW || h != prevH) {</span><span class="s3">\n            </span><span class="s1">prevW = w;</span><span class="s3">\n            </span><span class="s1">prevH = h;</span><span class="s3">\n            </span><span class="s1">scratchCanvas = createTextureCanvas(r, w, h);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return scratchCanvas;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return createTextureCanvas(r, w, h);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">_key</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _key(renderType, id) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(renderType, </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">).concat(id); // TODO not very efficient</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/** Marks textues associated with the element for garbage collection. */</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">invalidate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function invalidate(eles) {</span><span class="s3">\n      </span><span class="s1">var _ref2 = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {},</span><span class="s3">\n        </span><span class="s1">_ref2$forceRedraw = _ref2.forceRedraw,</span><span class="s3">\n        </span><span class="s1">forceRedraw = _ref2$forceRedraw === undefined ? false : _ref2$forceRedraw,</span><span class="s3">\n        </span><span class="s1">_ref2$filterEle = _ref2.filterEle,</span><span class="s3">\n        </span><span class="s1">filterEle = _ref2$filterEle === undefined ? function () {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">} : _ref2$filterEle,</span><span class="s3">\n        </span><span class="s1">_ref2$filterType = _ref2.filterType,</span><span class="s3">\n        </span><span class="s1">filterType = _ref2$filterType === undefined ? function () {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">} : _ref2$filterType;</span><span class="s3">\n      </span><span class="s1">var needGC = false;</span><span class="s3">\n      </span><span class="s1">var runGCNow = false;</span><span class="s3">\n      </span><span class="s1">var _iterator3 = _createForOfIteratorHelper(eles),</span><span class="s3">\n        </span><span class="s1">_step3;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {</span><span class="s3">\n          </span><span class="s1">var ele = _step3.value;</span><span class="s3">\n          </span><span class="s1">if (filterEle(ele)) {</span><span class="s3">\n            </span><span class="s1">var _iterator4 = _createForOfIteratorHelper(this.renderTypes.values()),</span><span class="s3">\n              </span><span class="s1">_step4;</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {</span><span class="s3">\n                </span><span class="s1">var opts = _step4.value;</span><span class="s3">\n                </span><span class="s1">var renderType = opts.type;</span><span class="s3">\n                </span><span class="s1">if (filterType(renderType)) {</span><span class="s3">\n                  </span><span class="s1">var styleKey = opts.getKey(ele);</span><span class="s3">\n                  </span><span class="s1">var atlasCollection = this.collections.get(opts.collection);</span><span class="s3">\n\n                  </span><span class="s1">// when a node's background image finishes loading, the style key doesn't change but still needs to be redrawn</span><span class="s3">\n                  </span><span class="s1">if (forceRedraw) {</span><span class="s3">\n                    </span><span class="s1">atlasCollection.markKeyForGC(styleKey);</span><span class="s3">\n                    </span><span class="s1">runGCNow = true; // run GC to remove the old texture right now, that way we don't need to remember for the next gc </span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">var id = opts.getID ? opts.getID(ele) : ele.id();</span><span class="s3">\n                    </span><span class="s1">var mapKey = this._key(renderType, id);</span><span class="s3">\n                    </span><span class="s1">var oldStyleKey = this.typeAndIdToKey.get(mapKey);</span><span class="s3">\n                    </span><span class="s1">if (oldStyleKey !== undefined &amp;&amp; oldStyleKey !== styleKey) {</span><span class="s3">\n                      </span><span class="s1">this.typeAndIdToKey[</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">](mapKey);</span><span class="s3">\n                      </span><span class="s1">atlasCollection.markKeyForGC(oldStyleKey);</span><span class="s3">\n                      </span><span class="s1">needGC = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} catch (err) {</span><span class="s3">\n              </span><span class="s1">_iterator4.e(err);</span><span class="s3">\n            </span><span class="s1">} finally {</span><span class="s3">\n              </span><span class="s1">_iterator4.f();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_iterator3.e(err);</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">_iterator3.f();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (runGCNow) {</span><span class="s3">\n        </span><span class="s1">this.gc();</span><span class="s3">\n        </span><span class="s1">needGC = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return needGC;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/** Garbage collect */</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">gc</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function gc() {</span><span class="s3">\n      </span><span class="s1">var _iterator5 = _createForOfIteratorHelper(this.collections.values()),</span><span class="s3">\n        </span><span class="s1">_step5;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {</span><span class="s3">\n          </span><span class="s1">var collection = _step5.value;</span><span class="s3">\n          </span><span class="s1">collection.gc();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_iterator5.e(err);</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">_iterator5.f();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getOrCreateAtlas</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getOrCreateAtlas(ele, type, bb) {</span><span class="s3">\n      </span><span class="s1">var opts = this.renderTypes.get(type);</span><span class="s3">\n      </span><span class="s1">var styleKey = opts.getKey(ele);</span><span class="s3">\n      </span><span class="s1">if (!bb) bb = opts.getBoundingBox(ele);</span><span class="s3">\n      </span><span class="s1">var atlasCollection = this.collections.get(opts.collection);</span><span class="s3">\n\n      </span><span class="s1">// draws the texture only if needed</span><span class="s3">\n      </span><span class="s1">var drawn = false;</span><span class="s3">\n      </span><span class="s1">var atlas = atlasCollection.draw(styleKey, bb, function (context) {</span><span class="s3">\n        </span><span class="s1">opts.drawElement(context, ele, bb, true, true);</span><span class="s3">\n        </span><span class="s1">drawn = true;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">if (drawn) {</span><span class="s3">\n        </span><span class="s1">var id = opts.getID ? opts.getID(ele) : ele.id(); // for testing</span><span class="s3">\n        </span><span class="s1">var mapKey = this._key(type, id);</span><span class="s3">\n        </span><span class="s1">this.typeAndIdToKey.set(mapKey, styleKey);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return atlas;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">startBatch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function startBatch() {</span><span class="s3">\n      </span><span class="s1">this.batchAtlases = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlasCount</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlasCount() {</span><span class="s3">\n      </span><span class="s1">return this.batchAtlases.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlases</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlases() {</span><span class="s3">\n      </span><span class="s1">return this.batchAtlases;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">canAddToCurrentBatch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function canAddToCurrentBatch(ele, type) {</span><span class="s3">\n      </span><span class="s1">if (this.batchAtlases.length === this.maxAtlasesPerBatch) {</span><span class="s3">\n        </span><span class="s1">// batch is full, is the atlas already part of this batch?</span><span class="s3">\n        </span><span class="s1">var opts = this.renderTypes.get(type);</span><span class="s3">\n        </span><span class="s1">var styleKey = opts.getKey(ele);</span><span class="s3">\n        </span><span class="s1">var atlasCollection = this.collections.get(opts.collection);</span><span class="s3">\n        </span><span class="s1">var atlas = atlasCollection.getAtlas(styleKey);</span><span class="s3">\n        </span><span class="s1">// return true if there is an atlas and it is part of this batch already</span><span class="s3">\n        </span><span class="s1">return Boolean(atlas) &amp;&amp; this.batchAtlases.includes(atlas);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true; // not full</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlasIndexForBatch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlasIndexForBatch(atlas) {</span><span class="s3">\n      </span><span class="s1">var atlasID = this.batchAtlases.indexOf(atlas);</span><span class="s3">\n      </span><span class="s1">if (atlasID &lt; 0) {</span><span class="s3">\n        </span><span class="s1">if (this.batchAtlases.length === this.maxAtlasesPerBatch) {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.batchAtlases.push(atlas);</span><span class="s3">\n        </span><span class="s1">atlasID = this.batchAtlases.length - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return atlasID;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getIndexArray</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getIndexArray() {</span><span class="s3">\n      </span><span class="s1">return Array.from({</span><span class="s3">\n        </span><span class="s1">length: this.maxAtlasesPerBatch</span><span class="s3">\n      </span><span class="s1">}, function (v, i) {</span><span class="s3">\n        </span><span class="s1">return i;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAtlasInfo</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAtlasInfo(ele, type) {</span><span class="s3">\n      </span><span class="s1">var opts = this.renderTypes.get(type);</span><span class="s3">\n      </span><span class="s1">var bb = opts.getBoundingBox(ele);</span><span class="s3">\n      </span><span class="s1">var atlas = this.getOrCreateAtlas(ele, type, bb);</span><span class="s3">\n      </span><span class="s1">var index = this.getAtlasIndexForBatch(atlas);</span><span class="s3">\n      </span><span class="s1">if (index === undefined) {</span><span class="s3">\n        </span><span class="s1">return undefined; // batch is full</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var styleKey = opts.getKey(ele);</span><span class="s3">\n      </span><span class="s1">var _atlas$getOffsets3 = atlas.getOffsets(styleKey),</span><span class="s3">\n        </span><span class="s1">_atlas$getOffsets4 = _slicedToArray(_atlas$getOffsets3, 2),</span><span class="s3">\n        </span><span class="s1">tex1 = _atlas$getOffsets4[0],</span><span class="s3">\n        </span><span class="s1">tex2 = _atlas$getOffsets4[1];</span><span class="s3">\n      </span><span class="s1">// This object may be passed back to setTransformMatrix()</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">index: index,</span><span class="s3">\n        </span><span class="s1">tex1: tex1,</span><span class="s3">\n        </span><span class="s1">tex2: tex2,</span><span class="s3">\n        </span><span class="s1">bb: bb</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* matrix is expected to be a 9 element array</span><span class="s3">\n     </span><span class="s1">* this function follows same pattern as CRp.drawCachedElementPortion(...)</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">setTransformMatrix</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function setTransformMatrix(ele, matrix, type, atlasInfo) {</span><span class="s3">\n      </span><span class="s1">var first = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true;</span><span class="s3">\n      </span><span class="s1">var opts = this.getRenderTypeOpts(type);</span><span class="s3">\n      </span><span class="s1">var padding = opts.getPadding ? opts.getPadding(ele) : 0;</span><span class="s3">\n      </span><span class="s1">if (atlasInfo) {</span><span class="s3">\n        </span><span class="s1">// we've already computed the bb and tex bounds for a texture</span><span class="s3">\n        </span><span class="s1">var bb = atlasInfo.bb,</span><span class="s3">\n          </span><span class="s1">tex1 = atlasInfo.tex1,</span><span class="s3">\n          </span><span class="s1">tex2 = atlasInfo.tex2;</span><span class="s3">\n\n        </span><span class="s1">// wrapped textures need separate matrix for each part</span><span class="s3">\n        </span><span class="s1">var ratio = tex1.w / (tex1.w + tex2.w);</span><span class="s3">\n        </span><span class="s1">if (!first) {</span><span class="s3">\n          </span><span class="s1">// first = true means its the first part of the wrapped texture</span><span class="s3">\n          </span><span class="s1">ratio = 1 - ratio;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var adjBB = this.getAdjustedBB(bb, padding, first, ratio);</span><span class="s3">\n        </span><span class="s1">this._applyTransformMatrix(matrix, adjBB, opts, ele);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// we don't have a texture yet, or we want to avoid creating a texture for simple shapes</span><span class="s3">\n        </span><span class="s1">var _bb = opts.getBoundingBox(ele);</span><span class="s3">\n        </span><span class="s1">var _adjBB = this.getAdjustedBB(_bb, padding, true, 1);</span><span class="s3">\n        </span><span class="s1">this._applyTransformMatrix(matrix, _adjBB, opts, ele);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">_applyTransformMatrix</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function _applyTransformMatrix(matrix, adjBB, opts, ele) {</span><span class="s3">\n      </span><span class="s1">var x, y;</span><span class="s3">\n      </span><span class="s1">identity(matrix);</span><span class="s3">\n      </span><span class="s1">var theta = opts.getRotation ? opts.getRotation(ele) : 0;</span><span class="s3">\n      </span><span class="s1">if (theta !== 0) {</span><span class="s3">\n        </span><span class="s1">var _opts$getRotationPoin = opts.getRotationPoint(ele),</span><span class="s3">\n          </span><span class="s1">sx = _opts$getRotationPoin.x,</span><span class="s3">\n          </span><span class="s1">sy = _opts$getRotationPoin.y;</span><span class="s3">\n        </span><span class="s1">translate(matrix, matrix, [sx, sy]);</span><span class="s3">\n        </span><span class="s1">rotate(matrix, matrix, theta);</span><span class="s3">\n        </span><span class="s1">var offset = opts.getRotationOffset(ele);</span><span class="s3">\n        </span><span class="s1">x = offset.x + adjBB.xOffset;</span><span class="s3">\n        </span><span class="s1">y = offset.y;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">x = adjBB.x1;</span><span class="s3">\n        </span><span class="s1">y = adjBB.y1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">translate(matrix, matrix, [x, y]);</span><span class="s3">\n      </span><span class="s1">scale(matrix, matrix, [adjBB.w, adjBB.h]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Adjusts a node or label BB to accomodate padding and split for wrapped textures.</span><span class="s3">\n     </span><span class="s1">* @param bb - the original bounding box</span><span class="s3">\n     </span><span class="s1">* @param padding - the padding to add to the bounding box</span><span class="s3">\n     </span><span class="s1">* @param first - whether this is the first part of a wrapped texture</span><span class="s3">\n     </span><span class="s1">* @param ratio - the ratio of the texture width of part of the text to the entire texture</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAdjustedBB</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getAdjustedBB(bb, padding, first, ratio) {</span><span class="s3">\n      </span><span class="s1">var x1 = bb.x1,</span><span class="s3">\n        </span><span class="s1">y1 = bb.y1,</span><span class="s3">\n        </span><span class="s1">w = bb.w,</span><span class="s3">\n        </span><span class="s1">h = bb.h;</span><span class="s3">\n      </span><span class="s1">if (padding) {</span><span class="s3">\n        </span><span class="s1">x1 -= padding;</span><span class="s3">\n        </span><span class="s1">y1 -= padding;</span><span class="s3">\n        </span><span class="s1">w += 2 * padding;</span><span class="s3">\n        </span><span class="s1">h += 2 * padding;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var xOffset = 0;</span><span class="s3">\n      </span><span class="s1">var adjW = w * ratio;</span><span class="s3">\n      </span><span class="s1">if (first &amp;&amp; ratio &lt; 1) {</span><span class="s3">\n        </span><span class="s1">w = adjW;</span><span class="s3">\n      </span><span class="s1">} else if (!first &amp;&amp; ratio &lt; 1) {</span><span class="s3">\n        </span><span class="s1">xOffset = w - adjW;</span><span class="s3">\n        </span><span class="s1">x1 += xOffset;</span><span class="s3">\n        </span><span class="s1">w = adjW;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x1: x1,</span><span class="s3">\n        </span><span class="s1">y1: y1,</span><span class="s3">\n        </span><span class="s1">w: w,</span><span class="s3">\n        </span><span class="s1">h: h,</span><span class="s3">\n        </span><span class="s1">xOffset: xOffset</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getDebugInfo</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getDebugInfo() {</span><span class="s3">\n      </span><span class="s1">var debugInfo = [];</span><span class="s3">\n      </span><span class="s1">var _iterator6 = _createForOfIteratorHelper(this.collections),</span><span class="s3">\n        </span><span class="s1">_step6;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {</span><span class="s3">\n          </span><span class="s1">var _step6$value = _slicedToArray(_step6.value, 2),</span><span class="s3">\n            </span><span class="s1">name = _step6$value[0],</span><span class="s3">\n            </span><span class="s1">collection = _step6$value[1];</span><span class="s3">\n          </span><span class="s1">var _collection$getCounts = collection.getCounts(),</span><span class="s3">\n            </span><span class="s1">keyCount = _collection$getCounts.keyCount,</span><span class="s3">\n            </span><span class="s1">atlasCount = _collection$getCounts.atlasCount;</span><span class="s3">\n          </span><span class="s1">debugInfo.push({</span><span class="s3">\n            </span><span class="s1">type: name,</span><span class="s3">\n            </span><span class="s1">keyCount: keyCount,</span><span class="s3">\n            </span><span class="s1">atlasCount: atlasCount</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_iterator6.e(err);</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">_iterator6.f();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return debugInfo;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">// Vertex types</span><span class="s3">\n</span><span class="s1">var TEXTURE = 0;</span><span class="s3">\n</span><span class="s1">var EDGE_STRAIGHT = 1;</span><span class="s3">\n</span><span class="s1">var EDGE_CURVE_SEGMENT = 2;</span><span class="s3">\n</span><span class="s1">var EDGE_ARROW = 3;</span><span class="s3">\n</span><span class="s1">var RECTANGLE = 4;</span><span class="s3">\n</span><span class="s1">var ElementDrawingWebGL = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">/** </span><span class="s3">\n   </span><span class="s1">* @param {WebGLRenderingContext} gl </span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function ElementDrawingWebGL(r, gl, opts) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, ElementDrawingWebGL);</span><span class="s3">\n    </span><span class="s1">this.r = r;</span><span class="s3">\n    </span><span class="s1">this.gl = gl;</span><span class="s3">\n    </span><span class="s1">this.maxInstances = opts.webglBatchSize;</span><span class="s3">\n    </span><span class="s1">this.atlasSize = opts.webglTexSize;</span><span class="s3">\n    </span><span class="s1">this.bgColor = opts.bgColor;</span><span class="s3">\n    </span><span class="s1">this.debug = opts.webglDebug;</span><span class="s3">\n    </span><span class="s1">this.batchDebugInfo = [];</span><span class="s3">\n    </span><span class="s1">opts.enableWrapping = true;</span><span class="s3">\n    </span><span class="s1">opts.createTextureCanvas = createTextureCanvas; // Unit tests mock this</span><span class="s3">\n    </span><span class="s1">this.atlasManager = new AtlasManager(r, opts);</span><span class="s3">\n    </span><span class="s1">this.program = this.createShaderProgram(RENDER_TARGET.SCREEN);</span><span class="s3">\n    </span><span class="s1">this.pickingProgram = this.createShaderProgram(RENDER_TARGET.PICKING);</span><span class="s3">\n    </span><span class="s1">this.vao = this.createVAO();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(ElementDrawingWebGL, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">addAtlasCollection</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function addAtlasCollection(groupName, opts) {</span><span class="s3">\n      </span><span class="s1">this.atlasManager.addAtlasCollection(groupName, opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">addAtlasRenderType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function addAtlasRenderType(typeName, opts) {</span><span class="s3">\n      </span><span class="s1">this.atlasManager.addRenderType(typeName, opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">invalidate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function invalidate(eles) {</span><span class="s3">\n      </span><span class="s1">var _ref = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {},</span><span class="s3">\n        </span><span class="s1">type = _ref.type;</span><span class="s3">\n      </span><span class="s1">var atlasManager = this.atlasManager;</span><span class="s3">\n      </span><span class="s1">if (type) {</span><span class="s3">\n        </span><span class="s1">return atlasManager.invalidate(eles, {</span><span class="s3">\n          </span><span class="s1">filterType: function filterType(t) {</span><span class="s3">\n            </span><span class="s1">return t === type;</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">forceRedraw: true</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return atlasManager.invalidate(eles);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">gc</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function gc() {</span><span class="s3">\n      </span><span class="s1">this.atlasManager.gc();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">createShaderProgram</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function createShaderProgram(renderTarget) {</span><span class="s3">\n      </span><span class="s1">var gl = this.gl;</span><span class="s3">\n\n      </span><span class="s1">// compute texture coordinates in the shader, becase we are using instanced drawing</span><span class="s3">\n      </span><span class="s1">var vertexShaderSource = </span><span class="s3">\&quot;</span><span class="s1">#version 300 es</span><span class="s3">\\</span><span class="s1">n      precision highp float;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      uniform mat3 uPanZoomMatrix;</span><span class="s3">\\</span><span class="s1">n      uniform int  uAtlasSize;</span><span class="s3">\\</span><span class="s1">n      </span><span class="s3">\\</span><span class="s1">n      // instanced</span><span class="s3">\\</span><span class="s1">n      in vec2 aPosition; </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      in mat3 aTransform;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      // what are we rendering?</span><span class="s3">\\</span><span class="s1">n      in int aVertType;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      // for picking</span><span class="s3">\\</span><span class="s1">n      in vec4 aIndex;</span><span class="s3">\\</span><span class="s1">n      </span><span class="s3">\\</span><span class="s1">n      // For textures</span><span class="s3">\\</span><span class="s1">n      in int aAtlasId; // which shader unit/atlas to use</span><span class="s3">\\</span><span class="s1">n      in vec4 aTex; // x/y/w/h of texture in atlas</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      // for edges</span><span class="s3">\\</span><span class="s1">n      in vec4 aPointAPointB;</span><span class="s3">\\</span><span class="s1">n      in vec4 aPointCPointD;</span><span class="s3">\\</span><span class="s1">n      in float aLineWidth;</span><span class="s3">\\</span><span class="s1">n      in vec4 aColor;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      out vec2 vTexCoord;</span><span class="s3">\\</span><span class="s1">n      out vec4 vColor;</span><span class="s3">\\</span><span class="s1">n      flat out int vAtlasId;</span><span class="s3">\\</span><span class="s1">n      flat out vec4 vIndex;</span><span class="s3">\\</span><span class="s1">n      flat out int vVertType;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      void main(void) {</span><span class="s3">\\</span><span class="s1">n        int vid = gl_VertexID;</span><span class="s3">\\</span><span class="s1">n        vec2 position = aPosition;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n        if(aVertType == </span><span class="s3">\&quot;</span><span class="s1">.concat(TEXTURE, </span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\\</span><span class="s1">n          float texX = aTex.x;</span><span class="s3">\\</span><span class="s1">n          float texY = aTex.y;</span><span class="s3">\\</span><span class="s1">n          float texW = aTex.z;</span><span class="s3">\\</span><span class="s1">n          float texH = aTex.w;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          int vid = gl_VertexID;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          if(vid == 1 || vid == 2 || vid == 4) {</span><span class="s3">\\</span><span class="s1">n            texX += texW;</span><span class="s3">\\</span><span class="s1">n          }</span><span class="s3">\\</span><span class="s1">n          if(vid == 2 || vid == 4 || vid == 5) {</span><span class="s3">\\</span><span class="s1">n            texY += texH;</span><span class="s3">\\</span><span class="s1">n          }</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          float d = float(uAtlasSize);</span><span class="s3">\\</span><span class="s1">n          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);</span><span class="s3">\\</span><span class="s1">n        }</span><span class="s3">\\</span><span class="s1">n        else if(aVertType == </span><span class="s3">\&quot;</span><span class="s1">).concat(RECTANGLE, </span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\\</span><span class="s1">n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);</span><span class="s3">\\</span><span class="s1">n          vColor = aColor;</span><span class="s3">\\</span><span class="s1">n        }</span><span class="s3">\\</span><span class="s1">n        else if(aVertType == </span><span class="s3">\&quot;</span><span class="s1">).concat(EDGE_STRAIGHT, </span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\\</span><span class="s1">n          vec2 source = aPointAPointB.xy;</span><span class="s3">\\</span><span class="s1">n          vec2 target = aPointAPointB.zw;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          // adjust the geometry so that the line is centered on the edge</span><span class="s3">\\</span><span class="s1">n          position.y = position.y - 0.5;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          vec2 xBasis = target - source;</span><span class="s3">\\</span><span class="s1">n          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));</span><span class="s3">\\</span><span class="s1">n          vec2 point = source + xBasis * position.x + yBasis * aLineWidth * position.y;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);</span><span class="s3">\\</span><span class="s1">n          vColor = aColor;</span><span class="s3">\\</span><span class="s1">n        } </span><span class="s3">\\</span><span class="s1">n        else if(aVertType == </span><span class="s3">\&quot;</span><span class="s1">).concat(EDGE_CURVE_SEGMENT, </span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\\</span><span class="s1">n          vec2 pointA = aPointAPointB.xy;</span><span class="s3">\\</span><span class="s1">n          vec2 pointB = aPointAPointB.zw;</span><span class="s3">\\</span><span class="s1">n          vec2 pointC = aPointCPointD.xy;</span><span class="s3">\\</span><span class="s1">n          vec2 pointD = aPointCPointD.zw;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          // adjust the geometry so that the line is centered on the edge</span><span class="s3">\\</span><span class="s1">n          position.y = position.y - 0.5;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          vec2 p0 = pointA;</span><span class="s3">\\</span><span class="s1">n          vec2 p1 = pointB;</span><span class="s3">\\</span><span class="s1">n          vec2 p2 = pointC;</span><span class="s3">\\</span><span class="s1">n          vec2 pos = position;</span><span class="s3">\\</span><span class="s1">n          if(position.x == 1.0) {</span><span class="s3">\\</span><span class="s1">n            p0 = pointD;</span><span class="s3">\\</span><span class="s1">n            p1 = pointC;</span><span class="s3">\\</span><span class="s1">n            p2 = pointB;</span><span class="s3">\\</span><span class="s1">n            pos = vec2(0.0, -position.y);</span><span class="s3">\\</span><span class="s1">n          }</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          vec2 p01 = p1 - p0;</span><span class="s3">\\</span><span class="s1">n          vec2 p12 = p2 - p1;</span><span class="s3">\\</span><span class="s1">n          vec2 p21 = p1 - p2;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          // Find the normal vector.</span><span class="s3">\\</span><span class="s1">n          vec2 tangent = normalize(normalize(p12) + normalize(p01));</span><span class="s3">\\</span><span class="s1">n          vec2 normal = vec2(-tangent.y, tangent.x);</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          // Find the vector perpendicular to p0 -&gt; p1.</span><span class="s3">\\</span><span class="s1">n          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          // Determine the bend direction.</span><span class="s3">\\</span><span class="s1">n          float sigma = sign(dot(p01 + p21, normal));</span><span class="s3">\\</span><span class="s1">n          float width = aLineWidth;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          if(sign(pos.y) == -sigma) {</span><span class="s3">\\</span><span class="s1">n            // This is an intersecting vertex. Adjust the position so that there's no overlap.</span><span class="s3">\\</span><span class="s1">n            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);</span><span class="s3">\\</span><span class="s1">n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);</span><span class="s3">\\</span><span class="s1">n          } else {</span><span class="s3">\\</span><span class="s1">n            // This is a non-intersecting vertex. Treat it like a mitre join.</span><span class="s3">\\</span><span class="s1">n            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);</span><span class="s3">\\</span><span class="s1">n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);</span><span class="s3">\\</span><span class="s1">n          }</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          vColor = aColor;</span><span class="s3">\\</span><span class="s1">n        } </span><span class="s3">\\</span><span class="s1">n        else if(aVertType == </span><span class="s3">\&quot;</span><span class="s1">).concat(EDGE_ARROW, </span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; vid &lt; 3) {</span><span class="s3">\\</span><span class="s1">n          // massage the first triangle into an edge arrow</span><span class="s3">\\</span><span class="s1">n          if(vid == 0)</span><span class="s3">\\</span><span class="s1">n            position = vec2(-0.15, -0.3);</span><span class="s3">\\</span><span class="s1">n          if(vid == 1)</span><span class="s3">\\</span><span class="s1">n            position = vec2( 0.0,   0.0);</span><span class="s3">\\</span><span class="s1">n          if(vid == 2)</span><span class="s3">\\</span><span class="s1">n            position = vec2( 0.15, -0.3);</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);</span><span class="s3">\\</span><span class="s1">n          vColor = aColor;</span><span class="s3">\\</span><span class="s1">n        }</span><span class="s3">\\</span><span class="s1">n        else {</span><span class="s3">\\</span><span class="s1">n          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space</span><span class="s3">\\</span><span class="s1">n        }</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n        vAtlasId = aAtlasId;</span><span class="s3">\\</span><span class="s1">n        vIndex = aIndex;</span><span class="s3">\\</span><span class="s1">n        vVertType = aVertType;</span><span class="s3">\\</span><span class="s1">n      }</span><span class="s3">\\</span><span class="s1">n    </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">var idxs = this.atlasManager.getIndexArray();</span><span class="s3">\n      </span><span class="s1">var fragmentShaderSource = </span><span class="s3">\&quot;</span><span class="s1">#version 300 es</span><span class="s3">\\</span><span class="s1">n      precision highp float;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      // define texture unit for each node in the batch</span><span class="s3">\\</span><span class="s1">n      </span><span class="s3">\&quot;</span><span class="s1">.concat(idxs.map(function (i) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">uniform sampler2D uTexture</span><span class="s3">\&quot;</span><span class="s1">.concat(i, </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}).join('</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t'), </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      uniform vec4 uBGColor;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      in vec2 vTexCoord;</span><span class="s3">\\</span><span class="s1">n      in vec4 vColor;</span><span class="s3">\\</span><span class="s1">n      flat in int vAtlasId;</span><span class="s3">\\</span><span class="s1">n      flat in vec4 vIndex;</span><span class="s3">\\</span><span class="s1">n      flat in int vVertType;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      out vec4 outColor;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n      void main(void) {</span><span class="s3">\\</span><span class="s1">n        if(vVertType == </span><span class="s3">\&quot;</span><span class="s1">).concat(TEXTURE, </span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\\</span><span class="s1">n          </span><span class="s3">\&quot;</span><span class="s1">).concat(idxs.map(function (i) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">if(vAtlasId == </span><span class="s3">\&quot;</span><span class="s1">.concat(i, </span><span class="s3">\&quot;</span><span class="s1">) outColor = texture(uTexture</span><span class="s3">\&quot;</span><span class="s1">).concat(i, </span><span class="s3">\&quot;</span><span class="s1">, vTexCoord);</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}).join('</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">telse '), </span><span class="s3">\&quot;\\</span><span class="s1">n        } else if(vVertType == </span><span class="s3">\&quot;</span><span class="s1">).concat(EDGE_ARROW, </span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\\</span><span class="s1">n          // blend arrow color with background (using premultiplied alpha)</span><span class="s3">\\</span><span class="s1">n          outColor.rgb = vColor.rgb + (uBGColor.rgb * (1.0 - vColor.a)); </span><span class="s3">\\</span><span class="s1">n          outColor.a = 1.0; // make opaque, masks out line under arrow</span><span class="s3">\\</span><span class="s1">n        } else {</span><span class="s3">\\</span><span class="s1">n          outColor = vColor;</span><span class="s3">\\</span><span class="s1">n        }</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n        </span><span class="s3">\&quot;</span><span class="s1">).concat(renderTarget.picking ? </span><span class="s3">\&quot;</span><span class="s1">if(outColor.a == 0.0) discard;</span><span class="s3">\\</span><span class="s1">n             else outColor = vIndex;</span><span class="s3">\&quot; </span><span class="s1">: '', </span><span class="s3">\&quot;\\</span><span class="s1">n      }</span><span class="s3">\\</span><span class="s1">n    </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">var program = createProgram(gl, vertexShaderSource, fragmentShaderSource);</span><span class="s3">\n\n      </span><span class="s1">// instance geometry</span><span class="s3">\n      </span><span class="s1">program.aPosition = gl.getAttribLocation(program, 'aPosition');</span><span class="s3">\n\n      </span><span class="s1">// attributes</span><span class="s3">\n      </span><span class="s1">program.aIndex = gl.getAttribLocation(program, 'aIndex');</span><span class="s3">\n      </span><span class="s1">program.aVertType = gl.getAttribLocation(program, 'aVertType');</span><span class="s3">\n      </span><span class="s1">program.aTransform = gl.getAttribLocation(program, 'aTransform');</span><span class="s3">\n      </span><span class="s1">program.aAtlasId = gl.getAttribLocation(program, 'aAtlasId');</span><span class="s3">\n      </span><span class="s1">program.aTex = gl.getAttribLocation(program, 'aTex');</span><span class="s3">\n      </span><span class="s1">program.aPointAPointB = gl.getAttribLocation(program, 'aPointAPointB');</span><span class="s3">\n      </span><span class="s1">program.aPointCPointD = gl.getAttribLocation(program, 'aPointCPointD');</span><span class="s3">\n      </span><span class="s1">program.aLineWidth = gl.getAttribLocation(program, 'aLineWidth');</span><span class="s3">\n      </span><span class="s1">program.aColor = gl.getAttribLocation(program, 'aColor');</span><span class="s3">\n\n      </span><span class="s1">// uniforms</span><span class="s3">\n      </span><span class="s1">program.uPanZoomMatrix = gl.getUniformLocation(program, 'uPanZoomMatrix');</span><span class="s3">\n      </span><span class="s1">program.uAtlasSize = gl.getUniformLocation(program, 'uAtlasSize');</span><span class="s3">\n      </span><span class="s1">program.uBGColor = gl.getUniformLocation(program, 'uBGColor');</span><span class="s3">\n      </span><span class="s1">program.uTextures = [];</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; this.atlasManager.getMaxAtlasesPerBatch(); i++) {</span><span class="s3">\n        </span><span class="s1">program.uTextures.push(gl.getUniformLocation(program, </span><span class="s3">\&quot;</span><span class="s1">uTexture</span><span class="s3">\&quot;</span><span class="s1">.concat(i)));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return program;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">createVAO</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function createVAO() {</span><span class="s3">\n      </span><span class="s1">var instanceGeometry = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1];</span><span class="s3">\n      </span><span class="s1">this.vertexCount = instanceGeometry.length / 2;</span><span class="s3">\n      </span><span class="s1">var n = this.maxInstances;</span><span class="s3">\n      </span><span class="s1">var gl = this.gl,</span><span class="s3">\n        </span><span class="s1">program = this.program;</span><span class="s3">\n      </span><span class="s1">var vao = gl.createVertexArray();</span><span class="s3">\n      </span><span class="s1">gl.bindVertexArray(vao);</span><span class="s3">\n      </span><span class="s1">createBufferStaticDraw(gl, 'vec2', program.aPosition, instanceGeometry);</span><span class="s3">\n\n      </span><span class="s1">// Create buffers for all the attributes</span><span class="s3">\n      </span><span class="s1">this.transformBuffer = create3x3MatrixBufferDynamicDraw(gl, n, program.aTransform);</span><span class="s3">\n      </span><span class="s1">this.indexBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aIndex);</span><span class="s3">\n      </span><span class="s1">this.vertTypeBuffer = createBufferDynamicDraw(gl, n, 'int', program.aVertType);</span><span class="s3">\n      </span><span class="s1">this.atlasIdBuffer = createBufferDynamicDraw(gl, n, 'int', program.aAtlasId);</span><span class="s3">\n      </span><span class="s1">this.texBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aTex);</span><span class="s3">\n      </span><span class="s1">this.pointAPointBBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aPointAPointB);</span><span class="s3">\n      </span><span class="s1">this.pointCPointDBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aPointCPointD);</span><span class="s3">\n      </span><span class="s1">this.lineWidthBuffer = createBufferDynamicDraw(gl, n, 'float', program.aLineWidth);</span><span class="s3">\n      </span><span class="s1">this.colorBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aColor);</span><span class="s3">\n      </span><span class="s1">gl.bindVertexArray(null);</span><span class="s3">\n      </span><span class="s1">return vao;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">buffers</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">get: function get() {</span><span class="s3">\n      </span><span class="s1">var _this = this;</span><span class="s3">\n      </span><span class="s1">if (!this._buffers) {</span><span class="s3">\n        </span><span class="s1">this._buffers = Object.keys(this).filter(function (k) {</span><span class="s3">\n          </span><span class="s1">return k.endsWith('Buffer');</span><span class="s3">\n        </span><span class="s1">}).map(function (k) {</span><span class="s3">\n          </span><span class="s1">return _this[k];</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this._buffers;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">startFrame</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function startFrame(panZoomMatrix) {</span><span class="s3">\n      </span><span class="s1">var renderTarget = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : RENDER_TARGET.SCREEN;</span><span class="s3">\n      </span><span class="s1">this.panZoomMatrix = panZoomMatrix;</span><span class="s3">\n      </span><span class="s1">this.renderTarget = renderTarget;</span><span class="s3">\n      </span><span class="s1">this.batchDebugInfo = [];</span><span class="s3">\n      </span><span class="s1">this.wrappedCount = 0; // TODO this should be in the AtlasManager</span><span class="s3">\n      </span><span class="s1">this.rectangleCount = 0;</span><span class="s3">\n      </span><span class="s1">this.startBatch();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">startBatch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function startBatch() {</span><span class="s3">\n      </span><span class="s1">this.instanceCount = 0;</span><span class="s3">\n      </span><span class="s1">this.atlasManager.startBatch();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">endFrame</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function endFrame() {</span><span class="s3">\n      </span><span class="s1">this.endBatch();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getTempMatrix</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getTempMatrix() {</span><span class="s3">\n      </span><span class="s1">return this.tempMatrix = this.tempMatrix || create();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">drawTexture</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function drawTexture(ele, eleIndex, type) {</span><span class="s3">\n      </span><span class="s1">var atlasManager = this.atlasManager;</span><span class="s3">\n      </span><span class="s1">if (!ele.visible()) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!atlasManager.getRenderTypeOpts(type).isVisible(ele)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!atlasManager.canAddToCurrentBatch(ele, type)) {</span><span class="s3">\n        </span><span class="s1">this.endBatch(); // draws then starts a new batch</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.instanceCount + 1 &gt;= this.maxInstances) {</span><span class="s3">\n        </span><span class="s1">this.endBatch(); // make sure there's space for at least two instances, wrapped textures need two instances</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var instance = this.instanceCount;</span><span class="s3">\n      </span><span class="s1">this.vertTypeBuffer.getView(instance)[0] = TEXTURE;</span><span class="s3">\n      </span><span class="s1">var indexView = this.indexBuffer.getView(instance);</span><span class="s3">\n      </span><span class="s1">indexToVec4(eleIndex, indexView);</span><span class="s3">\n      </span><span class="s1">var atlasInfo = atlasManager.getAtlasInfo(ele, type);</span><span class="s3">\n      </span><span class="s1">var index = atlasInfo.index,</span><span class="s3">\n        </span><span class="s1">tex1 = atlasInfo.tex1,</span><span class="s3">\n        </span><span class="s1">tex2 = atlasInfo.tex2;</span><span class="s3">\n      </span><span class="s1">if (tex2.w &gt; 0) this.wrappedCount++;</span><span class="s3">\n      </span><span class="s1">var first = true;</span><span class="s3">\n      </span><span class="s1">for (var _i = 0, _arr = [tex1, tex2]; _i &lt; _arr.length; _i++) {</span><span class="s3">\n        </span><span class="s1">var tex = _arr[_i];</span><span class="s3">\n        </span><span class="s1">if (tex.w != 0) {</span><span class="s3">\n          </span><span class="s1">var _instance = this.instanceCount;</span><span class="s3">\n          </span><span class="s1">this.vertTypeBuffer.getView(_instance)[0] = TEXTURE;</span><span class="s3">\n          </span><span class="s1">var _indexView = this.indexBuffer.getView(_instance);</span><span class="s3">\n          </span><span class="s1">indexToVec4(eleIndex, _indexView);</span><span class="s3">\n\n          </span><span class="s1">// Set values in the buffers using Typed Array Views for performance.</span><span class="s3">\n          </span><span class="s1">var atlasIdView = this.atlasIdBuffer.getView(_instance);</span><span class="s3">\n          </span><span class="s1">atlasIdView[0] = index;</span><span class="s3">\n\n          </span><span class="s1">// we have two sets of texture coordinates and transforms because textures can wrap in the atlas</span><span class="s3">\n          </span><span class="s1">var texView = this.texBuffer.getView(_instance);</span><span class="s3">\n          </span><span class="s1">texView[0] = tex.x;</span><span class="s3">\n          </span><span class="s1">texView[1] = tex.y;</span><span class="s3">\n          </span><span class="s1">texView[2] = tex.w;</span><span class="s3">\n          </span><span class="s1">texView[3] = tex.h;</span><span class="s3">\n          </span><span class="s1">var matrixView = this.transformBuffer.getMatrixView(_instance);</span><span class="s3">\n          </span><span class="s1">atlasManager.setTransformMatrix(ele, matrixView, type, atlasInfo, first);</span><span class="s3">\n          </span><span class="s1">this.instanceCount++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">first = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.instanceCount &gt;= this.maxInstances) {</span><span class="s3">\n        </span><span class="s1">this.endBatch();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">drawSimpleRectangle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function drawSimpleRectangle(ele, eleIndex, type) {</span><span class="s3">\n      </span><span class="s1">if (!ele.visible()) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var atlasManager = this.atlasManager;</span><span class="s3">\n      </span><span class="s1">var instance = this.instanceCount;</span><span class="s3">\n      </span><span class="s1">this.vertTypeBuffer.getView(instance)[0] = RECTANGLE;</span><span class="s3">\n      </span><span class="s1">var indexView = this.indexBuffer.getView(instance);</span><span class="s3">\n      </span><span class="s1">indexToVec4(eleIndex, indexView);</span><span class="s3">\n      </span><span class="s1">var color = ele.pstyle('background-color').value;</span><span class="s3">\n      </span><span class="s1">var opacity = ele.pstyle('background-opacity').value;</span><span class="s3">\n      </span><span class="s1">var colorView = this.colorBuffer.getView(instance);</span><span class="s3">\n      </span><span class="s1">toWebGLColor(color, opacity, colorView);</span><span class="s3">\n      </span><span class="s1">var matrixView = this.transformBuffer.getMatrixView(instance);</span><span class="s3">\n      </span><span class="s1">atlasManager.setTransformMatrix(ele, matrixView, type);</span><span class="s3">\n      </span><span class="s1">this.rectangleCount++;</span><span class="s3">\n      </span><span class="s1">this.instanceCount++;</span><span class="s3">\n      </span><span class="s1">if (this.instanceCount &gt;= this.maxInstances) {</span><span class="s3">\n        </span><span class="s1">this.endBatch();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">drawEdgeArrow</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function drawEdgeArrow(edge, eleIndex, prefix) {</span><span class="s3">\n      </span><span class="s1">if (!edge.visible()) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Edge points and arrow angles etc are calculated by the base renderer and cached in the rscratch object.</span><span class="s3">\n      </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n      </span><span class="s1">var x, y, angle;</span><span class="s3">\n      </span><span class="s1">if (prefix === 'source') {</span><span class="s3">\n        </span><span class="s1">x = rs.arrowStartX;</span><span class="s3">\n        </span><span class="s1">y = rs.arrowStartY;</span><span class="s3">\n        </span><span class="s1">angle = rs.srcArrowAngle;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">x = rs.arrowEndX;</span><span class="s3">\n        </span><span class="s1">y = rs.arrowEndY;</span><span class="s3">\n        </span><span class="s1">angle = rs.tgtArrowAngle;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// taken from CRp.drawArrowhead</span><span class="s3">\n      </span><span class="s1">if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// check shape after the x/y check because pstyle() is a bit slow</span><span class="s3">\n      </span><span class="s1">var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;</span><span class="s3">\n      </span><span class="s1">if (arrowShape === 'none') {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var color = edge.pstyle(prefix + '-arrow-color').value;</span><span class="s3">\n      </span><span class="s1">var baseOpacity = edge.pstyle('opacity').value;</span><span class="s3">\n      </span><span class="s1">var lineOpacity = edge.pstyle('line-opacity').value;</span><span class="s3">\n      </span><span class="s1">var opacity = baseOpacity * lineOpacity;</span><span class="s3">\n      </span><span class="s1">var lineWidth = edge.pstyle('width').pfValue;</span><span class="s3">\n      </span><span class="s1">var scale$1 = edge.pstyle('arrow-scale').value;</span><span class="s3">\n      </span><span class="s1">var size = this.r.getArrowWidth(lineWidth, scale$1);</span><span class="s3">\n      </span><span class="s1">var instance = this.instanceCount;</span><span class="s3">\n      </span><span class="s1">var transform = this.transformBuffer.getMatrixView(instance);</span><span class="s3">\n      </span><span class="s1">identity(transform);</span><span class="s3">\n      </span><span class="s1">translate(transform, transform, [x, y]);</span><span class="s3">\n      </span><span class="s1">scale(transform, transform, [size, size]);</span><span class="s3">\n      </span><span class="s1">rotate(transform, transform, angle);</span><span class="s3">\n      </span><span class="s1">this.vertTypeBuffer.getView(instance)[0] = EDGE_ARROW;</span><span class="s3">\n      </span><span class="s1">var indexView = this.indexBuffer.getView(instance);</span><span class="s3">\n      </span><span class="s1">indexToVec4(eleIndex, indexView);</span><span class="s3">\n      </span><span class="s1">var colorView = this.colorBuffer.getView(instance);</span><span class="s3">\n      </span><span class="s1">toWebGLColor(color, opacity, colorView);</span><span class="s3">\n      </span><span class="s1">this.instanceCount++;</span><span class="s3">\n      </span><span class="s1">if (this.instanceCount &gt;= this.maxInstances) {</span><span class="s3">\n        </span><span class="s1">this.endBatch();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">drawEdgeLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function drawEdgeLine(edge, eleIndex) {</span><span class="s3">\n      </span><span class="s1">if (!edge.visible()) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var points = this.getEdgePoints(edge);</span><span class="s3">\n      </span><span class="s1">if (!points) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// line style</span><span class="s3">\n      </span><span class="s1">var baseOpacity = edge.pstyle('opacity').value;</span><span class="s3">\n      </span><span class="s1">var lineOpacity = edge.pstyle('line-opacity').value;</span><span class="s3">\n      </span><span class="s1">var width = edge.pstyle('width').pfValue;</span><span class="s3">\n      </span><span class="s1">var color = edge.pstyle('line-color').value;</span><span class="s3">\n      </span><span class="s1">var opacity = baseOpacity * lineOpacity;</span><span class="s3">\n      </span><span class="s1">if (points.length / 2 + this.instanceCount &gt; this.maxInstances) {</span><span class="s3">\n        </span><span class="s1">this.endBatch();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (points.length == 4) {</span><span class="s3">\n        </span><span class="s1">// straight line</span><span class="s3">\n        </span><span class="s1">var instance = this.instanceCount;</span><span class="s3">\n        </span><span class="s1">this.vertTypeBuffer.getView(instance)[0] = EDGE_STRAIGHT;</span><span class="s3">\n        </span><span class="s1">var indexView = this.indexBuffer.getView(instance);</span><span class="s3">\n        </span><span class="s1">indexToVec4(eleIndex, indexView);</span><span class="s3">\n        </span><span class="s1">var colorView = this.colorBuffer.getView(instance);</span><span class="s3">\n        </span><span class="s1">toWebGLColor(color, opacity, colorView);</span><span class="s3">\n        </span><span class="s1">var lineWidthBuffer = this.lineWidthBuffer.getView(instance);</span><span class="s3">\n        </span><span class="s1">lineWidthBuffer[0] = width;</span><span class="s3">\n        </span><span class="s1">var sourceTargetView = this.pointAPointBBuffer.getView(instance);</span><span class="s3">\n        </span><span class="s1">sourceTargetView[0] = points[0]; // source x</span><span class="s3">\n        </span><span class="s1">sourceTargetView[1] = points[1]; // source y</span><span class="s3">\n        </span><span class="s1">sourceTargetView[2] = points[2]; // target x</span><span class="s3">\n        </span><span class="s1">sourceTargetView[3] = points[3]; // target y</span><span class="s3">\n\n        </span><span class="s1">this.instanceCount++;</span><span class="s3">\n        </span><span class="s1">if (this.instanceCount &gt;= this.maxInstances) {</span><span class="s3">\n          </span><span class="s1">this.endBatch();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// curved line</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; points.length - 2; i += 2) {</span><span class="s3">\n          </span><span class="s1">var _instance2 = this.instanceCount;</span><span class="s3">\n          </span><span class="s1">this.vertTypeBuffer.getView(_instance2)[0] = EDGE_CURVE_SEGMENT;</span><span class="s3">\n          </span><span class="s1">var _indexView2 = this.indexBuffer.getView(_instance2);</span><span class="s3">\n          </span><span class="s1">indexToVec4(eleIndex, _indexView2);</span><span class="s3">\n          </span><span class="s1">var _colorView = this.colorBuffer.getView(_instance2);</span><span class="s3">\n          </span><span class="s1">toWebGLColor(color, opacity, _colorView);</span><span class="s3">\n          </span><span class="s1">var _lineWidthBuffer = this.lineWidthBuffer.getView(_instance2);</span><span class="s3">\n          </span><span class="s1">_lineWidthBuffer[0] = width;</span><span class="s3">\n          </span><span class="s1">var pAx = points[i - 2],</span><span class="s3">\n            </span><span class="s1">pAy = points[i - 1];</span><span class="s3">\n          </span><span class="s1">var pBx = points[i],</span><span class="s3">\n            </span><span class="s1">pBy = points[i + 1];</span><span class="s3">\n          </span><span class="s1">var pCx = points[i + 2],</span><span class="s3">\n            </span><span class="s1">pCy = points[i + 3];</span><span class="s3">\n          </span><span class="s1">var pDx = points[i + 4],</span><span class="s3">\n            </span><span class="s1">pDy = points[i + 5];</span><span class="s3">\n\n          </span><span class="s1">// make phantom points for the first and last segments</span><span class="s3">\n          </span><span class="s1">// TODO adding 0.001 to avoid division by zero in the shader (I think), need a better solution</span><span class="s3">\n          </span><span class="s1">if (i == 0) {</span><span class="s3">\n            </span><span class="s1">pAx = 2 * pBx - pCx + 0.001;</span><span class="s3">\n            </span><span class="s1">pAy = 2 * pBy - pCy + 0.001;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (i == points.length - 4) {</span><span class="s3">\n            </span><span class="s1">pDx = 2 * pCx - pBx + 0.001;</span><span class="s3">\n            </span><span class="s1">pDy = 2 * pCy - pBy + 0.001;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var pointABView = this.pointAPointBBuffer.getView(_instance2);</span><span class="s3">\n          </span><span class="s1">pointABView[0] = pAx;</span><span class="s3">\n          </span><span class="s1">pointABView[1] = pAy;</span><span class="s3">\n          </span><span class="s1">pointABView[2] = pBx;</span><span class="s3">\n          </span><span class="s1">pointABView[3] = pBy;</span><span class="s3">\n          </span><span class="s1">var pointCDView = this.pointCPointDBuffer.getView(_instance2);</span><span class="s3">\n          </span><span class="s1">pointCDView[0] = pCx;</span><span class="s3">\n          </span><span class="s1">pointCDView[1] = pCy;</span><span class="s3">\n          </span><span class="s1">pointCDView[2] = pDx;</span><span class="s3">\n          </span><span class="s1">pointCDView[3] = pDy;</span><span class="s3">\n          </span><span class="s1">this.instanceCount++;</span><span class="s3">\n          </span><span class="s1">if (this.instanceCount &gt;= this.maxInstances) {</span><span class="s3">\n            </span><span class="s1">this.endBatch();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getEdgePoints</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getEdgePoints(edge) {</span><span class="s3">\n      </span><span class="s1">var rs = edge._private.rscratch;</span><span class="s3">\n\n      </span><span class="s1">// if bezier ctrl pts can not be calculated, then die</span><span class="s3">\n      </span><span class="s1">if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {</span><span class="s3">\n        </span><span class="s1">// isNaN in case edge is impossible and browser bugs (e.g. safari)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var controlPoints = rs.allpts;</span><span class="s3">\n      </span><span class="s1">if (controlPoints.length == 4) {</span><span class="s3">\n        </span><span class="s1">return controlPoints;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var numSegments = this.getNumSegments(edge);</span><span class="s3">\n      </span><span class="s1">return this.getCurveSegmentPoints(controlPoints, numSegments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getNumSegments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getNumSegments(edge) {</span><span class="s3">\n      </span><span class="s1">// TODO Need a heuristic that decides how many segments to use. Factors to consider:</span><span class="s3">\n      </span><span class="s1">// - edge width/length</span><span class="s3">\n      </span><span class="s1">// - edge curvature (the more the curvature, the more segments)</span><span class="s3">\n      </span><span class="s1">// - zoom level (more segments when zoomed in)</span><span class="s3">\n      </span><span class="s1">// - number of visible edges (more segments when there are fewer edges)</span><span class="s3">\n      </span><span class="s1">// - performance (fewer segments when performance is a concern)</span><span class="s3">\n      </span><span class="s1">// - user configurable option(s)</span><span class="s3">\n      </span><span class="s1">// note: number of segments should be less than the max number of instances</span><span class="s3">\n      </span><span class="s1">// note: segments don't need to be evenly spaced out, it might make sense to have shorter segments nearer to the control points</span><span class="s3">\n      </span><span class="s1">var numSegments = 15;</span><span class="s3">\n      </span><span class="s1">return Math.min(Math.max(numSegments, 5), this.maxInstances);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getCurveSegmentPoints</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getCurveSegmentPoints(controlPoints, segments) {</span><span class="s3">\n      </span><span class="s1">if (controlPoints.length == 4) {</span><span class="s3">\n        </span><span class="s1">return controlPoints; // straight line</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var curvePoints = Array((segments + 1) * 2);</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt;= segments; i++) {</span><span class="s3">\n        </span><span class="s1">// the first and last points are the same as the first and last control points</span><span class="s3">\n        </span><span class="s1">if (i == 0) {</span><span class="s3">\n          </span><span class="s1">curvePoints[0] = controlPoints[0];</span><span class="s3">\n          </span><span class="s1">curvePoints[1] = controlPoints[1];</span><span class="s3">\n        </span><span class="s1">} else if (i == segments) {</span><span class="s3">\n          </span><span class="s1">curvePoints[i * 2] = controlPoints[controlPoints.length - 2];</span><span class="s3">\n          </span><span class="s1">curvePoints[i * 2 + 1] = controlPoints[controlPoints.length - 1];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var t = i / segments; // segments have equal length, its not strictly necessary to do it this way</span><span class="s3">\n          </span><span class="s1">// pass in curvePoints to set the values in the array directly</span><span class="s3">\n          </span><span class="s1">this.setCurvePoint(controlPoints, t, curvePoints, i * 2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return curvePoints;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">setCurvePoint</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function setCurvePoint(points, t, curvePoints, cpi) {</span><span class="s3">\n      </span><span class="s1">if (points.length &lt;= 2) {</span><span class="s3">\n        </span><span class="s1">curvePoints[cpi] = points[0];</span><span class="s3">\n        </span><span class="s1">curvePoints[cpi + 1] = points[1];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var newpoints = Array(points.length - 2);</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; newpoints.length; i += 2) {</span><span class="s3">\n          </span><span class="s1">var x = (1 - t) * points[i] + t * points[i + 2];</span><span class="s3">\n          </span><span class="s1">var y = (1 - t) * points[i + 1] + t * points[i + 3];</span><span class="s3">\n          </span><span class="s1">newpoints[i] = x;</span><span class="s3">\n          </span><span class="s1">newpoints[i + 1] = y;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.setCurvePoint(newpoints, t, curvePoints, cpi);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">endBatch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function endBatch() {</span><span class="s3">\n      </span><span class="s1">var gl = this.gl,</span><span class="s3">\n        </span><span class="s1">vao = this.vao,</span><span class="s3">\n        </span><span class="s1">vertexCount = this.vertexCount,</span><span class="s3">\n        </span><span class="s1">count = this.instanceCount;</span><span class="s3">\n      </span><span class="s1">if (count === 0) return;</span><span class="s3">\n      </span><span class="s1">var program = this.renderTarget.picking ? this.pickingProgram : this.program;</span><span class="s3">\n      </span><span class="s1">gl.useProgram(program);</span><span class="s3">\n      </span><span class="s1">gl.bindVertexArray(vao);</span><span class="s3">\n\n      </span><span class="s1">// buffer the attribute data</span><span class="s3">\n      </span><span class="s1">var _iterator = _createForOfIteratorHelper(this.buffers),</span><span class="s3">\n        </span><span class="s1">_step;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (_iterator.s(); !(_step = _iterator.n()).done;) {</span><span class="s3">\n          </span><span class="s1">var buffer = _step.value;</span><span class="s3">\n          </span><span class="s1">buffer.bufferSubData(count);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_iterator.e(err);</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">_iterator.f();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var atlases = this.atlasManager.getAtlases();</span><span class="s3">\n      </span><span class="s1">// must buffer before activating texture units</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; atlases.length; i++) {</span><span class="s3">\n        </span><span class="s1">atlases[i].bufferIfNeeded(gl);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Activate all the texture units that we need</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; atlases.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">gl.activeTexture(gl.TEXTURE0 + _i2);</span><span class="s3">\n        </span><span class="s1">gl.bindTexture(gl.TEXTURE_2D, atlases[_i2].texture);</span><span class="s3">\n        </span><span class="s1">gl.uniform1i(program.uTextures[_i2], _i2);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Set the uniforms</span><span class="s3">\n      </span><span class="s1">gl.uniformMatrix3fv(program.uPanZoomMatrix, false, this.panZoomMatrix);</span><span class="s3">\n      </span><span class="s1">gl.uniform1i(program.uAtlasSize, this.atlasManager.getAtlasSize());</span><span class="s3">\n      </span><span class="s1">// set background color, needed for edge arrow color blending</span><span class="s3">\n      </span><span class="s1">var webglBgColor = toWebGLColor(this.bgColor, 1);</span><span class="s3">\n      </span><span class="s1">gl.uniform4fv(program.uBGColor, webglBgColor);</span><span class="s3">\n\n      </span><span class="s1">// draw!</span><span class="s3">\n      </span><span class="s1">gl.drawArraysInstanced(gl.TRIANGLES, 0, vertexCount, count);</span><span class="s3">\n      </span><span class="s1">gl.bindVertexArray(null);</span><span class="s3">\n      </span><span class="s1">gl.bindTexture(gl.TEXTURE_2D, null); // TODO is this right when having multiple texture units?</span><span class="s3">\n\n      </span><span class="s1">if (this.debug) {</span><span class="s3">\n        </span><span class="s1">this.batchDebugInfo.push({</span><span class="s3">\n          </span><span class="s1">count: count,</span><span class="s3">\n          </span><span class="s1">// instance count</span><span class="s3">\n          </span><span class="s1">atlasCount: atlases.length</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// start the next batch, even if not needed</span><span class="s3">\n      </span><span class="s1">this.startBatch();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getDebugInfo</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getDebugInfo() {</span><span class="s3">\n      </span><span class="s1">var atlasInfo = this.atlasManager.getDebugInfo();</span><span class="s3">\n      </span><span class="s1">var totalAtlases = atlasInfo.reduce(function (count, info) {</span><span class="s3">\n        </span><span class="s1">return count + info.atlasCount;</span><span class="s3">\n      </span><span class="s1">}, 0);</span><span class="s3">\n      </span><span class="s1">var batchInfo = this.batchDebugInfo;</span><span class="s3">\n      </span><span class="s1">var totalInstances = batchInfo.reduce(function (count, info) {</span><span class="s3">\n        </span><span class="s1">return count + info.count;</span><span class="s3">\n      </span><span class="s1">}, 0);</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">atlasInfo: atlasInfo,</span><span class="s3">\n        </span><span class="s1">totalAtlases: totalAtlases,</span><span class="s3">\n        </span><span class="s1">wrappedCount: this.wrappedCount,</span><span class="s3">\n        </span><span class="s1">rectangleCount: this.rectangleCount,</span><span class="s3">\n        </span><span class="s1">batchCount: batchInfo.length,</span><span class="s3">\n        </span><span class="s1">batchInfo: batchInfo,</span><span class="s3">\n        </span><span class="s1">totalInstances: totalInstances</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">function fillStyle(color, opacity) {</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">rgba(</span><span class="s3">\&quot;</span><span class="s1">.concat(color[0], </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">).concat(color[1], </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">).concat(color[2], </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">).concat(opacity, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var OverlayUnderlayRenderer = /*#__PURE__*/function () {</span><span class="s3">\n  </span><span class="s1">function OverlayUnderlayRenderer(r) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, OverlayUnderlayRenderer);</span><span class="s3">\n    </span><span class="s1">this.r = r;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _createClass(OverlayUnderlayRenderer, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getStyleKey</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getStyleKey(type, node) {</span><span class="s3">\n      </span><span class="s1">var _this$getStyle = this.getStyle(type, node),</span><span class="s3">\n        </span><span class="s1">shape = _this$getStyle.shape,</span><span class="s3">\n        </span><span class="s1">opacity = _this$getStyle.opacity,</span><span class="s3">\n        </span><span class="s1">color = _this$getStyle.color;</span><span class="s3">\n      </span><span class="s1">if (!shape) return null;</span><span class="s3">\n      </span><span class="s1">var w = node.width();</span><span class="s3">\n      </span><span class="s1">var h = node.height();</span><span class="s3">\n      </span><span class="s1">var c = fillStyle(color, opacity);</span><span class="s3">\n      </span><span class="s1">return hashString(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(shape, </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">).concat(w, </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">).concat(h, </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">).concat(c)); // TODO hack, not very efficient</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">isVisible</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function isVisible(type, node) {</span><span class="s3">\n      </span><span class="s1">var opacity = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(type, </span><span class="s3">\&quot;</span><span class="s1">-opacity</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n      </span><span class="s1">return opacity &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getStyle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getStyle(type, node) {</span><span class="s3">\n      </span><span class="s1">var opacity = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(type, </span><span class="s3">\&quot;</span><span class="s1">-opacity</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n      </span><span class="s1">var color = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(type, </span><span class="s3">\&quot;</span><span class="s1">-color</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n      </span><span class="s1">var shape = node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(type, </span><span class="s3">\&quot;</span><span class="s1">-shape</span><span class="s3">\&quot;</span><span class="s1">)).value;</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">opacity: opacity,</span><span class="s3">\n        </span><span class="s1">color: color,</span><span class="s3">\n        </span><span class="s1">shape: shape</span><span class="s3">\n      </span><span class="s1">}; // TODO need to add radius at some point</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getPadding</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function getPadding(type, node) {</span><span class="s3">\n      </span><span class="s1">return node.pstyle(</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(type, </span><span class="s3">\&quot;</span><span class="s1">-padding</span><span class="s3">\&quot;</span><span class="s1">)).pfValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">draw</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function draw(type, context, node, bb) {</span><span class="s3">\n      </span><span class="s1">if (!this.isVisible(type, node)) return;</span><span class="s3">\n      </span><span class="s1">var r = this.r;</span><span class="s3">\n      </span><span class="s1">var w = bb.w;</span><span class="s3">\n      </span><span class="s1">var h = bb.h;</span><span class="s3">\n      </span><span class="s1">var x = w / 2;</span><span class="s3">\n      </span><span class="s1">var y = h / 2;</span><span class="s3">\n      </span><span class="s1">var _this$getStyle2 = this.getStyle(type, node),</span><span class="s3">\n        </span><span class="s1">shape = _this$getStyle2.shape,</span><span class="s3">\n        </span><span class="s1">color = _this$getStyle2.color,</span><span class="s3">\n        </span><span class="s1">opacity = _this$getStyle2.opacity;</span><span class="s3">\n      </span><span class="s1">context.save();</span><span class="s3">\n      </span><span class="s1">context.fillStyle = fillStyle(color, opacity);</span><span class="s3">\n      </span><span class="s1">if (shape === 'round-rectangle' || shape === 'roundrectangle') {</span><span class="s3">\n        </span><span class="s1">r.drawRoundRectanglePath(context, x, y, w, h, 'auto');</span><span class="s3">\n      </span><span class="s1">} else if (shape === 'ellipse') {</span><span class="s3">\n        </span><span class="s1">r.drawEllipsePath(context, x, y, w, h);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">context.fill();</span><span class="s3">\n      </span><span class="s1">context.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">var CRp$4 = {};</span><span class="s3">\n</span><span class="s1">CRp$4.initWebgl = function (opts, fns) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var gl = r.data.contexts[r.WEBGL];</span><span class="s3">\n  </span><span class="s1">opts.bgColor = getBGColor(r);</span><span class="s3">\n  </span><span class="s1">opts.webglTexSize = Math.min(opts.webglTexSize, gl.getParameter(gl.MAX_TEXTURE_SIZE));</span><span class="s3">\n  </span><span class="s1">opts.webglTexRows = Math.min(opts.webglTexRows, 54);</span><span class="s3">\n  </span><span class="s1">opts.webglTexRowsNodes = Math.min(opts.webglTexRowsNodes, 54);</span><span class="s3">\n  </span><span class="s1">opts.webglBatchSize = Math.min(opts.webglBatchSize, 16384);</span><span class="s3">\n  </span><span class="s1">opts.webglTexPerBatch = Math.min(opts.webglTexPerBatch, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));</span><span class="s3">\n  </span><span class="s1">r.webglDebug = opts.webglDebug;</span><span class="s3">\n  </span><span class="s1">r.webglDebugShowAtlases = opts.webglDebugShowAtlases;</span><span class="s3">\n\n  </span><span class="s1">// for offscreen rendering when render target is PICKING</span><span class="s3">\n  </span><span class="s1">r.pickingFrameBuffer = createPickingFrameBuffer(gl);</span><span class="s3">\n  </span><span class="s1">r.pickingFrameBuffer.needsDraw = true;</span><span class="s3">\n  </span><span class="s1">var getLabelRotation = function getLabelRotation(prop) {</span><span class="s3">\n    </span><span class="s1">return function (ele) {</span><span class="s3">\n      </span><span class="s1">return r.getTextAngle(ele, prop);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var isLabelVisible = function isLabelVisible(prop) {</span><span class="s3">\n    </span><span class="s1">return function (ele) {</span><span class="s3">\n      </span><span class="s1">var label = ele.pstyle(prop);</span><span class="s3">\n      </span><span class="s1">return label &amp;&amp; label.value;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">r.drawing = new ElementDrawingWebGL(r, gl, opts);</span><span class="s3">\n  </span><span class="s1">var our = new OverlayUnderlayRenderer(r);</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasCollection('node', atlasCollectionDefaults({</span><span class="s3">\n    </span><span class="s1">texRows: opts.webglTexRowsNodes</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasCollection('label', atlasCollectionDefaults({</span><span class="s3">\n    </span><span class="s1">texRows: opts.webglTexRows</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasRenderType('node-body', renderDefaults({</span><span class="s3">\n    </span><span class="s1">collection: 'node',</span><span class="s3">\n    </span><span class="s1">getKey: fns.getStyleKey,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: fns.getElementBox,</span><span class="s3">\n    </span><span class="s1">drawElement: fns.drawElement</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasRenderType('label', renderDefaults({</span><span class="s3">\n    </span><span class="s1">// node label or edge mid label</span><span class="s3">\n    </span><span class="s1">collection: 'label',</span><span class="s3">\n    </span><span class="s1">getKey: fns.getLabelKey,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: fns.getLabelBox,</span><span class="s3">\n    </span><span class="s1">drawElement: fns.drawLabel,</span><span class="s3">\n    </span><span class="s1">getRotation: getLabelRotation(null),</span><span class="s3">\n    </span><span class="s1">getRotationPoint: fns.getLabelRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: fns.getLabelRotationOffset,</span><span class="s3">\n    </span><span class="s1">isVisible: isLabelVisible('label')</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasRenderType('node-overlay', renderDefaults({</span><span class="s3">\n    </span><span class="s1">collection: 'node',</span><span class="s3">\n    </span><span class="s1">getBoundingBox: fns.getElementBox,</span><span class="s3">\n    </span><span class="s1">getKey: function getKey(ele) {</span><span class="s3">\n      </span><span class="s1">return our.getStyleKey('overlay', ele);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">drawElement: function drawElement(ctx, ele, bb) {</span><span class="s3">\n      </span><span class="s1">return our.draw('overlay', ctx, ele, bb);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">isVisible: function isVisible(ele) {</span><span class="s3">\n      </span><span class="s1">return our.isVisible('overlay', ele);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">getPadding: function getPadding(ele) {</span><span class="s3">\n      </span><span class="s1">return our.getPadding('overlay', ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasRenderType('node-underlay', renderDefaults({</span><span class="s3">\n    </span><span class="s1">collection: 'node',</span><span class="s3">\n    </span><span class="s1">getBoundingBox: fns.getElementBox,</span><span class="s3">\n    </span><span class="s1">getKey: function getKey(ele) {</span><span class="s3">\n      </span><span class="s1">return our.getStyleKey('underlay', ele);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">drawElement: function drawElement(ctx, ele, bb) {</span><span class="s3">\n      </span><span class="s1">return our.draw('underlay', ctx, ele, bb);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">isVisible: function isVisible(ele) {</span><span class="s3">\n      </span><span class="s1">return our.isVisible('underlay', ele);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">getPadding: function getPadding(ele) {</span><span class="s3">\n      </span><span class="s1">return our.getPadding('underlay', ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasRenderType('edge-source-label', renderDefaults({</span><span class="s3">\n    </span><span class="s1">collection: 'label',</span><span class="s3">\n    </span><span class="s1">getKey: fns.getSourceLabelKey,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: fns.getSourceLabelBox,</span><span class="s3">\n    </span><span class="s1">drawElement: fns.drawSourceLabel,</span><span class="s3">\n    </span><span class="s1">getRotation: getLabelRotation('source'),</span><span class="s3">\n    </span><span class="s1">getRotationPoint: fns.getSourceLabelRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: fns.getSourceLabelRotationOffset,</span><span class="s3">\n    </span><span class="s1">isVisible: isLabelVisible('source-label')</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">r.drawing.addAtlasRenderType('edge-target-label', renderDefaults({</span><span class="s3">\n    </span><span class="s1">collection: 'label',</span><span class="s3">\n    </span><span class="s1">getKey: fns.getTargetLabelKey,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: fns.getTargetLabelBox,</span><span class="s3">\n    </span><span class="s1">drawElement: fns.drawTargetLabel,</span><span class="s3">\n    </span><span class="s1">getRotation: getLabelRotation('target'),</span><span class="s3">\n    </span><span class="s1">getRotationPoint: fns.getTargetLabelRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: fns.getTargetLabelRotationOffset,</span><span class="s3">\n    </span><span class="s1">isVisible: isLabelVisible('target-label')</span><span class="s3">\n  </span><span class="s1">}));</span><span class="s3">\n\n  </span><span class="s1">// this is a very simplistic way of triggering garbage collection</span><span class="s3">\n  </span><span class="s1">var setGCFlag = debounce(function () {</span><span class="s3">\n    </span><span class="s1">console.log('garbage collect flag set');</span><span class="s3">\n    </span><span class="s1">r.data.gc = true;</span><span class="s3">\n  </span><span class="s1">}, 10000);</span><span class="s3">\n  </span><span class="s1">r.onUpdateEleCalcs(function (willDraw, eles) {</span><span class="s3">\n    </span><span class="s1">var gcNeeded = false;</span><span class="s3">\n    </span><span class="s1">if (eles &amp;&amp; eles.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">gcNeeded |= r.drawing.invalidate(eles);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (gcNeeded) {</span><span class="s3">\n      </span><span class="s1">setGCFlag();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Override</span><span class="s3">\&quot; </span><span class="s1">certain functions in canvas and base renderer</span><span class="s3">\n  </span><span class="s1">overrideCanvasRendererFunctions(r);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function getBGColor(r) {</span><span class="s3">\n  </span><span class="s1">var container = r.cy.container();</span><span class="s3">\n  </span><span class="s1">var cssColor = container &amp;&amp; container.style &amp;&amp; container.style.backgroundColor || 'white';</span><span class="s3">\n  </span><span class="s1">return color2tuple(cssColor);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Plug into the canvas renderer to use webgl for rendering.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function overrideCanvasRendererFunctions(r) {</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// Override the render function to call the webgl render function if the zoom level is appropriate</span><span class="s3">\n    </span><span class="s1">var renderCanvas = r.render;</span><span class="s3">\n    </span><span class="s1">r.render = function (options) {</span><span class="s3">\n      </span><span class="s1">options = options || {};</span><span class="s3">\n      </span><span class="s1">var cy = r.cy;</span><span class="s3">\n      </span><span class="s1">if (r.webgl) {</span><span class="s3">\n        </span><span class="s1">// if the zoom level is greater than the max zoom level, then disable webgl</span><span class="s3">\n        </span><span class="s1">if (cy.zoom() &gt; maxZoom$1) {</span><span class="s3">\n          </span><span class="s1">clearWebgl(r);</span><span class="s3">\n          </span><span class="s1">renderCanvas.call(r, options);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">clearCanvas(r);</span><span class="s3">\n          </span><span class="s1">renderWebgl(r, options, RENDER_TARGET.SCREEN);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// Override the matchCanvasSize function to update the picking frame buffer size</span><span class="s3">\n    </span><span class="s1">var baseFunc = r.matchCanvasSize;</span><span class="s3">\n    </span><span class="s1">r.matchCanvasSize = function (container) {</span><span class="s3">\n      </span><span class="s1">baseFunc.call(r, container);</span><span class="s3">\n      </span><span class="s1">r.pickingFrameBuffer.setFramebufferAttachmentSizes(r.canvasWidth, r.canvasHeight);</span><span class="s3">\n      </span><span class="s1">r.pickingFrameBuffer.needsDraw = true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// Override function to call the webgl version</span><span class="s3">\n    </span><span class="s1">r.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {</span><span class="s3">\n      </span><span class="s1">// the canvas version of this function is very slow on large graphs</span><span class="s3">\n      </span><span class="s1">return findNearestElementsWebgl(r, x, y);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Don't override the selction box picking, its not accurate enough with webgl</span><span class="s3">\n  </span><span class="s1">// { // Override function to call the webgl version</span><span class="s3">\n  </span><span class="s1">//   r.getAllInBox = function(x1, y1, x2, y2) {</span><span class="s3">\n  </span><span class="s1">//     return getAllInBoxWebgl(r, x1, y1, x2, y2);</span><span class="s3">\n  </span><span class="s1">//   }</span><span class="s3">\n  </span><span class="s1">// }</span><span class="s3">\n\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// need to know when the cached elements have changed so we can invalidate our caches</span><span class="s3">\n    </span><span class="s1">var _baseFunc = r.invalidateCachedZSortedEles;</span><span class="s3">\n    </span><span class="s1">r.invalidateCachedZSortedEles = function () {</span><span class="s3">\n      </span><span class="s1">_baseFunc.call(r);</span><span class="s3">\n      </span><span class="s1">r.pickingFrameBuffer.needsDraw = true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// need to know when the cached elements have changed so we can invalidate our caches</span><span class="s3">\n    </span><span class="s1">var _baseFunc2 = r.notify;</span><span class="s3">\n    </span><span class="s1">r.notify = function (eventName, eles) {</span><span class="s3">\n      </span><span class="s1">_baseFunc2.call(r, eventName, eles);</span><span class="s3">\n      </span><span class="s1">if (eventName === 'viewport' || eventName === 'bounds') {</span><span class="s3">\n        </span><span class="s1">r.pickingFrameBuffer.needsDraw = true;</span><span class="s3">\n      </span><span class="s1">} else if (eventName === 'background') {</span><span class="s3">\n        </span><span class="s1">// background image finished loading, need to redraw</span><span class="s3">\n        </span><span class="s1">r.drawing.invalidate(eles, {</span><span class="s3">\n          </span><span class="s1">type: 'node-body'</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clearWebgl(r) {</span><span class="s3">\n  </span><span class="s1">var gl = r.data.contexts[r.WEBGL];</span><span class="s3">\n  </span><span class="s1">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clearCanvas(r) {</span><span class="s3">\n  </span><span class="s1">// the CRp.clearCanvas() function doesn't take the transform into account</span><span class="s3">\n  </span><span class="s1">var clear = function clear(context) {</span><span class="s3">\n    </span><span class="s1">context.save();</span><span class="s3">\n    </span><span class="s1">context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n    </span><span class="s1">context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);</span><span class="s3">\n    </span><span class="s1">context.restore();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">clear(r.data.contexts[r.NODE]);</span><span class="s3">\n  </span><span class="s1">clear(r.data.contexts[r.DRAG]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createPanZoomMatrix(r) {</span><span class="s3">\n  </span><span class="s1">var width = r.canvasWidth;</span><span class="s3">\n  </span><span class="s1">var height = r.canvasHeight;</span><span class="s3">\n  </span><span class="s1">var _util$getEffectivePan = getEffectivePanZoom(r),</span><span class="s3">\n    </span><span class="s1">pan = _util$getEffectivePan.pan,</span><span class="s3">\n    </span><span class="s1">zoom = _util$getEffectivePan.zoom;</span><span class="s3">\n  </span><span class="s1">var transform = create();</span><span class="s3">\n  </span><span class="s1">translate(transform, transform, [pan.x, pan.y]);</span><span class="s3">\n  </span><span class="s1">scale(transform, transform, [zoom, zoom]);</span><span class="s3">\n  </span><span class="s1">var projection$1 = create();</span><span class="s3">\n  </span><span class="s1">projection(projection$1, width, height);</span><span class="s3">\n  </span><span class="s1">var product = create();</span><span class="s3">\n  </span><span class="s1">multiply(product, projection$1, transform);</span><span class="s3">\n  </span><span class="s1">return product;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function setContextTransform(r, context) {</span><span class="s3">\n  </span><span class="s1">var width = r.canvasWidth;</span><span class="s3">\n  </span><span class="s1">var height = r.canvasHeight;</span><span class="s3">\n  </span><span class="s1">var _util$getEffectivePan2 = getEffectivePanZoom(r),</span><span class="s3">\n    </span><span class="s1">pan = _util$getEffectivePan2.pan,</span><span class="s3">\n    </span><span class="s1">zoom = _util$getEffectivePan2.zoom;</span><span class="s3">\n  </span><span class="s1">context.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n  </span><span class="s1">context.clearRect(0, 0, width, height);</span><span class="s3">\n  </span><span class="s1">context.translate(pan.x, pan.y);</span><span class="s3">\n  </span><span class="s1">context.scale(zoom, zoom);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function drawSelectionRectangle(r, options) {</span><span class="s3">\n  </span><span class="s1">r.drawSelectionRectangle(options, function (context) {</span><span class="s3">\n    </span><span class="s1">return setContextTransform(r, context);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// eslint-disable-next-line no-unused-vars</span><span class="s3">\n</span><span class="s1">function drawAxes(r) {</span><span class="s3">\n  </span><span class="s1">// for debgging</span><span class="s3">\n  </span><span class="s1">var context = r.data.contexts[r.NODE];</span><span class="s3">\n  </span><span class="s1">context.save();</span><span class="s3">\n  </span><span class="s1">setContextTransform(r, context);</span><span class="s3">\n  </span><span class="s1">context.strokeStyle = 'rgba(0, 0, 0, 0.3)';</span><span class="s3">\n  </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">context.moveTo(-1e3, 0);</span><span class="s3">\n  </span><span class="s1">context.lineTo(1000, 0);</span><span class="s3">\n  </span><span class="s1">context.stroke();</span><span class="s3">\n  </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">context.moveTo(0, -1e3);</span><span class="s3">\n  </span><span class="s1">context.lineTo(0, 1000);</span><span class="s3">\n  </span><span class="s1">context.stroke();</span><span class="s3">\n  </span><span class="s1">context.restore();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function drawAtlases(r) {</span><span class="s3">\n  </span><span class="s1">// For debugging the atlases</span><span class="s3">\n  </span><span class="s1">var draw = function draw(drawing, name, row) {</span><span class="s3">\n    </span><span class="s1">var collection = drawing.atlasManager.getAtlasCollection(name);</span><span class="s3">\n    </span><span class="s1">var context = r.data.contexts[r.NODE];</span><span class="s3">\n    </span><span class="s1">var scale = 0.125;</span><span class="s3">\n    </span><span class="s1">var atlases = collection.atlases;</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; atlases.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var atlas = atlases[_i];</span><span class="s3">\n      </span><span class="s1">var canvas = atlas.canvas;</span><span class="s3">\n      </span><span class="s1">if (canvas) {</span><span class="s3">\n        </span><span class="s1">var w = canvas.width;</span><span class="s3">\n        </span><span class="s1">var h = canvas.height;</span><span class="s3">\n        </span><span class="s1">var x = w * _i;</span><span class="s3">\n        </span><span class="s1">var y = canvas.height * row;</span><span class="s3">\n        </span><span class="s1">context.save();</span><span class="s3">\n        </span><span class="s1">context.scale(scale, scale);</span><span class="s3">\n        </span><span class="s1">context.drawImage(canvas, x, y);</span><span class="s3">\n        </span><span class="s1">context.strokeStyle = 'black';</span><span class="s3">\n        </span><span class="s1">context.rect(x, y, w, h);</span><span class="s3">\n        </span><span class="s1">context.stroke();</span><span class="s3">\n        </span><span class="s1">context.restore();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var i = 0;</span><span class="s3">\n  </span><span class="s1">draw(r.drawing, 'node', i++);</span><span class="s3">\n  </span><span class="s1">draw(r.drawing, 'label', i++);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Arguments are in model coordinates.</span><span class="s3">\n </span><span class="s1">* (x1, y1) is top left corner</span><span class="s3">\n </span><span class="s1">* (x2, y2) is bottom right corner (optional)</span><span class="s3">\n </span><span class="s1">* Returns a Set of indexes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getPickingIndexes(r, mX1, mY1, mX2, mY2) {</span><span class="s3">\n  </span><span class="s1">var x, y, w, h;</span><span class="s3">\n  </span><span class="s1">var _util$getEffectivePan3 = getEffectivePanZoom(r),</span><span class="s3">\n    </span><span class="s1">pan = _util$getEffectivePan3.pan,</span><span class="s3">\n    </span><span class="s1">zoom = _util$getEffectivePan3.zoom;</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">var _util$modelToRendered = modelToRenderedPosition(r, pan, zoom, mX1, mY1),</span><span class="s3">\n      </span><span class="s1">_util$modelToRendered2 = _slicedToArray(_util$modelToRendered, 2),</span><span class="s3">\n      </span><span class="s1">cX1 = _util$modelToRendered2[0],</span><span class="s3">\n      </span><span class="s1">cY1 = _util$modelToRendered2[1];</span><span class="s3">\n    </span><span class="s1">var t = 6; // should be even</span><span class="s3">\n    </span><span class="s1">x = cX1 - t / 2;</span><span class="s3">\n    </span><span class="s1">y = cY1 - t / 2;</span><span class="s3">\n    </span><span class="s1">w = t;</span><span class="s3">\n    </span><span class="s1">h = t;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (w === 0 || h === 0) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var gl = r.data.contexts[r.WEBGL];</span><span class="s3">\n  </span><span class="s1">gl.bindFramebuffer(gl.FRAMEBUFFER, r.pickingFrameBuffer);</span><span class="s3">\n  </span><span class="s1">if (r.pickingFrameBuffer.needsDraw) {</span><span class="s3">\n    </span><span class="s1">// Draw element z-indexes to the picking framebuffer</span><span class="s3">\n    </span><span class="s1">gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);</span><span class="s3">\n    </span><span class="s1">renderWebgl(r, null, RENDER_TARGET.PICKING);</span><span class="s3">\n    </span><span class="s1">r.pickingFrameBuffer.needsDraw = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var n = w * h; // number of pixels to read</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-undef</span><span class="s3">\n  </span><span class="s1">var data = new Uint8Array(n * 4); // 4 bytes per pixel</span><span class="s3">\n  </span><span class="s1">gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);</span><span class="s3">\n  </span><span class="s1">gl.bindFramebuffer(gl.FRAMEBUFFER, null);</span><span class="s3">\n  </span><span class="s1">var indexes = new Set();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; n; i++) {</span><span class="s3">\n    </span><span class="s1">var pixel = data.slice(i * 4, i * 4 + 4);</span><span class="s3">\n    </span><span class="s1">var index = vec4ToIndex(pixel) - 1; // The framebuffer is cleared with 0s, so z-indexes are offset by 1</span><span class="s3">\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">indexes.add(index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return indexes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cy.js: model coordinate y axis goes down</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findNearestElementsWebgl(r, x, y) {</span><span class="s3">\n  </span><span class="s1">// model coordinates</span><span class="s3">\n  </span><span class="s1">var indexes = getPickingIndexes(r, x, y);</span><span class="s3">\n  </span><span class="s1">var eles = r.getCachedZSortedEles();</span><span class="s3">\n  </span><span class="s1">var node, edge;</span><span class="s3">\n  </span><span class="s1">var _iterator = _createForOfIteratorHelper(indexes),</span><span class="s3">\n    </span><span class="s1">_step;</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">for (_iterator.s(); !(_step = _iterator.n()).done;) {</span><span class="s3">\n      </span><span class="s1">var index = _step.value;</span><span class="s3">\n      </span><span class="s1">var ele = eles[index];</span><span class="s3">\n      </span><span class="s1">if (!node &amp;&amp; ele.isNode()) {</span><span class="s3">\n        </span><span class="s1">node = ele;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!edge &amp;&amp; ele.isEdge()) {</span><span class="s3">\n        </span><span class="s1">edge = ele;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (node &amp;&amp; edge) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">_iterator.e(err);</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">_iterator.f();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [node, edge].filter(Boolean);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO: Is constantly checking this slower than just rendering a texture?</span><span class="s3">\n</span><span class="s1">// Maybe this should be cached as a flag on each node.</span><span class="s3">\n</span><span class="s1">function isSimpleRectangle(node) {</span><span class="s3">\n  </span><span class="s1">return node.pstyle('shape').value === 'rectangle' &amp;&amp; node.pstyle('background-fill').value === 'solid' &amp;&amp; node.pstyle('border-width').pfValue === 0 &amp;&amp; node.pstyle('background-image').strValue === 'none';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function drawEle(r, index, ele) {</span><span class="s3">\n  </span><span class="s1">var drawing = r.drawing;</span><span class="s3">\n  </span><span class="s1">index += 1; // 0 is used to clear the background, need to offset all z-indexes by one</span><span class="s3">\n  </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n    </span><span class="s1">drawing.drawTexture(ele, index, 'node-underlay');</span><span class="s3">\n    </span><span class="s1">if (isSimpleRectangle(ele)) {</span><span class="s3">\n      </span><span class="s1">drawing.drawSimpleRectangle(ele, index, 'node-body');</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">drawing.drawTexture(ele, index, 'node-body');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">drawing.drawTexture(ele, index, 'label');</span><span class="s3">\n    </span><span class="s1">drawing.drawTexture(ele, index, 'node-overlay');</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">drawing.drawEdgeLine(ele, index);</span><span class="s3">\n    </span><span class="s1">drawing.drawEdgeArrow(ele, index, 'source');</span><span class="s3">\n    </span><span class="s1">drawing.drawEdgeArrow(ele, index, 'target');</span><span class="s3">\n    </span><span class="s1">drawing.drawTexture(ele, index, 'label');</span><span class="s3">\n    </span><span class="s1">drawing.drawTexture(ele, index, 'edge-source-label');</span><span class="s3">\n    </span><span class="s1">drawing.drawTexture(ele, index, 'edge-target-label');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function renderWebgl(r, options, renderTarget) {</span><span class="s3">\n  </span><span class="s1">var start;</span><span class="s3">\n  </span><span class="s1">if (r.webglDebug) {</span><span class="s3">\n    </span><span class="s1">start = performance.now(); // eslint-disable-line no-undef</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var drawing = r.drawing;</span><span class="s3">\n  </span><span class="s1">var eleCount = 0;</span><span class="s3">\n  </span><span class="s1">if (renderTarget.screen) {</span><span class="s3">\n    </span><span class="s1">if (r.data.canvasNeedsRedraw[r.SELECT_BOX]) {</span><span class="s3">\n      </span><span class="s1">drawSelectionRectangle(r, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// see drawing-elements.js drawCachedElement()</span><span class="s3">\n  </span><span class="s1">if (r.data.canvasNeedsRedraw[r.NODE] || renderTarget.picking) {</span><span class="s3">\n    </span><span class="s1">var gl = r.data.contexts[r.WEBGL];</span><span class="s3">\n    </span><span class="s1">if (renderTarget.screen) {</span><span class="s3">\n      </span><span class="s1">gl.clearColor(0, 0, 0, 0); // background color</span><span class="s3">\n      </span><span class="s1">gl.enable(gl.BLEND); // enable alpha blending of textures</span><span class="s3">\n      </span><span class="s1">gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // we are using premultiplied alpha</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">gl.disable(gl.BLEND);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</span><span class="s3">\n    </span><span class="s1">gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);</span><span class="s3">\n    </span><span class="s1">var panZoomMatrix = createPanZoomMatrix(r);</span><span class="s3">\n    </span><span class="s1">var eles = r.getCachedZSortedEles();</span><span class="s3">\n    </span><span class="s1">eleCount = eles.length;</span><span class="s3">\n    </span><span class="s1">drawing.startFrame(panZoomMatrix, renderTarget);</span><span class="s3">\n    </span><span class="s1">if (renderTarget.screen) {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; eles.nondrag.length; i++) {</span><span class="s3">\n        </span><span class="s1">drawEle(r, i, eles.nondrag[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; eles.drag.length; _i2++) {</span><span class="s3">\n        </span><span class="s1">drawEle(r, _i2, eles.drag[_i2]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (renderTarget.picking) {</span><span class="s3">\n      </span><span class="s1">for (var _i3 = 0; _i3 &lt; eles.length; _i3++) {</span><span class="s3">\n        </span><span class="s1">drawEle(r, _i3, eles[_i3]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">drawing.endFrame();</span><span class="s3">\n    </span><span class="s1">if (renderTarget.screen &amp;&amp; r.webglDebugShowAtlases) {</span><span class="s3">\n      </span><span class="s1">drawAxes(r);</span><span class="s3">\n      </span><span class="s1">drawAtlases(r);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">r.data.canvasNeedsRedraw[r.NODE] = false;</span><span class="s3">\n    </span><span class="s1">r.data.canvasNeedsRedraw[r.DRAG] = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.webglDebug) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line no-undef</span><span class="s3">\n    </span><span class="s1">var end = performance.now();</span><span class="s3">\n    </span><span class="s1">var compact = false;</span><span class="s3">\n    </span><span class="s1">var time = Math.ceil(end - start);</span><span class="s3">\n    </span><span class="s1">var debugInfo = drawing.getDebugInfo();</span><span class="s3">\n    </span><span class="s1">var report = [</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(eleCount, </span><span class="s3">\&quot; </span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(debugInfo.totalInstances, </span><span class="s3">\&quot; </span><span class="s1">instances</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(debugInfo.batchCount, </span><span class="s3">\&quot; </span><span class="s1">batches</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(debugInfo.totalAtlases, </span><span class="s3">\&quot; </span><span class="s1">atlases</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(debugInfo.wrappedCount, </span><span class="s3">\&quot; </span><span class="s1">wrapped textures</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(debugInfo.rectangleCount, </span><span class="s3">\&quot; </span><span class="s1">simple rectangles</span><span class="s3">\&quot;</span><span class="s1">)].join(', ');</span><span class="s3">\n    </span><span class="s1">if (compact) {</span><span class="s3">\n      </span><span class="s1">console.log(</span><span class="s3">\&quot;</span><span class="s1">WebGL (</span><span class="s3">\&quot;</span><span class="s1">.concat(renderTarget.name, </span><span class="s3">\&quot;</span><span class="s1">) - time </span><span class="s3">\&quot;</span><span class="s1">).concat(time, </span><span class="s3">\&quot;</span><span class="s1">ms, </span><span class="s3">\&quot;</span><span class="s1">).concat(report));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console.log(</span><span class="s3">\&quot;</span><span class="s1">WebGL (</span><span class="s3">\&quot;</span><span class="s1">.concat(renderTarget.name, </span><span class="s3">\&quot;</span><span class="s1">) - frame time </span><span class="s3">\&quot;</span><span class="s1">).concat(time, </span><span class="s3">\&quot;</span><span class="s1">ms</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">console.log('Totals:');</span><span class="s3">\n      </span><span class="s1">console.log(</span><span class="s3">\&quot;  \&quot;</span><span class="s1">.concat(report));</span><span class="s3">\n      </span><span class="s1">console.log('Texture Atlases Used:');</span><span class="s3">\n      </span><span class="s1">var atlasInfo = debugInfo.atlasInfo;</span><span class="s3">\n      </span><span class="s1">var _iterator3 = _createForOfIteratorHelper(atlasInfo),</span><span class="s3">\n        </span><span class="s1">_step3;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {</span><span class="s3">\n          </span><span class="s1">var info = _step3.value;</span><span class="s3">\n          </span><span class="s1">console.log(</span><span class="s3">\&quot;  \&quot;</span><span class="s1">.concat(info.type, </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">).concat(info.keyCount, </span><span class="s3">\&quot; </span><span class="s1">keys, </span><span class="s3">\&quot;</span><span class="s1">).concat(info.atlasCount, </span><span class="s3">\&quot; </span><span class="s1">atlases</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_iterator3.e(err);</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">_iterator3.f();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">console.log('');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (r.data.gc) {</span><span class="s3">\n    </span><span class="s1">console.log('Garbage Collect!');</span><span class="s3">\n    </span><span class="s1">r.data.gc = false;</span><span class="s3">\n    </span><span class="s1">drawing.gc();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var CRp$3 = {};</span><span class="s3">\n\n</span><span class="s1">// @O Polygon drawing</span><span class="s3">\n</span><span class="s1">CRp$3.drawPolygonPath = function (context, x, y, width, height, points) {</span><span class="s3">\n  </span><span class="s1">var halfW = width / 2;</span><span class="s3">\n  </span><span class="s1">var halfH = height / 2;</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.moveTo(x + halfW * points[0], y + halfH * points[1]);</span><span class="s3">\n  </span><span class="s1">for (var i = 1; i &lt; points.length / 2; i++) {</span><span class="s3">\n    </span><span class="s1">context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$3.drawRoundPolygonPath = function (context, x, y, width, height, points, corners) {</span><span class="s3">\n  </span><span class="s1">corners.forEach(function (corner) {</span><span class="s3">\n    </span><span class="s1">return drawPreparedRoundCorner(context, corner);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Round rectangle drawing</span><span class="s3">\n</span><span class="s1">CRp$3.drawRoundRectanglePath = function (context, x, y, width, height, radius) {</span><span class="s3">\n  </span><span class="s1">var halfWidth = width / 2;</span><span class="s3">\n  </span><span class="s1">var halfHeight = height / 2;</span><span class="s3">\n  </span><span class="s1">var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : Math.min(radius, halfHeight, halfWidth);</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Start at top middle</span><span class="s3">\n  </span><span class="s1">context.moveTo(x, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">// Arc from middle top to right side</span><span class="s3">\n  </span><span class="s1">context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);</span><span class="s3">\n  </span><span class="s1">// Arc from right side to bottom</span><span class="s3">\n  </span><span class="s1">context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);</span><span class="s3">\n  </span><span class="s1">// Arc from bottom to left side</span><span class="s3">\n  </span><span class="s1">context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);</span><span class="s3">\n  </span><span class="s1">// Arc from left side to topBorder</span><span class="s3">\n  </span><span class="s1">context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);</span><span class="s3">\n  </span><span class="s1">// Join line</span><span class="s3">\n  </span><span class="s1">context.lineTo(x, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$3.drawBottomRoundRectanglePath = function (context, x, y, width, height, radius) {</span><span class="s3">\n  </span><span class="s1">var halfWidth = width / 2;</span><span class="s3">\n  </span><span class="s1">var halfHeight = height / 2;</span><span class="s3">\n  </span><span class="s1">var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Start at top middle</span><span class="s3">\n  </span><span class="s1">context.moveTo(x, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x + halfWidth, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x + halfWidth, y);</span><span class="s3">\n  </span><span class="s1">context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);</span><span class="s3">\n  </span><span class="s1">context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x - halfWidth, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$3.drawCutRectanglePath = function (context, x, y, width, height, points, corners) {</span><span class="s3">\n  </span><span class="s1">var halfWidth = width / 2;</span><span class="s3">\n  </span><span class="s1">var halfHeight = height / 2;</span><span class="s3">\n  </span><span class="s1">var cornerLength = corners === 'auto' ? getCutRectangleCornerLength() : corners;</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.moveTo(x - halfWidth + cornerLength, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x + halfWidth - cornerLength, y - halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x + halfWidth, y - halfHeight + cornerLength);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x + halfWidth, y + halfHeight - cornerLength);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x + halfWidth - cornerLength, y + halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x - halfWidth + cornerLength, y + halfHeight);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x - halfWidth, y + halfHeight - cornerLength);</span><span class="s3">\n  </span><span class="s1">context.lineTo(x - halfWidth, y - halfHeight + cornerLength);</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$3.drawBarrelPath = function (context, x, y, width, height) {</span><span class="s3">\n  </span><span class="s1">var halfWidth = width / 2;</span><span class="s3">\n  </span><span class="s1">var halfHeight = height / 2;</span><span class="s3">\n  </span><span class="s1">var xBegin = x - halfWidth;</span><span class="s3">\n  </span><span class="s1">var xEnd = x + halfWidth;</span><span class="s3">\n  </span><span class="s1">var yBegin = y - halfHeight;</span><span class="s3">\n  </span><span class="s1">var yEnd = y + halfHeight;</span><span class="s3">\n  </span><span class="s1">var barrelCurveConstants = getBarrelCurveConstants(width, height);</span><span class="s3">\n  </span><span class="s1">var wOffset = barrelCurveConstants.widthOffset;</span><span class="s3">\n  </span><span class="s1">var hOffset = barrelCurveConstants.heightOffset;</span><span class="s3">\n  </span><span class="s1">var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.moveTo(xBegin, yBegin + hOffset);</span><span class="s3">\n  </span><span class="s1">context.lineTo(xBegin, yEnd - hOffset);</span><span class="s3">\n  </span><span class="s1">context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);</span><span class="s3">\n  </span><span class="s1">context.lineTo(xEnd - wOffset, yEnd);</span><span class="s3">\n  </span><span class="s1">context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);</span><span class="s3">\n  </span><span class="s1">context.lineTo(xEnd, yBegin + hOffset);</span><span class="s3">\n  </span><span class="s1">context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);</span><span class="s3">\n  </span><span class="s1">context.lineTo(xBegin + wOffset, yBegin);</span><span class="s3">\n  </span><span class="s1">context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sin0 = Math.sin(0);</span><span class="s3">\n</span><span class="s1">var cos0 = Math.cos(0);</span><span class="s3">\n</span><span class="s1">var sin = {};</span><span class="s3">\n</span><span class="s1">var cos = {};</span><span class="s3">\n</span><span class="s1">var ellipseStepSize = Math.PI / 40;</span><span class="s3">\n</span><span class="s1">for (var i = 0 * Math.PI; i &lt; 2 * Math.PI; i += ellipseStepSize) {</span><span class="s3">\n  </span><span class="s1">sin[i] = Math.sin(i);</span><span class="s3">\n  </span><span class="s1">cos[i] = Math.cos(i);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">CRp$3.drawEllipsePath = function (context, centerX, centerY, width, height) {</span><span class="s3">\n  </span><span class="s1">if (context.beginPath) {</span><span class="s3">\n    </span><span class="s1">context.beginPath();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (context.ellipse) {</span><span class="s3">\n    </span><span class="s1">context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var xPos, yPos;</span><span class="s3">\n    </span><span class="s1">var rw = width / 2;</span><span class="s3">\n    </span><span class="s1">var rh = height / 2;</span><span class="s3">\n    </span><span class="s1">for (var i = 0 * Math.PI; i &lt; 2 * Math.PI; i += ellipseStepSize) {</span><span class="s3">\n      </span><span class="s1">xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;</span><span class="s3">\n      </span><span class="s1">yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;</span><span class="s3">\n      </span><span class="s1">if (i === 0) {</span><span class="s3">\n        </span><span class="s1">context.moveTo(xPos, yPos);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">context.lineTo(xPos, yPos);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">context.closePath();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* global atob, ArrayBuffer, Uint8Array, Blob */</span><span class="s3">\n\n</span><span class="s1">var CRp$2 = {};</span><span class="s3">\n</span><span class="s1">CRp$2.createBuffer = function (w, h) {</span><span class="s3">\n  </span><span class="s1">var buffer = document.createElement('canvas'); // eslint-disable-line no-undef</span><span class="s3">\n  </span><span class="s1">buffer.width = w;</span><span class="s3">\n  </span><span class="s1">buffer.height = h;</span><span class="s3">\n  </span><span class="s1">return [buffer, buffer.getContext('2d')];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$2.bufferCanvasImage = function (options) {</span><span class="s3">\n  </span><span class="s1">var cy = this.cy;</span><span class="s3">\n  </span><span class="s1">var eles = cy.mutableElements();</span><span class="s3">\n  </span><span class="s1">var bb = eles.boundingBox();</span><span class="s3">\n  </span><span class="s1">var ctrRect = this.findContainerClientCoords();</span><span class="s3">\n  </span><span class="s1">var width = options.full ? Math.ceil(bb.w) : ctrRect[2];</span><span class="s3">\n  </span><span class="s1">var height = options.full ? Math.ceil(bb.h) : ctrRect[3];</span><span class="s3">\n  </span><span class="s1">var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);</span><span class="s3">\n  </span><span class="s1">var pxRatio = this.getPixelRatio();</span><span class="s3">\n  </span><span class="s1">var scale = 1;</span><span class="s3">\n  </span><span class="s1">if (options.scale !== undefined) {</span><span class="s3">\n    </span><span class="s1">width *= options.scale;</span><span class="s3">\n    </span><span class="s1">height *= options.scale;</span><span class="s3">\n    </span><span class="s1">scale = options.scale;</span><span class="s3">\n  </span><span class="s1">} else if (specdMaxDims) {</span><span class="s3">\n    </span><span class="s1">var maxScaleW = Infinity;</span><span class="s3">\n    </span><span class="s1">var maxScaleH = Infinity;</span><span class="s3">\n    </span><span class="s1">if (number$1(options.maxWidth)) {</span><span class="s3">\n      </span><span class="s1">maxScaleW = scale * options.maxWidth / width;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (number$1(options.maxHeight)) {</span><span class="s3">\n      </span><span class="s1">maxScaleH = scale * options.maxHeight / height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scale = Math.min(maxScaleW, maxScaleH);</span><span class="s3">\n    </span><span class="s1">width *= scale;</span><span class="s3">\n    </span><span class="s1">height *= scale;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!specdMaxDims) {</span><span class="s3">\n    </span><span class="s1">width *= pxRatio;</span><span class="s3">\n    </span><span class="s1">height *= pxRatio;</span><span class="s3">\n    </span><span class="s1">scale *= pxRatio;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef</span><span class="s3">\n\n  </span><span class="s1">buffCanvas.width = width;</span><span class="s3">\n  </span><span class="s1">buffCanvas.height = height;</span><span class="s3">\n  </span><span class="s1">buffCanvas.style.width = width + 'px';</span><span class="s3">\n  </span><span class="s1">buffCanvas.style.height = height + 'px';</span><span class="s3">\n  </span><span class="s1">var buffCxt = buffCanvas.getContext('2d');</span><span class="s3">\n\n  </span><span class="s1">// Rasterize the layers, but only if container has nonzero size</span><span class="s3">\n  </span><span class="s1">if (width &gt; 0 &amp;&amp; height &gt; 0) {</span><span class="s3">\n    </span><span class="s1">buffCxt.clearRect(0, 0, width, height);</span><span class="s3">\n    </span><span class="s1">buffCxt.globalCompositeOperation = 'source-over';</span><span class="s3">\n    </span><span class="s1">var zsortedEles = this.getCachedZSortedEles();</span><span class="s3">\n    </span><span class="s1">if (options.full) {</span><span class="s3">\n      </span><span class="s1">// draw the full bounds of the graph</span><span class="s3">\n      </span><span class="s1">buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);</span><span class="s3">\n      </span><span class="s1">buffCxt.scale(scale, scale);</span><span class="s3">\n      </span><span class="s1">this.drawElements(buffCxt, zsortedEles);</span><span class="s3">\n      </span><span class="s1">buffCxt.scale(1 / scale, 1 / scale);</span><span class="s3">\n      </span><span class="s1">buffCxt.translate(bb.x1 * scale, bb.y1 * scale);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// draw the current view</span><span class="s3">\n      </span><span class="s1">var pan = cy.pan();</span><span class="s3">\n      </span><span class="s1">var translation = {</span><span class="s3">\n        </span><span class="s1">x: pan.x * scale,</span><span class="s3">\n        </span><span class="s1">y: pan.y * scale</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">scale *= cy.zoom();</span><span class="s3">\n      </span><span class="s1">buffCxt.translate(translation.x, translation.y);</span><span class="s3">\n      </span><span class="s1">buffCxt.scale(scale, scale);</span><span class="s3">\n      </span><span class="s1">this.drawElements(buffCxt, zsortedEles);</span><span class="s3">\n      </span><span class="s1">buffCxt.scale(1 / scale, 1 / scale);</span><span class="s3">\n      </span><span class="s1">buffCxt.translate(-translation.x, -translation.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// need to fill bg at end like this in order to fill cleared transparent pixels in jpgs</span><span class="s3">\n    </span><span class="s1">if (options.bg) {</span><span class="s3">\n      </span><span class="s1">buffCxt.globalCompositeOperation = 'destination-over';</span><span class="s3">\n      </span><span class="s1">buffCxt.fillStyle = options.bg;</span><span class="s3">\n      </span><span class="s1">buffCxt.rect(0, 0, width, height);</span><span class="s3">\n      </span><span class="s1">buffCxt.fill();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return buffCanvas;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function b64ToBlob(b64, mimeType) {</span><span class="s3">\n  </span><span class="s1">var bytes = atob(b64);</span><span class="s3">\n  </span><span class="s1">var buff = new ArrayBuffer(bytes.length);</span><span class="s3">\n  </span><span class="s1">var buffUint8 = new Uint8Array(buff);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; bytes.length; i++) {</span><span class="s3">\n    </span><span class="s1">buffUint8[i] = bytes.charCodeAt(i);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new Blob([buff], {</span><span class="s3">\n    </span><span class="s1">type: mimeType</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function b64UriToB64(b64uri) {</span><span class="s3">\n  </span><span class="s1">var i = b64uri.indexOf(',');</span><span class="s3">\n  </span><span class="s1">return b64uri.substr(i + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function output(options, canvas, mimeType) {</span><span class="s3">\n  </span><span class="s1">var getB64Uri = function getB64Uri() {</span><span class="s3">\n    </span><span class="s1">return canvas.toDataURL(mimeType, options.quality);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">switch (options.output) {</span><span class="s3">\n    </span><span class="s1">case 'blob-promise':</span><span class="s3">\n      </span><span class="s1">return new Promise$1(function (resolve, reject) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">canvas.toBlob(function (blob) {</span><span class="s3">\n            </span><span class="s1">if (blob != null) {</span><span class="s3">\n              </span><span class="s1">resolve(blob);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">reject(new Error('`canvas.toBlob()` sent a null value in its callback'));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}, mimeType, options.quality);</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">reject(err);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">case 'blob':</span><span class="s3">\n      </span><span class="s1">return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);</span><span class="s3">\n    </span><span class="s1">case 'base64':</span><span class="s3">\n      </span><span class="s1">return b64UriToB64(getB64Uri());</span><span class="s3">\n    </span><span class="s1">case 'base64uri':</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return getB64Uri();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">CRp$2.png = function (options) {</span><span class="s3">\n  </span><span class="s1">return output(options, this.bufferCanvasImage(options), 'image/png');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp$2.jpg = function (options) {</span><span class="s3">\n  </span><span class="s1">return output(options, this.bufferCanvasImage(options), 'image/jpeg');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CRp$1 = {};</span><span class="s3">\n</span><span class="s1">CRp$1.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points, corners) {</span><span class="s3">\n  </span><span class="s1">switch (name) {</span><span class="s3">\n    </span><span class="s1">case 'ellipse':</span><span class="s3">\n      </span><span class="s1">return this.drawEllipsePath(context, centerX, centerY, width, height);</span><span class="s3">\n    </span><span class="s1">case 'polygon':</span><span class="s3">\n      </span><span class="s1">return this.drawPolygonPath(context, centerX, centerY, width, height, points);</span><span class="s3">\n    </span><span class="s1">case 'round-polygon':</span><span class="s3">\n      </span><span class="s1">return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points, corners);</span><span class="s3">\n    </span><span class="s1">case 'roundrectangle':</span><span class="s3">\n    </span><span class="s1">case 'round-rectangle':</span><span class="s3">\n      </span><span class="s1">return this.drawRoundRectanglePath(context, centerX, centerY, width, height, corners);</span><span class="s3">\n    </span><span class="s1">case 'cutrectangle':</span><span class="s3">\n    </span><span class="s1">case 'cut-rectangle':</span><span class="s3">\n      </span><span class="s1">return this.drawCutRectanglePath(context, centerX, centerY, width, height, points, corners);</span><span class="s3">\n    </span><span class="s1">case 'bottomroundrectangle':</span><span class="s3">\n    </span><span class="s1">case 'bottom-round-rectangle':</span><span class="s3">\n      </span><span class="s1">return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height, corners);</span><span class="s3">\n    </span><span class="s1">case 'barrel':</span><span class="s3">\n      </span><span class="s1">return this.drawBarrelPath(context, centerX, centerY, width, height);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var CR = CanvasRenderer;</span><span class="s3">\n</span><span class="s1">var CRp = CanvasRenderer.prototype;</span><span class="s3">\n</span><span class="s1">CRp.CANVAS_LAYERS = 3;</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">CRp.SELECT_BOX = 0;</span><span class="s3">\n</span><span class="s1">CRp.DRAG = 1;</span><span class="s3">\n</span><span class="s1">CRp.NODE = 2;</span><span class="s3">\n</span><span class="s1">CRp.WEBGL = 3;</span><span class="s3">\n</span><span class="s1">CRp.CANVAS_TYPES = ['2d', '2d', '2d', 'webgl2'];</span><span class="s3">\n</span><span class="s1">CRp.BUFFER_COUNT = 3;</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">CRp.TEXTURE_BUFFER = 0;</span><span class="s3">\n</span><span class="s1">CRp.MOTIONBLUR_BUFFER_NODE = 1;</span><span class="s3">\n</span><span class="s1">CRp.MOTIONBLUR_BUFFER_DRAG = 2;</span><span class="s3">\n</span><span class="s1">function CanvasRenderer(options) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">var containerWindow = r.cy.window();</span><span class="s3">\n  </span><span class="s1">var document = containerWindow.document;</span><span class="s3">\n  </span><span class="s1">if (options.webgl) {</span><span class="s3">\n    </span><span class="s1">CRp.CANVAS_LAYERS = r.CANVAS_LAYERS = 4;</span><span class="s3">\n    </span><span class="s1">console.log('webgl rendering enabled');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.data = {</span><span class="s3">\n    </span><span class="s1">canvases: new Array(CRp.CANVAS_LAYERS),</span><span class="s3">\n    </span><span class="s1">contexts: new Array(CRp.CANVAS_LAYERS),</span><span class="s3">\n    </span><span class="s1">canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),</span><span class="s3">\n    </span><span class="s1">bufferCanvases: new Array(CRp.BUFFER_COUNT),</span><span class="s3">\n    </span><span class="s1">bufferContexts: new Array(CRp.CANVAS_LAYERS)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var tapHlOffAttr = '-webkit-tap-highlight-color';</span><span class="s3">\n  </span><span class="s1">var tapHlOffStyle = 'rgba(0,0,0,0)';</span><span class="s3">\n  </span><span class="s1">r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef</span><span class="s3">\n  </span><span class="s1">var containerStyle = r.data.canvasContainer.style;</span><span class="s3">\n  </span><span class="s1">r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;</span><span class="s3">\n  </span><span class="s1">containerStyle.position = 'relative';</span><span class="s3">\n  </span><span class="s1">containerStyle.zIndex = '0';</span><span class="s3">\n  </span><span class="s1">containerStyle.overflow = 'hidden';</span><span class="s3">\n  </span><span class="s1">var container = options.cy.container();</span><span class="s3">\n  </span><span class="s1">container.appendChild(r.data.canvasContainer);</span><span class="s3">\n  </span><span class="s1">container.style[tapHlOffAttr] = tapHlOffStyle;</span><span class="s3">\n  </span><span class="s1">var styleMap = {</span><span class="s3">\n    </span><span class="s1">'-webkit-user-select': 'none',</span><span class="s3">\n    </span><span class="s1">'-moz-user-select': '-moz-none',</span><span class="s3">\n    </span><span class="s1">'user-select': 'none',</span><span class="s3">\n    </span><span class="s1">'-webkit-tap-highlight-color': 'rgba(0,0,0,0)',</span><span class="s3">\n    </span><span class="s1">'outline-style': 'none'</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (ms()) {</span><span class="s3">\n    </span><span class="s1">styleMap['-ms-touch-action'] = 'none';</span><span class="s3">\n    </span><span class="s1">styleMap['touch-action'] = 'none';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; CRp.CANVAS_LAYERS; i++) {</span><span class="s3">\n    </span><span class="s1">var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">var type = CRp.CANVAS_TYPES[i];</span><span class="s3">\n    </span><span class="s1">r.data.contexts[i] = canvas.getContext(type);</span><span class="s3">\n    </span><span class="s1">if (!r.data.contexts[i]) {</span><span class="s3">\n      </span><span class="s1">error('Could not create canvas of type ' + type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Object.keys(styleMap).forEach(function (k) {</span><span class="s3">\n      </span><span class="s1">canvas.style[k] = styleMap[k];</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">canvas.style.position = 'absolute';</span><span class="s3">\n    </span><span class="s1">canvas.setAttribute('data-id', 'layer' + i);</span><span class="s3">\n    </span><span class="s1">canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);</span><span class="s3">\n    </span><span class="s1">r.data.canvasContainer.appendChild(canvas);</span><span class="s3">\n    </span><span class="s1">r.data.canvasNeedsRedraw[i] = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.data.topCanvas = r.data.canvases[0];</span><span class="s3">\n  </span><span class="s1">r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');</span><span class="s3">\n  </span><span class="s1">r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');</span><span class="s3">\n  </span><span class="s1">r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');</span><span class="s3">\n  </span><span class="s1">if (r.data.canvases[CRp.WEBGL]) {</span><span class="s3">\n    </span><span class="s1">r.data.canvases[CRp.WEBGL].setAttribute('data-id', 'layer' + CRp.WEBGL + '-webgl');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; CRp.BUFFER_COUNT; i++) {</span><span class="s3">\n    </span><span class="s1">r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');</span><span class="s3">\n    </span><span class="s1">r.data.bufferCanvases[i].style.position = 'absolute';</span><span class="s3">\n    </span><span class="s1">r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);</span><span class="s3">\n    </span><span class="s1">r.data.bufferCanvases[i].style.zIndex = String(-i - 1);</span><span class="s3">\n    </span><span class="s1">r.data.bufferCanvases[i].style.visibility = 'hidden';</span><span class="s3">\n    </span><span class="s1">//r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">r.pathsEnabled = true;</span><span class="s3">\n  </span><span class="s1">var emptyBb = makeBoundingBox();</span><span class="s3">\n  </span><span class="s1">var getBoxCenter = function getBoxCenter(bb) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: (bb.x1 + bb.x2) / 2,</span><span class="s3">\n      </span><span class="s1">y: (bb.y1 + bb.y2) / 2</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getCenterOffset = function getCenterOffset(bb) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: -bb.w / 2,</span><span class="s3">\n      </span><span class="s1">y: -bb.h / 2</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {</span><span class="s3">\n    </span><span class="s1">var _p = ele[0]._private;</span><span class="s3">\n    </span><span class="s1">var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;</span><span class="s3">\n    </span><span class="s1">return !same;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getStyleKey = function getStyleKey(ele) {</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.nodeKey;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getLabelKey = function getLabelKey(ele) {</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.labelStyleKey;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getSourceLabelKey = function getSourceLabelKey(ele) {</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.sourceLabelStyleKey;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getTargetLabelKey = function getTargetLabelKey(ele) {</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.targetLabelStyleKey;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {</span><span class="s3">\n    </span><span class="s1">return r.drawElement(context, ele, bb, false, false, useEleOpacity);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {</span><span class="s3">\n    </span><span class="s1">return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {</span><span class="s3">\n    </span><span class="s1">return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {</span><span class="s3">\n    </span><span class="s1">return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getElementBox = function getElementBox(ele) {</span><span class="s3">\n    </span><span class="s1">ele.boundingBox();</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.bodyBounds;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getLabelBox = function getLabelBox(ele) {</span><span class="s3">\n    </span><span class="s1">ele.boundingBox();</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.labelBounds.main || emptyBb;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getSourceLabelBox = function getSourceLabelBox(ele) {</span><span class="s3">\n    </span><span class="s1">ele.boundingBox();</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.labelBounds.source || emptyBb;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getTargetLabelBox = function getTargetLabelBox(ele) {</span><span class="s3">\n    </span><span class="s1">ele.boundingBox();</span><span class="s3">\n    </span><span class="s1">return ele[0]._private.labelBounds.target || emptyBb;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {</span><span class="s3">\n    </span><span class="s1">return scaledLabelShown;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getElementRotationPoint = function getElementRotationPoint(ele) {</span><span class="s3">\n    </span><span class="s1">return getBoxCenter(getElementBox(ele));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var addTextMargin = function addTextMargin(prefix, pt, ele) {</span><span class="s3">\n    </span><span class="s1">var pre = prefix ? prefix + '-' : '';</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,</span><span class="s3">\n      </span><span class="s1">y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getRsPt = function getRsPt(ele, x, y) {</span><span class="s3">\n    </span><span class="s1">var rs = ele[0]._private.rscratch;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: rs[x],</span><span class="s3">\n      </span><span class="s1">y: rs[y]</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getLabelRotationPoint = function getLabelRotationPoint(ele) {</span><span class="s3">\n    </span><span class="s1">return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {</span><span class="s3">\n    </span><span class="s1">return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {</span><span class="s3">\n    </span><span class="s1">return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getElementRotationOffset = function getElementRotationOffset(ele) {</span><span class="s3">\n    </span><span class="s1">return getCenterOffset(getElementBox(ele));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {</span><span class="s3">\n    </span><span class="s1">return getCenterOffset(getSourceLabelBox(ele));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {</span><span class="s3">\n    </span><span class="s1">return getCenterOffset(getTargetLabelBox(ele));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var getLabelRotationOffset = function getLabelRotationOffset(ele) {</span><span class="s3">\n    </span><span class="s1">var bb = getLabelBox(ele);</span><span class="s3">\n    </span><span class="s1">var p = getCenterOffset(getLabelBox(ele));</span><span class="s3">\n    </span><span class="s1">if (ele.isNode()) {</span><span class="s3">\n      </span><span class="s1">switch (ele.pstyle('text-halign').value) {</span><span class="s3">\n        </span><span class="s1">case 'left':</span><span class="s3">\n          </span><span class="s1">p.x = -bb.w - (bb.leftPad || 0);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'right':</span><span class="s3">\n          </span><span class="s1">p.x = -(bb.rightPad || 0);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">switch (ele.pstyle('text-valign').value) {</span><span class="s3">\n        </span><span class="s1">case 'top':</span><span class="s3">\n          </span><span class="s1">p.y = -bb.h - (bb.topPad || 0);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'bottom':</span><span class="s3">\n          </span><span class="s1">p.y = -(bb.botPad || 0);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return p;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {</span><span class="s3">\n    </span><span class="s1">getKey: getStyleKey,</span><span class="s3">\n    </span><span class="s1">doesEleInvalidateKey: backgroundTimestampHasChanged,</span><span class="s3">\n    </span><span class="s1">drawElement: drawElement,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: getElementBox,</span><span class="s3">\n    </span><span class="s1">getRotationPoint: getElementRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: getElementRotationOffset,</span><span class="s3">\n    </span><span class="s1">allowEdgeTxrCaching: false,</span><span class="s3">\n    </span><span class="s1">allowParentTxrCaching: false</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {</span><span class="s3">\n    </span><span class="s1">getKey: getLabelKey,</span><span class="s3">\n    </span><span class="s1">drawElement: drawLabel,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: getLabelBox,</span><span class="s3">\n    </span><span class="s1">getRotationPoint: getLabelRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: getLabelRotationOffset,</span><span class="s3">\n    </span><span class="s1">isVisible: isLabelVisibleAtScale</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {</span><span class="s3">\n    </span><span class="s1">getKey: getSourceLabelKey,</span><span class="s3">\n    </span><span class="s1">drawElement: drawSourceLabel,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: getSourceLabelBox,</span><span class="s3">\n    </span><span class="s1">getRotationPoint: getSourceLabelRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: getSourceLabelRotationOffset,</span><span class="s3">\n    </span><span class="s1">isVisible: isLabelVisibleAtScale</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {</span><span class="s3">\n    </span><span class="s1">getKey: getTargetLabelKey,</span><span class="s3">\n    </span><span class="s1">drawElement: drawTargetLabel,</span><span class="s3">\n    </span><span class="s1">getBoundingBox: getTargetLabelBox,</span><span class="s3">\n    </span><span class="s1">getRotationPoint: getTargetLabelRotationPoint,</span><span class="s3">\n    </span><span class="s1">getRotationOffset: getTargetLabelRotationOffset,</span><span class="s3">\n    </span><span class="s1">isVisible: isLabelVisibleAtScale</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);</span><span class="s3">\n  </span><span class="s1">r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {</span><span class="s3">\n    </span><span class="s1">// each cache should check for sub-key diff to see that the update affects that cache particularly</span><span class="s3">\n    </span><span class="s1">eleTxrCache.invalidateElements(eles);</span><span class="s3">\n    </span><span class="s1">lblTxrCache.invalidateElements(eles);</span><span class="s3">\n    </span><span class="s1">slbTxrCache.invalidateElements(eles);</span><span class="s3">\n    </span><span class="s1">tlbTxrCache.invalidateElements(eles);</span><span class="s3">\n\n    </span><span class="s1">// any change invalidates the layers</span><span class="s3">\n    </span><span class="s1">lyrTxrCache.invalidateElements(eles);</span><span class="s3">\n\n    </span><span class="s1">// update the old bg timestamp so diffs can be done in the ele txr caches</span><span class="s3">\n    </span><span class="s1">for (var _i = 0; _i &lt; eles.length; _i++) {</span><span class="s3">\n      </span><span class="s1">var _p = eles[_i]._private;</span><span class="s3">\n      </span><span class="s1">_p.oldBackgroundTimestamp = _p.backgroundTimestamp;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">var refineInLayers = function refineInLayers(reqs) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; reqs.length; i++) {</span><span class="s3">\n      </span><span class="s1">lyrTxrCache.enqueueElementRefinement(reqs[i].ele);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">eleTxrCache.onDequeue(refineInLayers);</span><span class="s3">\n  </span><span class="s1">lblTxrCache.onDequeue(refineInLayers);</span><span class="s3">\n  </span><span class="s1">slbTxrCache.onDequeue(refineInLayers);</span><span class="s3">\n  </span><span class="s1">tlbTxrCache.onDequeue(refineInLayers);</span><span class="s3">\n  </span><span class="s1">if (options.webgl) {</span><span class="s3">\n    </span><span class="s1">r.initWebgl(options, {</span><span class="s3">\n      </span><span class="s1">getStyleKey: getStyleKey,</span><span class="s3">\n      </span><span class="s1">getLabelKey: getLabelKey,</span><span class="s3">\n      </span><span class="s1">getSourceLabelKey: getSourceLabelKey,</span><span class="s3">\n      </span><span class="s1">getTargetLabelKey: getTargetLabelKey,</span><span class="s3">\n      </span><span class="s1">drawElement: drawElement,</span><span class="s3">\n      </span><span class="s1">drawLabel: drawLabel,</span><span class="s3">\n      </span><span class="s1">drawSourceLabel: drawSourceLabel,</span><span class="s3">\n      </span><span class="s1">drawTargetLabel: drawTargetLabel,</span><span class="s3">\n      </span><span class="s1">getElementBox: getElementBox,</span><span class="s3">\n      </span><span class="s1">getLabelBox: getLabelBox,</span><span class="s3">\n      </span><span class="s1">getSourceLabelBox: getSourceLabelBox,</span><span class="s3">\n      </span><span class="s1">getTargetLabelBox: getTargetLabelBox,</span><span class="s3">\n      </span><span class="s1">getElementRotationPoint: getElementRotationPoint,</span><span class="s3">\n      </span><span class="s1">getElementRotationOffset: getElementRotationOffset,</span><span class="s3">\n      </span><span class="s1">getLabelRotationPoint: getLabelRotationPoint,</span><span class="s3">\n      </span><span class="s1">getSourceLabelRotationPoint: getSourceLabelRotationPoint,</span><span class="s3">\n      </span><span class="s1">getTargetLabelRotationPoint: getTargetLabelRotationPoint,</span><span class="s3">\n      </span><span class="s1">getLabelRotationOffset: getLabelRotationOffset,</span><span class="s3">\n      </span><span class="s1">getSourceLabelRotationOffset: getSourceLabelRotationOffset,</span><span class="s3">\n      </span><span class="s1">getTargetLabelRotationOffset: getTargetLabelRotationOffset</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">CRp.redrawHint = function (group, bool) {</span><span class="s3">\n  </span><span class="s1">var r = this;</span><span class="s3">\n  </span><span class="s1">switch (group) {</span><span class="s3">\n    </span><span class="s1">case 'eles':</span><span class="s3">\n      </span><span class="s1">r.data.canvasNeedsRedraw[CRp.NODE] = bool;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'drag':</span><span class="s3">\n      </span><span class="s1">r.data.canvasNeedsRedraw[CRp.DRAG] = bool;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'select':</span><span class="s3">\n      </span><span class="s1">r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case 'gc':</span><span class="s3">\n      </span><span class="s1">r.data.gc = true;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// whether to use Path2D caching for drawing</span><span class="s3">\n</span><span class="s1">var pathsImpld = typeof Path2D !== 'undefined';</span><span class="s3">\n</span><span class="s1">CRp.path2dEnabled = function (on) {</span><span class="s3">\n  </span><span class="s1">if (on === undefined) {</span><span class="s3">\n    </span><span class="s1">return this.pathsEnabled;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.pathsEnabled = on ? true : false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp.usePaths = function () {</span><span class="s3">\n  </span><span class="s1">return pathsImpld &amp;&amp; this.pathsEnabled;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp.setImgSmoothing = function (context, bool) {</span><span class="s3">\n  </span><span class="s1">if (context.imageSmoothingEnabled != null) {</span><span class="s3">\n    </span><span class="s1">context.imageSmoothingEnabled = bool;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">context.webkitImageSmoothingEnabled = bool;</span><span class="s3">\n    </span><span class="s1">context.mozImageSmoothingEnabled = bool;</span><span class="s3">\n    </span><span class="s1">context.msImageSmoothingEnabled = bool;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp.getImgSmoothing = function (context) {</span><span class="s3">\n  </span><span class="s1">if (context.imageSmoothingEnabled != null) {</span><span class="s3">\n    </span><span class="s1">return context.imageSmoothingEnabled;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">CRp.makeOffscreenCanvas = function (width, height) {</span><span class="s3">\n  </span><span class="s1">var canvas;</span><span class="s3">\n  </span><span class="s1">if ((typeof OffscreenCanvas === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: _typeof(OffscreenCanvas)) !== (</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">canvas = new OffscreenCanvas(width, height);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var containerWindow = this.cy.window();</span><span class="s3">\n    </span><span class="s1">var document = containerWindow.document;</span><span class="s3">\n    </span><span class="s1">canvas = document.createElement('canvas'); // eslint-disable-line no-undef</span><span class="s3">\n    </span><span class="s1">canvas.width = width;</span><span class="s3">\n    </span><span class="s1">canvas.height = height;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return canvas;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">[CRp$b, CRp$a, CRp$9, CRp$8, CRp$7, CRp$6, CRp$5, CRp$4, CRp$3, CRp$2, CRp$1].forEach(function (props) {</span><span class="s3">\n  </span><span class="s1">extend(CRp, props);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var renderer = [{</span><span class="s3">\n  </span><span class="s1">name: 'null',</span><span class="s3">\n  </span><span class="s1">impl: NullRenderer</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'base',</span><span class="s3">\n  </span><span class="s1">impl: BR</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">name: 'canvas',</span><span class="s3">\n  </span><span class="s1">impl: CR</span><span class="s3">\n</span><span class="s1">}];</span><span class="s3">\n\n</span><span class="s1">var incExts = [{</span><span class="s3">\n  </span><span class="s1">type: 'layout',</span><span class="s3">\n  </span><span class="s1">extensions: layout</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n  </span><span class="s1">type: 'renderer',</span><span class="s3">\n  </span><span class="s1">extensions: renderer</span><span class="s3">\n</span><span class="s1">}];</span><span class="s3">\n\n</span><span class="s1">// registered extensions to cytoscape, indexed by name</span><span class="s3">\n</span><span class="s1">var extensions = {};</span><span class="s3">\n\n</span><span class="s1">// registered modules for extensions, indexed by name</span><span class="s3">\n</span><span class="s1">var modules = {};</span><span class="s3">\n</span><span class="s1">function setExtension(type, name, registrant) {</span><span class="s3">\n  </span><span class="s1">var ext = registrant;</span><span class="s3">\n  </span><span class="s1">var overrideErr = function overrideErr(field) {</span><span class="s3">\n    </span><span class="s1">warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (type === 'core') {</span><span class="s3">\n    </span><span class="s1">if (Core.prototype[name]) {</span><span class="s3">\n      </span><span class="s1">return overrideErr(name);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">Core.prototype[name] = registrant;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (type === 'collection') {</span><span class="s3">\n    </span><span class="s1">if (Collection.prototype[name]) {</span><span class="s3">\n      </span><span class="s1">return overrideErr(name);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">Collection.prototype[name] = registrant;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (type === 'layout') {</span><span class="s3">\n    </span><span class="s1">// fill in missing layout functions in the prototype</span><span class="s3">\n\n    </span><span class="s1">var Layout = function Layout(options) {</span><span class="s3">\n      </span><span class="s1">this.options = options;</span><span class="s3">\n      </span><span class="s1">registrant.call(this, options);</span><span class="s3">\n\n      </span><span class="s1">// make sure layout has _private for use w/ std apis like .on()</span><span class="s3">\n      </span><span class="s1">if (!plainObject(this._private)) {</span><span class="s3">\n        </span><span class="s1">this._private = {};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this._private.cy = options.cy;</span><span class="s3">\n      </span><span class="s1">this._private.listeners = [];</span><span class="s3">\n      </span><span class="s1">this.createEmitter();</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var layoutProto = Layout.prototype = Object.create(registrant.prototype);</span><span class="s3">\n    </span><span class="s1">var optLayoutFns = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; optLayoutFns.length; i++) {</span><span class="s3">\n      </span><span class="s1">var fnName = optLayoutFns[i];</span><span class="s3">\n      </span><span class="s1">layoutProto[fnName] = layoutProto[fnName] || function () {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// either .start() or .run() is defined, so autogen the other</span><span class="s3">\n    </span><span class="s1">if (layoutProto.start &amp;&amp; !layoutProto.run) {</span><span class="s3">\n      </span><span class="s1">layoutProto.run = function () {</span><span class="s3">\n        </span><span class="s1">this.start();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else if (!layoutProto.start &amp;&amp; layoutProto.run) {</span><span class="s3">\n      </span><span class="s1">layoutProto.start = function () {</span><span class="s3">\n        </span><span class="s1">this.run();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var regStop = registrant.prototype.stop;</span><span class="s3">\n    </span><span class="s1">layoutProto.stop = function () {</span><span class="s3">\n      </span><span class="s1">var opts = this.options;</span><span class="s3">\n      </span><span class="s1">if (opts &amp;&amp; opts.animate) {</span><span class="s3">\n        </span><span class="s1">var anis = this.animations;</span><span class="s3">\n        </span><span class="s1">if (anis) {</span><span class="s3">\n          </span><span class="s1">for (var _i = 0; _i &lt; anis.length; _i++) {</span><span class="s3">\n            </span><span class="s1">anis[_i].stop();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (regStop) {</span><span class="s3">\n        </span><span class="s1">regStop.call(this);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.emit('layoutstop');</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (!layoutProto.destroy) {</span><span class="s3">\n      </span><span class="s1">layoutProto.destroy = function () {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">layoutProto.cy = function () {</span><span class="s3">\n      </span><span class="s1">return this._private.cy;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var getCy = function getCy(layout) {</span><span class="s3">\n      </span><span class="s1">return layout._private.cy;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var emitterOpts = {</span><span class="s3">\n      </span><span class="s1">addEventFields: function addEventFields(layout, evt) {</span><span class="s3">\n        </span><span class="s1">evt.layout = layout;</span><span class="s3">\n        </span><span class="s1">evt.cy = getCy(layout);</span><span class="s3">\n        </span><span class="s1">evt.target = layout;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">bubble: function bubble() {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">parent: function parent(layout) {</span><span class="s3">\n        </span><span class="s1">return getCy(layout);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">extend(layoutProto, {</span><span class="s3">\n      </span><span class="s1">createEmitter: function createEmitter() {</span><span class="s3">\n        </span><span class="s1">this._private.emitter = new Emitter(emitterOpts, this);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">emitter: function emitter() {</span><span class="s3">\n        </span><span class="s1">return this._private.emitter;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">on: function on(evt, cb) {</span><span class="s3">\n        </span><span class="s1">this.emitter().on(evt, cb);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">one: function one(evt, cb) {</span><span class="s3">\n        </span><span class="s1">this.emitter().one(evt, cb);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">once: function once(evt, cb) {</span><span class="s3">\n        </span><span class="s1">this.emitter().one(evt, cb);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">removeListener: function removeListener(evt, cb) {</span><span class="s3">\n        </span><span class="s1">this.emitter().removeListener(evt, cb);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">removeAllListeners: function removeAllListeners() {</span><span class="s3">\n        </span><span class="s1">this.emitter().removeAllListeners();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">emit: function emit(evt, params) {</span><span class="s3">\n        </span><span class="s1">this.emitter().emit(evt, params);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">define.eventAliasesOn(layoutProto);</span><span class="s3">\n    </span><span class="s1">ext = Layout; // replace with our wrapped layout</span><span class="s3">\n  </span><span class="s1">} else if (type === 'renderer' &amp;&amp; name !== 'null' &amp;&amp; name !== 'base') {</span><span class="s3">\n    </span><span class="s1">// user registered renderers inherit from base</span><span class="s3">\n\n    </span><span class="s1">var BaseRenderer = getExtension('renderer', 'base');</span><span class="s3">\n    </span><span class="s1">var bProto = BaseRenderer.prototype;</span><span class="s3">\n    </span><span class="s1">var RegistrantRenderer = registrant;</span><span class="s3">\n    </span><span class="s1">var rProto = registrant.prototype;</span><span class="s3">\n    </span><span class="s1">var Renderer = function Renderer() {</span><span class="s3">\n      </span><span class="s1">BaseRenderer.apply(this, arguments);</span><span class="s3">\n      </span><span class="s1">RegistrantRenderer.apply(this, arguments);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">var proto = Renderer.prototype;</span><span class="s3">\n    </span><span class="s1">for (var pName in bProto) {</span><span class="s3">\n      </span><span class="s1">var pVal = bProto[pName];</span><span class="s3">\n      </span><span class="s1">var existsInR = rProto[pName] != null;</span><span class="s3">\n      </span><span class="s1">if (existsInR) {</span><span class="s3">\n        </span><span class="s1">return overrideErr(pName);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">proto[pName] = pVal; // take impl from base</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var _pName in rProto) {</span><span class="s3">\n      </span><span class="s1">proto[_pName] = rProto[_pName]; // take impl from registrant</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bProto.clientFunctions.forEach(function (name) {</span><span class="s3">\n      </span><span class="s1">proto[name] = proto[name] || function () {</span><span class="s3">\n        </span><span class="s1">error('Renderer does not implement `renderer.' + name + '()` on its prototype');</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">ext = Renderer;</span><span class="s3">\n  </span><span class="s1">} else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {</span><span class="s3">\n    </span><span class="s1">// to avoid potential prototype pollution</span><span class="s3">\n    </span><span class="s1">return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return setMap({</span><span class="s3">\n    </span><span class="s1">map: extensions,</span><span class="s3">\n    </span><span class="s1">keys: [type, name],</span><span class="s3">\n    </span><span class="s1">value: ext</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getExtension(type, name) {</span><span class="s3">\n  </span><span class="s1">return getMap({</span><span class="s3">\n    </span><span class="s1">map: extensions,</span><span class="s3">\n    </span><span class="s1">keys: [type, name]</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function setModule(type, name, moduleType, moduleName, registrant) {</span><span class="s3">\n  </span><span class="s1">return setMap({</span><span class="s3">\n    </span><span class="s1">map: modules,</span><span class="s3">\n    </span><span class="s1">keys: [type, name, moduleType, moduleName],</span><span class="s3">\n    </span><span class="s1">value: registrant</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getModule(type, name, moduleType, moduleName) {</span><span class="s3">\n  </span><span class="s1">return getMap({</span><span class="s3">\n    </span><span class="s1">map: modules,</span><span class="s3">\n    </span><span class="s1">keys: [type, name, moduleType, moduleName]</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var extension = function extension() {</span><span class="s3">\n  </span><span class="s1">// e.g. extension('renderer', 'svg')</span><span class="s3">\n  </span><span class="s1">if (arguments.length === 2) {</span><span class="s3">\n    </span><span class="s1">return getExtension.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// e.g. extension('renderer', 'svg', { ... })</span><span class="s3">\n  </span><span class="s1">else if (arguments.length === 3) {</span><span class="s3">\n    </span><span class="s1">return setExtension.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')</span><span class="s3">\n  </span><span class="s1">else if (arguments.length === 4) {</span><span class="s3">\n    </span><span class="s1">return getModule.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })</span><span class="s3">\n  </span><span class="s1">else if (arguments.length === 5) {</span><span class="s3">\n    </span><span class="s1">return setModule.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">error('Invalid extension access syntax');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// allows a core instance to access extensions internally</span><span class="s3">\n</span><span class="s1">Core.prototype.extension = extension;</span><span class="s3">\n\n</span><span class="s1">// included extensions</span><span class="s3">\n</span><span class="s1">incExts.forEach(function (group) {</span><span class="s3">\n  </span><span class="s1">group.extensions.forEach(function (ext) {</span><span class="s3">\n    </span><span class="s1">setExtension(group.type, ext.name, ext.impl);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// a dummy stylesheet object that doesn't need a reference to the core</span><span class="s3">\n</span><span class="s1">// (useful for init)</span><span class="s3">\n</span><span class="s1">var _Stylesheet = function Stylesheet() {</span><span class="s3">\n  </span><span class="s1">if (!(this instanceof _Stylesheet)) {</span><span class="s3">\n    </span><span class="s1">return new _Stylesheet();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.length = 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var sheetfn = _Stylesheet.prototype;</span><span class="s3">\n</span><span class="s1">sheetfn.instanceString = function () {</span><span class="s3">\n  </span><span class="s1">return 'stylesheet';</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// just store the selector to be parsed later</span><span class="s3">\n</span><span class="s1">sheetfn.selector = function (selector) {</span><span class="s3">\n  </span><span class="s1">var i = this.length++;</span><span class="s3">\n  </span><span class="s1">this[i] = {</span><span class="s3">\n    </span><span class="s1">selector: selector,</span><span class="s3">\n    </span><span class="s1">properties: []</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// just store the property to be parsed later</span><span class="s3">\n</span><span class="s1">sheetfn.css = function (name, value) {</span><span class="s3">\n  </span><span class="s1">var i = this.length - 1;</span><span class="s3">\n  </span><span class="s1">if (string(name)) {</span><span class="s3">\n    </span><span class="s1">this[i].properties.push({</span><span class="s3">\n      </span><span class="s1">name: name,</span><span class="s3">\n      </span><span class="s1">value: value</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (plainObject(name)) {</span><span class="s3">\n    </span><span class="s1">var map = name;</span><span class="s3">\n    </span><span class="s1">var propNames = Object.keys(map);</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; propNames.length; j++) {</span><span class="s3">\n      </span><span class="s1">var key = propNames[j];</span><span class="s3">\n      </span><span class="s1">var mapVal = map[key];</span><span class="s3">\n      </span><span class="s1">if (mapVal == null) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var prop = _Style.properties[key] || _Style.properties[dash2camel(key)];</span><span class="s3">\n      </span><span class="s1">if (prop == null) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var _name = prop.name;</span><span class="s3">\n      </span><span class="s1">var _value = mapVal;</span><span class="s3">\n      </span><span class="s1">this[i].properties.push({</span><span class="s3">\n        </span><span class="s1">name: _name,</span><span class="s3">\n        </span><span class="s1">value: _value</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">sheetfn.style = sheetfn.css;</span><span class="s3">\n\n</span><span class="s1">// generate a real style object from the dummy stylesheet</span><span class="s3">\n</span><span class="s1">sheetfn.generateStyle = function (cy) {</span><span class="s3">\n  </span><span class="s1">var style = new _Style(cy);</span><span class="s3">\n  </span><span class="s1">return this.appendToStyle(style);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// append a dummy stylesheet object on a real style object</span><span class="s3">\n</span><span class="s1">sheetfn.appendToStyle = function (style) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.length; i++) {</span><span class="s3">\n    </span><span class="s1">var context = this[i];</span><span class="s3">\n    </span><span class="s1">var selector = context.selector;</span><span class="s3">\n    </span><span class="s1">var props = context.properties;</span><span class="s3">\n    </span><span class="s1">style.selector(selector); // apply selector</span><span class="s3">\n\n    </span><span class="s1">for (var j = 0; j &lt; props.length; j++) {</span><span class="s3">\n      </span><span class="s1">var prop = props[j];</span><span class="s3">\n      </span><span class="s1">style.css(prop.name, prop.value); // apply property</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var version = </span><span class="s3">\&quot;</span><span class="s1">3.31.1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">var cytoscape = function cytoscape(options) {</span><span class="s3">\n  </span><span class="s1">// if no options specified, use default</span><span class="s3">\n  </span><span class="s1">if (options === undefined) {</span><span class="s3">\n    </span><span class="s1">options = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// create instance</span><span class="s3">\n  </span><span class="s1">if (plainObject(options)) {</span><span class="s3">\n    </span><span class="s1">return new Core(options);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// allow for registration of extensions</span><span class="s3">\n  </span><span class="s1">else if (string(options)) {</span><span class="s3">\n    </span><span class="s1">return extension.apply(extension, arguments);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// e.g. cytoscape.use( require('cytoscape-foo'), bar )</span><span class="s3">\n</span><span class="s1">cytoscape.use = function (ext) {</span><span class="s3">\n  </span><span class="s1">var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext</span><span class="s3">\n\n  </span><span class="s1">args.unshift(cytoscape); // cytoscape is first arg to ext</span><span class="s3">\n\n  </span><span class="s1">ext.apply(null, args);</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">cytoscape.warnings = function (bool) {</span><span class="s3">\n  </span><span class="s1">return warnings(bool);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// replaced by build system</span><span class="s3">\n</span><span class="s1">cytoscape.version = version;</span><span class="s3">\n\n</span><span class="s1">// expose public apis (mostly for extensions)</span><span class="s3">\n</span><span class="s1">cytoscape.stylesheet = cytoscape.Stylesheet = _Stylesheet;</span><span class="s3">\n\n</span><span class="s1">export { cytoscape as default };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>