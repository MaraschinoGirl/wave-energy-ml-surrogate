<html>
<head>
<title>2871.46ec88c6997ef947f39f.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
2871.46ec88c6997ef947f39f.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;2871.46ec88c6997ef947f39f.js?v=46ec88c6997ef947f39f&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;;AAEA,wFAAwF,EAAE,MAAM;AAChG;AACA;AACA;AACA,kBAAkB,sBAAsB;;AAExC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,EAAE,IAAI,EAAE;AAC/E,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,6DAA6D,EAAE,IAAI,EAAE;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0CAA0C;AAC1C,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,yBAAyB;AACnC,uBAAuB;AACvB;AACA,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA,UAAU,wBAAwB;AAClC,sBAAsB;AACtB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA,mCAAmC;AACnC;;AAEA;AACA,sCAAsC;AACtC,uBAAuB;AACvB;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,4CAA4C;;AAE5C,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,8BAA8B;AAC9B,sBAAsB,UAAU;AAChC,sBAAsB,uBAAuB;AAC7C;AACA;AACA;;AAEA,4BAA4B;;AAErB,0BAA0B;;AAE1B;AACP;AACA;AACA;AACA,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/python.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function wordRegexp(words) {</span><span class="s3">\n  </span><span class="s1">return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^((</span><span class="s3">\&quot; </span><span class="s1">+ words.join(</span><span class="s3">\&quot;</span><span class="s1">)|(</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\\\\</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var wordOperators = wordRegexp([</span><span class="s3">\&quot;</span><span class="s1">and</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">not</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">is</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">var commonKeywords = [</span><span class="s3">\&quot;</span><span class="s1">as</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">del</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">elif</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">except</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">lambda</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">pass</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">raise</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">yield</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">False</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">True</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">var commonBuiltins = [</span><span class="s3">\&quot;</span><span class="s1">abs</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bin</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bool</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bytearray</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">callable</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">chr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">classmethod</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">compile</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">complex</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">delattr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dict</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dir</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">divmod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">enumerate</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">eval</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">filter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">float</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">frozenset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">getattr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">globals</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">hasattr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">hash</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">help</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">hex</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">int</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">isinstance</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">issubclass</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">iter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">len</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">list</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">locals</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">max</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">memoryview</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">min</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">oct</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">open</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">ord</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">pow</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">range</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">repr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">reversed</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">round</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">setattr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">slice</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">sorted</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">staticmethod</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">str</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">sum</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">tuple</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">vars</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">zip</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">__import__</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">NotImplemented</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">Ellipsis</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">__debug__</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">function top(state) {</span><span class="s3">\n  </span><span class="s1">return state.scopes[state.scopes.length - 1];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function mkPython(parserConf) {</span><span class="s3">\n  </span><span class="s1">var ERRORCLASS = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">}@,:`=;</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">]/;</span><span class="s3">\n  </span><span class="s1">//               (Backwards-compatibility with old, cumbersome config system)</span><span class="s3">\n  </span><span class="s1">var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,</span><span class="s3">\n                   </span><span class="s1">parserConf.operators || /^([-+*/%</span><span class="s3">\\</span><span class="s1">/&amp;|^]=?|[&lt;&gt;=]+|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/=?|</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">*=?|!=|[~!@]|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.)/]</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; operators.length; i++) if (!operators[i]) operators.splice(i--, 1)</span><span class="s3">\n\n  </span><span class="s1">var hangingIndent = parserConf.hangingIndent;</span><span class="s3">\n\n  </span><span class="s1">var myKeywords = commonKeywords, myBuiltins = commonBuiltins;</span><span class="s3">\n  </span><span class="s1">if (parserConf.extra_keywords != undefined)</span><span class="s3">\n    </span><span class="s1">myKeywords = myKeywords.concat(parserConf.extra_keywords);</span><span class="s3">\n\n  </span><span class="s1">if (parserConf.extra_builtins != undefined)</span><span class="s3">\n    </span><span class="s1">myBuiltins = myBuiltins.concat(parserConf.extra_builtins);</span><span class="s3">\n\n  </span><span class="s1">var py3 = !(parserConf.version &amp;&amp; Number(parserConf.version) &lt; 3)</span><span class="s3">\n  </span><span class="s1">if (py3) {</span><span class="s3">\n    </span><span class="s1">// since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator</span><span class="s3">\n    </span><span class="s1">var identifiers = parserConf.identifiers|| /^[_A-Za-z</span><span class="s3">\\</span><span class="s1">u00A1-</span><span class="s3">\\</span><span class="s1">uFFFF][_A-Za-z0-9</span><span class="s3">\\</span><span class="s1">u00A1-</span><span class="s3">\\</span><span class="s1">uFFFF]*/;</span><span class="s3">\n    </span><span class="s1">myKeywords = myKeywords.concat([</span><span class="s3">\&quot;</span><span class="s1">nonlocal</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">None</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">aiter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">anext</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">breakpoint</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">myBuiltins = myBuiltins.concat([</span><span class="s3">\&quot;</span><span class="s1">ascii</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bytes</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">exec</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">print</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">var stringPrefixes = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|</span><span class="s3">\\\&quot;</span><span class="s1">{3}|['</span><span class="s3">\\\&quot;</span><span class="s1">]))</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;</span><span class="s3">\n    </span><span class="s1">myKeywords = myKeywords.concat([</span><span class="s3">\&quot;</span><span class="s1">exec</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">print</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">myBuiltins = myBuiltins.concat([</span><span class="s3">\&quot;</span><span class="s1">apply</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">basestring</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">buffer</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cmp</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">coerce</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">execfile</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                    \&quot;</span><span class="s1">file</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">intern</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">long</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">raw_input</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">reduce</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">reload</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                    \&quot;</span><span class="s1">unichr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">unicode</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">xrange</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">None</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">var stringPrefixes = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(([rubf]|(ur)|(br))?('{3}|</span><span class="s3">\\\&quot;</span><span class="s1">{3}|['</span><span class="s3">\\\&quot;</span><span class="s1">]))</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var keywords = wordRegexp(myKeywords);</span><span class="s3">\n  </span><span class="s1">var builtins = wordRegexp(myBuiltins);</span><span class="s3">\n\n  </span><span class="s1">// tokenizers</span><span class="s3">\n  </span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n    </span><span class="s1">var sol = stream.sol() &amp;&amp; state.lastToken != </span><span class="s3">\&quot;\\\\\&quot;\n    </span><span class="s1">if (sol) state.indent = stream.indentation()</span><span class="s3">\n    </span><span class="s1">// Handle scope changes</span><span class="s3">\n    </span><span class="s1">if (sol &amp;&amp; top(state).type == </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">var scopeOffset = top(state).offset;</span><span class="s3">\n      </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n        </span><span class="s1">var lineOffset = stream.indentation();</span><span class="s3">\n        </span><span class="s1">if (lineOffset &gt; scopeOffset)</span><span class="s3">\n          </span><span class="s1">pushPyScope(stream, state);</span><span class="s3">\n        </span><span class="s1">else if (lineOffset &lt; scopeOffset &amp;&amp; dedent(stream, state) &amp;&amp; stream.peek() != </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">state.errorToken = true;</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var style = tokenBaseInner(stream, state);</span><span class="s3">\n        </span><span class="s1">if (scopeOffset &gt; 0 &amp;&amp; dedent(stream, state))</span><span class="s3">\n          </span><span class="s1">style += </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ ERRORCLASS;</span><span class="s3">\n        </span><span class="s1">return style;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tokenBaseInner(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenBaseInner(stream, state, inFormat) {</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n\n    </span><span class="s1">// Handle Comments</span><span class="s3">\n    </span><span class="s1">if (!inFormat &amp;&amp; stream.match(/^#.*/)) return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// Handle Number Literals</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^[0-9</span><span class="s3">\\</span><span class="s1">.]/, false)) {</span><span class="s3">\n      </span><span class="s1">var floatLiteral = false;</span><span class="s3">\n      </span><span class="s1">// Floats</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^[</span><span class="s3">\\</span><span class="s1">d_]*</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+(e[</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">-]?</span><span class="s3">\\</span><span class="s1">d+)?/i)) { floatLiteral = true; }</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^[</span><span class="s3">\\</span><span class="s1">d_]+</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*/)) { floatLiteral = true; }</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+/)) { floatLiteral = true; }</span><span class="s3">\n      </span><span class="s1">if (floatLiteral) {</span><span class="s3">\n        </span><span class="s1">// Float literals may be </span><span class="s3">\&quot;</span><span class="s1">imaginary</span><span class="s3">\&quot;\n        </span><span class="s1">stream.eat(/J/i);</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Integers</span><span class="s3">\n      </span><span class="s1">var intLiteral = false;</span><span class="s3">\n      </span><span class="s1">// Hex</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;</span><span class="s3">\n      </span><span class="s1">// Binary</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^0b[01_]+/i)) intLiteral = true;</span><span class="s3">\n      </span><span class="s1">// Octal</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;</span><span class="s3">\n      </span><span class="s1">// Decimal</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^[1-9][</span><span class="s3">\\</span><span class="s1">d_]*(e[</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">-]?[</span><span class="s3">\\</span><span class="s1">d_]+)?/)) {</span><span class="s3">\n        </span><span class="s1">// Decimal literals may be </span><span class="s3">\&quot;</span><span class="s1">imaginary</span><span class="s3">\&quot;\n        </span><span class="s1">stream.eat(/J/i);</span><span class="s3">\n        </span><span class="s1">// TODO - Can you have imaginary longs?</span><span class="s3">\n        </span><span class="s1">intLiteral = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Zero by itself with no other piece of number.</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^0(?![</span><span class="s3">\\</span><span class="s1">dx])/i)) intLiteral = true;</span><span class="s3">\n      </span><span class="s1">if (intLiteral) {</span><span class="s3">\n        </span><span class="s1">// Integer literals may be </span><span class="s3">\&quot;</span><span class="s1">long</span><span class="s3">\&quot;\n        </span><span class="s1">stream.eat(/L/i);</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Handle Strings</span><span class="s3">\n    </span><span class="s1">if (stream.match(stringPrefixes)) {</span><span class="s3">\n      </span><span class="s1">var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;</span><span class="s3">\n      </span><span class="s1">if (!isFmtString) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenStringFactory(stream.current(), state.tokenize);</span><span class="s3">\n        </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">state.tokenize = formatStringFactory(stream.current(), state.tokenize);</span><span class="s3">\n        </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; operators.length; i++)</span><span class="s3">\n      </span><span class="s1">if (stream.match(operators[i])) return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;\n\n    </span><span class="s1">if (stream.match(delimiters)) return </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (state.lastToken == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(identifiers))</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (stream.match(keywords) || stream.match(wordOperators))</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (stream.match(builtins))</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">builtin</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (stream.match(/^(self|cls)</span><span class="s3">\\</span><span class="s1">b/))</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">self</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (stream.match(identifiers)) {</span><span class="s3">\n      </span><span class="s1">if (state.lastToken == </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot; </span><span class="s1">|| state.lastToken == </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Handle non-detected items</span><span class="s3">\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return inFormat ? null :ERRORCLASS;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function formatStringFactory(delimiter, tokenOuter) {</span><span class="s3">\n    </span><span class="s1">while (</span><span class="s3">\&quot;</span><span class="s1">rubf</span><span class="s3">\&quot;</span><span class="s1">.indexOf(delimiter.charAt(0).toLowerCase()) &gt;= 0)</span><span class="s3">\n      </span><span class="s1">delimiter = delimiter.substr(1);</span><span class="s3">\n\n    </span><span class="s1">var singleline = delimiter.length == 1;</span><span class="s3">\n    </span><span class="s1">var OUTCLASS = </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">function tokenNestedExpr(depth) {</span><span class="s3">\n      </span><span class="s1">return function(stream, state) {</span><span class="s3">\n        </span><span class="s1">var inner = tokenBaseInner(stream, state, true)</span><span class="s3">\n        </span><span class="s1">if (inner == </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (stream.current() == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">state.tokenize = tokenNestedExpr(depth + 1)</span><span class="s3">\n          </span><span class="s1">} else if (stream.current() == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (depth &gt; 1) state.tokenize = tokenNestedExpr(depth - 1)</span><span class="s3">\n            </span><span class="s1">else state.tokenize = tokenString</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return inner</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function tokenString(stream, state) {</span><span class="s3">\n      </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n        </span><span class="s1">stream.eatWhile(/[^'</span><span class="s3">\&quot;\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">]/);</span><span class="s3">\n        </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">stream.next();</span><span class="s3">\n          </span><span class="s1">if (singleline &amp;&amp; stream.eol())</span><span class="s3">\n            </span><span class="s1">return OUTCLASS;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match(delimiter)) {</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenOuter;</span><span class="s3">\n          </span><span class="s1">return OUTCLASS;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match('{{')) {</span><span class="s3">\n          </span><span class="s1">// ignore {{ in f-str</span><span class="s3">\n          </span><span class="s1">return OUTCLASS;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match('{', false)) {</span><span class="s3">\n          </span><span class="s1">// switch to nested mode</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenNestedExpr(0)</span><span class="s3">\n          </span><span class="s1">if (stream.current()) return OUTCLASS;</span><span class="s3">\n          </span><span class="s1">else return state.tokenize(stream, state)</span><span class="s3">\n        </span><span class="s1">} else if (stream.match('}}')) {</span><span class="s3">\n          </span><span class="s1">return OUTCLASS;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match('}')) {</span><span class="s3">\n          </span><span class="s1">// single } in f-string is an error</span><span class="s3">\n          </span><span class="s1">return ERRORCLASS;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">stream.eat(/['</span><span class="s3">\&quot;</span><span class="s1">]/);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (singleline) {</span><span class="s3">\n        </span><span class="s1">if (parserConf.singleLineStringErrors)</span><span class="s3">\n          </span><span class="s1">return ERRORCLASS;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenOuter;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return OUTCLASS;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tokenString.isString = true;</span><span class="s3">\n    </span><span class="s1">return tokenString;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenStringFactory(delimiter, tokenOuter) {</span><span class="s3">\n    </span><span class="s1">while (</span><span class="s3">\&quot;</span><span class="s1">rubf</span><span class="s3">\&quot;</span><span class="s1">.indexOf(delimiter.charAt(0).toLowerCase()) &gt;= 0)</span><span class="s3">\n      </span><span class="s1">delimiter = delimiter.substr(1);</span><span class="s3">\n\n    </span><span class="s1">var singleline = delimiter.length == 1;</span><span class="s3">\n    </span><span class="s1">var OUTCLASS = </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">function tokenString(stream, state) {</span><span class="s3">\n      </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n        </span><span class="s1">stream.eatWhile(/[^'</span><span class="s3">\&quot;\\\\</span><span class="s1">]/);</span><span class="s3">\n        </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">stream.next();</span><span class="s3">\n          </span><span class="s1">if (singleline &amp;&amp; stream.eol())</span><span class="s3">\n            </span><span class="s1">return OUTCLASS;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match(delimiter)) {</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenOuter;</span><span class="s3">\n          </span><span class="s1">return OUTCLASS;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">stream.eat(/['</span><span class="s3">\&quot;</span><span class="s1">]/);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (singleline) {</span><span class="s3">\n        </span><span class="s1">if (parserConf.singleLineStringErrors)</span><span class="s3">\n          </span><span class="s1">return ERRORCLASS;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenOuter;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return OUTCLASS;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tokenString.isString = true;</span><span class="s3">\n    </span><span class="s1">return tokenString;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushPyScope(stream, state) {</span><span class="s3">\n    </span><span class="s1">while (top(state).type != </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot;</span><span class="s1">) state.scopes.pop()</span><span class="s3">\n    </span><span class="s1">state.scopes.push({offset: top(state).offset + stream.indentUnit,</span><span class="s3">\n                       </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                       </span><span class="s1">align: null})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushBracketScope(stream, state, type) {</span><span class="s3">\n    </span><span class="s1">var align = stream.match(/^[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">(]*(?:#|$)/, false) ? null : stream.column() + 1</span><span class="s3">\n    </span><span class="s1">state.scopes.push({offset: state.indent + (hangingIndent || stream.indentUnit),</span><span class="s3">\n                       </span><span class="s1">type: type,</span><span class="s3">\n                       </span><span class="s1">align: align})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function dedent(stream, state) {</span><span class="s3">\n    </span><span class="s1">var indented = stream.indentation();</span><span class="s3">\n    </span><span class="s1">while (state.scopes.length &gt; 1 &amp;&amp; top(state).offset &gt; indented) {</span><span class="s3">\n      </span><span class="s1">if (top(state).type != </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n      </span><span class="s1">state.scopes.pop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return top(state).offset != indented;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenLexer(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (stream.sol()) {</span><span class="s3">\n      </span><span class="s1">state.beginningOfLine = true;</span><span class="s3">\n      </span><span class="s1">state.dedent = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var style = state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">var current = stream.current();</span><span class="s3">\n\n    </span><span class="s1">// Handle decorators</span><span class="s3">\n    </span><span class="s1">if (state.beginningOfLine &amp;&amp; current == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return stream.match(identifiers, false) ? </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot; </span><span class="s1">: py3 ? </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">: ERRORCLASS;</span><span class="s3">\n\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">S/.test(current)) state.beginningOfLine = false;</span><span class="s3">\n\n    </span><span class="s1">if ((style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">builtin</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">&amp;&amp; state.lastToken == </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// Handle scope changes.</span><span class="s3">\n    </span><span class="s1">if (current == </span><span class="s3">\&quot;</span><span class="s1">pass</span><span class="s3">\&quot; </span><span class="s1">|| current == </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">state.dedent = true;</span><span class="s3">\n\n    </span><span class="s1">if (current == </span><span class="s3">\&quot;</span><span class="s1">lambda</span><span class="s3">\&quot;</span><span class="s1">) state.lambda = true;</span><span class="s3">\n    </span><span class="s1">if (current == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !state.lambda &amp;&amp; top(state).type == </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^</span><span class="s3">\\</span><span class="s1">s*(?:#|$)/, false))</span><span class="s3">\n      </span><span class="s1">pushPyScope(stream, state);</span><span class="s3">\n\n    </span><span class="s1">if (current.length == 1 &amp;&amp; !/string|comment/.test(style)) {</span><span class="s3">\n      </span><span class="s1">var delimiter_index = </span><span class="s3">\&quot;</span><span class="s1">[({</span><span class="s3">\&quot;</span><span class="s1">.indexOf(current);</span><span class="s3">\n      </span><span class="s1">if (delimiter_index != -1)</span><span class="s3">\n        </span><span class="s1">pushBracketScope(stream, state, </span><span class="s3">\&quot;</span><span class="s1">])}</span><span class="s3">\&quot;</span><span class="s1">.slice(delimiter_index, delimiter_index+1));</span><span class="s3">\n\n      </span><span class="s1">delimiter_index = </span><span class="s3">\&quot;</span><span class="s1">])}</span><span class="s3">\&quot;</span><span class="s1">.indexOf(current);</span><span class="s3">\n      </span><span class="s1">if (delimiter_index != -1) {</span><span class="s3">\n        </span><span class="s1">if (top(state).type == current) state.indent = state.scopes.pop().offset - (hangingIndent || stream.indentUnit)</span><span class="s3">\n        </span><span class="s1">else return ERRORCLASS;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (state.dedent &amp;&amp; stream.eol() &amp;&amp; top(state).type == </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; state.scopes.length &gt; 1)</span><span class="s3">\n      </span><span class="s1">state.scopes.pop();</span><span class="s3">\n\n    </span><span class="s1">return style;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">python</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n    </span><span class="s1">startState: function() {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">tokenize: tokenBase,</span><span class="s3">\n        </span><span class="s1">scopes: [{offset: 0, type: </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot;</span><span class="s1">, align: null}],</span><span class="s3">\n        </span><span class="s1">indent: 0,</span><span class="s3">\n        </span><span class="s1">lastToken: null,</span><span class="s3">\n        </span><span class="s1">lambda: false,</span><span class="s3">\n        </span><span class="s1">dedent: 0</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var addErr = state.errorToken;</span><span class="s3">\n      </span><span class="s1">if (addErr) state.errorToken = false;</span><span class="s3">\n      </span><span class="s1">var style = tokenLexer(stream, state);</span><span class="s3">\n\n      </span><span class="s1">if (style &amp;&amp; style != </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">state.lastToken = (style == </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">) ? stream.current() : style;</span><span class="s3">\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">) style = null;</span><span class="s3">\n\n      </span><span class="s1">if (stream.eol() &amp;&amp; state.lambda)</span><span class="s3">\n        </span><span class="s1">state.lambda = false;</span><span class="s3">\n      </span><span class="s1">return addErr ? ERRORCLASS : style;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">indent: function(state, textAfter, cx) {</span><span class="s3">\n      </span><span class="s1">if (state.tokenize != tokenBase)</span><span class="s3">\n        </span><span class="s1">return state.tokenize.isString ? null : 0;</span><span class="s3">\n\n      </span><span class="s1">var scope = top(state)</span><span class="s3">\n      </span><span class="s1">var closing = scope.type == textAfter.charAt(0) ||</span><span class="s3">\n          </span><span class="s1">scope.type == </span><span class="s3">\&quot;</span><span class="s1">py</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !state.dedent &amp;&amp; /^(else:|elif |except |finally:)/.test(textAfter)</span><span class="s3">\n      </span><span class="s1">if (scope.align != null)</span><span class="s3">\n        </span><span class="s1">return scope.align - (closing ? 1 : 0)</span><span class="s3">\n      </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return scope.offset - (closing ? hangingIndent || cx.unit : 0)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">languageData: {</span><span class="s3">\n      </span><span class="s1">autocomplete: commonKeywords.concat(commonBuiltins).concat([</span><span class="s3">\&quot;</span><span class="s1">exec</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">print</span><span class="s3">\&quot;</span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">indentOnInput: /^</span><span class="s3">\\</span><span class="s1">s*([</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">)]|else:|elif |except |finally:)$/,</span><span class="s3">\n      </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">closeBrackets: {brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">', </span><span class="s3">\&quot;</span><span class="s1">'''</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">']}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var words = function(str) { return str.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">); };</span><span class="s3">\n\n</span><span class="s1">export const python = mkPython({})</span><span class="s3">\n\n</span><span class="s1">export const cython = mkPython({</span><span class="s3">\n  </span><span class="s1">extra_keywords: words(</span><span class="s3">\&quot;</span><span class="s1">by cdef cimport cpdef ctypedef enum except </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\n                        \&quot;</span><span class="s1">extern gil include nogil property public </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\n                        \&quot;</span><span class="s1">readonly struct union DEF IF ELIF ELSE</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>