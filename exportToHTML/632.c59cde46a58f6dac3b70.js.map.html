<html>
<head>
<title>632.c59cde46a58f6dac3b70.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
632.c59cde46a58f6dac3b70.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;632.c59cde46a58f6dac3b70.js?v=c59cde46a58f6dac3b70&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/oz.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function wordRegexp(words) {</span><span class="s3">\n  </span><span class="s1">return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^((</span><span class="s3">\&quot; </span><span class="s1">+ words.join(</span><span class="s3">\&quot;</span><span class="s1">)|(</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\\\\</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var singleOperators = /[</span><span class="s3">\\</span><span class="s1">^@!</span><span class="s3">\\</span><span class="s1">|&lt;&gt;#~</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">/,=]/;</span><span class="s3">\n</span><span class="s1">var doubleOperators = /(&lt;-)|(:=)|(=&lt;)|(&gt;=)|(&lt;=)|(&lt;:)|(&gt;:)|(=:)|(</span><span class="s3">\\\\</span><span class="s1">=)|(</span><span class="s3">\\\\</span><span class="s1">=:)|(!!)|(==)|(::)/;</span><span class="s3">\n</span><span class="s1">var tripleOperators = /(:::)|(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.)|(=&lt;:)|(&gt;=:)/;</span><span class="s3">\n\n</span><span class="s1">var middle = [</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">of</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">elseof</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">elsecase</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">elseif</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              \&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">require</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">prepare</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">define</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">var end = [</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">var atoms = wordRegexp([</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">nil</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">unit</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">var commonKeywords = wordRegexp([</span><span class="s3">\&quot;</span><span class="s1">andthen</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">attr</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">declare</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">feat</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lex</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                 \&quot;</span><span class="s1">mod</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">mode</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">orelse</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">parser</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">prod</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">scanner</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">self</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">syn</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">token</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">var openingKeywords = wordRegexp([</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">proc</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">fun</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cond</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                  \&quot;</span><span class="s1">choice</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">not</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">thread</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">raise</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lock</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">suchthat</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">meth</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">functor</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">var middleKeywords = wordRegexp(middle);</span><span class="s3">\n</span><span class="s1">var endKeywords = wordRegexp(end);</span><span class="s3">\n\n</span><span class="s1">// Tokenizers</span><span class="s3">\n</span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n  </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Brackets</span><span class="s3">\n  </span><span class="s1">if(stream.match(/[{}]/)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bracket</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Special [] keyword</span><span class="s3">\n  </span><span class="s1">if (stream.match('[]')) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Operators</span><span class="s3">\n  </span><span class="s1">if (stream.match(tripleOperators) || stream.match(doubleOperators)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Atoms</span><span class="s3">\n  </span><span class="s1">if(stream.match(atoms)) {</span><span class="s3">\n    </span><span class="s1">return 'atom';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Opening keywords</span><span class="s3">\n  </span><span class="s1">var matched = stream.match(openingKeywords);</span><span class="s3">\n  </span><span class="s1">if (matched) {</span><span class="s3">\n    </span><span class="s1">if (!state.doInCurrentLine)</span><span class="s3">\n      </span><span class="s1">state.currentIndent++;</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n      </span><span class="s1">state.doInCurrentLine = false;</span><span class="s3">\n\n    </span><span class="s1">// Special matching for signatures</span><span class="s3">\n    </span><span class="s1">if(matched[0] == </span><span class="s3">\&quot;</span><span class="s1">proc</span><span class="s3">\&quot; </span><span class="s1">|| matched[0] == </span><span class="s3">\&quot;</span><span class="s1">fun</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenFunProc;</span><span class="s3">\n    </span><span class="s1">else if(matched[0] == </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenClass;</span><span class="s3">\n    </span><span class="s1">else if(matched[0] == </span><span class="s3">\&quot;</span><span class="s1">meth</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenMeth;</span><span class="s3">\n\n    </span><span class="s1">return 'keyword';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Middle and other keywords</span><span class="s3">\n  </span><span class="s1">if (stream.match(middleKeywords) || stream.match(commonKeywords)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// End keywords</span><span class="s3">\n  </span><span class="s1">if (stream.match(endKeywords)) {</span><span class="s3">\n    </span><span class="s1">state.currentIndent--;</span><span class="s3">\n    </span><span class="s1">return 'keyword';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Eat the next char for next comparisons</span><span class="s3">\n  </span><span class="s1">var ch = stream.next();</span><span class="s3">\n\n  </span><span class="s1">// Strings</span><span class="s3">\n  </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">' || ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenString(ch);</span><span class="s3">\n    </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Numbers</span><span class="s3">\n  </span><span class="s1">if (/[~</span><span class="s3">\\</span><span class="s1">d]/.test(ch)) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if(! /^[0-9]/.test(stream.peek()))</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">else if (( stream.next() == </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(</span><span class="s3">\\</span><span class="s1">.[0-9]+)?([eE][~+]?[0-9]+)?/))</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if ((ch == </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(</span><span class="s3">\\</span><span class="s1">.[0-9]+)?([eE][~+]?[0-9]+)?/))</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Comments</span><span class="s3">\n  </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n    </span><span class="s1">return 'comment';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenComment;</span><span class="s3">\n      </span><span class="s1">return tokenComment(stream, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Single operators</span><span class="s3">\n  </span><span class="s1">if(singleOperators.test(ch)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If nothing match, we skip the entire alphanumerical block</span><span class="s3">\n  </span><span class="s1">stream.eatWhile(/</span><span class="s3">\\</span><span class="s1">w/);</span><span class="s3">\n\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenClass(stream, state) {</span><span class="s3">\n  </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);</span><span class="s3">\n  </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenMeth(stream, state) {</span><span class="s3">\n  </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);</span><span class="s3">\n  </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenFunProc(stream, state) {</span><span class="s3">\n  </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if(!state.hasPassedFirstStage &amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">state.hasPassedFirstStage = true;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bracket</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if(state.hasPassedFirstStage) {</span><span class="s3">\n    </span><span class="s1">stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|</span><span class="s3">\\</span><span class="s1">$/);</span><span class="s3">\n    </span><span class="s1">state.hasPassedFirstStage = false;</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">var maybeEnd = false, ch;</span><span class="s3">\n  </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenString(quote) {</span><span class="s3">\n  </span><span class="s1">return function (stream, state) {</span><span class="s3">\n    </span><span class="s1">var escaped = false, next, end = false;</span><span class="s3">\n    </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (next == quote &amp;&amp; !escaped) {</span><span class="s3">\n        </span><span class="s1">end = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end || !escaped)</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildElectricInputRegEx() {</span><span class="s3">\n  </span><span class="s1">// Reindentation should occur on [] or on a match of any of</span><span class="s3">\n  </span><span class="s1">// the block closing keywords, at the end of a line.</span><span class="s3">\n  </span><span class="s1">var allClosings = middle.concat(end);</span><span class="s3">\n  </span><span class="s1">return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]]|(</span><span class="s3">\&quot; </span><span class="s1">+ allClosings.join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const oz = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">oz</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n  </span><span class="s1">startState: function () {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">tokenize: tokenBase,</span><span class="s3">\n      </span><span class="s1">currentIndent: 0,</span><span class="s3">\n      </span><span class="s1">doInCurrentLine: false,</span><span class="s3">\n      </span><span class="s1">hasPassedFirstStage: false</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">token: function (stream, state) {</span><span class="s3">\n    </span><span class="s1">if (stream.sol())</span><span class="s3">\n      </span><span class="s1">state.doInCurrentLine = 0;</span><span class="s3">\n\n    </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">indent: function (state, textAfter, cx) {</span><span class="s3">\n    </span><span class="s1">var trueText = textAfter.replace(/^</span><span class="s3">\\</span><span class="s1">s+|</span><span class="s3">\\</span><span class="s1">s+$/g, '');</span><span class="s3">\n\n    </span><span class="s1">if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(</span><span class="s3">\\</span><span class="s1">[])/))</span><span class="s3">\n      </span><span class="s1">return cx.unit * (state.currentIndent - 1);</span><span class="s3">\n\n    </span><span class="s1">if (state.currentIndent &lt; 0)</span><span class="s3">\n      </span><span class="s1">return 0;</span><span class="s3">\n\n    </span><span class="s1">return state.currentIndent * cx.unit</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">indentOnInut: buildElectricInputRegEx(),</span><span class="s3">\n    </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">, block: {open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot;</span><span class="s1">}}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>