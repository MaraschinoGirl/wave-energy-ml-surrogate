<html>
<head>
<title>131.729c28b8323daf822cbe.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
131.729c28b8323daf822cbe.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;131.729c28b8323daf822cbe.js?v=729c28b8323daf822cbe&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAsB;AACe;AACE;AACgD;AAChF;AACP;AACA;AACA;AACA;AACA;AACO,6CAA6C,EAAE,EAAE,IAAI;AACrD,6DAA6D,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6FAA6F;AAC7F;AACA;AACe,yFAAyF,+BAA+B,eAAG;AAC1I,+BAA+B,uCAAuC;AACtE;AACA,QAAQ,cAAU;AAClB;AACA;AACA,QAAQ,cAAU;AAClB;AACA;AACA;AACA;AACA;AACA,mBAAmB,kCAAwB;AAC3C,mBAAmB,wCAA8B;AACjD;AACA;AACA;AACA;AACA;AACA,QAAQ,kBAAQ;AAChB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;ACrD6B;AACgI;AAC7J;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,mEAAmE;AACnF,cAAc,eAAe;AAC7B;AACA,uBAAuB,UAAU,EAAE,QAAQ;AAC3C;AACA,qCAAqC,SAAS,GAAG,uBAAuB;AACxE;AACA,kCAAkC,0BAAY,CAAC,aAAG,cAAc,4BAA4B;AAC5F;AACA;AACA;AACA;AACA,0CAA0C,aAAG,gBAAgB,wBAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0BAAY,CAAC,aAAG,cAAc,4BAA4B;AAC5F;AACA,4BAA4B,cAAc,IAAI,QAAQ;AACtD;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,sCAAsC;AAClD;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA,sBAAsB,2BAAa;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,iCAAmB;AAC3C,qDAAqD,gCAAkB;AACvE,4BAA4B,gCAAkB;AAC9C,WAAW,iCAAmB,GAAG,qBAAqB;AACtD;AACA;;AC5FuG;AACnD;AACkB;AACtE;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wFAAwF;AACxG,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAM;AACzB,0DAA0D,gBAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAM,oCAAoC,4BAAkB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAAe;AACzD,yDAAyD,gBAAM,oCAAoC,2BAAa;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HwC;AACxC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACe,wCAAwC;AACvD,eAAe,aAAa;AAC5B;AACA;;;;;ACZ6B;AACQ;AAC6D;AAC5B;AACtE;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAG,SAAS,gBAAM,KAAK,2BAAa;AACxD;AACA;AACA,qGAAqG,IAAI;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAO;AACpB;AACA,uCAAuC,4BAAc;AACrD,iBAAiB,iBAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAG,SAAS,gBAAM,MAAM,wBAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;ACnH8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,eAAe,wBAAwB;AACvC;AACA;;ACfsD;AACgB;AACZ;AAClC;AACxB,0CAAe,kBAAkB,EAAE,EAAC;AACpC;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB;AAC/D;AACA,aAAa;AACb;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc,EAAE,+BAA+B,IAAI,GAAG,EAAE,eAAe,IAAI,GAAG,EAAE,aAAa,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,aAAa,IAAI,iBAAiB,IAAI,GAAG,IAAI,SAAS,IAAI,iBAAiB,IAAI,UAAU,IAAI,uCAAuC,EAAE,gDAAgD,IAAI,GAAG,IAAI,SAAS,IAAI,aAAa,IAAI,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,2CAA2C,8CAA8C,EAAE,0DAA0D,aAAa,EAAE,2CAA2C,eAAe,EAAE,oCAAoC,eAAe,EAAE,iCAAiC,eAAe,EAAE,iCAAiC,eAAe,EAAE,iCAAiC,eAAe,EAAE,qCAAqC,iBAAiB,EAAE,kCAAkC,iBAAiB,EAAE;AACtpC;AACA,iDAAiD,EAAE,YAAY,EAAE,IAAI,MAAM,gCAAgC,EAAE,iBAAiB,IAAI,gCAAgC,EAAE,iBAAiB,IAAI,SAAS;AAClM;AACA;AACA,wEAAwE,IAAI,EAAE,EAAE,iCAAiC,IAAI,EAAE,EAAE,sCAAsC,IAAI,EAAE,EAAE,gDAAgD,IAAI,oBAAoB,EAAE,0DAA0D,KAAK,IAAI,KAAK,eAAe,KAAK,IAAI,KAAK,qBAAqB,KAAK,IAAI,KAAK,eAAe,KAAK,IAAI,KAAK,mBAAmB,KAAK,IAAI,KAAK,EAAE,GAAG,UAAU,IAAI;AAC1c,mCAAmC,EAAE,+BAA+B,EAAE;AACtE,qBAAqB,MAAM,0BAA0B,KAAK,oCAAoC,KAAK;AACnG;AACA,kDAAkD,EAAE;AACpD,wBAAwB,IAAI,GAAG,EAAE,UAAU,IAAI,gBAAgB,IAAI,GAAG,EAAE,WAAW,IAAI,yEAAyE,EAAE,iBAAiB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,2EAA2E,EAAE,iBAAiB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,2EAA2E,EAAE,kBAAkB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,kBAAkB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,kBAAkB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,sBAAsB,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE;AACl/B;AACA;AACA,mCAAmC,EAAE,aAAa,EAAE,GAAG,EAAE,SAAS,GAAG;AACrE;AACA;AACA;AACA,iEAAiE,eAAe,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA,aAAa,yCAAyC;AACtD;AACA,aAAa,0CAA0C;AACvD;AACA,cAAc,0CAA0C;AACxD;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,0BAA0B,KAAK,oCAAoC,KAAK;AAC9G;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc,EAAE,+BAA+B,IAAI,GAAG,EAAE,eAAe,IAAI,GAAG,EAAE,aAAa,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,aAAa,IAAI,iBAAiB,IAAI,GAAG,IAAI,SAAS,IAAI,iBAAiB,IAAI,UAAU,IAAI,uCAAuC,EAAE,gDAAgD,IAAI,GAAG,IAAI,SAAS,IAAI,aAAa,IAAI,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,2CAA2C,8CAA8C,EAAE,yDAAyD,aAAa,EAAE,0CAA0C,eAAe,EAAE,mCAAmC,eAAe,EAAE,gCAAgC,eAAe,EAAE,gCAAgC,eAAe,EAAE,gCAAgC,eAAe,EAAE,mCAAmC,iBAAiB,EAAE,iCAAiC,iBAAiB,EAAE;AACnoC;AACA;AACA;AACA;AACA,gCAAgC,EAAE,mBAAmB,EAAE,iBAAiB,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5Ka;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAW;AACrC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,kBAAkB,mBAAO,CAAC,KAA0B;AACpD;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA,0IAA0I,WAAW;AACrJ;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe;AACf;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,cAAc,mBAAO,CAAC,KAAK;AAC3B,kBAAkB,mBAAO,CAAC,KAA0B;AACpD;AACA;AACA,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D,8BAA8B,uCAAuC;AACrE,8BAA8B,uCAAuC;AACrE;AACA;AACA,gBAAgB,qBAAqB,gCAAgC,qBAAqB,EAAE,WAAW;AACvG,eAAe,qBAAqB,mBAAmB,cAAc,oBAAoB,WAAW,YAAY;AAChH;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wDAAwD,KAAK,GAAG,gBAAgB;AAChF,6DAA6D,KAAK,6BAA6B,KAAK,0CAA0C,IAAI;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ,aAAa,OAAO;AAChE;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB,EAAE,8BAA8B;AAC3G,aAAa;AACb;AACA;AACA;AACA,kCAAkC,IAAI,WAAW,KAAK,IAAI,WAAW,IAAI,oBAAoB;AAC7F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;ACpEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,uBAAuB,GAAG,eAAe,GAAG,YAAY,GAAG,WAAW,GAAG,iBAAiB,GAAG,WAAW,GAAG,SAAS,GAAG,kBAAkB,GAAG,WAAW;AACjL,eAAe,mBAAO,CAAC,KAAQ;AAC/B,iBAAiB,mBAAO,CAAC,KAAuB;AAChD,wBAAwB,mBAAO,CAAC,KAA8B;AAC9D,yBAAyB,mBAAO,CAAC,KAAkC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,kBAAkB;AAClB,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe;AACf,iBAAiB,mBAAO,CAAC,KAAoB;AAC7C,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,gBAAgB,mBAAO,CAAC,KAAmB;AAC3C,qCAAoC,EAAE,qCAAqC,uBAAuB,EAAC;AACnG,uCAAsC,EAAE,qCAAqC,yBAAyB,EAAC;AACvG,6CAA4C,EAAE,qCAAqC,+BAA+B,EAAC;AACnH,uCAAsC,EAAE,qCAAqC,yBAAyB,EAAC;AACvG,wCAAuC,EAAE,qCAAqC,0BAA0B,EAAC;AACzG,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G,yBAAyB,mBAAO,CAAC,KAA4B;AAC7D,mDAAkD,EAAE,qCAAqC,sCAAsC,EAAC;AAChI,kBAAkB,mBAAO,CAAC,KAAqB;AAC/C,mDAAkD,EAAE,qCAAqC,+BAA+B,EAAC;AACzH;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,WAAW,GAAG,SAAS,GAAG,WAAW,GAAG,aAAa,GAAG,YAAY,GAAG,kBAAkB,GAAG,mBAAmB;AAC1Q;AACA;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,EAAE,EAAE,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe,EAAE,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE,EAAE,WAAW;AAClC;AACA;AACA;AACA,4DAA4D,GAAG,EAAE,GAAG;AACpE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kFAAkF,IAAI,WAAW,IAAI;AACrG;AACA,mBAAmB;AACnB;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA,qDAAqD,IAAI;AACzD;AACA,wBAAwB;AACxB;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;AC3Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU,GAAG,WAAW,GAAG,WAAW,GAAG,eAAe,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,aAAa,GAAG,YAAY,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,WAAW,GAAG,iBAAiB,GAAG,WAAW,GAAG,SAAS;AACvS,eAAe,mBAAO,CAAC,KAAQ;AAC/B,gBAAgB,mBAAO,CAAC,KAAS;AACjC,aAAa,mBAAO,CAAC,KAAQ;AAC7B,qCAAoC,EAAE,qCAAqC,oBAAoB,EAAC;AAChG,uCAAsC,EAAE,qCAAqC,sBAAsB,EAAC;AACpG,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH,uCAAsC,EAAE,qCAAqC,sBAAsB,EAAC;AACpG,+CAA8C,EAAE,qCAAqC,8BAA8B,EAAC;AACpH,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH,8CAA6C,EAAE,qCAAqC,6BAA6B,EAAC;AAClH,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,cAAc,mBAAO,CAAC,KAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,8CAA6C,EAAE,qCAAqC,8BAA8B,EAAC;AACnH,kDAAiD,EAAE,qCAAqC,kCAAkC,EAAC;AAC3H,4CAA2C,EAAE,qCAAqC,4BAA4B,EAAC;AAC/G,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,wDAAwD,SAAS;AACjE,kBAAkB,SAAS,EAAE,UAAU,EAAE,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,UAAU,IAAI,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,UAAU,EAAE,QAAQ,IAAI,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,uCAAuC,WAAW;AAClD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,WAAW;AAC7B;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,sBAAsB,SAAS,EAAE,KAAK,GAAG,OAAO,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,WAAW,UAAU,GAAG,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,sBAAsB;AACtB;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D,gDAAgD,IAAI,GAAG,EAAE;AACzD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS,KAAK,WAAW;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,QAAQ,GAAG,QAAQ,YAAY;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,OAAO;AACvG;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,qFAAqF,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC5G;AACA;AACA,4DAA4D,EAAE;AAC9D;AACA;;;;;;;;ACxrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,sBAAsB,GAAG,aAAa,GAAG,gBAAgB,GAAG,sBAAsB;AACvG,eAAe,mBAAO,CAAC,KAAQ;AAC/B;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qBAAqB,sBAAsB,sBAAsB;AAClE,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,EAAE,WAAW;AACtC;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,2CAA2C,0BAA0B,GAAG,UAAU;AAClF;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD,oCAAoC,UAAU,EAAE,eAAe;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA,SAAS;AACT;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK,EAAE,KAAK,EAAE,MAAM,IAAI,GAAG,EAAE,aAAa;AACtF;AACA;AACA,4CAA4C,KAAK,EAAE,EAAE,EAAE,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;AC9Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,oBAAoB;AACnJ,kBAAkB,mBAAO,CAAC,KAAW;AACrC,eAAe,mBAAO,CAAC,KAAQ;AAC/B,gBAAgB,mBAAO,CAAC,IAAS;AACjC,oBAAoB;AACpB,gBAAgB,SAAS,sCAAsC,QAAQ;AACvE;AACA,yBAAyB;AACzB,gBAAgB,qBAAqB;AACrC,iCAAiC,QAAQ,oBAAoB,YAAY;AACzE,iCAAiC,QAAQ;AACzC;AACA;AACA,YAAY,KAAK;AACjB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,mBAAmB;AACnB;AACA,YAAY,KAAK;AACjB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,+BAA+B,yBAAyB,wEAAwE,wBAAwB;AACxJ;AACA,wBAAwB;AACxB,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB,GAAG,EAAE;AACxE,mCAAmC,IAAI,mEAAmE,IAAI;AAC9G,uCAAuC,IAAI,oCAAoC,iBAAiB,GAAG,QAAQ;AAC3G;AACA,2CAA2C,IAAI;AAC/C,2CAA2C,IAAI;AAC/C;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA,+BAA+B,yBAAyB,0EAA0E,IAAI,yBAAyB,wBAAwB,QAAQ,IAAI;AACnM,iCAAiC,uBAAuB;AACxD;AACA;AACA,YAAY,+BAA+B;AAC3C;AACA,0CAA0C,mBAAmB,GAAG,KAAK;AACrE;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA,mCAAmC;AACnC;AACA;AACA,gDAAgD;AAChD,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,IAAI,cAAc;AAC1D;AACA,gCAAgC,UAAU,EAAE,wDAAwD;AACpG;AACA;AACA;AACA,2BAA2B,eAAe,iBAAiB,IAAI,0BAA0B;AACzF,uEAAuE,cAAc,GAAG,QAAQ;AAChG;AACA,wCAAwC,QAAQ,EAAE,sDAAsD;AACxG;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,YAAY,iCAAiC;AAC7C,YAAY,+CAA+C;AAC3D,8HAA8H;AAC9H;AACA;AACA;AACA;AACA,qFAAqF,aAAa,EAAE,WAAW;AAC/G;AACA;AACA;AACA;AACA;;;;;;;;AC1Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,0BAA0B,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,iBAAiB;AACnH,kBAAkB,mBAAO,CAAC,KAAW;AACrC,2BAA2B,mBAAO,CAAC,KAA6B;AAChE,gBAAgB,mBAAO,CAAC,IAAS;AACjC,kBAAkB,mBAAO,CAAC,KAAW;AACrC,eAAe,mBAAO,CAAC,KAAQ;AAC/B,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF,YAAY,aAAa;AACzB,YAAY,gBAAgB;AAC5B,oDAAoD,2BAA2B;AAC/E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC,SAAS,aAAa;AACnF;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB,MAAM,sBAAsB;AAC9F;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F,gBAAgB,WAAW;AAC3B;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;;;;;;;;ACjPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;AC3Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAW;AACrC;AACA;AACA,gDAAgD,KAAK,UAAU,OAAO;AACtE;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,iBAAiB;AACjI,eAAe,mBAAO,CAAC,KAAQ;AAC/B,cAAc,mBAAO,CAAC,KAAiB;AACvC,iBAAiB,mBAAO,CAAC,KAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D,sCAAsC,OAAO;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA,qBAAqB;AACrB;;;;;;;;AC1Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB,2BAA2B;AAC7C,kBAAkB,2BAA2B;AAC7C,iBAAiB,0BAA0B;AAC3C,kBAAkB,2BAA2B;AAC7C;AACA;AACA,iBAAiB,qDAAqD;AACtE,kBAAkB,WAAW;AAC7B,gBAAgB,WAAW;AAC3B,eAAe;AACf,oBAAoB;AACpB;AACA;AACA,gBAAgB;AAChB;;;;;;;;ACzBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,oBAAoB,GAAG,YAAY,GAAG,eAAe,GAAG,oBAAoB,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,gBAAgB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,cAAc;AACzb,kBAAkB,mBAAO,CAAC,KAAW;AACrC,eAAe,mBAAO,CAAC,KAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA,+BAA+B,aAAa,EAAE,WAAW,EAAE,oCAAoC;AAC/F;AACA,sBAAsB;AACtB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB,IAAI;AACtB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,8BAA8B,qDAAqD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kEAAkE,IAAI,cAAc,MAAM;AAC1F,uCAAuC,MAAM,gFAAgF,IAAI,KAAK,0CAA0C,GAAG,IAAI,KAAK;AAC5L,SAAS;AACT,mEAAmE,IAAI;AACvE;AACA;AACA;AACA;AACA,mDAAmD,IAAI,KAAK;AAC5D;AACA;AACA,SAAS;AACT,6DAA6D,gBAAgB;AAC7E;AACA,KAAK;AACL;AACA,kEAAkE,IAAI,cAAc,MAAM,yDAAyD,MAAM,oBAAoB,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,KAAK;AAC5M,mEAAmE,IAAI,2EAA2E,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,KAAK;AACjL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,kEAAkE,MAAM,EAAE,8BAA8B;AACxG;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,CAAC,WAAW,YAAY,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD,6CAA6C,UAAU;AACvD;AACA,4CAA4C,SAAS;AACrD,4CAA4C,SAAS,6CAA6C;AAClG;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;ACjLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,sBAAsB,GAAG,6BAA6B;AAC9E,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;AClBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,4BAA4B;AACxD,iBAAiB,mBAAO,CAAC,KAAW;AACpC,kBAAkB,mBAAO,CAAC,KAAY;AACtC,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,cAAc;AAC1B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,yBAAyB;AACzB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,8BAA8B,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,gBAAgB;AAC5K,gBAAgB,mBAAO,CAAC,KAAU;AAClC,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,iBAAiB,mBAAO,CAAC,KAAW;AACpC,kBAAkB,mBAAO,CAAC,KAAY;AACtC,eAAe,mBAAO,CAAC,KAAS;AAChC;AACA;AACA;AACA;AACA,CAAC,eAAe,gBAAgB,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,oEAAoE,KAAK;AACzE;AACA;AACA,mCAAmC,UAAU,+BAA+B,KAAK,OAAO,KAAK;AAC7F,8CAA8C,KAAK;AACnD,yDAAyD,KAAK;AAC9D;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gDAAgD,UAAU,iBAAiB,UAAU;AACrF,8DAA8D,KAAK;AACnE,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA,gDAAgD,UAAU,kBAAkB,MAAM;AAClF,oBAAoB,UAAU,iBAAiB,MAAM,KAAK,MAAM,MAAM,KAAK;AAC3E,0DAA0D,KAAK;AAC/D;AACA;AACA;AACA,gDAAgD,UAAU,mBAAmB,MAAM;AACnF,oBAAoB,UAAU,kBAAkB,MAAM,KAAK,MAAM,MAAM,MAAM,OAAO,MAAM;AAC1F,0DAA0D,KAAK;AAC/D;AACA;AACA;AACA,gDAAgD,MAAM,iBAAiB,MAAM,WAAW,MAAM;AAC9F;AACA,gDAAgD,MAAM,gBAAgB,MAAM;AAC5E;AACA;AACA;AACA,+CAA+C,MAAM,YAAY,MAAM,WAAW,MAAM;AACxF;AACA;AACA;AACA;AACA,gDAAgD,UAAU,kBAAkB,UAAU;AACtF,mBAAmB,UAAU,mBAAmB,MAAM;AACtD,0DAA0D,KAAK;AAC/D;AACA;AACA;AACA,4BAA4B,qCAAqC;AACjE;AACA,+BAA+B,YAAY,qDAAqD,WAAW,GAAG,mBAAmB;AACjI;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM,EAAE,IAAI;AACnD;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA,uCAAuC,MAAM,YAAY,MAAM,gCAAgC,KAAK;AACpG;AACA;AACA,iDAAiD,MAAM,iBAAiB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,EAAE,IAAI,EAAE,SAAS;AACrE;AACA;AACA;AACA,6DAA6D,MAAM,+DAA+D,KAAK;AACvI;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD,0DAA0D,MAAM,KAAK,OAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,gBAAgB,QAAQ,gBAAgB,OAAO;AAC/C,eAAe,qBAAqB,oDAAoD,QAAQ,QAAQ,uBAAuB,QAAQ,aAAa;AACpJ;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;;;;;;;AC1Ma;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,kBAAkB,mBAAO,CAAC,KAAY;AACtC,eAAe,mBAAO,CAAC,KAAS;AAChC;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA,0CAA0C,KAAK,EAAE,iCAAiC;AAClF;AACA,mEAAmE,UAAU;AAC7E;AACA;AACA,wCAAwC,WAAW;AACnD;AACA,wCAAwC,WAAW,KAAK,WAAW,cAAc,WAAW;AAC5F;AACA,UAAU,WAAW;AACrB,8CAA8C,WAAW,cAAc,WAAW;AAClF,0CAA0C,WAAW,IAAI,uCAAuC;AAChG;AACA;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,kBAAkB,GAAG,4BAA4B;AACnE,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,mBAAmB,mBAAO,CAAC,KAAY;AACvC,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,mBAAmB,mBAAO,CAAC,KAAY;AACvC,mBAAmB,mBAAO,CAAC,IAAY;AACvC,kBAAkB,mBAAO,CAAC,KAAW;AACrC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,kBAAkB,mBAAO,CAAC,KAAY;AACtC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,kBAAkB,mBAAO,CAAC,KAAY;AACtC,eAAe,mBAAO,CAAC,KAAS;AAChC,iBAAiB,mBAAO,CAAC,KAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B,4CAA4C;AACxE;AACA,mDAAmD,qBAAqB,IAAI,uBAAuB;AACnG,qDAAqD,EAAE,4BAA4B;AACnF;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,qBAAqB,IAAI,wBAAwB;AACpG;AACA;AACA;AACA,8BAA8B,EAAE,6BAA6B,OAAO,2BAA2B,IAAI,mCAAmC,IAAI,yBAAyB,GAAG,qBAAqB,EAAE,wCAAwC,+BAA+B,GAAG,mBAAmB,GAAG;AAC7R;AACA;AACA;AACA,kEAAkE,uBAAuB,GAAG,6BAA6B;AACzH,gEAAgE,uBAAuB,GAAG,2BAA2B;AACrH,wEAAwE,uBAAuB,GAAG,mCAAmC;AACrI,8DAA8D,uBAAuB,GAAG,yBAAyB;AACjH;AACA,wEAAwE,uBAAuB,GAAG,+BAA+B;AACjI,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,KAAK;AACL;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,8DAA8D,aAAa;AAC3E,+BAA+B,aAAa,qDAAqD,aAAa;AAC9G,+BAA+B,aAAa,qDAAqD,aAAa;AAC9G;AACA;AACA;AACA,gGAAgG,OAAO;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW,MAAM,uBAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD;AACA,sEAAsE,cAAc;AACpF;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAA6C;AACvE;AACA;AACA,qCAAqC,qBAAqB,cAAc,IAAI;AAC5E;AACA;AACA,iDAAiD,cAAc;AAC/D,kDAAkD,qBAAqB;AACvE,qCAAqC,qBAAqB,iBAAiB,IAAI,IAAI,WAAW,IAAI,SAAS;AAC3G;AACA;AACA;AACA,YAAY,sDAAsD;AAClE;AACA;AACA,mCAAmC,wBAAwB,wFAAwF,gBAAgB,GAAG,wBAAwB;AAC9L;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA,uCAAuC,UAAU;AACjD;AACA,uCAAuC,UAAU;AACjD;AACA;AACA,YAAY,2CAA2C;AACvD,YAAY,QAAQ;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB,MAAM,eAAe;AACpF;AACA;AACA;AACA,YAAY,qBAAqB,aAAa,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,EAAE,4BAA4B,uBAAuB;AAC/F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,sDAAsD,eAAe,iBAAiB,QAAQ;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS,gBAAgB,+BAA+B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,sCAAsC,YAAY,oBAAoB,kDAAkD;AACxH;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iGAAiG;AAC5I;AACA;AACA;AACA;AACA;AACA,4EAA4E,yBAAyB,GAAG;AACxG,4CAA4C,kBAAkB,GAAG,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK,EAAE,qEAAqE;AACnH,uCAAuC,MAAM,KAAK,KAAK;AACvD;AACA;AACA;AACA;AACA,gCAAgC,aAAa,EAAE,IAAI,8BAA8B,UAAU;AAC3F;AACA;AACA,eAAe;AACf;;;;;;;;ACvgBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,wBAAwB;AAC3G,kBAAkB,mBAAO,CAAC,KAAY;AACtC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,eAAe,mBAAO,CAAC,KAAyB;AAChD,iBAAiB,mBAAO,CAAC,KAAW;AACpC;AACA,YAAY,yCAAyC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB,GAAG,QAAQ;AACtD;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,GAAG,aAAa,mBAAmB,kDAAkD,EAAE;AAC5M;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,EAAE,oEAAoE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY,gBAAgB;AAC5B,qEAAqE,cAAc,GAAG,sBAAsB;AAC5G;AACA;AACA,YAAY,MAAM;AAClB,6CAA6C,KAAK;AAClD;AACA,iEAAiE,yBAAyB,aAAa,MAAM,IAAI,wBAAwB,UAAU,KAAK;AACxJ,gEAAgE,wBAAwB;AACxF;AACA,KAAK;AACL;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C,qEAAqE,cAAc,IAAI,qDAAqD;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ,IAAI,eAAe;AAC9F;AACA;AACA;AACA;AACA,oCAAoC,QAAQ,8BAA8B,cAAc;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;;;;;;;AC3Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,2BAA2B,GAAG,oBAAoB;AAChF,kBAAkB,mBAAO,CAAC,KAAY;AACtC,eAAe,mBAAO,CAAC,KAAS;AAChC,4BAA4B,sEAAsE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc,EAAE,oCAAoC;AACpG,kCAAkC,iBAAiB,GAAG,QAAQ;AAC9D;AACA;AACA;AACA,gDAAgD,cAAc,EAAE,oCAAoC,EAAE,uCAAuC;AAC7I,kCAAkC,iBAAiB,GAAG,QAAQ,GAAG,uCAAuC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,8CAA8C,+DAA+D;AAC7G;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,gBAAgB,+BAA+B;AAC/C,6DAA6D,QAAQ,EAAE,qCAAqC;AAC5G;AACA,oDAAoD,UAAU,EAAE,kEAAkE;AAClI,2DAA2D,SAAS;AACpE;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,0CAA0C,uEAAuE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,yCAAyC;AACzC;AACA,2BAA2B;AAC3B;;;;;;;;AChFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,YAAY,GAAG,WAAW,GAAG,iBAAiB,GAAG,WAAW,GAAG,SAAS,GAAG,kBAAkB;AAC/G,iBAAiB,mBAAO,CAAC,KAAoB;AAC7C,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,gBAAgB,mBAAO,CAAC,KAAmB;AAC3C,qCAAoC,EAAE,qCAAqC,uBAAuB,EAAC;AACnG,uCAAsC,EAAE,qCAAqC,yBAAyB,EAAC;AACvG,6CAA4C,EAAE,qCAAqC,+BAA+B,EAAC;AACnH,uCAAsC,EAAE,qCAAqC,yBAAyB,EAAC;AACvG,wCAAuC,EAAE,qCAAqC,0BAA0B,EAAC;AACzG,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G,2BAA2B,mBAAO,CAAC,KAA4B;AAC/D,oBAAoB,mBAAO,CAAC,KAAqB;AACjD,gBAAgB,mBAAO,CAAC,KAAiB;AACzC,kBAAkB,mBAAO,CAAC,KAAW;AACrC,kBAAkB,mBAAO,CAAC,KAAmB;AAC7C,kBAAkB,mBAAO,CAAC,KAAmB;AAC7C,mBAAmB,mBAAO,CAAC,KAA6B;AACxD,eAAe,mBAAO,CAAC,KAAgB;AACvC,uBAAuB,mBAAO,CAAC,KAAkB;AACjD,cAAc,mBAAO,CAAC,KAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8BAA8B,IAAI,kBAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gBAAgB,aAAa;AAC7B,gDAAgD,SAAS,yCAAyC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,6CAA6C,KAAK,gBAAgB,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,mDAAmD,UAAU,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qCAAqC,KAAK;AAChD;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,EAAE,gBAAgB,EAAE,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA,gCAAgC,IAAI,WAAW,IAAI,IAAI,eAAe;AACtE;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,iBAAiB,SAAS,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA,uCAAuC,KAAK;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,4DAA4D,SAAS;AACrE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;;;;;;ACzmBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,cAAc,mBAAO,CAAC,KAAiB;AACvC;AACA,kBAAe;AACf;;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,mBAAO,CAAC,KAAU;AAC9B;AACA,kBAAe;AACf;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA,gBAAgB,UAAU,OAAO,mDAAmD,KAAK;AACzF,eAAe,UAAU,OAAO,wBAAwB,SAAS,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA,qDAAqD,KAAK;AAC1D;AACA,wBAAwB,mBAAmB;AAC3C,qCAAqC,KAAK,KAAK,aAAa;AAC5D;AACA;AACA,2DAA2D,KAAK,KAAK,aAAa,IAAI;AACtF;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B,kBAAe;AACf;;;;;;;;AChDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAS;AAChC,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,gBAAgB,mBAAO,CAAC,IAAqB;AAC7C,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA,eAAe,QAAQ,wBAAwB,sBAAsB,2BAA2B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,MAAM,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,KAAK,MAAM,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA,wGAAwG,+BAA+B,QAAQ,IAAI;AACnJ;AACA;AACA;AACA;AACA,gDAAgD,KAAK,GAAG,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACzGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAS;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA,kBAAe;AACf;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA,gBAAgB,UAAU,YAAY;AACtC,sDAAsD,KAAK;AAC3D,sDAAsD,KAAK,mBAAmB,KAAK;AACnF,eAAe,UAAU,YAAY,4CAA4C,eAAe,KAAK,uBAAuB,eAAe,IAAI,iBAAiB,KAAK;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK,KAAK,IAAI;AACzD;AACA,2CAA2C,MAAM,KAAK,KAAK,KAAK,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA,2CAA2C,OAAO,KAAK,IAAI;AAC3D;AACA;AACA,2CAA2C,OAAO,IAAI,IAAI;AAC1D;AACA;AACA;AACA,+CAA+C,OAAO,KAAK,IAAI;AAC/D;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,4BAA4B,GAAG,aAAa;AACzE,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,eAAe,mBAAO,CAAC,KAAS;AAChC,aAAa;AACb,gBAAgB,UAAU,6BAA6B;AACvD;AACA,+CAA+C,cAAc,EAAE,MAAM,gBAAgB,UAAU;AAC/F,KAAK;AACL,eAAe,UAAU,8CAA8C,wBAAwB,YAAY,SAAS;AACpH,uBAAuB,gBAAgB;AACvC,iBAAiB,UAAU;AAC3B,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uCAAuC,aAAa,MAAM,iDAAiD;AAC3G;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,kBAAe;AACf;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA,gBAAgB,QAAQ,uCAAuC,gBAAgB;AAC/E,eAAe,QAAQ,wBAAwB,kBAAkB,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,KAAmB;AACrD,sBAAsB,mBAAO,CAAC,KAAe;AAC7C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,mBAAmB,mBAAO,CAAC,KAAY;AACvC,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,4BAA4B,mBAAO,CAAC,KAAqB;AACzD,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,aAAa,mBAAO,CAAC,KAAM;AAC3B,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;AC3Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,eAAe,mBAAO,CAAC,KAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA,mCAAmC,KAAK,IAAI,EAAE;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA,4BAA4B,QAAQ,OAAO,EAAE,mCAAmC,YAAY,0CAA0C,cAAc;AACpJ;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAe;AACf;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,eAAe,mBAAO,CAAC,KAAS;AAChC,0BAA0B,mBAAO,CAAC,KAAmB;AACrD;AACA,gBAAgB,UAAU,OAAO,mDAAmD,KAAK;AACzF,eAAe,UAAU,OAAO,wBAAwB,SAAS,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC7Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,aAAa,8BAA8B;AAC3C;AACA,kBAAe;AACf;;;;;;;;ACzBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA,eAAe,QAAQ,wBAAwB,kBAAkB,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gDAAgD,UAAU,KAAK,MAAM;AACrE;AACA,8DAA8D,QAAQ,IAAI,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAS;AAChC,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,kBAAkB,KAAK;AAC7F;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC,QAAQ,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uDAAuD,MAAM,GAAG,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC1Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,KAAwB;AACnD,eAAe,mBAAO,CAAC,KAAS;AAChC,eAAe,mBAAO,CAAC,KAAoB;AAC3C,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA,eAAe,QAAQ,wBAAwB,gBAAgB,qBAAqB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,gDAAgD,QAAQ;AACxD,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACZa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,8BAA8B;AAChV,kBAAkB,mBAAO,CAAC,KAAoB;AAC9C,eAAe,mBAAO,CAAC,KAAiB;AACxC,gBAAgB,mBAAO,CAAC,IAAkB;AAC1C,eAAe,mBAAO,CAAC,KAAiB;AACxC;AACA,YAAY,gBAAgB;AAC5B;AACA,wBAAwB,qCAAqC,KAAK,GAAG;AACrE;AACA,KAAK;AACL;AACA,8BAA8B;AAC9B,4BAA4B,iBAAiB,QAAQ;AACrD,uJAAuJ,SAAS,IAAI,KAAK;AACzK;AACA,wBAAwB;AACxB;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB;AACnB;AACA,+BAA+B,iBAAiB,QAAQ,KAAK,IAAI,SAAS;AAC1E;AACA,qBAAqB;AACrB;AACA,qCAAqC,KAAK,EAAE,sCAAsC;AAClF,+CAA+C,MAAM,KAAK,mCAAmC;AAC7F;AACA,sBAAsB;AACtB;AACA,qCAAqC,KAAK,EAAE,sCAAsC;AAClF;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B,wBAAwB,0CAA0C,MAAM;AACpG,2DAA2D,WAAW,IAAI,KAAK,IAAI,aAAa,EAAE,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc,IAAI,sBAAsB;AAC7E,2DAA2D,KAAK,QAAQ,QAAQ,IAAI,KAAK,yBAAyB,KAAK,GAAG,KAAK;AAC/H;AACA,wBAAwB;AACxB;AACA,sBAAsB,WAAW,QAAQ;AACzC;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,kCAAkC,4EAA4E,GAAG,QAAQ,IAAI,EAAE;AAC/H,KAAK;AACL;AACA,kBAAkB;AAClB;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,OAAO,KAAK,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;;;;;;;;AClIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,KAAM;AAC3B,cAAc,mBAAO,CAAC,KAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM,qBAAqB;AAC3B;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,mBAAmB;AACrC,oBAAoB,mBAAO,CAAC,KAAyB;AACrD,eAAe,mBAAO,CAAC,KAAS;AAChC,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,gBAAgB,mBAAO,CAAC,IAAqB;AAC7C,kBAAkB,mBAAO,CAAC,KAAe;AACzC,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,mDAAmD;AACnE,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,gDAAgD,IAAI,UAAU;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,MAAM;AAClB;AACA,uCAAuC,mBAAmB;AAC1D,8BAA8B,4BAA4B,UAAU,EAAE;AACtE;AACA,mBAAmB;AACnB;AACA,YAAY,UAAU;AACtB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8CAA8C;AAC7F,iCAAiC;AACjC;AACA;AACA,SAAS;AACT,yCAAyC,GAAG,aAAa,mBAAmB;AAC5E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD,gEAAgE,yBAAyB,aAAa,MAAM,IAAI,wBAAwB,UAAU,KAAK,KAAK;AAC5J,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAe;AACf;;;;;;;;ACzHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,gBAAgB,mBAAO,CAAC,IAAwB;AAChD,kBAAkB,mBAAO,CAAC,KAAe;AACzC,oBAAoB,mBAAO,CAAC,KAAyB;AACrD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA,gBAAgB,UAAU,uBAAuB;AACjD,kBAAkB,QAAQ;AAC1B,2BAA2B,QAAQ;AACnC,eAAe,UAAU,4BAA4B,wBAAwB,SAAS,WAAW,SAAS,QAAQ,cAAc,KAAK;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK,EAAE,oCAAoC;AACpG,0CAA0C,KAAK,gEAAgE,kDAAkD;AACjK;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,MAAM,SAAS;AACnE;AACA;AACA;AACA,+BAA+B,sDAAsD;AACrF;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,QAAQ;AAC7H;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACvGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;AACtD;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAQ;AAC/B,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,iBAAiB,mBAAO,CAAC,IAAU;AACnC,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;AChBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD;AACA,gBAAgB,YAAY,8CAA8C,WAAW;AACrF,eAAe,YAAY,wBAAwB,UAAU,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+DAA+D,KAAK,GAAG,WAAW;AAClF;AACA;AACA;AACA,8CAA8C,MAAM,mBAAmB,MAAM,iEAAiE,KAAK,uDAAuD,KAAK;AAC/M;AACA;AACA;AACA;AACA,2CAA2C,YAAY,MAAM,OAAO;AACpE;AACA;AACA;AACA,2CAA2C,KAAK,iBAAiB,OAAO,GAAG,KAAK,MAAM,OAAO,GAAG,KAAK;AACrG,0CAA0C,OAAO,GAAG,KAAK;AACzD,8DAA8D,QAAQ,kBAAkB,YAAY,IAAI,OAAO,QAAQ,KAAK;AAC5H,2CAA2C,QAAQ,KAAK,QAAQ,cAAc,OAAO,MAAM,UAAU,MAAM,UAAU;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,+BAA+B,cAAc;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB,EAAE,mCAAmC;AACrG;AACA,wDAAwD,gCAAgC;AACxF;AACA,0FAA0F,IAAI;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO,GAAG,KAAK;AACpE;AACA,yEAAyE,OAAO,GAAG,KAAK,yBAAyB,OAAO,QAAQ,KAAK;AACrI;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC3Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,KAAU;AACnC;AACA,kBAAe;AACf;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,0BAA0B;AACtD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;;;;;;;ACjBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,gBAAgB,mBAAO,CAAC,KAAqB;AAC7C;AACA;AACA,eAAe,YAAY,wBAAwB,gBAAgB,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA,+CAA+C,0CAA0C,GAAG,KAAK,IAAI,WAAW;AAChH;AACA;AACA,yCAAyC,QAAQ,MAAM,KAAK;AAC5D;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACxBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,gBAAgB,mBAAO,CAAC,KAAqB;AAC7C;AACA;AACA,eAAe,YAAY,wBAAwB,iBAAiB,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS,GAAG,KAAK,IAAI,EAAE;AAChG;AACA;AACA;AACA;AACA,sCAAsC,SAAS,GAAG,KAAK,IAAI,QAAQ,GAAG,EAAE;AACxE,sCAAsC,MAAM,MAAM,IAAI;AACtD;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,KAAe;AAC7C,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,sBAAsB,mBAAO,CAAC,KAAe;AAC7C,kBAAkB,mBAAO,CAAC,KAAW;AACrC,0BAA0B,mBAAO,CAAC,KAAmB;AACrD,mBAAmB,mBAAO,CAAC,KAAY;AACvC,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,sBAAsB,mBAAO,CAAC,KAAe;AAC7C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,eAAe,mBAAO,CAAC,IAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAkD;AACxD,MAAM,4CAA4C;AAClD;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD;AACA,cAAc,qBAAqB;AACnC;AACA,mDAAmD,MAAM,OAAO,YAAY;AAC5E,KAAK;AACL,eAAe,YAAY,wBAAwB,SAAS,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,0CAA0C,KAAK,UAAU,IAAI,EAAE,WAAW;AAC1E,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,qBAAqB,mBAAO,CAAC,KAA0B;AACvD;AACA,cAAc,qBAAqB;AACnC;AACA,mDAAmD,MAAM,OAAO,YAAY;AAC5E,KAAK;AACL,eAAe,YAAY,wBAAwB,SAAS,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA,oEAAoE,KAAK,+BAA+B,mDAAmD,GAAG,KAAK;AACnK,0CAA0C,KAAK,EAAE,IAAI,EAAE,WAAW;AAClE,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD;AACA;AACA,eAAe,wCAAwC;AACvD,eAAe,wCAAwC;AACvD,wBAAwB,uCAAuC;AAC/D,wBAAwB,uCAAuC;AAC/D;AACA;AACA,gBAAgB,qBAAqB,mCAAmC,qBAAqB,EAAE,WAAW;AAC1G,eAAe,qBAAqB,wBAAwB,cAAc,oBAAoB,WAAW,YAAY;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,0CAA0C,MAAM,EAAE,oBAAoB,EAAE,YAAY,WAAW,KAAK;AACpG,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD;AACA,cAAc,qBAAqB;AACnC;AACA,mDAAmD,MAAM,OAAO,YAAY;AAC5E,KAAK;AACL,eAAe,YAAY,wBAAwB,SAAS,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,sDAAsD,KAAK,WAAW,IAAI,EAAE,WAAW;AACvF,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD;AACA,gBAAgB,YAAY,+CAA+C,WAAW;AACtF,eAAe,YAAY,wBAAwB,cAAc,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA,sDAAsD,IAAI,MAAM,IAAI,SAAS,KAAK;AAClF,kCAAkC,KAAK,eAAe,IAAI;AAC1D,2CAA2C,YAAY,YAAY,KAAK,IAAI,KAAK,GAAG,WAAW,IAAI,QAAQ;AAC3G,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACzBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAS;AAChC,kBAAkB,mBAAO,CAAC,KAAuB;AACjD;AACA,gBAAgB,YAAY,+CAA+C,WAAW;AACtF,eAAe,YAAY,wBAAwB,WAAW,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,+DAA+D,WAAW,IAAI,EAAE;AAChF,2CAA2C,OAAO,QAAQ,KAAK;AAC/D,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAS;AAChC,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C;AACA,gBAAgB,UAAU,mBAAmB,wDAAwD,gBAAgB;AACrH,eAAe,UAAU,mBAAmB,wBAAwB,mBAAmB,iBAAiB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,sDAAsD,YAAY,uBAAuB,WAAW;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,aAAa;AACb;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;AC9Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,KAAiC;AAC5D,kBAAkB,mBAAO,CAAC,KAAuB;AACjD,eAAe,mBAAO,CAAC,KAAoB;AAC3C,gBAAgB,mBAAO,CAAC,KAAqB;AAC7C;AACA,gBAAgB,UAAU,QAAQ,mEAAmE,GAAG,MAAM,GAAG;AACjH,eAAe,UAAU,QAAQ,wBAAwB,KAAK,EAAE,OAAO,GAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA,uEAAuE,YAAY;AACnF;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA,4BAA4B,MAAM;AAClC;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,uCAAuC,EAAE,EAAE,GAAG;AAC9C,kDAAkD,KAAK,GAAG,EAAE;AAC5D;AACA;AACA,sDAAsD,MAAM,kCAAkC,MAAM;AACpG;AACA,mDAAmD,QAAQ,GAAG,KAAK;AACnE,sDAAsD,QAAQ,GAAG,KAAK;AACtE;AACA;AACA,iBAAiB;AACjB,8CAA8C,QAAQ,GAAG,KAAK,MAAM,EAAE;AACtE,aAAa;AACb;AACA;AACA;AACA;AACA,oDAAoD,EAAE,EAAE,GAAG,qCAAqC,GAAG,IAAI,IAAI,EAAE,EAAE,GAAG,oCAAoC,IAAI,GAAG,KAAK,GAAG,EAAE,KAAK,KAAK,GAAG,EAAE;AACtL;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;AC/DA,eAAe,mBAAO,CAAC,KAAa;AACpC,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA,sBAAsB,mBAAO,CAAC,KAAoB;AAClD,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,YAAY,mBAAO,CAAC,KAAU;AAC9B,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,iBAAiB,mBAAO,CAAC,GAAe;AACxC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,aAAa,mBAAO,CAAC,IAAW;AAChC,cAAc,mBAAO,CAAC,KAAW;AACjC,eAAe,mBAAO,CAAC,KAAY;AACnC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClFA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACZA,eAAe,mBAAO,CAAC,KAAa;AACpC,gBAAgB,mBAAO,CAAC,KAAc;AACtC,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnFA,aAAa,mBAAO,CAAC,KAAW;AAChC,iBAAiB,mBAAO,CAAC,KAAe;AACxC,SAAS,mBAAO,CAAC,KAAM;AACvB,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,iBAAiB,mBAAO,CAAC,KAAe;AACxC,iBAAiB,mBAAO,CAAC,KAAe;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/GA,iBAAiB,mBAAO,CAAC,KAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzFA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACjBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACjBA,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/createAjvInstance.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/processRawValidationErrors.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/validator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/customizeValidator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/precompiledValidator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/createPrecompiledValidator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv-formats/dist/formats.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv-formats/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv-formats/dist/limit.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/ajv.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/codegen/code.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/codegen/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/codegen/scope.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/errors.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/names.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/ref_error.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/resolve.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/rules.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/util.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/applicability.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/boolSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/dataType.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/defaults.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/keyword.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/compile/validate/subschema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/core.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/runtime/equal.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/runtime/ucs2length.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/runtime/uri.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/runtime/validation_error.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/allOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/anyOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/contains.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/dependencies.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/if.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/items.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/items2020.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/not.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/oneOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/properties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/applicator/thenElse.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/code.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/core/id.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/core/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/core/ref.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/discriminator/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/discriminator/types.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/draft7.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/format/format.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/format/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/metadata.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/const.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/enum.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/limitItems.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/limitLength.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/limitNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/limitProperties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/multipleOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/pattern.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/required.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/validator-ajv8/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_SetCache.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_arraySome.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIsEqual.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIsEqualDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_cacheHas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_equalArrays.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_equalByTag.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_equalObjects.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_mapToArray.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_setCacheAdd.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_setCacheHas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_setToArray.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isEqual.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import Ajv from 'ajv';</span><span class="s3">\n</span><span class="s1">import addFormats from 'ajv-formats';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">import { ADDITIONAL_PROPERTY_FLAG, RJSF_ADDITONAL_PROPERTIES_FLAG } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">export const AJV_CONFIG = {</span><span class="s3">\n    </span><span class="s1">allErrors: true,</span><span class="s3">\n    </span><span class="s1">multipleOfPrecision: 8,</span><span class="s3">\n    </span><span class="s1">strict: false,</span><span class="s3">\n    </span><span class="s1">verbose: true,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export const COLOR_FORMAT_REGEX = /^(#?([0-9A-Fa-f]{3}){1,2}</span><span class="s3">\\</span><span class="s1">b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</span><span class="s3">\\</span><span class="s1">b</span><span class="s3">\\</span><span class="s1">s*,</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</span><span class="s3">\\</span><span class="s1">b</span><span class="s3">\\</span><span class="s1">s*,</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])</span><span class="s3">\\</span><span class="s1">b</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">))|(rgb</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">s*(</span><span class="s3">\\</span><span class="s1">d?</span><span class="s3">\\</span><span class="s1">d%|100%)+</span><span class="s3">\\</span><span class="s1">s*,</span><span class="s3">\\</span><span class="s1">s*(</span><span class="s3">\\</span><span class="s1">d?</span><span class="s3">\\</span><span class="s1">d%|100%)+</span><span class="s3">\\</span><span class="s1">s*,</span><span class="s3">\\</span><span class="s1">s*(</span><span class="s3">\\</span><span class="s1">d?</span><span class="s3">\\</span><span class="s1">d%|100%)+</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">)))$/;</span><span class="s3">\n</span><span class="s1">export const DATA_URL_FORMAT_REGEX = /^data:([a-z]+</span><span class="s3">\\</span><span class="s1">/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;</span><span class="s3">\n</span><span class="s1">/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.</span><span class="s3">\n </span><span class="s1">* If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the</span><span class="s3">\n </span><span class="s1">* list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If</span><span class="s3">\n </span><span class="s1">* `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing</span><span class="s3">\n </span><span class="s1">* the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By</span><span class="s3">\n </span><span class="s1">* default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`</span><span class="s3">\n </span><span class="s1">* parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of</span><span class="s3">\n </span><span class="s1">* [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access</span><span class="s3">\n </span><span class="s1">* @param [customFormats] - The set of additional custom formats that the validator will support</span><span class="s3">\n </span><span class="s1">* @param [ajvOptionsOverrides={}] - The set of validator config override options</span><span class="s3">\n </span><span class="s1">* @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it</span><span class="s3">\n </span><span class="s1">* @param [AjvClass] - The `Ajv` class to use when creating the validator instance</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides = {}, ajvFormatOptions, AjvClass = Ajv) {</span><span class="s3">\n    </span><span class="s1">const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });</span><span class="s3">\n    </span><span class="s1">if (ajvFormatOptions) {</span><span class="s3">\n        </span><span class="s1">addFormats(ajv, ajvFormatOptions);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ajvFormatOptions !== false) {</span><span class="s3">\n        </span><span class="s1">addFormats(ajv);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// add custom formats</span><span class="s3">\n    </span><span class="s1">ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);</span><span class="s3">\n    </span><span class="s1">ajv.addFormat('color', COLOR_FORMAT_REGEX);</span><span class="s3">\n    </span><span class="s1">// Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.</span><span class="s3">\n    </span><span class="s1">ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);</span><span class="s3">\n    </span><span class="s1">ajv.addKeyword(RJSF_ADDITONAL_PROPERTIES_FLAG);</span><span class="s3">\n    </span><span class="s1">// add more schemas to validate against</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(additionalMetaSchemas)) {</span><span class="s3">\n        </span><span class="s1">ajv.addMetaSchema(additionalMetaSchemas);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// add more custom formats to validate against</span><span class="s3">\n    </span><span class="s1">if (isObject(customFormats)) {</span><span class="s3">\n        </span><span class="s1">Object.keys(customFormats).forEach((formatName) =&gt; {</span><span class="s3">\n            </span><span class="s1">ajv.addFormat(formatName, customFormats[formatName]);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ajv;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=createAjvInstance.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import { createErrorHandler, getDefaultFormState, getUiOptions, PROPERTIES_KEY, toErrorSchema, unwrapErrorHandler, validationDataMerge, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">/** Transforming the error output from ajv to format used by @rjsf/utils.</span><span class="s3">\n </span><span class="s1">* At some point, components should be updated to support ajv.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param errors - The list of AJV errors to convert to `RJSFValidationErrors`</span><span class="s3">\n </span><span class="s1">* @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function transformRJSFValidationErrors(errors = [], uiSchema) {</span><span class="s3">\n    </span><span class="s1">return errors.map((e) =&gt; {</span><span class="s3">\n        </span><span class="s1">const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;</span><span class="s3">\n        </span><span class="s1">let { message = '' } = rest;</span><span class="s3">\n        </span><span class="s1">let property = instancePath.replace(/</span><span class="s3">\\</span><span class="s1">//g, '.');</span><span class="s3">\n        </span><span class="s1">let stack = `${property} ${message}`.trim();</span><span class="s3">\n        </span><span class="s1">if ('missingProperty' in params) {</span><span class="s3">\n            </span><span class="s1">property = property ? `${property}.${params.missingProperty}` : params.missingProperty;</span><span class="s3">\n            </span><span class="s1">const currentProperty = params.missingProperty;</span><span class="s3">\n            </span><span class="s1">const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^</span><span class="s3">\\</span><span class="s1">./, '')}`)).title;</span><span class="s3">\n            </span><span class="s1">if (uiSchemaTitle) {</span><span class="s3">\n                </span><span class="s1">message = message.replace(currentProperty, uiSchemaTitle);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);</span><span class="s3">\n                </span><span class="s1">if (parentSchemaTitle) {</span><span class="s3">\n                    </span><span class="s1">message = message.replace(currentProperty, parentSchemaTitle);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">stack = message;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^</span><span class="s3">\\</span><span class="s1">./, '')}`)).title;</span><span class="s3">\n            </span><span class="s1">if (uiSchemaTitle) {</span><span class="s3">\n                </span><span class="s1">stack = `'${uiSchemaTitle}' ${message}`.trim();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;</span><span class="s3">\n                </span><span class="s1">if (parentSchemaTitle) {</span><span class="s3">\n                    </span><span class="s1">stack = `'${parentSchemaTitle}' ${message}`.trim();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// put data in expected format</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">name: keyword,</span><span class="s3">\n            </span><span class="s1">property,</span><span class="s3">\n            </span><span class="s1">message,</span><span class="s3">\n            </span><span class="s1">params,</span><span class="s3">\n            </span><span class="s1">stack,</span><span class="s3">\n            </span><span class="s1">schemaPath,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives</span><span class="s3">\n </span><span class="s1">* the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also</span><span class="s3">\n </span><span class="s1">* supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and</span><span class="s3">\n </span><span class="s1">* transform them in what ever way it chooses.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call</span><span class="s3">\n </span><span class="s1">* @param rawErrors - The list of raw `ErrorObject`s to process</span><span class="s3">\n </span><span class="s1">* @param formData - The form data to validate</span><span class="s3">\n </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n </span><span class="s1">* @param [customValidate] - An optional function that is used to perform custom validation</span><span class="s3">\n </span><span class="s1">* @param [transformErrors] - An optional function that is used to transform errors after AJV validation</span><span class="s3">\n </span><span class="s1">* @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function processRawValidationErrors(validator, rawErrors, formData, schema, customValidate, transformErrors, uiSchema) {</span><span class="s3">\n    </span><span class="s1">const { validationError: invalidSchemaError } = rawErrors;</span><span class="s3">\n    </span><span class="s1">let errors = transformRJSFValidationErrors(rawErrors.errors, uiSchema);</span><span class="s3">\n    </span><span class="s1">if (invalidSchemaError) {</span><span class="s3">\n        </span><span class="s1">errors = [...errors, { stack: invalidSchemaError.message }];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof transformErrors === 'function') {</span><span class="s3">\n        </span><span class="s1">errors = transformErrors(errors, uiSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let errorSchema = toErrorSchema(errors);</span><span class="s3">\n    </span><span class="s1">if (invalidSchemaError) {</span><span class="s3">\n        </span><span class="s1">errorSchema = {</span><span class="s3">\n            </span><span class="s1">...errorSchema,</span><span class="s3">\n            </span><span class="s1">$schema: {</span><span class="s3">\n                </span><span class="s1">__errors: [invalidSchemaError.message],</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof customValidate !== 'function') {</span><span class="s3">\n        </span><span class="s1">return { errors, errorSchema };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Include form data with undefined values, which is required for custom validation.</span><span class="s3">\n    </span><span class="s1">const newFormData = getDefaultFormState(validator, schema, formData, schema, true);</span><span class="s3">\n    </span><span class="s1">const errorHandler = customValidate(newFormData, createErrorHandler(newFormData), uiSchema);</span><span class="s3">\n    </span><span class="s1">const userErrorSchema = unwrapErrorHandler(errorHandler);</span><span class="s3">\n    </span><span class="s1">return validationDataMerge({ errors, errorSchema }, userErrorSchema);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=processRawValidationErrors.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ID_KEY, ROOT_SCHEMA_PREFIX, toErrorList, withIdRefPrefix, hashForSchema, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import createAjvInstance from './createAjvInstance';</span><span class="s3">\n</span><span class="s1">import processRawValidationErrors from './processRawValidationErrors';</span><span class="s3">\n</span><span class="s1">/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default class AJV8Validator {</span><span class="s3">\n    </span><span class="s1">/** Constructs an `AJV8Validator` instance using the `options`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance</span><span class="s3">\n     </span><span class="s1">* @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options, localizer) {</span><span class="s3">\n        </span><span class="s1">const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;</span><span class="s3">\n        </span><span class="s1">this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);</span><span class="s3">\n        </span><span class="s1">this.localizer = localizer;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Converts an `errorSchema` into a list of `RJSFValidationErrors`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param errorSchema - The `ErrorSchema` instance to convert</span><span class="s3">\n     </span><span class="s1">* @param [fieldPath=[]] - The current field path, defaults to [] if not specified</span><span class="s3">\n     </span><span class="s1">* @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in</span><span class="s3">\n     </span><span class="s1">*        the next major release.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toErrorList(errorSchema, fieldPath = []) {</span><span class="s3">\n        </span><span class="s1">return toErrorList(errorSchema, fieldPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use</span><span class="s3">\n     </span><span class="s1">* by the playground. Returns the `errors` from the validation</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data   * @param schema</span><span class="s3">\n     </span><span class="s1">* @param formData - The form data to validate</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rawValidation(schema, formData) {</span><span class="s3">\n        </span><span class="s1">let compilationError = undefined;</span><span class="s3">\n        </span><span class="s1">let compiledValidator;</span><span class="s3">\n        </span><span class="s1">if (schema[ID_KEY]) {</span><span class="s3">\n            </span><span class="s1">compiledValidator = this.ajv.getSchema(schema[ID_KEY]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (compiledValidator === undefined) {</span><span class="s3">\n                </span><span class="s1">compiledValidator = this.ajv.compile(schema);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">compiledValidator(formData);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">compilationError = err;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let errors;</span><span class="s3">\n        </span><span class="s1">if (compiledValidator) {</span><span class="s3">\n            </span><span class="s1">if (typeof this.localizer === 'function') {</span><span class="s3">\n                </span><span class="s1">this.localizer(compiledValidator.errors);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">errors = compiledValidator.errors || undefined;</span><span class="s3">\n            </span><span class="s1">// Clear errors to prevent persistent errors, see #1104</span><span class="s3">\n            </span><span class="s1">compiledValidator.errors = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">errors: errors,</span><span class="s3">\n            </span><span class="s1">validationError: compilationError,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives</span><span class="s3">\n     </span><span class="s1">* the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also</span><span class="s3">\n     </span><span class="s1">* supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and</span><span class="s3">\n     </span><span class="s1">* transform them in what ever way it chooses.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The form data to validate</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n     </span><span class="s1">* @param [customValidate] - An optional function that is used to perform custom validation</span><span class="s3">\n     </span><span class="s1">* @param [transformErrors] - An optional function that is used to transform errors after AJV validation</span><span class="s3">\n     </span><span class="s1">* @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {</span><span class="s3">\n        </span><span class="s1">const rawErrors = this.rawValidation(schema, formData);</span><span class="s3">\n        </span><span class="s1">return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Validates data against a schema, returning true if the data is valid, or</span><span class="s3">\n     </span><span class="s1">* false otherwise. If the schema is invalid, then this function will return</span><span class="s3">\n     </span><span class="s1">* false.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n     </span><span class="s1">* @param formData - The form data to validate</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema used to provide $ref resolutions</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isValid(schema, formData, rootSchema) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">const rootSchemaId = (_a = rootSchema[ID_KEY]) !== null &amp;&amp; _a !== void 0 ? _a : ROOT_SCHEMA_PREFIX;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// add the rootSchema ROOT_SCHEMA_PREFIX as id.</span><span class="s3">\n            </span><span class="s1">// then rewrite the schema ref's to point to the rootSchema</span><span class="s3">\n            </span><span class="s1">// this accounts for the case where schema have references to models</span><span class="s3">\n            </span><span class="s1">// that lives in the rootSchema but not in the schema in question.</span><span class="s3">\n            </span><span class="s1">// if (this.ajv.getSchema(rootSchemaId) === undefined) {</span><span class="s3">\n            </span><span class="s1">// TODO restore the commented out `if` above when the TODO in the `finally` is completed</span><span class="s3">\n            </span><span class="s1">this.ajv.addSchema(rootSchema, rootSchemaId);</span><span class="s3">\n            </span><span class="s1">// }</span><span class="s3">\n            </span><span class="s1">const schemaWithIdRefPrefix = withIdRefPrefix(schema);</span><span class="s3">\n            </span><span class="s1">const schemaId = (_b = schemaWithIdRefPrefix[ID_KEY]) !== null &amp;&amp; _b !== void 0 ? _b : hashForSchema(schemaWithIdRefPrefix);</span><span class="s3">\n            </span><span class="s1">let compiledValidator;</span><span class="s3">\n            </span><span class="s1">compiledValidator = this.ajv.getSchema(schemaId);</span><span class="s3">\n            </span><span class="s1">if (compiledValidator === undefined) {</span><span class="s3">\n                </span><span class="s1">// Add schema by an explicit ID so it can be fetched later</span><span class="s3">\n                </span><span class="s1">// Fall back to using compile if necessary</span><span class="s3">\n                </span><span class="s1">// https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand</span><span class="s3">\n                </span><span class="s1">compiledValidator =</span><span class="s3">\n                    </span><span class="s1">this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||</span><span class="s3">\n                        </span><span class="s1">this.ajv.compile(schemaWithIdRefPrefix);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const result = compiledValidator(formData);</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">console.warn('Error encountered compiling schema:', e);</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">// TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.</span><span class="s3">\n            </span><span class="s1">// make sure we remove the rootSchema from the global ajv instance</span><span class="s3">\n            </span><span class="s1">this.ajv.removeSchema(rootSchemaId);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=validator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import AJV8Validator from './validator';</span><span class="s3">\n</span><span class="s1">/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if</span><span class="s3">\n </span><span class="s1">* provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV</span><span class="s3">\n </span><span class="s1">* validation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance</span><span class="s3">\n </span><span class="s1">* @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s</span><span class="s3">\n </span><span class="s1">* @returns - The custom validator implementation resulting from the set of parameters provided</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function customizeValidator(options = {}, localizer) {</span><span class="s3">\n    </span><span class="s1">return new AJV8Validator(options, localizer);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=customizeValidator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import { hashForSchema, ID_KEY, JUNK_OPTION_ID, toErrorList, retrieveSchema, } from '@rjsf/utils';</span><span class="s3">\n</span><span class="s1">import processRawValidationErrors from './processRawValidationErrors';</span><span class="s3">\n</span><span class="s1">/** `ValidatorType` implementation that uses an AJV 8 precompiled validator as created by the</span><span class="s3">\n </span><span class="s1">* `compileSchemaValidators()` function provided by the `@rjsf/validator-ajv8` library.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default class AJV8PrecompiledValidator {</span><span class="s3">\n    </span><span class="s1">/** Constructs an `AJV8PrecompiledValidator` instance using the `validateFns` and `rootSchema`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param validateFns - The map of the validation functions that are generated by the `schemaCompile()` function</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema that was used with the `compileSchema()` function</span><span class="s3">\n     </span><span class="s1">* @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s</span><span class="s3">\n     </span><span class="s1">* @throws - Error when the base schema of the precompiled validator does not have a matching validator function</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(validateFns, rootSchema, localizer) {</span><span class="s3">\n        </span><span class="s1">this.rootSchema = rootSchema;</span><span class="s3">\n        </span><span class="s1">this.validateFns = validateFns;</span><span class="s3">\n        </span><span class="s1">this.localizer = localizer;</span><span class="s3">\n        </span><span class="s1">this.mainValidator = this.getValidator(rootSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the precompiled validator associated with the given `schema` from the map of precompiled validator</span><span class="s3">\n     </span><span class="s1">* functions.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which a precompiled validator function is desired</span><span class="s3">\n     </span><span class="s1">* @returns - The precompiled validator function associated with this schema</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getValidator(schema) {</span><span class="s3">\n        </span><span class="s1">const key = get(schema, ID_KEY) || hashForSchema(schema);</span><span class="s3">\n        </span><span class="s1">const validator = this.validateFns[key];</span><span class="s3">\n        </span><span class="s1">if (!validator) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`No precompiled validator function was found for the given schema for </span><span class="s3">\&quot;</span><span class="s1">${key}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return validator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Ensures that the validator is using the same schema as the root schema used to construct the precompiled</span><span class="s3">\n     </span><span class="s1">* validator. It first compares the given `schema` against the root schema and if they aren't the same, then it</span><span class="s3">\n     </span><span class="s1">* checks against the resolved root schema, on the chance that a resolved version of the root schema was passed in</span><span class="s3">\n     </span><span class="s1">* instead of the raw root schema.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n     </span><span class="s1">* @param [formData] - The form data to validate if any</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ensureSameRootSchema(schema, formData) {</span><span class="s3">\n        </span><span class="s1">if (!isEqual(schema, this.rootSchema)) {</span><span class="s3">\n            </span><span class="s1">// Resolve the root schema with the passed in form data since that may affect the resolution</span><span class="s3">\n            </span><span class="s1">const resolvedRootSchema = retrieveSchema(this, this.rootSchema, this.rootSchema, formData);</span><span class="s3">\n            </span><span class="s1">if (!isEqual(schema, resolvedRootSchema)) {</span><span class="s3">\n                </span><span class="s1">throw new Error('The schema associated with the precompiled validator differs from the rootSchema provided for validation');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Converts an `errorSchema` into a list of `RJSFValidationErrors`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param errorSchema - The `ErrorSchema` instance to convert</span><span class="s3">\n     </span><span class="s1">* @param [fieldPath=[]] - The current field path, defaults to [] if not specified</span><span class="s3">\n     </span><span class="s1">* @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in</span><span class="s3">\n     </span><span class="s1">*        the next major release.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toErrorList(errorSchema, fieldPath = []) {</span><span class="s3">\n        </span><span class="s1">return toErrorList(errorSchema, fieldPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use</span><span class="s3">\n     </span><span class="s1">* by the playground. Returns the `errors` from the validation</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n     </span><span class="s1">* @param [formData] - The form data to validate, if any</span><span class="s3">\n     </span><span class="s1">* @throws - Error when the schema provided does not match the base schema of the precompiled validator</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rawValidation(schema, formData) {</span><span class="s3">\n        </span><span class="s1">this.ensureSameRootSchema(schema, formData);</span><span class="s3">\n        </span><span class="s1">this.mainValidator(formData);</span><span class="s3">\n        </span><span class="s1">if (typeof this.localizer === 'function') {</span><span class="s3">\n            </span><span class="s1">this.localizer(this.mainValidator.errors);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const errors = this.mainValidator.errors || undefined;</span><span class="s3">\n        </span><span class="s1">// Clear errors to prevent persistent errors, see #1104</span><span class="s3">\n        </span><span class="s1">this.mainValidator.errors = null;</span><span class="s3">\n        </span><span class="s1">return { errors: errors };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives</span><span class="s3">\n     </span><span class="s1">* the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also</span><span class="s3">\n     </span><span class="s1">* supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and</span><span class="s3">\n     </span><span class="s1">* transform them in what ever way it chooses.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The form data to validate</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n     </span><span class="s1">* @param [customValidate] - An optional function that is used to perform custom validation</span><span class="s3">\n     </span><span class="s1">* @param [transformErrors] - An optional function that is used to transform errors after AJV validation</span><span class="s3">\n     </span><span class="s1">* @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {</span><span class="s3">\n        </span><span class="s1">const rawErrors = this.rawValidation(schema, formData);</span><span class="s3">\n        </span><span class="s1">return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Validates data against a schema, returning true if the data is valid, or false otherwise. If the schema is</span><span class="s3">\n     </span><span class="s1">* invalid, then this function will return false.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema against which to validate the form data</span><span class="s3">\n     </span><span class="s1">* @param formData - The form data to validate</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema used to provide $ref resolutions</span><span class="s3">\n     </span><span class="s1">* @returns - true if the formData validates against the schema, false otherwise</span><span class="s3">\n     </span><span class="s1">* @throws - Error when the schema provided does not match the base schema of the precompiled validator OR if there</span><span class="s3">\n     </span><span class="s1">*        isn't a precompiled validator function associated with the schema</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isValid(schema, formData, rootSchema) {</span><span class="s3">\n        </span><span class="s1">this.ensureSameRootSchema(rootSchema, formData);</span><span class="s3">\n        </span><span class="s1">if (get(schema, ID_KEY) === JUNK_OPTION_ID) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const validator = this.getValidator(schema);</span><span class="s3">\n        </span><span class="s1">return validator(formData);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=precompiledValidator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import AJV8PrecompiledValidator from './precompiledValidator';</span><span class="s3">\n</span><span class="s1">/** Creates and returns a `ValidatorType` interface that is implemented with a precompiled validator. If a `localizer`</span><span class="s3">\n </span><span class="s1">* is provided, it is used to translate the messages generated by the underlying AJV validation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* NOTE: The `validateFns` parameter is an object obtained by importing from a precompiled validation file created via</span><span class="s3">\n </span><span class="s1">* the `compileSchemaValidators()` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validateFns - The map of the validation functions that are created by the `compileSchemaValidators()` function</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that was used with the `compileSchemaValidators()` function</span><span class="s3">\n </span><span class="s1">* @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s</span><span class="s3">\n </span><span class="s1">* @returns - The precompiled validator implementation resulting from the set of parameters provided</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function createPrecompiledValidator(validateFns, rootSchema, localizer) {</span><span class="s3">\n    </span><span class="s1">return new AJV8PrecompiledValidator(validateFns, rootSchema, localizer);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=createPrecompiledValidator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import customizeValidator from './customizeValidator';</span><span class="s3">\n</span><span class="s1">import createPrecompiledValidator from './createPrecompiledValidator';</span><span class="s3">\n</span><span class="s1">export { customizeValidator, createPrecompiledValidator };</span><span class="s3">\n</span><span class="s1">export * from './types';</span><span class="s3">\n</span><span class="s1">export default customizeValidator();</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;</span><span class="s3">\n</span><span class="s1">function fmtDef(validate, compare) {</span><span class="s3">\n    </span><span class="s1">return { validate, compare };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.fullFormats = {</span><span class="s3">\n    </span><span class="s1">// date: http://tools.ietf.org/html/rfc3339#section-5.6</span><span class="s3">\n    </span><span class="s1">date: fmtDef(date, compareDate),</span><span class="s3">\n    </span><span class="s1">// date-time: http://tools.ietf.org/html/rfc3339#section-5.6</span><span class="s3">\n    </span><span class="s1">time: fmtDef(time, compareTime),</span><span class="s3">\n    \&quot;</span><span class="s1">date-time</span><span class="s3">\&quot;</span><span class="s1">: fmtDef(date_time, compareDateTime),</span><span class="s3">\n    </span><span class="s1">// duration: https://tools.ietf.org/html/rfc3339#appendix-A</span><span class="s3">\n    </span><span class="s1">duration: /^P(?!$)((</span><span class="s3">\\</span><span class="s1">d+Y)?(</span><span class="s3">\\</span><span class="s1">d+M)?(</span><span class="s3">\\</span><span class="s1">d+D)?(T(?=</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">d+H)?(</span><span class="s3">\\</span><span class="s1">d+M)?(</span><span class="s3">\\</span><span class="s1">d+S)?)?|(</span><span class="s3">\\</span><span class="s1">d+W)?)$/,</span><span class="s3">\n    </span><span class="s1">uri,</span><span class="s3">\n    \&quot;</span><span class="s1">uri-reference</span><span class="s3">\&quot;</span><span class="s1">: /^(?:[a-z][a-z0-9+</span><span class="s3">\\</span><span class="s1">-.]*:)?(?:</span><span class="s3">\\</span><span class="s1">/?</span><span class="s3">\\</span><span class="s1">/(?:(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:]|%[0-9a-f]{2})*@)?(?:</span><span class="s3">\\</span><span class="s1">[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)</span><span class="s3">\\</span><span class="s1">.){3}(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+</span><span class="s3">\\</span><span class="s1">.[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:]+)</span><span class="s3">\\</span><span class="s1">]|(?:(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)</span><span class="s3">\\</span><span class="s1">.){3}(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)|(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=]|%[0-9a-f]{2})*)(?::</span><span class="s3">\\</span><span class="s1">d*)?(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@]|%[0-9a-f]{2})*)*|</span><span class="s3">\\</span><span class="s1">/(?:(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@]|%[0-9a-f]{2})+(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@]|%[0-9a-f]{2})+(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:</span><span class="s3">\\</span><span class="s1">?(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'</span><span class="s3">\&quot;</span><span class="s1">()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,</span><span class="s3">\n    </span><span class="s1">// uri-template: https://tools.ietf.org/html/rfc6570</span><span class="s3">\n    \&quot;</span><span class="s1">uri-template</span><span class="s3">\&quot;</span><span class="s1">: /^(?:(?:[^</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x20</span><span class="s3">\&quot;</span><span class="s1">'&lt;&gt;%</span><span class="s3">\\\\</span><span class="s1">^`{|}]|%[0-9a-f]{2})|</span><span class="s3">\\</span><span class="s1">{[+#./;?&amp;=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|</span><span class="s3">\\</span><span class="s1">*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|</span><span class="s3">\\</span><span class="s1">*)?)*</span><span class="s3">\\</span><span class="s1">})*$/i,</span><span class="s3">\n    </span><span class="s1">// For the source: https://gist.github.com/dperini/729294</span><span class="s3">\n    </span><span class="s1">// For test cases: https://mathiasbynens.be/demo/url-regex</span><span class="s3">\n    </span><span class="s1">url: /^(?:https?|ftp):</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/(?:</span><span class="s3">\\</span><span class="s1">S+(?::</span><span class="s3">\\</span><span class="s1">S*)?@)?(?:(?!(?:10|127)(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d{1,3}){3})(?!(?:169</span><span class="s3">\\</span><span class="s1">.254|192</span><span class="s3">\\</span><span class="s1">.168)(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d{1,3}){2})(?!172</span><span class="s3">\\</span><span class="s1">.(?:1[6-9]|2</span><span class="s3">\\</span><span class="s1">d|3[0-1])(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d{1,3}){2})(?:[1-9]</span><span class="s3">\\</span><span class="s1">d?|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|2[01]</span><span class="s3">\\</span><span class="s1">d|22[0-3])(?:</span><span class="s3">\\</span><span class="s1">.(?:1?</span><span class="s3">\\</span><span class="s1">d{1,2}|2[0-4]</span><span class="s3">\\</span><span class="s1">d|25[0-5])){2}(?:</span><span class="s3">\\</span><span class="s1">.(?:[1-9]</span><span class="s3">\\</span><span class="s1">d?|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|2[0-4]</span><span class="s3">\\</span><span class="s1">d|25[0-4]))|(?:(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">u{00a1}-</span><span class="s3">\\</span><span class="s1">u{ffff}]+-)*[a-z0-9</span><span class="s3">\\</span><span class="s1">u{00a1}-</span><span class="s3">\\</span><span class="s1">u{ffff}]+)(?:</span><span class="s3">\\</span><span class="s1">.(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">u{00a1}-</span><span class="s3">\\</span><span class="s1">u{ffff}]+-)*[a-z0-9</span><span class="s3">\\</span><span class="s1">u{00a1}-</span><span class="s3">\\</span><span class="s1">u{ffff}]+)*(?:</span><span class="s3">\\</span><span class="s1">.(?:[a-z</span><span class="s3">\\</span><span class="s1">u{00a1}-</span><span class="s3">\\</span><span class="s1">u{ffff}]{2,})))(?::</span><span class="s3">\\</span><span class="s1">d{2,5})?(?:</span><span class="s3">\\</span><span class="s1">/[^</span><span class="s3">\\</span><span class="s1">s]*)?$/iu,</span><span class="s3">\n    </span><span class="s1">email: /^[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:</span><span class="s3">\\</span><span class="s1">.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?</span><span class="s3">\\</span><span class="s1">.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,</span><span class="s3">\n    </span><span class="s1">hostname: /^(?=.{1,253}</span><span class="s3">\\</span><span class="s1">.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:</span><span class="s3">\\</span><span class="s1">.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*</span><span class="s3">\\</span><span class="s1">.?$/i,</span><span class="s3">\n    </span><span class="s1">// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html</span><span class="s3">\n    </span><span class="s1">ipv4: /^(?:(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)</span><span class="s3">\\</span><span class="s1">.){3}(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)$/,</span><span class="s3">\n    </span><span class="s1">ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.(25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d|[1-9]?</span><span class="s3">\\</span><span class="s1">d)){3}))|:)))$/i,</span><span class="s3">\n    </span><span class="s1">regex,</span><span class="s3">\n    </span><span class="s1">// uuid: http://tools.ietf.org/html/rfc4122</span><span class="s3">\n    </span><span class="s1">uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,</span><span class="s3">\n    </span><span class="s1">// JSON-pointer: https://tools.ietf.org/html/rfc6901</span><span class="s3">\n    </span><span class="s1">// uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A</span><span class="s3">\n    \&quot;</span><span class="s1">json-pointer</span><span class="s3">\&quot;</span><span class="s1">: /^(?:</span><span class="s3">\\</span><span class="s1">/(?:[^~/]|~0|~1)*)*$/,</span><span class="s3">\n    \&quot;</span><span class="s1">json-pointer-uri-fragment</span><span class="s3">\&quot;</span><span class="s1">: /^#(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9_</span><span class="s3">\\</span><span class="s1">-.!$&amp;'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,</span><span class="s3">\n    </span><span class="s1">// relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00</span><span class="s3">\n    \&quot;</span><span class="s1">relative-json-pointer</span><span class="s3">\&quot;</span><span class="s1">: /^(?:0|[1-9][0-9]*)(?:#|(?:</span><span class="s3">\\</span><span class="s1">/(?:[^~/]|~0|~1)*)*)$/,</span><span class="s3">\n    </span><span class="s1">// the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types</span><span class="s3">\n    </span><span class="s1">// byte: https://github.com/miguelmota/is-base64</span><span class="s3">\n    </span><span class="s1">byte,</span><span class="s3">\n    </span><span class="s1">// signed 32 bit integer</span><span class="s3">\n    </span><span class="s1">int32: { type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, validate: validateInt32 },</span><span class="s3">\n    </span><span class="s1">// signed 64 bit integer</span><span class="s3">\n    </span><span class="s1">int64: { type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, validate: validateInt64 },</span><span class="s3">\n    </span><span class="s1">// C-type float</span><span class="s3">\n    </span><span class="s1">float: { type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, validate: validateNumber },</span><span class="s3">\n    </span><span class="s1">// C-type double</span><span class="s3">\n    </span><span class="s1">double: { type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, validate: validateNumber },</span><span class="s3">\n    </span><span class="s1">// hint to the UI to hide input strings</span><span class="s3">\n    </span><span class="s1">password: true,</span><span class="s3">\n    </span><span class="s1">// unchecked string payload</span><span class="s3">\n    </span><span class="s1">binary: true,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.fastFormats = {</span><span class="s3">\n    </span><span class="s1">...exports.fullFormats,</span><span class="s3">\n    </span><span class="s1">date: fmtDef(/^</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d-[0-1]</span><span class="s3">\\</span><span class="s1">d-[0-3]</span><span class="s3">\\</span><span class="s1">d$/, compareDate),</span><span class="s3">\n    </span><span class="s1">time: fmtDef(/^(?:[0-2]</span><span class="s3">\\</span><span class="s1">d:[0-5]</span><span class="s3">\\</span><span class="s1">d:[0-5]</span><span class="s3">\\</span><span class="s1">d|23:59:60)(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?(?:z|[+-]</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d(?::?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)?)?$/i, compareTime),</span><span class="s3">\n    \&quot;</span><span class="s1">date-time</span><span class="s3">\&quot;</span><span class="s1">: fmtDef(/^</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d-[0-1]</span><span class="s3">\\</span><span class="s1">d-[0-3]</span><span class="s3">\\</span><span class="s1">d[t</span><span class="s3">\\</span><span class="s1">s](?:[0-2]</span><span class="s3">\\</span><span class="s1">d:[0-5]</span><span class="s3">\\</span><span class="s1">d:[0-5]</span><span class="s3">\\</span><span class="s1">d|23:59:60)(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?(?:z|[+-]</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d(?::?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)?)$/i, compareDateTime),</span><span class="s3">\n    </span><span class="s1">// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js</span><span class="s3">\n    </span><span class="s1">uri: /^(?:[a-z][a-z0-9+</span><span class="s3">\\</span><span class="s1">-.]*:)(?:</span><span class="s3">\\</span><span class="s1">/?</span><span class="s3">\\</span><span class="s1">/)?[^</span><span class="s3">\\</span><span class="s1">s]*$/i,</span><span class="s3">\n    \&quot;</span><span class="s1">uri-reference</span><span class="s3">\&quot;</span><span class="s1">: /^(?:(?:[a-z][a-z0-9+</span><span class="s3">\\</span><span class="s1">-.]*:)?</span><span class="s3">\\</span><span class="s1">/?</span><span class="s3">\\</span><span class="s1">/)?(?:[^</span><span class="s3">\\\\\\</span><span class="s1">s#][^</span><span class="s3">\\</span><span class="s1">s#]*)?(?:#[^</span><span class="s3">\\\\\\</span><span class="s1">s]*)?$/i,</span><span class="s3">\n    </span><span class="s1">// email (sources from jsen validator):</span><span class="s3">\n    </span><span class="s1">// http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363</span><span class="s3">\n    </span><span class="s1">// http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')</span><span class="s3">\n    </span><span class="s1">email: /^[a-z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:</span><span class="s3">\\</span><span class="s1">.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.formatNames = Object.keys(exports.fullFormats);</span><span class="s3">\n</span><span class="s1">function isLeapYear(year) {</span><span class="s3">\n    </span><span class="s1">// https://tools.ietf.org/html/rfc3339#appendix-C</span><span class="s3">\n    </span><span class="s1">return year % 4 === 0 &amp;&amp; (year % 100 !== 0 || year % 400 === 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const DATE = /^(</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)-(</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)-(</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)$/;</span><span class="s3">\n</span><span class="s1">const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</span><span class="s3">\n</span><span class="s1">function date(str) {</span><span class="s3">\n    </span><span class="s1">// full-date from http://tools.ietf.org/html/rfc3339#section-5.6</span><span class="s3">\n    </span><span class="s1">const matches = DATE.exec(str);</span><span class="s3">\n    </span><span class="s1">if (!matches)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">const year = +matches[1];</span><span class="s3">\n    </span><span class="s1">const month = +matches[2];</span><span class="s3">\n    </span><span class="s1">const day = +matches[3];</span><span class="s3">\n    </span><span class="s1">return (month &gt;= 1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">month &lt;= 12 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">day &gt;= 1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">day &lt;= (month === 2 &amp;&amp; isLeapYear(year) ? 29 : DAYS[month]));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compareDate(d1, d2) {</span><span class="s3">\n    </span><span class="s1">if (!(d1 &amp;&amp; d2))</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">if (d1 &gt; d2)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">if (d1 &lt; d2)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const TIME = /^(</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d):(</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d):(</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?(z|[+-]</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d(?::?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d)?)?$/i;</span><span class="s3">\n</span><span class="s1">function time(str, withTimeZone) {</span><span class="s3">\n    </span><span class="s1">const matches = TIME.exec(str);</span><span class="s3">\n    </span><span class="s1">if (!matches)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">const hour = +matches[1];</span><span class="s3">\n    </span><span class="s1">const minute = +matches[2];</span><span class="s3">\n    </span><span class="s1">const second = +matches[3];</span><span class="s3">\n    </span><span class="s1">const timeZone = matches[5];</span><span class="s3">\n    </span><span class="s1">return (((hour &lt;= 23 &amp;&amp; minute &lt;= 59 &amp;&amp; second &lt;= 59) ||</span><span class="s3">\n        </span><span class="s1">(hour === 23 &amp;&amp; minute === 59 &amp;&amp; second === 60)) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!withTimeZone || timeZone !== </span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compareTime(t1, t2) {</span><span class="s3">\n    </span><span class="s1">if (!(t1 &amp;&amp; t2))</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">const a1 = TIME.exec(t1);</span><span class="s3">\n    </span><span class="s1">const a2 = TIME.exec(t2);</span><span class="s3">\n    </span><span class="s1">if (!(a1 &amp;&amp; a2))</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">t1 = a1[1] + a1[2] + a1[3] + (a1[4] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">t2 = a2[1] + a2[2] + a2[3] + (a2[4] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (t1 &gt; t2)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">if (t1 &lt; t2)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const DATE_TIME_SEPARATOR = /t|</span><span class="s3">\\</span><span class="s1">s/i;</span><span class="s3">\n</span><span class="s1">function date_time(str) {</span><span class="s3">\n    </span><span class="s1">// http://tools.ietf.org/html/rfc3339#section-5.6</span><span class="s3">\n    </span><span class="s1">const dateTime = str.split(DATE_TIME_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">return dateTime.length === 2 &amp;&amp; date(dateTime[0]) &amp;&amp; time(dateTime[1], true);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compareDateTime(dt1, dt2) {</span><span class="s3">\n    </span><span class="s1">if (!(dt1 &amp;&amp; dt2))</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">const res = compareDate(d1, d2);</span><span class="s3">\n    </span><span class="s1">if (res === undefined)</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">return res || compareTime(t1, t2);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const NOT_URI_FRAGMENT = /</span><span class="s3">\\</span><span class="s1">/|:/;</span><span class="s3">\n</span><span class="s1">const URI = /^(?:[a-z][a-z0-9+</span><span class="s3">\\</span><span class="s1">-.]*:)(?:</span><span class="s3">\\</span><span class="s1">/?</span><span class="s3">\\</span><span class="s1">/(?:(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:]|%[0-9a-f]{2})*@)?(?:</span><span class="s3">\\</span><span class="s1">[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)</span><span class="s3">\\</span><span class="s1">.){3}(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+</span><span class="s3">\\</span><span class="s1">.[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:]+)</span><span class="s3">\\</span><span class="s1">]|(?:(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)</span><span class="s3">\\</span><span class="s1">.){3}(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|[01]?</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">d?)|(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=]|%[0-9a-f]{2})*)(?::</span><span class="s3">\\</span><span class="s1">d*)?(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})*)*|</span><span class="s3">\\</span><span class="s1">/(?:(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})+(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})+(?:</span><span class="s3">\\</span><span class="s1">/(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:</span><span class="s3">\\</span><span class="s1">?(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9</span><span class="s3">\\</span><span class="s1">-._~!$&amp;'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;</span><span class="s3">\n</span><span class="s1">function uri(str) {</span><span class="s3">\n    </span><span class="s1">// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;\n    </span><span class="s1">return NOT_URI_FRAGMENT.test(str) &amp;&amp; URI.test(str);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;</span><span class="s3">\n</span><span class="s1">function byte(str) {</span><span class="s3">\n    </span><span class="s1">BYTE.lastIndex = 0;</span><span class="s3">\n    </span><span class="s1">return BYTE.test(str);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const MIN_INT32 = -(2 ** 31);</span><span class="s3">\n</span><span class="s1">const MAX_INT32 = 2 ** 31 - 1;</span><span class="s3">\n</span><span class="s1">function validateInt32(value) {</span><span class="s3">\n    </span><span class="s1">return Number.isInteger(value) &amp;&amp; value &lt;= MAX_INT32 &amp;&amp; value &gt;= MIN_INT32;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validateInt64(value) {</span><span class="s3">\n    </span><span class="s1">// JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64</span><span class="s3">\n    </span><span class="s1">return Number.isInteger(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validateNumber() {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const Z_ANCHOR = /[^</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">Z/;</span><span class="s3">\n</span><span class="s1">function regex(str) {</span><span class="s3">\n    </span><span class="s1">if (Z_ANCHOR.test(str))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">new RegExp(str);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (e) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=formats.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const formats_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./formats</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const limit_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./limit</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">ajv/dist/compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const fullName = new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">fullFormats</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const fastName = new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">fastFormats</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const formatsPlugin = (ajv, opts = { keywords: true }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(opts)) {</span><span class="s3">\n        </span><span class="s1">addFormats(ajv, opts, formats_1.fullFormats, fullName);</span><span class="s3">\n        </span><span class="s1">return ajv;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const [formats, exportName] = opts.mode === </span><span class="s3">\&quot;</span><span class="s1">fast</span><span class="s3">\&quot; </span><span class="s1">? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];</span><span class="s3">\n    </span><span class="s1">const list = opts.formats || formats_1.formatNames;</span><span class="s3">\n    </span><span class="s1">addFormats(ajv, list, formats, exportName);</span><span class="s3">\n    </span><span class="s1">if (opts.keywords)</span><span class="s3">\n        </span><span class="s1">limit_1.default(ajv);</span><span class="s3">\n    </span><span class="s1">return ajv;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">formatsPlugin.get = (name, mode = </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot;</span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">const formats = mode === </span><span class="s3">\&quot;</span><span class="s1">fast</span><span class="s3">\&quot; </span><span class="s1">? formats_1.fastFormats : formats_1.fullFormats;</span><span class="s3">\n    </span><span class="s1">const f = formats[name];</span><span class="s3">\n    </span><span class="s1">if (!f)</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unknown format </span><span class="s3">\&quot;</span><span class="s1">${name}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n    </span><span class="s1">return f;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function addFormats(ajv, list, fs, exportName) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">var _b;</span><span class="s3">\n    </span><span class="s1">(_a = (_b = ajv.opts.code).formats) !== null &amp;&amp; _a !== void 0 ? _a : (_b.formats = codegen_1._ `require(</span><span class="s3">\&quot;</span><span class="s1">ajv-formats/dist/formats</span><span class="s3">\&quot;</span><span class="s1">).${exportName}`);</span><span class="s3">\n    </span><span class="s1">for (const f of list)</span><span class="s3">\n        </span><span class="s1">ajv.addFormat(f, fs[f]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">module.exports = exports = formatsPlugin;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.default = formatsPlugin;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.formatLimitDefinition = void 0;</span><span class="s3">\n</span><span class="s1">const ajv_1 = require(</span><span class="s3">\&quot;</span><span class="s1">ajv</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">ajv/dist/compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ops = codegen_1.operators;</span><span class="s3">\n</span><span class="s1">const KWDs = {</span><span class="s3">\n    </span><span class="s1">formatMaximum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.LTE, fail: ops.GT },</span><span class="s3">\n    </span><span class="s1">formatMinimum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.GTE, fail: ops.LT },</span><span class="s3">\n    </span><span class="s1">formatExclusiveMaximum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.LT, fail: ops.GTE },</span><span class="s3">\n    </span><span class="s1">formatExclusiveMinimum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.GT, fail: ops.LTE },</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ keyword, schemaCode }) =&gt; codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,</span><span class="s3">\n    </span><span class="s1">params: ({ keyword, schemaCode }) =&gt; codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.formatLimitDefinition = {</span><span class="s3">\n    </span><span class="s1">keyword: Object.keys(KWDs),</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, schemaCode, keyword, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { opts, self } = it;</span><span class="s3">\n        </span><span class="s1">if (!opts.validateFormats)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, </span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (fCxt.$data)</span><span class="s3">\n            </span><span class="s1">validate$DataFormat();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">validateFormat();</span><span class="s3">\n        </span><span class="s1">function validate$DataFormat() {</span><span class="s3">\n            </span><span class="s1">const fmts = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">formats</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n                </span><span class="s1">ref: self.formats,</span><span class="s3">\n                </span><span class="s1">code: opts.code.formats,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const fmt = gen.const(</span><span class="s3">\&quot;</span><span class="s1">fmt</span><span class="s3">\&quot;</span><span class="s1">, codegen_1._ `${fmts}[${fCxt.schemaCode}]`);</span><span class="s3">\n            </span><span class="s1">cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">`, compareCode(fmt)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function validateFormat() {</span><span class="s3">\n            </span><span class="s1">const format = fCxt.schema;</span><span class="s3">\n            </span><span class="s1">const fmtDef = self.formats[format];</span><span class="s3">\n            </span><span class="s1">if (!fmtDef || fmtDef === true)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">if (typeof fmtDef != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n                </span><span class="s1">fmtDef instanceof RegExp ||</span><span class="s3">\n                </span><span class="s1">typeof fmtDef.compare != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`</span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot;</span><span class="s1">: format </span><span class="s3">\&quot;</span><span class="s1">${format}</span><span class="s3">\&quot; </span><span class="s1">does not define </span><span class="s3">\&quot;</span><span class="s1">compare</span><span class="s3">\&quot; </span><span class="s1">function`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const fmt = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">formats</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n                </span><span class="s1">key: format,</span><span class="s3">\n                </span><span class="s1">ref: fmtDef,</span><span class="s3">\n                </span><span class="s1">code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">cxt.fail$data(compareCode(fmt));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function compareCode(fmt) {</span><span class="s3">\n            </span><span class="s1">return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">dependencies: [</span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const formatLimitPlugin = (ajv) =&gt; {</span><span class="s3">\n    </span><span class="s1">ajv.addKeyword(exports.formatLimitDefinition);</span><span class="s3">\n    </span><span class="s1">return ajv;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = formatLimitPlugin;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=limit.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;</span><span class="s3">\n</span><span class="s1">const core_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./core</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const draft7_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./vocabularies/draft7</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const discriminator_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./vocabularies/discriminator</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const draft7MetaSchema = require(</span><span class="s3">\&quot;</span><span class="s1">./refs/json-schema-draft-07.json</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const META_SUPPORT_DATA = [</span><span class="s3">\&quot;</span><span class="s1">/properties</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const META_SCHEMA_ID = </span><span class="s3">\&quot;</span><span class="s1">http://json-schema.org/draft-07/schema</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class Ajv extends core_1.default {</span><span class="s3">\n    </span><span class="s1">_addVocabularies() {</span><span class="s3">\n        </span><span class="s1">super._addVocabularies();</span><span class="s3">\n        </span><span class="s1">draft7_1.default.forEach((v) =&gt; this.addVocabulary(v));</span><span class="s3">\n        </span><span class="s1">if (this.opts.discriminator)</span><span class="s3">\n            </span><span class="s1">this.addKeyword(discriminator_1.default);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_addDefaultMetaSchema() {</span><span class="s3">\n        </span><span class="s1">super._addDefaultMetaSchema();</span><span class="s3">\n        </span><span class="s1">if (!this.opts.meta)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const metaSchema = this.opts.$data</span><span class="s3">\n            </span><span class="s1">? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)</span><span class="s3">\n            </span><span class="s1">: draft7MetaSchema;</span><span class="s3">\n        </span><span class="s1">this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);</span><span class="s3">\n        </span><span class="s1">this.refs[</span><span class="s3">\&quot;</span><span class="s1">http://json-schema.org/schema</span><span class="s3">\&quot;</span><span class="s1">] = META_SCHEMA_ID;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">defaultMeta() {</span><span class="s3">\n        </span><span class="s1">return (this.opts.defaultMeta =</span><span class="s3">\n            </span><span class="s1">super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Ajv = Ajv;</span><span class="s3">\n</span><span class="s1">module.exports = exports = Ajv;</span><span class="s3">\n</span><span class="s1">module.exports.Ajv = Ajv;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.default = Ajv;</span><span class="s3">\n</span><span class="s1">var validate_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/validate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">KeywordCxt</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return validate_1.KeywordCxt; } });</span><span class="s3">\n</span><span class="s1">var codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1._; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">str</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.str; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">stringify</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.stringify; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">nil</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.nil; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Name</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.Name; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CodeGen</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.CodeGen; } });</span><span class="s3">\n</span><span class="s1">var validation_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./runtime/validation_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ValidationError</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return validation_error_1.default; } });</span><span class="s3">\n</span><span class="s1">var ref_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/ref_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">MissingRefError</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return ref_error_1.default; } });</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ajv.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-extraneous-class</span><span class="s3">\n</span><span class="s1">class _CodeOrName {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports._CodeOrName = _CodeOrName;</span><span class="s3">\n</span><span class="s1">exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;</span><span class="s3">\n</span><span class="s1">class Name extends _CodeOrName {</span><span class="s3">\n    </span><span class="s1">constructor(s) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">if (!exports.IDENTIFIER.test(s))</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">CodeGen: name must be a valid identifier</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.str = s;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.str;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">emptyStr() {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return { [this.str]: 1 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Name = Name;</span><span class="s3">\n</span><span class="s1">class _Code extends _CodeOrName {</span><span class="s3">\n    </span><span class="s1">constructor(code) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._items = typeof code === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? [code] : code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.str;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">emptyStr() {</span><span class="s3">\n        </span><span class="s1">if (this._items.length &gt; 1)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">const item = this._items[0];</span><span class="s3">\n        </span><span class="s1">return item === </span><span class="s3">\&quot;\&quot; </span><span class="s1">|| item === '</span><span class="s3">\&quot;\&quot;</span><span class="s1">';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get str() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return ((_a = this._str) !== null &amp;&amp; _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) =&gt; `${s}${c}`, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return ((_a = this._names) !== null &amp;&amp; _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (c instanceof Name)</span><span class="s3">\n                </span><span class="s1">names[c.str] = (names[c.str] || 0) + 1;</span><span class="s3">\n            </span><span class="s1">return names;</span><span class="s3">\n        </span><span class="s1">}, {})));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports._Code = _Code;</span><span class="s3">\n</span><span class="s1">exports.nil = new _Code(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function _(strs, ...args) {</span><span class="s3">\n    </span><span class="s1">const code = [strs[0]];</span><span class="s3">\n    </span><span class="s1">let i = 0;</span><span class="s3">\n    </span><span class="s1">while (i &lt; args.length) {</span><span class="s3">\n        </span><span class="s1">addCodeArg(code, args[i]);</span><span class="s3">\n        </span><span class="s1">code.push(strs[++i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new _Code(code);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports._ = _;</span><span class="s3">\n</span><span class="s1">const plus = new _Code(</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function str(strs, ...args) {</span><span class="s3">\n    </span><span class="s1">const expr = [safeStringify(strs[0])];</span><span class="s3">\n    </span><span class="s1">let i = 0;</span><span class="s3">\n    </span><span class="s1">while (i &lt; args.length) {</span><span class="s3">\n        </span><span class="s1">expr.push(plus);</span><span class="s3">\n        </span><span class="s1">addCodeArg(expr, args[i]);</span><span class="s3">\n        </span><span class="s1">expr.push(plus, safeStringify(strs[++i]));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimize(expr);</span><span class="s3">\n    </span><span class="s1">return new _Code(expr);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.str = str;</span><span class="s3">\n</span><span class="s1">function addCodeArg(code, arg) {</span><span class="s3">\n    </span><span class="s1">if (arg instanceof _Code)</span><span class="s3">\n        </span><span class="s1">code.push(...arg._items);</span><span class="s3">\n    </span><span class="s1">else if (arg instanceof Name)</span><span class="s3">\n        </span><span class="s1">code.push(arg);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">code.push(interpolate(arg));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.addCodeArg = addCodeArg;</span><span class="s3">\n</span><span class="s1">function optimize(expr) {</span><span class="s3">\n    </span><span class="s1">let i = 1;</span><span class="s3">\n    </span><span class="s1">while (i &lt; expr.length - 1) {</span><span class="s3">\n        </span><span class="s1">if (expr[i] === plus) {</span><span class="s3">\n            </span><span class="s1">const res = mergeExprItems(expr[i - 1], expr[i + 1]);</span><span class="s3">\n            </span><span class="s1">if (res !== undefined) {</span><span class="s3">\n                </span><span class="s1">expr.splice(i - 1, 3, res);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">expr[i++] = </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">i++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeExprItems(a, b) {</span><span class="s3">\n    </span><span class="s1">if (b === '</span><span class="s3">\&quot;\&quot;</span><span class="s1">')</span><span class="s3">\n        </span><span class="s1">return a;</span><span class="s3">\n    </span><span class="s1">if (a === '</span><span class="s3">\&quot;\&quot;</span><span class="s1">')</span><span class="s3">\n        </span><span class="s1">return b;</span><span class="s3">\n    </span><span class="s1">if (typeof a == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (b instanceof Name || a[a.length - 1] !== '</span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (typeof b != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return `${a.slice(0, -1)}${b}</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n        </span><span class="s1">if (b[0] === '</span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\n            </span><span class="s1">return a.slice(0, -1) + b.slice(1);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof b == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; b[0] === '</span><span class="s3">\&quot;</span><span class="s1">' &amp;&amp; !(a instanceof Name))</span><span class="s3">\n        </span><span class="s1">return `</span><span class="s3">\&quot;</span><span class="s1">${a}${b.slice(1)}`;</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function strConcat(c1, c2) {</span><span class="s3">\n    </span><span class="s1">return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.strConcat = strConcat;</span><span class="s3">\n</span><span class="s1">// TODO do not allow arrays here</span><span class="s3">\n</span><span class="s1">function interpolate(x) {</span><span class="s3">\n    </span><span class="s1">return typeof x == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof x == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">|| x === null</span><span class="s3">\n        </span><span class="s1">? x</span><span class="s3">\n        </span><span class="s1">: safeStringify(Array.isArray(x) ? x.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) : x);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function stringify(x) {</span><span class="s3">\n    </span><span class="s1">return new _Code(safeStringify(x));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.stringify = stringify;</span><span class="s3">\n</span><span class="s1">function safeStringify(x) {</span><span class="s3">\n    </span><span class="s1">return JSON.stringify(x)</span><span class="s3">\n        </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">u2028/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">u2029/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.safeStringify = safeStringify;</span><span class="s3">\n</span><span class="s1">function getProperty(key) {</span><span class="s3">\n    </span><span class="s1">return typeof key == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getProperty = getProperty;</span><span class="s3">\n</span><span class="s1">//Does best effort to format the name properly</span><span class="s3">\n</span><span class="s1">function getEsmExportName(key) {</span><span class="s3">\n    </span><span class="s1">if (typeof key == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; exports.IDENTIFIER.test(key)) {</span><span class="s3">\n        </span><span class="s1">return new _Code(`${key}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getEsmExportName = getEsmExportName;</span><span class="s3">\n</span><span class="s1">function regexpCode(rx) {</span><span class="s3">\n    </span><span class="s1">return new _Code(rx.toString());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.regexpCode = regexpCode;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=code.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const scope_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./scope</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var code_2 = require(</span><span class="s3">\&quot;</span><span class="s1">./code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2._; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">str</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.str; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">strConcat</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.strConcat; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">nil</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.nil; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">getProperty</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.getProperty; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">stringify</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.stringify; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">regexpCode</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.regexpCode; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Name</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return code_2.Name; } });</span><span class="s3">\n</span><span class="s1">var scope_2 = require(</span><span class="s3">\&quot;</span><span class="s1">./scope</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Scope</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return scope_2.Scope; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ValueScope</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return scope_2.ValueScope; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ValueScopeName</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return scope_2.ValueScopeName; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">varKinds</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return scope_2.varKinds; } });</span><span class="s3">\n</span><span class="s1">exports.operators = {</span><span class="s3">\n    </span><span class="s1">GT: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">GTE: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">LT: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">LTE: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">EQ: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">NEQ: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">!==</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">NOT: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">OR: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">AND: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ADD: new code_1._Code(</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class Node {</span><span class="s3">\n    </span><span class="s1">optimizeNodes() {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(_names, _constants) {</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Def extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(varKind, name, rhs) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.varKind = varKind;</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.rhs = rhs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ es5, _n }) {</span><span class="s3">\n        </span><span class="s1">const varKind = es5 ? scope_1.varKinds.var : this.varKind;</span><span class="s3">\n        </span><span class="s1">const rhs = this.rhs === undefined ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: ` = ${this.rhs}`;</span><span class="s3">\n        </span><span class="s1">return `${varKind} ${this.name}${rhs};` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">if (!names[this.name.str])</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (this.rhs)</span><span class="s3">\n            </span><span class="s1">this.rhs = optimizeExpr(this.rhs, names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Assign extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(lhs, rhs, sideEffects) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.lhs = lhs;</span><span class="s3">\n        </span><span class="s1">this.rhs = rhs;</span><span class="s3">\n        </span><span class="s1">this.sideEffects = sideEffects;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ _n }) {</span><span class="s3">\n        </span><span class="s1">return `${this.lhs} = ${this.rhs};` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">if (this.lhs instanceof code_1.Name &amp;&amp; !names[this.lhs.str] &amp;&amp; !this.sideEffects)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.rhs = optimizeExpr(this.rhs, names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };</span><span class="s3">\n        </span><span class="s1">return addExprNames(names, this.rhs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class AssignOp extends Assign {</span><span class="s3">\n    </span><span class="s1">constructor(lhs, op, rhs, sideEffects) {</span><span class="s3">\n        </span><span class="s1">super(lhs, rhs, sideEffects);</span><span class="s3">\n        </span><span class="s1">this.op = op;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ _n }) {</span><span class="s3">\n        </span><span class="s1">return `${this.lhs} ${this.op}= ${this.rhs};` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Label extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(label) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.label = label;</span><span class="s3">\n        </span><span class="s1">this.names = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ _n }) {</span><span class="s3">\n        </span><span class="s1">return `${this.label}:` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Break extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(label) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.label = label;</span><span class="s3">\n        </span><span class="s1">this.names = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ _n }) {</span><span class="s3">\n        </span><span class="s1">const label = this.label ? ` ${this.label}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return `break${label};` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Throw extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(error) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.error = error;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ _n }) {</span><span class="s3">\n        </span><span class="s1">return `throw ${this.error};` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return this.error.names;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class AnyCode extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(code) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.code = code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render({ _n }) {</span><span class="s3">\n        </span><span class="s1">return `${this.code};` + _n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNodes() {</span><span class="s3">\n        </span><span class="s1">return `${this.code}` ? this : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">this.code = optimizeExpr(this.code, names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return this.code instanceof code_1._CodeOrName ? this.code.names : {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ParentNode extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(nodes = []) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.nodes = nodes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return this.nodes.reduce((code, n) =&gt; code + n.render(opts), </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNodes() {</span><span class="s3">\n        </span><span class="s1">const { nodes } = this;</span><span class="s3">\n        </span><span class="s1">let i = nodes.length;</span><span class="s3">\n        </span><span class="s1">while (i--) {</span><span class="s3">\n            </span><span class="s1">const n = nodes[i].optimizeNodes();</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(n))</span><span class="s3">\n                </span><span class="s1">nodes.splice(i, 1, ...n);</span><span class="s3">\n            </span><span class="s1">else if (n)</span><span class="s3">\n                </span><span class="s1">nodes[i] = n;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">nodes.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return nodes.length &gt; 0 ? this : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">const { nodes } = this;</span><span class="s3">\n        </span><span class="s1">let i = nodes.length;</span><span class="s3">\n        </span><span class="s1">while (i--) {</span><span class="s3">\n            </span><span class="s1">// iterating backwards improves 1-pass optimization</span><span class="s3">\n            </span><span class="s1">const n = nodes[i];</span><span class="s3">\n            </span><span class="s1">if (n.optimizeNames(names, constants))</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">subtractNames(names, n.names);</span><span class="s3">\n            </span><span class="s1">nodes.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return nodes.length &gt; 0 ? this : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return this.nodes.reduce((names, n) =&gt; addNames(names, n.names), {});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BlockNode extends ParentNode {</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">+ opts._n + super.render(opts) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">+ opts._n;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Root extends ParentNode {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Else extends BlockNode {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Else.kind = </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class If extends BlockNode {</span><span class="s3">\n    </span><span class="s1">constructor(condition, nodes) {</span><span class="s3">\n        </span><span class="s1">super(nodes);</span><span class="s3">\n        </span><span class="s1">this.condition = condition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">let code = `if(${this.condition})` + super.render(opts);</span><span class="s3">\n        </span><span class="s1">if (this.else)</span><span class="s3">\n            </span><span class="s1">code += </span><span class="s3">\&quot;</span><span class="s1">else </span><span class="s3">\&quot; </span><span class="s1">+ this.else.render(opts);</span><span class="s3">\n        </span><span class="s1">return code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNodes() {</span><span class="s3">\n        </span><span class="s1">super.optimizeNodes();</span><span class="s3">\n        </span><span class="s1">const cond = this.condition;</span><span class="s3">\n        </span><span class="s1">if (cond === true)</span><span class="s3">\n            </span><span class="s1">return this.nodes; // else is ignored here</span><span class="s3">\n        </span><span class="s1">let e = this.else;</span><span class="s3">\n        </span><span class="s1">if (e) {</span><span class="s3">\n            </span><span class="s1">const ns = e.optimizeNodes();</span><span class="s3">\n            </span><span class="s1">e = this.else = Array.isArray(ns) ? new Else(ns) : ns;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (e) {</span><span class="s3">\n            </span><span class="s1">if (cond === false)</span><span class="s3">\n                </span><span class="s1">return e instanceof If ? e : e.nodes;</span><span class="s3">\n            </span><span class="s1">if (this.nodes.length)</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">return new If(not(cond), e instanceof If ? [e] : e.nodes);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cond === false || !this.nodes.length)</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);</span><span class="s3">\n        </span><span class="s1">if (!(super.optimizeNames(names, constants) || this.else))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.condition = optimizeExpr(this.condition, names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">const names = super.names;</span><span class="s3">\n        </span><span class="s1">addExprNames(names, this.condition);</span><span class="s3">\n        </span><span class="s1">if (this.else)</span><span class="s3">\n            </span><span class="s1">addNames(names, this.else.names);</span><span class="s3">\n        </span><span class="s1">return names;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">If.kind = </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class For extends BlockNode {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">For.kind = </span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class ForLoop extends For {</span><span class="s3">\n    </span><span class="s1">constructor(iteration) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.iteration = iteration;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return `for(${this.iteration})` + super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">if (!super.optimizeNames(names, constants))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.iteration = optimizeExpr(this.iteration, names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return addNames(super.names, this.iteration.names);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ForRange extends For {</span><span class="s3">\n    </span><span class="s1">constructor(varKind, name, from, to) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.varKind = varKind;</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;</span><span class="s3">\n        </span><span class="s1">const { name, from, to } = this;</span><span class="s3">\n        </span><span class="s1">return `for(${varKind} ${name}=${from}; ${name}&lt;${to}; ${name}++)` + super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">const names = addExprNames(super.names, this.from);</span><span class="s3">\n        </span><span class="s1">return addExprNames(names, this.to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ForIter extends For {</span><span class="s3">\n    </span><span class="s1">constructor(loop, varKind, name, iterable) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.loop = loop;</span><span class="s3">\n        </span><span class="s1">this.varKind = varKind;</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.iterable = iterable;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">if (!super.optimizeNames(names, constants))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.iterable = optimizeExpr(this.iterable, names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">return addNames(super.names, this.iterable.names);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Func extends BlockNode {</span><span class="s3">\n    </span><span class="s1">constructor(name, args, async) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.args = args;</span><span class="s3">\n        </span><span class="s1">this.async = async;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">const _async = this.async ? </span><span class="s3">\&quot;</span><span class="s1">async </span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return `${_async}function ${this.name}(${this.args})` + super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Func.kind = </span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class Return extends ParentNode {</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">return </span><span class="s3">\&quot; </span><span class="s1">+ super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Return.kind = </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class Try extends BlockNode {</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">let code = </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot; </span><span class="s1">+ super.render(opts);</span><span class="s3">\n        </span><span class="s1">if (this.catch)</span><span class="s3">\n            </span><span class="s1">code += this.catch.render(opts);</span><span class="s3">\n        </span><span class="s1">if (this.finally)</span><span class="s3">\n            </span><span class="s1">code += this.finally.render(opts);</span><span class="s3">\n        </span><span class="s1">return code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNodes() {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">super.optimizeNodes();</span><span class="s3">\n        </span><span class="s1">(_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();</span><span class="s3">\n        </span><span class="s1">(_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimizeNames(names, constants) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">super.optimizeNames(names, constants);</span><span class="s3">\n        </span><span class="s1">(_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);</span><span class="s3">\n        </span><span class="s1">(_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get names() {</span><span class="s3">\n        </span><span class="s1">const names = super.names;</span><span class="s3">\n        </span><span class="s1">if (this.catch)</span><span class="s3">\n            </span><span class="s1">addNames(names, this.catch.names);</span><span class="s3">\n        </span><span class="s1">if (this.finally)</span><span class="s3">\n            </span><span class="s1">addNames(names, this.finally.names);</span><span class="s3">\n        </span><span class="s1">return names;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Catch extends BlockNode {</span><span class="s3">\n    </span><span class="s1">constructor(error) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.error = error;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return `catch(${this.error})` + super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Catch.kind = </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class Finally extends BlockNode {</span><span class="s3">\n    </span><span class="s1">render(opts) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot; </span><span class="s1">+ super.render(opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Finally.kind = </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class CodeGen {</span><span class="s3">\n    </span><span class="s1">constructor(extScope, opts = {}) {</span><span class="s3">\n        </span><span class="s1">this._values = {};</span><span class="s3">\n        </span><span class="s1">this._blockStarts = [];</span><span class="s3">\n        </span><span class="s1">this._constants = {};</span><span class="s3">\n        </span><span class="s1">this.opts = { ...opts, _n: opts.lines ? </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot; </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this._extScope = extScope;</span><span class="s3">\n        </span><span class="s1">this._scope = new scope_1.Scope({ parent: extScope });</span><span class="s3">\n        </span><span class="s1">this._nodes = [new Root()];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this._root.render(this.opts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// returns unique name in the internal scope</span><span class="s3">\n    </span><span class="s1">name(prefix) {</span><span class="s3">\n        </span><span class="s1">return this._scope.name(prefix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// reserves unique name in the external scope</span><span class="s3">\n    </span><span class="s1">scopeName(prefix) {</span><span class="s3">\n        </span><span class="s1">return this._extScope.name(prefix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// reserves unique name in the external scope and assigns value to it</span><span class="s3">\n    </span><span class="s1">scopeValue(prefixOrName, value) {</span><span class="s3">\n        </span><span class="s1">const name = this._extScope.value(prefixOrName, value);</span><span class="s3">\n        </span><span class="s1">const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());</span><span class="s3">\n        </span><span class="s1">vs.add(name);</span><span class="s3">\n        </span><span class="s1">return name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getScopeValue(prefix, keyOrRef) {</span><span class="s3">\n        </span><span class="s1">return this._extScope.getValue(prefix, keyOrRef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// return code that assigns values in the external scope to the names that are used internally</span><span class="s3">\n    </span><span class="s1">// (same names that were returned by gen.scopeName or gen.scopeValue)</span><span class="s3">\n    </span><span class="s1">scopeRefs(scopeName) {</span><span class="s3">\n        </span><span class="s1">return this._extScope.scopeRefs(scopeName, this._values);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scopeCode() {</span><span class="s3">\n        </span><span class="s1">return this._extScope.scopeCode(this._values);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_def(varKind, nameOrPrefix, rhs, constant) {</span><span class="s3">\n        </span><span class="s1">const name = this._scope.toName(nameOrPrefix);</span><span class="s3">\n        </span><span class="s1">if (rhs !== undefined &amp;&amp; constant)</span><span class="s3">\n            </span><span class="s1">this._constants[name.str] = rhs;</span><span class="s3">\n        </span><span class="s1">this._leafNode(new Def(varKind, name, rhs));</span><span class="s3">\n        </span><span class="s1">return name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `const` declaration (`var` in es5 mode)</span><span class="s3">\n    </span><span class="s1">const(nameOrPrefix, rhs, _constant) {</span><span class="s3">\n        </span><span class="s1">return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `let` declaration with optional assignment (`var` in es5 mode)</span><span class="s3">\n    </span><span class="s1">let(nameOrPrefix, rhs, _constant) {</span><span class="s3">\n        </span><span class="s1">return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `var` declaration with optional assignment</span><span class="s3">\n    </span><span class="s1">var(nameOrPrefix, rhs, _constant) {</span><span class="s3">\n        </span><span class="s1">return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// assignment code</span><span class="s3">\n    </span><span class="s1">assign(lhs, rhs, sideEffects) {</span><span class="s3">\n        </span><span class="s1">return this._leafNode(new Assign(lhs, rhs, sideEffects));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `+=` code</span><span class="s3">\n    </span><span class="s1">add(lhs, rhs) {</span><span class="s3">\n        </span><span class="s1">return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// appends passed SafeExpr to code or executes Block</span><span class="s3">\n    </span><span class="s1">code(c) {</span><span class="s3">\n        </span><span class="s1">if (typeof c == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">c();</span><span class="s3">\n        </span><span class="s1">else if (c !== code_1.nil)</span><span class="s3">\n            </span><span class="s1">this._leafNode(new AnyCode(c));</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// returns code for object literal for the passed argument list of key-value pairs</span><span class="s3">\n    </span><span class="s1">object(...keyValues) {</span><span class="s3">\n        </span><span class="s1">const code = [</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">for (const [key, value] of keyValues) {</span><span class="s3">\n            </span><span class="s1">if (code.length &gt; 1)</span><span class="s3">\n                </span><span class="s1">code.push(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">code.push(key);</span><span class="s3">\n            </span><span class="s1">if (key !== value || this.opts.es5) {</span><span class="s3">\n                </span><span class="s1">code.push(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">(0, code_1.addCodeArg)(code, value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">code.push(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return new code_1._Code(code);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)</span><span class="s3">\n    </span><span class="s1">if(condition, thenBody, elseBody) {</span><span class="s3">\n        </span><span class="s1">this._blockNode(new If(condition));</span><span class="s3">\n        </span><span class="s1">if (thenBody &amp;&amp; elseBody) {</span><span class="s3">\n            </span><span class="s1">this.code(thenBody).else().code(elseBody).endIf();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (thenBody) {</span><span class="s3">\n            </span><span class="s1">this.code(thenBody).endIf();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (elseBody) {</span><span class="s3">\n            </span><span class="s1">throw new Error('CodeGen: </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot; </span><span class="s1">body without </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot; </span><span class="s1">body');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `else if` clause - invalid without `if` or after `else` clauses</span><span class="s3">\n    </span><span class="s1">elseIf(condition) {</span><span class="s3">\n        </span><span class="s1">return this._elseNode(new If(condition));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `else` clause - only valid after `if` or `else if` clauses</span><span class="s3">\n    </span><span class="s1">else() {</span><span class="s3">\n        </span><span class="s1">return this._elseNode(new Else());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// end `if` statement (needed if gen.if was used only with condition)</span><span class="s3">\n    </span><span class="s1">endIf() {</span><span class="s3">\n        </span><span class="s1">return this._endBlockNode(If, Else);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_for(node, forBody) {</span><span class="s3">\n        </span><span class="s1">this._blockNode(node);</span><span class="s3">\n        </span><span class="s1">if (forBody)</span><span class="s3">\n            </span><span class="s1">this.code(forBody).endFor();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// a generic `for` clause (or statement if `forBody` is passed)</span><span class="s3">\n    </span><span class="s1">for(iteration, forBody) {</span><span class="s3">\n        </span><span class="s1">return this._for(new ForLoop(iteration), forBody);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `for` statement for a range of values</span><span class="s3">\n    </span><span class="s1">forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {</span><span class="s3">\n        </span><span class="s1">const name = this._scope.toName(nameOrPrefix);</span><span class="s3">\n        </span><span class="s1">return this._for(new ForRange(varKind, name, from, to), () =&gt; forBody(name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `for-of` statement (in es5 mode replace with a normal for loop)</span><span class="s3">\n    </span><span class="s1">forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {</span><span class="s3">\n        </span><span class="s1">const name = this._scope.toName(nameOrPrefix);</span><span class="s3">\n        </span><span class="s1">if (this.opts.es5) {</span><span class="s3">\n            </span><span class="s1">const arr = iterable instanceof code_1.Name ? iterable : this.var(</span><span class="s3">\&quot;</span><span class="s1">_arr</span><span class="s3">\&quot;</span><span class="s1">, iterable);</span><span class="s3">\n            </span><span class="s1">return this.forRange(</span><span class="s3">\&quot;</span><span class="s1">_i</span><span class="s3">\&quot;</span><span class="s1">, 0, (0, code_1._) `${arr}.length`, (i) =&gt; {</span><span class="s3">\n                </span><span class="s1">this.var(name, (0, code_1._) `${arr}[${i}]`);</span><span class="s3">\n                </span><span class="s1">forBody(name);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._for(new ForIter(</span><span class="s3">\&quot;</span><span class="s1">of</span><span class="s3">\&quot;</span><span class="s1">, varKind, name, iterable), () =&gt; forBody(name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `for-in` statement.</span><span class="s3">\n    </span><span class="s1">// With option `ownProperties` replaced with a `for-of` loop for object keys</span><span class="s3">\n    </span><span class="s1">forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {</span><span class="s3">\n        </span><span class="s1">if (this.opts.ownProperties) {</span><span class="s3">\n            </span><span class="s1">return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const name = this._scope.toName(nameOrPrefix);</span><span class="s3">\n        </span><span class="s1">return this._for(new ForIter(</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, varKind, name, obj), () =&gt; forBody(name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// end `for` loop</span><span class="s3">\n    </span><span class="s1">endFor() {</span><span class="s3">\n        </span><span class="s1">return this._endBlockNode(For);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `label` statement</span><span class="s3">\n    </span><span class="s1">label(label) {</span><span class="s3">\n        </span><span class="s1">return this._leafNode(new Label(label));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `break` statement</span><span class="s3">\n    </span><span class="s1">break(label) {</span><span class="s3">\n        </span><span class="s1">return this._leafNode(new Break(label));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `return` statement</span><span class="s3">\n    </span><span class="s1">return(value) {</span><span class="s3">\n        </span><span class="s1">const node = new Return();</span><span class="s3">\n        </span><span class="s1">this._blockNode(node);</span><span class="s3">\n        </span><span class="s1">this.code(value);</span><span class="s3">\n        </span><span class="s1">if (node.nodes.length !== 1)</span><span class="s3">\n            </span><span class="s1">throw new Error('CodeGen: </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">should have one node');</span><span class="s3">\n        </span><span class="s1">return this._endBlockNode(Return);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `try` statement</span><span class="s3">\n    </span><span class="s1">try(tryBody, catchCode, finallyCode) {</span><span class="s3">\n        </span><span class="s1">if (!catchCode &amp;&amp; !finallyCode)</span><span class="s3">\n            </span><span class="s1">throw new Error('CodeGen: </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot; </span><span class="s1">without </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n        </span><span class="s1">const node = new Try();</span><span class="s3">\n        </span><span class="s1">this._blockNode(node);</span><span class="s3">\n        </span><span class="s1">this.code(tryBody);</span><span class="s3">\n        </span><span class="s1">if (catchCode) {</span><span class="s3">\n            </span><span class="s1">const error = this.name(</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this._currNode = node.catch = new Catch(error);</span><span class="s3">\n            </span><span class="s1">catchCode(error);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (finallyCode) {</span><span class="s3">\n            </span><span class="s1">this._currNode = node.finally = new Finally();</span><span class="s3">\n            </span><span class="s1">this.code(finallyCode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._endBlockNode(Catch, Finally);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `throw` statement</span><span class="s3">\n    </span><span class="s1">throw(error) {</span><span class="s3">\n        </span><span class="s1">return this._leafNode(new Throw(error));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// start self-balancing block</span><span class="s3">\n    </span><span class="s1">block(body, nodeCount) {</span><span class="s3">\n        </span><span class="s1">this._blockStarts.push(this._nodes.length);</span><span class="s3">\n        </span><span class="s1">if (body)</span><span class="s3">\n            </span><span class="s1">this.code(body).endBlock(nodeCount);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// end the current self-balancing block</span><span class="s3">\n    </span><span class="s1">endBlock(nodeCount) {</span><span class="s3">\n        </span><span class="s1">const len = this._blockStarts.pop();</span><span class="s3">\n        </span><span class="s1">if (len === undefined)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">CodeGen: not in self-balancing block</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const toClose = this._nodes.length - len;</span><span class="s3">\n        </span><span class="s1">if (toClose &lt; 0 || (nodeCount !== undefined &amp;&amp; toClose !== nodeCount)) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._nodes.length = len;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `function` heading (or definition if funcBody is passed)</span><span class="s3">\n    </span><span class="s1">func(name, args = code_1.nil, async, funcBody) {</span><span class="s3">\n        </span><span class="s1">this._blockNode(new Func(name, args, async));</span><span class="s3">\n        </span><span class="s1">if (funcBody)</span><span class="s3">\n            </span><span class="s1">this.code(funcBody).endFunc();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// end function definition</span><span class="s3">\n    </span><span class="s1">endFunc() {</span><span class="s3">\n        </span><span class="s1">return this._endBlockNode(Func);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optimize(n = 1) {</span><span class="s3">\n        </span><span class="s1">while (n-- &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this._root.optimizeNodes();</span><span class="s3">\n            </span><span class="s1">this._root.optimizeNames(this._root.names, this._constants);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_leafNode(node) {</span><span class="s3">\n        </span><span class="s1">this._currNode.nodes.push(node);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_blockNode(node) {</span><span class="s3">\n        </span><span class="s1">this._currNode.nodes.push(node);</span><span class="s3">\n        </span><span class="s1">this._nodes.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_endBlockNode(N1, N2) {</span><span class="s3">\n        </span><span class="s1">const n = this._currNode;</span><span class="s3">\n        </span><span class="s1">if (n instanceof N1 || (N2 &amp;&amp; n instanceof N2)) {</span><span class="s3">\n            </span><span class="s1">this._nodes.pop();</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw new Error(`CodeGen: not in block </span><span class="s3">\&quot;</span><span class="s1">${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_elseNode(node) {</span><span class="s3">\n        </span><span class="s1">const n = this._currNode;</span><span class="s3">\n        </span><span class="s1">if (!(n instanceof If)) {</span><span class="s3">\n            </span><span class="s1">throw new Error('CodeGen: </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot; </span><span class="s1">without </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._currNode = n.else = node;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get _root() {</span><span class="s3">\n        </span><span class="s1">return this._nodes[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get _currNode() {</span><span class="s3">\n        </span><span class="s1">const ns = this._nodes;</span><span class="s3">\n        </span><span class="s1">return ns[ns.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set _currNode(node) {</span><span class="s3">\n        </span><span class="s1">const ns = this._nodes;</span><span class="s3">\n        </span><span class="s1">ns[ns.length - 1] = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.CodeGen = CodeGen;</span><span class="s3">\n</span><span class="s1">function addNames(names, from) {</span><span class="s3">\n    </span><span class="s1">for (const n in from)</span><span class="s3">\n        </span><span class="s1">names[n] = (names[n] || 0) + (from[n] || 0);</span><span class="s3">\n    </span><span class="s1">return names;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addExprNames(names, from) {</span><span class="s3">\n    </span><span class="s1">return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function optimizeExpr(expr, names, constants) {</span><span class="s3">\n    </span><span class="s1">if (expr instanceof code_1.Name)</span><span class="s3">\n        </span><span class="s1">return replaceName(expr);</span><span class="s3">\n    </span><span class="s1">if (!canOptimize(expr))</span><span class="s3">\n        </span><span class="s1">return expr;</span><span class="s3">\n    </span><span class="s1">return new code_1._Code(expr._items.reduce((items, c) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (c instanceof code_1.Name)</span><span class="s3">\n            </span><span class="s1">c = replaceName(c);</span><span class="s3">\n        </span><span class="s1">if (c instanceof code_1._Code)</span><span class="s3">\n            </span><span class="s1">items.push(...c._items);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">items.push(c);</span><span class="s3">\n        </span><span class="s1">return items;</span><span class="s3">\n    </span><span class="s1">}, []));</span><span class="s3">\n    </span><span class="s1">function replaceName(n) {</span><span class="s3">\n        </span><span class="s1">const c = constants[n.str];</span><span class="s3">\n        </span><span class="s1">if (c === undefined || names[n.str] !== 1)</span><span class="s3">\n            </span><span class="s1">return n;</span><span class="s3">\n        </span><span class="s1">delete names[n.str];</span><span class="s3">\n        </span><span class="s1">return c;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function canOptimize(e) {</span><span class="s3">\n        </span><span class="s1">return (e instanceof code_1._Code &amp;&amp;</span><span class="s3">\n            </span><span class="s1">e._items.some((c) =&gt; c instanceof code_1.Name &amp;&amp; names[c.str] === 1 &amp;&amp; constants[c.str] !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function subtractNames(names, from) {</span><span class="s3">\n    </span><span class="s1">for (const n in from)</span><span class="s3">\n        </span><span class="s1">names[n] = (names[n] || 0) - (from[n] || 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function not(x) {</span><span class="s3">\n    </span><span class="s1">return typeof x == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">|| typeof x == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| x === null ? !x : (0, code_1._) `!${par(x)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.not = not;</span><span class="s3">\n</span><span class="s1">const andCode = mappend(exports.operators.AND);</span><span class="s3">\n</span><span class="s1">// boolean AND (&amp;&amp;) expression with the passed arguments</span><span class="s3">\n</span><span class="s1">function and(...args) {</span><span class="s3">\n    </span><span class="s1">return args.reduce(andCode);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.and = and;</span><span class="s3">\n</span><span class="s1">const orCode = mappend(exports.operators.OR);</span><span class="s3">\n</span><span class="s1">// boolean OR (||) expression with the passed arguments</span><span class="s3">\n</span><span class="s1">function or(...args) {</span><span class="s3">\n    </span><span class="s1">return args.reduce(orCode);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.or = or;</span><span class="s3">\n</span><span class="s1">function mappend(op) {</span><span class="s3">\n    </span><span class="s1">return (x, y) =&gt; (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function par(x) {</span><span class="s3">\n    </span><span class="s1">return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">class ValueError extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(name) {</span><span class="s3">\n        </span><span class="s1">super(`CodeGen: </span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot; </span><span class="s1">for ${name} not defined`);</span><span class="s3">\n        </span><span class="s1">this.value = name.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var UsedValueState;</span><span class="s3">\n</span><span class="s1">(function (UsedValueState) {</span><span class="s3">\n    </span><span class="s1">UsedValueState[UsedValueState[</span><span class="s3">\&quot;</span><span class="s1">Started</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Started</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">UsedValueState[UsedValueState[</span><span class="s3">\&quot;</span><span class="s1">Completed</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Completed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));</span><span class="s3">\n</span><span class="s1">exports.varKinds = {</span><span class="s3">\n    </span><span class="s1">const: new code_1.Name(</span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">let: new code_1.Name(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">var: new code_1.Name(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class Scope {</span><span class="s3">\n    </span><span class="s1">constructor({ prefixes, parent } = {}) {</span><span class="s3">\n        </span><span class="s1">this._names = {};</span><span class="s3">\n        </span><span class="s1">this._prefixes = prefixes;</span><span class="s3">\n        </span><span class="s1">this._parent = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toName(nameOrPrefix) {</span><span class="s3">\n        </span><span class="s1">return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">name(prefix) {</span><span class="s3">\n        </span><span class="s1">return new code_1.Name(this._newName(prefix));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_newName(prefix) {</span><span class="s3">\n        </span><span class="s1">const ng = this._names[prefix] || this._nameGroup(prefix);</span><span class="s3">\n        </span><span class="s1">return `${prefix}${ng.index++}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_nameGroup(prefix) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes &amp;&amp; !this._prefixes.has(prefix))) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`CodeGen: prefix </span><span class="s3">\&quot;</span><span class="s1">${prefix}</span><span class="s3">\&quot; </span><span class="s1">is not allowed in this scope`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (this._names[prefix] = { prefix, index: 0 });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Scope = Scope;</span><span class="s3">\n</span><span class="s1">class ValueScopeName extends code_1.Name {</span><span class="s3">\n    </span><span class="s1">constructor(prefix, nameStr) {</span><span class="s3">\n        </span><span class="s1">super(nameStr);</span><span class="s3">\n        </span><span class="s1">this.prefix = prefix;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setValue(value, { property, itemIndex }) {</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n        </span><span class="s1">this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ValueScopeName = ValueScopeName;</span><span class="s3">\n</span><span class="s1">const line = (0, code_1._) `</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n</span><span class="s1">class ValueScope extends Scope {</span><span class="s3">\n    </span><span class="s1">constructor(opts) {</span><span class="s3">\n        </span><span class="s1">super(opts);</span><span class="s3">\n        </span><span class="s1">this._values = {};</span><span class="s3">\n        </span><span class="s1">this._scope = opts.scope;</span><span class="s3">\n        </span><span class="s1">this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get() {</span><span class="s3">\n        </span><span class="s1">return this._scope;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">name(prefix) {</span><span class="s3">\n        </span><span class="s1">return new ValueScopeName(prefix, this._newName(prefix));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">value(nameOrPrefix, value) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (value.ref === undefined)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">CodeGen: ref must be passed in value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const name = this.toName(nameOrPrefix);</span><span class="s3">\n        </span><span class="s1">const { prefix } = name;</span><span class="s3">\n        </span><span class="s1">const valueKey = (_a = value.key) !== null &amp;&amp; _a !== void 0 ? _a : value.ref;</span><span class="s3">\n        </span><span class="s1">let vs = this._values[prefix];</span><span class="s3">\n        </span><span class="s1">if (vs) {</span><span class="s3">\n            </span><span class="s1">const _name = vs.get(valueKey);</span><span class="s3">\n            </span><span class="s1">if (_name)</span><span class="s3">\n                </span><span class="s1">return _name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">vs = this._values[prefix] = new Map();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">vs.set(valueKey, name);</span><span class="s3">\n        </span><span class="s1">const s = this._scope[prefix] || (this._scope[prefix] = []);</span><span class="s3">\n        </span><span class="s1">const itemIndex = s.length;</span><span class="s3">\n        </span><span class="s1">s[itemIndex] = value.ref;</span><span class="s3">\n        </span><span class="s1">name.setValue(value, { property: prefix, itemIndex });</span><span class="s3">\n        </span><span class="s1">return name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getValue(prefix, keyOrRef) {</span><span class="s3">\n        </span><span class="s1">const vs = this._values[prefix];</span><span class="s3">\n        </span><span class="s1">if (!vs)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">return vs.get(keyOrRef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scopeRefs(scopeName, values = this._values) {</span><span class="s3">\n        </span><span class="s1">return this._reduceValues(values, (name) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (name.scopePath === undefined)</span><span class="s3">\n                </span><span class="s1">throw new Error(`CodeGen: name </span><span class="s3">\&quot;</span><span class="s1">${name}</span><span class="s3">\&quot; </span><span class="s1">has no value`);</span><span class="s3">\n            </span><span class="s1">return (0, code_1._) `${scopeName}${name.scopePath}`;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scopeCode(values = this._values, usedValues, getCode) {</span><span class="s3">\n        </span><span class="s1">return this._reduceValues(values, (name) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (name.value === undefined)</span><span class="s3">\n                </span><span class="s1">throw new Error(`CodeGen: name </span><span class="s3">\&quot;</span><span class="s1">${name}</span><span class="s3">\&quot; </span><span class="s1">has no value`);</span><span class="s3">\n            </span><span class="s1">return name.value.code;</span><span class="s3">\n        </span><span class="s1">}, usedValues, getCode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_reduceValues(values, valueCode, usedValues = {}, getCode) {</span><span class="s3">\n        </span><span class="s1">let code = code_1.nil;</span><span class="s3">\n        </span><span class="s1">for (const prefix in values) {</span><span class="s3">\n            </span><span class="s1">const vs = values[prefix];</span><span class="s3">\n            </span><span class="s1">if (!vs)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());</span><span class="s3">\n            </span><span class="s1">vs.forEach((name) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (nameSet.has(name))</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">nameSet.set(name, UsedValueState.Started);</span><span class="s3">\n                </span><span class="s1">let c = valueCode(name);</span><span class="s3">\n                </span><span class="s1">if (c) {</span><span class="s3">\n                    </span><span class="s1">const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;</span><span class="s3">\n                    </span><span class="s1">code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {</span><span class="s3">\n                    </span><span class="s1">code = (0, code_1._) `${code}${c}${this.opts._n}`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw new ValueError(name);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">nameSet.set(name, UsedValueState.Completed);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ValueScope = ValueScope;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=scope.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">exports.keywordError = {</span><span class="s3">\n    </span><span class="s1">message: ({ keyword }) =&gt; (0, codegen_1.str) `must pass </span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">keyword validation`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.keyword$DataError = {</span><span class="s3">\n    </span><span class="s1">message: ({ keyword, schemaType }) =&gt; schemaType</span><span class="s3">\n        </span><span class="s1">? (0, codegen_1.str) `</span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">keyword must be ${schemaType} ($data)`</span><span class="s3">\n        </span><span class="s1">: (0, codegen_1.str) `</span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">keyword is invalid ($data)`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {</span><span class="s3">\n    </span><span class="s1">const { it } = cxt;</span><span class="s3">\n    </span><span class="s1">const { gen, compositeRule, allErrors } = it;</span><span class="s3">\n    </span><span class="s1">const errObj = errorObjectCode(cxt, error, errorPaths);</span><span class="s3">\n    </span><span class="s1">if (overrideAllErrors !== null &amp;&amp; overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {</span><span class="s3">\n        </span><span class="s1">addError(gen, errObj);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">returnErrors(it, (0, codegen_1._) `[${errObj}]`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.reportError = reportError;</span><span class="s3">\n</span><span class="s1">function reportExtraError(cxt, error = exports.keywordError, errorPaths) {</span><span class="s3">\n    </span><span class="s1">const { it } = cxt;</span><span class="s3">\n    </span><span class="s1">const { gen, compositeRule, allErrors } = it;</span><span class="s3">\n    </span><span class="s1">const errObj = errorObjectCode(cxt, error, errorPaths);</span><span class="s3">\n    </span><span class="s1">addError(gen, errObj);</span><span class="s3">\n    </span><span class="s1">if (!(compositeRule || allErrors)) {</span><span class="s3">\n        </span><span class="s1">returnErrors(it, names_1.default.vErrors);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.reportExtraError = reportExtraError;</span><span class="s3">\n</span><span class="s1">function resetErrorsCount(gen, errsCount) {</span><span class="s3">\n    </span><span class="s1">gen.assign(names_1.default.errors, errsCount);</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () =&gt; gen.if(errsCount, () =&gt; gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () =&gt; gen.assign(names_1.default.vErrors, null)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.resetErrorsCount = resetErrorsCount;</span><span class="s3">\n</span><span class="s1">function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n    </span><span class="s1">if (errsCount === undefined)</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const err = gen.name(</span><span class="s3">\&quot;</span><span class="s1">err</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">gen.forRange(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">, errsCount, names_1.default.errors, (i) =&gt; {</span><span class="s3">\n        </span><span class="s1">gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () =&gt; gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));</span><span class="s3">\n        </span><span class="s1">gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);</span><span class="s3">\n        </span><span class="s1">if (it.opts.verbose) {</span><span class="s3">\n            </span><span class="s1">gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);</span><span class="s3">\n            </span><span class="s1">gen.assign((0, codegen_1._) `${err}.data`, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.extendErrors = extendErrors;</span><span class="s3">\n</span><span class="s1">function addError(gen, errObj) {</span><span class="s3">\n    </span><span class="s1">const err = gen.const(</span><span class="s3">\&quot;</span><span class="s1">err</span><span class="s3">\&quot;</span><span class="s1">, errObj);</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () =&gt; gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);</span><span class="s3">\n    </span><span class="s1">gen.code((0, codegen_1._) `${names_1.default.errors}++`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function returnErrors(it, errs) {</span><span class="s3">\n    </span><span class="s1">const { gen, validateName, schemaEnv } = it;</span><span class="s3">\n    </span><span class="s1">if (schemaEnv.$async) {</span><span class="s3">\n        </span><span class="s1">gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">gen.assign((0, codegen_1._) `${validateName}.errors`, errs);</span><span class="s3">\n        </span><span class="s1">gen.return(false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const E = {</span><span class="s3">\n    </span><span class="s1">keyword: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">schemaPath: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">schemaPath</span><span class="s3">\&quot;</span><span class="s1">), // also used in JTD errors</span><span class="s3">\n    </span><span class="s1">params: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">propertyName: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">propertyName</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">message: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">message</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">schema: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">parentSchema: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">parentSchema</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function errorObjectCode(cxt, error, errorPaths) {</span><span class="s3">\n    </span><span class="s1">const { createErrors } = cxt.it;</span><span class="s3">\n    </span><span class="s1">if (createErrors === false)</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1._) `{}`;</span><span class="s3">\n    </span><span class="s1">return errorObject(cxt, error, errorPaths);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function errorObject(cxt, error, errorPaths = {}) {</span><span class="s3">\n    </span><span class="s1">const { gen, it } = cxt;</span><span class="s3">\n    </span><span class="s1">const keyValues = [</span><span class="s3">\n        </span><span class="s1">errorInstancePath(it, errorPaths),</span><span class="s3">\n        </span><span class="s1">errorSchemaPath(cxt, errorPaths),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">extraErrorProps(cxt, error, keyValues);</span><span class="s3">\n    </span><span class="s1">return gen.object(...keyValues);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function errorInstancePath({ errorPath }, { instancePath }) {</span><span class="s3">\n    </span><span class="s1">const instPath = instancePath</span><span class="s3">\n        </span><span class="s1">? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`</span><span class="s3">\n        </span><span class="s1">: errorPath;</span><span class="s3">\n    </span><span class="s1">return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {</span><span class="s3">\n    </span><span class="s1">let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;</span><span class="s3">\n    </span><span class="s1">if (schemaPath) {</span><span class="s3">\n        </span><span class="s1">schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [E.schemaPath, schPath];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function extraErrorProps(cxt, { params, message }, keyValues) {</span><span class="s3">\n    </span><span class="s1">const { keyword, data, schemaValue, it } = cxt;</span><span class="s3">\n    </span><span class="s1">const { opts, propertyName, topSchemaRef, schemaPath } = it;</span><span class="s3">\n    </span><span class="s1">keyValues.push([E.keyword, keyword], [E.params, typeof params == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? params(cxt) : params || (0, codegen_1._) `{}`]);</span><span class="s3">\n    </span><span class="s1">if (opts.messages) {</span><span class="s3">\n        </span><span class="s1">keyValues.push([E.message, typeof message == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? message(cxt) : message]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (opts.verbose) {</span><span class="s3">\n        </span><span class="s1">keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (propertyName)</span><span class="s3">\n        </span><span class="s1">keyValues.push([E.propertyName, propertyName]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=errors.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const validation_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../runtime/validation_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const resolve_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./resolve</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const validate_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./validate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">class SchemaEnv {</span><span class="s3">\n    </span><span class="s1">constructor(env) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.refs = {};</span><span class="s3">\n        </span><span class="s1">this.dynamicAnchors = {};</span><span class="s3">\n        </span><span class="s1">let schema;</span><span class="s3">\n        </span><span class="s1">if (typeof env.schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">schema = env.schema;</span><span class="s3">\n        </span><span class="s1">this.schema = env.schema;</span><span class="s3">\n        </span><span class="s1">this.schemaId = env.schemaId;</span><span class="s3">\n        </span><span class="s1">this.root = env.root || this;</span><span class="s3">\n        </span><span class="s1">this.baseId = (_a = env.baseId) !== null &amp;&amp; _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || </span><span class="s3">\&quot;</span><span class="s1">$id</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">this.schemaPath = env.schemaPath;</span><span class="s3">\n        </span><span class="s1">this.localRefs = env.localRefs;</span><span class="s3">\n        </span><span class="s1">this.meta = env.meta;</span><span class="s3">\n        </span><span class="s1">this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;</span><span class="s3">\n        </span><span class="s1">this.refs = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.SchemaEnv = SchemaEnv;</span><span class="s3">\n</span><span class="s1">// let codeSize = 0</span><span class="s3">\n</span><span class="s1">// let nodeCount = 0</span><span class="s3">\n</span><span class="s1">// Compiles schema in SchemaEnv</span><span class="s3">\n</span><span class="s1">function compileSchema(sch) {</span><span class="s3">\n    </span><span class="s1">// TODO refactor - remove compilations</span><span class="s3">\n    </span><span class="s1">const _sch = getCompilingSchema.call(this, sch);</span><span class="s3">\n    </span><span class="s1">if (_sch)</span><span class="s3">\n        </span><span class="s1">return _sch;</span><span class="s3">\n    </span><span class="s1">const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails</span><span class="s3">\n    </span><span class="s1">const { es5, lines } = this.opts.code;</span><span class="s3">\n    </span><span class="s1">const { ownProperties } = this.opts;</span><span class="s3">\n    </span><span class="s1">const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });</span><span class="s3">\n    </span><span class="s1">let _ValidationError;</span><span class="s3">\n    </span><span class="s1">if (sch.$async) {</span><span class="s3">\n        </span><span class="s1">_ValidationError = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">Error</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">ref: validation_error_1.default,</span><span class="s3">\n            </span><span class="s1">code: (0, codegen_1._) `require(</span><span class="s3">\&quot;</span><span class="s1">ajv/dist/runtime/validation_error</span><span class="s3">\&quot;</span><span class="s1">).default`,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const validateName = gen.scopeName(</span><span class="s3">\&quot;</span><span class="s1">validate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">sch.validateName = validateName;</span><span class="s3">\n    </span><span class="s1">const schemaCxt = {</span><span class="s3">\n        </span><span class="s1">gen,</span><span class="s3">\n        </span><span class="s1">allErrors: this.opts.allErrors,</span><span class="s3">\n        </span><span class="s1">data: names_1.default.data,</span><span class="s3">\n        </span><span class="s1">parentData: names_1.default.parentData,</span><span class="s3">\n        </span><span class="s1">parentDataProperty: names_1.default.parentDataProperty,</span><span class="s3">\n        </span><span class="s1">dataNames: [names_1.default.data],</span><span class="s3">\n        </span><span class="s1">dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?</span><span class="s3">\n        </span><span class="s1">dataLevel: 0,</span><span class="s3">\n        </span><span class="s1">dataTypes: [],</span><span class="s3">\n        </span><span class="s1">definedProperties: new Set(),</span><span class="s3">\n        </span><span class="s1">topSchemaRef: gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot;</span><span class="s1">, this.opts.code.source === true</span><span class="s3">\n            </span><span class="s1">? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }</span><span class="s3">\n            </span><span class="s1">: { ref: sch.schema }),</span><span class="s3">\n        </span><span class="s1">validateName,</span><span class="s3">\n        </span><span class="s1">ValidationError: _ValidationError,</span><span class="s3">\n        </span><span class="s1">schema: sch.schema,</span><span class="s3">\n        </span><span class="s1">schemaEnv: sch,</span><span class="s3">\n        </span><span class="s1">rootId,</span><span class="s3">\n        </span><span class="s1">baseId: sch.baseId || rootId,</span><span class="s3">\n        </span><span class="s1">schemaPath: codegen_1.nil,</span><span class="s3">\n        </span><span class="s1">errSchemaPath: sch.schemaPath || (this.opts.jtd ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">errorPath: (0, codegen_1._) `</span><span class="s3">\&quot;\&quot;</span><span class="s1">`,</span><span class="s3">\n        </span><span class="s1">opts: this.opts,</span><span class="s3">\n        </span><span class="s1">self: this,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">let sourceCode;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">this._compilations.add(sch);</span><span class="s3">\n        </span><span class="s1">(0, validate_1.validateFunctionCode)(schemaCxt);</span><span class="s3">\n        </span><span class="s1">gen.optimize(this.opts.code.optimize);</span><span class="s3">\n        </span><span class="s1">// gen.optimize(1)</span><span class="s3">\n        </span><span class="s1">const validateCode = gen.toString();</span><span class="s3">\n        </span><span class="s1">sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;</span><span class="s3">\n        </span><span class="s1">// console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))</span><span class="s3">\n        </span><span class="s1">if (this.opts.code.process)</span><span class="s3">\n            </span><span class="s1">sourceCode = this.opts.code.process(sourceCode, sch);</span><span class="s3">\n        </span><span class="s1">// console.log(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n *** </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, sourceCode)</span><span class="s3">\n        </span><span class="s1">const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);</span><span class="s3">\n        </span><span class="s1">const validate = makeValidate(this, this.scope.get());</span><span class="s3">\n        </span><span class="s1">this.scope.value(validateName, { ref: validate });</span><span class="s3">\n        </span><span class="s1">validate.errors = null;</span><span class="s3">\n        </span><span class="s1">validate.schema = sch.schema;</span><span class="s3">\n        </span><span class="s1">validate.schemaEnv = sch;</span><span class="s3">\n        </span><span class="s1">if (sch.$async)</span><span class="s3">\n            </span><span class="s1">validate.$async = true;</span><span class="s3">\n        </span><span class="s1">if (this.opts.code.source === true) {</span><span class="s3">\n            </span><span class="s1">validate.source = { validateName, validateCode, scopeValues: gen._values };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.opts.unevaluated) {</span><span class="s3">\n            </span><span class="s1">const { props, items } = schemaCxt;</span><span class="s3">\n            </span><span class="s1">validate.evaluated = {</span><span class="s3">\n                </span><span class="s1">props: props instanceof codegen_1.Name ? undefined : props,</span><span class="s3">\n                </span><span class="s1">items: items instanceof codegen_1.Name ? undefined : items,</span><span class="s3">\n                </span><span class="s1">dynamicProps: props instanceof codegen_1.Name,</span><span class="s3">\n                </span><span class="s1">dynamicItems: items instanceof codegen_1.Name,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">if (validate.source)</span><span class="s3">\n                </span><span class="s1">validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">sch.validate = validate;</span><span class="s3">\n        </span><span class="s1">return sch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (e) {</span><span class="s3">\n        </span><span class="s1">delete sch.validate;</span><span class="s3">\n        </span><span class="s1">delete sch.validateName;</span><span class="s3">\n        </span><span class="s1">if (sourceCode)</span><span class="s3">\n            </span><span class="s1">this.logger.error(</span><span class="s3">\&quot;</span><span class="s1">Error compiling schema, function code:</span><span class="s3">\&quot;</span><span class="s1">, sourceCode);</span><span class="s3">\n        </span><span class="s1">// console.log(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n *** </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, sourceCode, this.opts)</span><span class="s3">\n        </span><span class="s1">throw e;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finally {</span><span class="s3">\n        </span><span class="s1">this._compilations.delete(sch);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.compileSchema = compileSchema;</span><span class="s3">\n</span><span class="s1">function resolveRef(root, baseId, ref) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);</span><span class="s3">\n    </span><span class="s1">const schOrFunc = root.refs[ref];</span><span class="s3">\n    </span><span class="s1">if (schOrFunc)</span><span class="s3">\n        </span><span class="s1">return schOrFunc;</span><span class="s3">\n    </span><span class="s1">let _sch = resolve.call(this, root, ref);</span><span class="s3">\n    </span><span class="s1">if (_sch === undefined) {</span><span class="s3">\n        </span><span class="s1">const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv</span><span class="s3">\n        </span><span class="s1">const { schemaId } = this.opts;</span><span class="s3">\n        </span><span class="s1">if (schema)</span><span class="s3">\n            </span><span class="s1">_sch = new SchemaEnv({ schema, schemaId, root, baseId });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (_sch === undefined)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">return (root.refs[ref] = inlineOrCompile.call(this, _sch));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.resolveRef = resolveRef;</span><span class="s3">\n</span><span class="s1">function inlineOrCompile(sch) {</span><span class="s3">\n    </span><span class="s1">if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))</span><span class="s3">\n        </span><span class="s1">return sch.schema;</span><span class="s3">\n    </span><span class="s1">return sch.validate ? sch : compileSchema.call(this, sch);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Index of schema compilation in the currently compiled list</span><span class="s3">\n</span><span class="s1">function getCompilingSchema(schEnv) {</span><span class="s3">\n    </span><span class="s1">for (const sch of this._compilations) {</span><span class="s3">\n        </span><span class="s1">if (sameSchemaEnv(sch, schEnv))</span><span class="s3">\n            </span><span class="s1">return sch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getCompilingSchema = getCompilingSchema;</span><span class="s3">\n</span><span class="s1">function sameSchemaEnv(s1, s2) {</span><span class="s3">\n    </span><span class="s1">return s1.schema === s2.schema &amp;&amp; s1.root === s2.root &amp;&amp; s1.baseId === s2.baseId;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// resolve and compile the references ($ref)</span><span class="s3">\n</span><span class="s1">// TODO returns AnySchemaObject (if the schema can be inlined) or validation function</span><span class="s3">\n</span><span class="s1">function resolve(root, // information about the root schema for the current schema</span><span class="s3">\n</span><span class="s1">ref // reference to resolve</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let sch;</span><span class="s3">\n    </span><span class="s1">while (typeof (sch = this.refs[ref]) == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">ref = sch;</span><span class="s3">\n    </span><span class="s1">return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Resolve schema, its root and baseId</span><span class="s3">\n</span><span class="s1">function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it</span><span class="s3">\n</span><span class="s1">ref // reference to resolve</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const p = this.opts.uriResolver.parse(ref);</span><span class="s3">\n    </span><span class="s1">const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);</span><span class="s3">\n    </span><span class="s1">let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);</span><span class="s3">\n    </span><span class="s1">// TODO `Object.keys(root.schema).length &gt; 0` should not be needed - but removing breaks 2 tests</span><span class="s3">\n    </span><span class="s1">if (Object.keys(root.schema).length &gt; 0 &amp;&amp; refPath === baseId) {</span><span class="s3">\n        </span><span class="s1">return getJsonPointer.call(this, p, root);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const id = (0, resolve_1.normalizeId)(refPath);</span><span class="s3">\n    </span><span class="s1">const schOrRef = this.refs[id] || this.schemas[id];</span><span class="s3">\n    </span><span class="s1">if (typeof schOrRef == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const sch = resolveSchema.call(this, root, schOrRef);</span><span class="s3">\n        </span><span class="s1">if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">return getJsonPointer.call(this, p, sch);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (!schOrRef.validate)</span><span class="s3">\n        </span><span class="s1">compileSchema.call(this, schOrRef);</span><span class="s3">\n    </span><span class="s1">if (id === (0, resolve_1.normalizeId)(ref)) {</span><span class="s3">\n        </span><span class="s1">const { schema } = schOrRef;</span><span class="s3">\n        </span><span class="s1">const { schemaId } = this.opts;</span><span class="s3">\n        </span><span class="s1">const schId = schema[schemaId];</span><span class="s3">\n        </span><span class="s1">if (schId)</span><span class="s3">\n            </span><span class="s1">baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);</span><span class="s3">\n        </span><span class="s1">return new SchemaEnv({ schema, schemaId, root, baseId });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return getJsonPointer.call(this, p, schOrRef);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.resolveSchema = resolveSchema;</span><span class="s3">\n</span><span class="s1">const PREVENT_SCOPE_CHANGE = new Set([</span><span class="s3">\n    \&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">patternProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">dependencies</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">definitions</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">function getJsonPointer(parsedRef, { baseId, schema, root }) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">for (const part of parsedRef.fragment.slice(1).split(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (typeof schema === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const partSchema = schema[(0, util_1.unescapeFragment)(part)];</span><span class="s3">\n        </span><span class="s1">if (partSchema === undefined)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">schema = partSchema;</span><span class="s3">\n        </span><span class="s1">// TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?</span><span class="s3">\n        </span><span class="s1">const schId = typeof schema === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; schema[this.opts.schemaId];</span><span class="s3">\n        </span><span class="s1">if (!PREVENT_SCOPE_CHANGE.has(part) &amp;&amp; schId) {</span><span class="s3">\n            </span><span class="s1">baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let env;</span><span class="s3">\n    </span><span class="s1">if (typeof schema != </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; schema.$ref &amp;&amp; !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {</span><span class="s3">\n        </span><span class="s1">const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);</span><span class="s3">\n        </span><span class="s1">env = resolveSchema.call(this, root, $ref);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// even though resolution failed we need to return SchemaEnv to throw exception</span><span class="s3">\n    </span><span class="s1">// so that compileAsync loads missing schema.</span><span class="s3">\n    </span><span class="s1">const { schemaId } = this.opts;</span><span class="s3">\n    </span><span class="s1">env = env || new SchemaEnv({ schema, schemaId, root, baseId });</span><span class="s3">\n    </span><span class="s1">if (env.schema !== env.root.schema)</span><span class="s3">\n        </span><span class="s1">return env;</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names = {</span><span class="s3">\n    </span><span class="s1">// validation function arguments</span><span class="s3">\n    </span><span class="s1">data: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot;</span><span class="s1">), // data passed to validation function</span><span class="s3">\n    </span><span class="s1">// args passed from referencing schema</span><span class="s3">\n    </span><span class="s1">valCxt: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">valCxt</span><span class="s3">\&quot;</span><span class="s1">), // validation/data context - should not be used directly, it is destructured to the names below</span><span class="s3">\n    </span><span class="s1">instancePath: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">instancePath</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">parentData: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">parentData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">parentDataProperty: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">parentDataProperty</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">rootData: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">rootData</span><span class="s3">\&quot;</span><span class="s1">), // root data - same as the data passed to the first/top validation function</span><span class="s3">\n    </span><span class="s1">dynamicAnchors: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">dynamicAnchors</span><span class="s3">\&quot;</span><span class="s1">), // used to support recursiveRef and dynamicRef</span><span class="s3">\n    </span><span class="s1">// function scoped variables</span><span class="s3">\n    </span><span class="s1">vErrors: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">vErrors</span><span class="s3">\&quot;</span><span class="s1">), // null or array of validation errors</span><span class="s3">\n    </span><span class="s1">errors: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">errors</span><span class="s3">\&quot;</span><span class="s1">), // counter of validation errors</span><span class="s3">\n    </span><span class="s1">this: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">globals</span><span class="s3">\&quot;\n    </span><span class="s1">self: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">self</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">scope: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">scope</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// JTD serialize/parse name for JSON string and position</span><span class="s3">\n    </span><span class="s1">json: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">jsonPos: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">jsonPos</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">jsonLen: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">jsonLen</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">jsonPart: new codegen_1.Name(</span><span class="s3">\&quot;</span><span class="s1">jsonPart</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = names;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=names.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const resolve_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./resolve</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">class MissingRefError extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(resolver, baseId, ref, msg) {</span><span class="s3">\n        </span><span class="s1">super(msg || `can't resolve reference ${ref} from id ${baseId}`);</span><span class="s3">\n        </span><span class="s1">this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);</span><span class="s3">\n        </span><span class="s1">this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.default = MissingRefError;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ref_error.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const equal = require(</span><span class="s3">\&quot;</span><span class="s1">fast-deep-equal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const traverse = require(</span><span class="s3">\&quot;</span><span class="s1">json-schema-traverse</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">// TODO refactor to use keyword definitions</span><span class="s3">\n</span><span class="s1">const SIMPLE_INLINED = new Set([</span><span class="s3">\n    \&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">maxLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">minLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">maxProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">minProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">maxItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">minItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">maximum</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">minimum</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">multipleOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">required</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">function inlineRef(schema, limit = true) {</span><span class="s3">\n    </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">if (limit === true)</span><span class="s3">\n        </span><span class="s1">return !hasRef(schema);</span><span class="s3">\n    </span><span class="s1">if (!limit)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return countKeys(schema) &lt;= limit;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.inlineRef = inlineRef;</span><span class="s3">\n</span><span class="s1">const REF_KEYWORDS = new Set([</span><span class="s3">\n    \&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$recursiveRef</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$recursiveAnchor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$dynamicRef</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$dynamicAnchor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">function hasRef(schema) {</span><span class="s3">\n    </span><span class="s1">for (const key in schema) {</span><span class="s3">\n        </span><span class="s1">if (REF_KEYWORDS.has(key))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">const sch = schema[key];</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(sch) &amp;&amp; sch.some(hasRef))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">if (typeof sch == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; hasRef(sch))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function countKeys(schema) {</span><span class="s3">\n    </span><span class="s1">let count = 0;</span><span class="s3">\n    </span><span class="s1">for (const key in schema) {</span><span class="s3">\n        </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return Infinity;</span><span class="s3">\n        </span><span class="s1">count++;</span><span class="s3">\n        </span><span class="s1">if (SIMPLE_INLINED.has(key))</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">if (typeof schema[key] == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">(0, util_1.eachItem)(schema[key], (sch) =&gt; (count += countKeys(sch)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (count === Infinity)</span><span class="s3">\n            </span><span class="s1">return Infinity;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return count;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getFullPath(resolver, id = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, normalize) {</span><span class="s3">\n    </span><span class="s1">if (normalize !== false)</span><span class="s3">\n        </span><span class="s1">id = normalizeId(id);</span><span class="s3">\n    </span><span class="s1">const p = resolver.parse(id);</span><span class="s3">\n    </span><span class="s1">return _getFullPath(resolver, p);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getFullPath = getFullPath;</span><span class="s3">\n</span><span class="s1">function _getFullPath(resolver, p) {</span><span class="s3">\n    </span><span class="s1">const serialized = resolver.serialize(p);</span><span class="s3">\n    </span><span class="s1">return serialized.split(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">)[0] + </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports._getFullPath = _getFullPath;</span><span class="s3">\n</span><span class="s1">const TRAILING_SLASH_HASH = /#</span><span class="s3">\\</span><span class="s1">/?$/;</span><span class="s3">\n</span><span class="s1">function normalizeId(id) {</span><span class="s3">\n    </span><span class="s1">return id ? id.replace(TRAILING_SLASH_HASH, </span><span class="s3">\&quot;\&quot;</span><span class="s1">) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.normalizeId = normalizeId;</span><span class="s3">\n</span><span class="s1">function resolveUrl(resolver, baseId, id) {</span><span class="s3">\n    </span><span class="s1">id = normalizeId(id);</span><span class="s3">\n    </span><span class="s1">return resolver.resolve(baseId, id);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.resolveUrl = resolveUrl;</span><span class="s3">\n</span><span class="s1">const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;</span><span class="s3">\n</span><span class="s1">function getSchemaRefs(schema, baseId) {</span><span class="s3">\n    </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return {};</span><span class="s3">\n    </span><span class="s1">const { schemaId, uriResolver } = this.opts;</span><span class="s3">\n    </span><span class="s1">const schId = normalizeId(schema[schemaId] || baseId);</span><span class="s3">\n    </span><span class="s1">const baseIds = { </span><span class="s3">\&quot;\&quot;</span><span class="s1">: schId };</span><span class="s3">\n    </span><span class="s1">const pathPrefix = getFullPath(uriResolver, schId, false);</span><span class="s3">\n    </span><span class="s1">const localRefs = {};</span><span class="s3">\n    </span><span class="s1">const schemaRefs = new Set();</span><span class="s3">\n    </span><span class="s1">traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (parentJsonPtr === undefined)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const fullPath = pathPrefix + jsonPtr;</span><span class="s3">\n        </span><span class="s1">let innerBaseId = baseIds[parentJsonPtr];</span><span class="s3">\n        </span><span class="s1">if (typeof sch[schemaId] == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">innerBaseId = addRef.call(this, sch[schemaId]);</span><span class="s3">\n        </span><span class="s1">addAnchor.call(this, sch.$anchor);</span><span class="s3">\n        </span><span class="s1">addAnchor.call(this, sch.$dynamicAnchor);</span><span class="s3">\n        </span><span class="s1">baseIds[jsonPtr] = innerBaseId;</span><span class="s3">\n        </span><span class="s1">function addRef(ref) {</span><span class="s3">\n            </span><span class="s1">// eslint-disable-next-line @typescript-eslint/unbound-method</span><span class="s3">\n            </span><span class="s1">const _resolve = this.opts.uriResolver.resolve;</span><span class="s3">\n            </span><span class="s1">ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);</span><span class="s3">\n            </span><span class="s1">if (schemaRefs.has(ref))</span><span class="s3">\n                </span><span class="s1">throw ambiguos(ref);</span><span class="s3">\n            </span><span class="s1">schemaRefs.add(ref);</span><span class="s3">\n            </span><span class="s1">let schOrRef = this.refs[ref];</span><span class="s3">\n            </span><span class="s1">if (typeof schOrRef == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">schOrRef = this.refs[schOrRef];</span><span class="s3">\n            </span><span class="s1">if (typeof schOrRef == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">checkAmbiguosRef(sch, schOrRef.schema, ref);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ref !== normalizeId(fullPath)) {</span><span class="s3">\n                </span><span class="s1">if (ref[0] === </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">checkAmbiguosRef(sch, localRefs[ref], ref);</span><span class="s3">\n                    </span><span class="s1">localRefs[ref] = sch;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.refs[ref] = fullPath;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return ref;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function addAnchor(anchor) {</span><span class="s3">\n            </span><span class="s1">if (typeof anchor == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (!ANCHOR.test(anchor))</span><span class="s3">\n                    </span><span class="s1">throw new Error(`invalid anchor </span><span class="s3">\&quot;</span><span class="s1">${anchor}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n                </span><span class="s1">addRef.call(this, `#${anchor}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return localRefs;</span><span class="s3">\n    </span><span class="s1">function checkAmbiguosRef(sch1, sch2, ref) {</span><span class="s3">\n        </span><span class="s1">if (sch2 !== undefined &amp;&amp; !equal(sch1, sch2))</span><span class="s3">\n            </span><span class="s1">throw ambiguos(ref);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function ambiguos(ref) {</span><span class="s3">\n        </span><span class="s1">return new Error(`reference </span><span class="s3">\&quot;</span><span class="s1">${ref}</span><span class="s3">\&quot; </span><span class="s1">resolves to more than one schema`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getSchemaRefs = getSchemaRefs;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=resolve.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.getRules = exports.isJSONType = void 0;</span><span class="s3">\n</span><span class="s1">const _jsonTypes = [</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const jsonTypes = new Set(_jsonTypes);</span><span class="s3">\n</span><span class="s1">function isJSONType(x) {</span><span class="s3">\n    </span><span class="s1">return typeof x == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; jsonTypes.has(x);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.isJSONType = isJSONType;</span><span class="s3">\n</span><span class="s1">function getRules() {</span><span class="s3">\n    </span><span class="s1">const groups = {</span><span class="s3">\n        </span><span class="s1">number: { type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, rules: [] },</span><span class="s3">\n        </span><span class="s1">string: { type: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, rules: [] },</span><span class="s3">\n        </span><span class="s1">array: { type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">, rules: [] },</span><span class="s3">\n        </span><span class="s1">object: { type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, rules: [] },</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">types: { ...groups, integer: true, boolean: true, null: true },</span><span class="s3">\n        </span><span class="s1">rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],</span><span class="s3">\n        </span><span class="s1">post: { rules: [] },</span><span class="s3">\n        </span><span class="s1">all: {},</span><span class="s3">\n        </span><span class="s1">keywords: {},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getRules = getRules;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=rules.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./codegen/code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">// TODO refactor to use Set</span><span class="s3">\n</span><span class="s1">function toHash(arr) {</span><span class="s3">\n    </span><span class="s1">const hash = {};</span><span class="s3">\n    </span><span class="s1">for (const item of arr)</span><span class="s3">\n        </span><span class="s1">hash[item] = true;</span><span class="s3">\n    </span><span class="s1">return hash;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.toHash = toHash;</span><span class="s3">\n</span><span class="s1">function alwaysValidSchema(it, schema) {</span><span class="s3">\n    </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return schema;</span><span class="s3">\n    </span><span class="s1">if (Object.keys(schema).length === 0)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">checkUnknownRules(it, schema);</span><span class="s3">\n    </span><span class="s1">return !schemaHasRules(schema, it.self.RULES.all);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.alwaysValidSchema = alwaysValidSchema;</span><span class="s3">\n</span><span class="s1">function checkUnknownRules(it, schema = it.schema) {</span><span class="s3">\n    </span><span class="s1">const { opts, self } = it;</span><span class="s3">\n    </span><span class="s1">if (!opts.strictSchema)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (typeof schema === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const rules = self.RULES.keywords;</span><span class="s3">\n    </span><span class="s1">for (const key in schema) {</span><span class="s3">\n        </span><span class="s1">if (!rules[key])</span><span class="s3">\n            </span><span class="s1">checkStrictMode(it, `unknown keyword: </span><span class="s3">\&quot;</span><span class="s1">${key}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.checkUnknownRules = checkUnknownRules;</span><span class="s3">\n</span><span class="s1">function schemaHasRules(schema, rules) {</span><span class="s3">\n    </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return !schema;</span><span class="s3">\n    </span><span class="s1">for (const key in schema)</span><span class="s3">\n        </span><span class="s1">if (rules[key])</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.schemaHasRules = schemaHasRules;</span><span class="s3">\n</span><span class="s1">function schemaHasRulesButRef(schema, RULES) {</span><span class="s3">\n    </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return !schema;</span><span class="s3">\n    </span><span class="s1">for (const key in schema)</span><span class="s3">\n        </span><span class="s1">if (key !== </span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; RULES.all[key])</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.schemaHasRulesButRef = schemaHasRulesButRef;</span><span class="s3">\n</span><span class="s1">function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {</span><span class="s3">\n    </span><span class="s1">if (!$data) {</span><span class="s3">\n        </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return schema;</span><span class="s3">\n        </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return (0, codegen_1._) `${schema}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.schemaRefOrVal = schemaRefOrVal;</span><span class="s3">\n</span><span class="s1">function unescapeFragment(str) {</span><span class="s3">\n    </span><span class="s1">return unescapeJsonPointer(decodeURIComponent(str));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.unescapeFragment = unescapeFragment;</span><span class="s3">\n</span><span class="s1">function escapeFragment(str) {</span><span class="s3">\n    </span><span class="s1">return encodeURIComponent(escapeJsonPointer(str));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.escapeFragment = escapeFragment;</span><span class="s3">\n</span><span class="s1">function escapeJsonPointer(str) {</span><span class="s3">\n    </span><span class="s1">if (typeof str == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return `${str}`;</span><span class="s3">\n    </span><span class="s1">return str.replace(/~/g, </span><span class="s3">\&quot;</span><span class="s1">~0</span><span class="s3">\&quot;</span><span class="s1">).replace(/</span><span class="s3">\\</span><span class="s1">//g, </span><span class="s3">\&quot;</span><span class="s1">~1</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.escapeJsonPointer = escapeJsonPointer;</span><span class="s3">\n</span><span class="s1">function unescapeJsonPointer(str) {</span><span class="s3">\n    </span><span class="s1">return str.replace(/~1/g, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">).replace(/~0/g, </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.unescapeJsonPointer = unescapeJsonPointer;</span><span class="s3">\n</span><span class="s1">function eachItem(xs, f) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(xs)) {</span><span class="s3">\n        </span><span class="s1">for (const x of xs)</span><span class="s3">\n            </span><span class="s1">f(x);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">f(xs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.eachItem = eachItem;</span><span class="s3">\n</span><span class="s1">function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {</span><span class="s3">\n    </span><span class="s1">return (gen, from, to, toName) =&gt; {</span><span class="s3">\n        </span><span class="s1">const res = to === undefined</span><span class="s3">\n            </span><span class="s1">? from</span><span class="s3">\n            </span><span class="s1">: to instanceof codegen_1.Name</span><span class="s3">\n                </span><span class="s1">? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)</span><span class="s3">\n                </span><span class="s1">: from instanceof codegen_1.Name</span><span class="s3">\n                    </span><span class="s1">? (mergeToName(gen, to, from), from)</span><span class="s3">\n                    </span><span class="s1">: mergeValues(from, to);</span><span class="s3">\n        </span><span class="s1">return toName === codegen_1.Name &amp;&amp; !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.mergeEvaluated = {</span><span class="s3">\n    </span><span class="s1">props: makeMergeEvaluated({</span><span class="s3">\n        </span><span class="s1">mergeNames: (gen, from, to) =&gt; gen.if((0, codegen_1._) `${to} !== true &amp;&amp; ${from} !== undefined`, () =&gt; {</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1._) `${from} === true`, () =&gt; gen.assign(to, true), () =&gt; gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">mergeToName: (gen, from, to) =&gt; gen.if((0, codegen_1._) `${to} !== true`, () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (from === true) {</span><span class="s3">\n                </span><span class="s1">gen.assign(to, true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">gen.assign(to, (0, codegen_1._) `${to} || {}`);</span><span class="s3">\n                </span><span class="s1">setEvaluated(gen, to, from);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">mergeValues: (from, to) =&gt; (from === true ? true : { ...from, ...to }),</span><span class="s3">\n        </span><span class="s1">resultToName: evaluatedPropsToName,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">items: makeMergeEvaluated({</span><span class="s3">\n        </span><span class="s1">mergeNames: (gen, from, to) =&gt; gen.if((0, codegen_1._) `${to} !== true &amp;&amp; ${from} !== undefined`, () =&gt; gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} &gt; ${from} ? ${to} : ${from}`)),</span><span class="s3">\n        </span><span class="s1">mergeToName: (gen, from, to) =&gt; gen.if((0, codegen_1._) `${to} !== true`, () =&gt; gen.assign(to, from === true ? true : (0, codegen_1._) `${to} &gt; ${from} ? ${to} : ${from}`)),</span><span class="s3">\n        </span><span class="s1">mergeValues: (from, to) =&gt; (from === true ? true : Math.max(from, to)),</span><span class="s3">\n        </span><span class="s1">resultToName: (gen, items) =&gt; gen.var(</span><span class="s3">\&quot;</span><span class="s1">items</span><span class="s3">\&quot;</span><span class="s1">, items),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function evaluatedPropsToName(gen, ps) {</span><span class="s3">\n    </span><span class="s1">if (ps === true)</span><span class="s3">\n        </span><span class="s1">return gen.var(</span><span class="s3">\&quot;</span><span class="s1">props</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">const props = gen.var(</span><span class="s3">\&quot;</span><span class="s1">props</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `{}`);</span><span class="s3">\n    </span><span class="s1">if (ps !== undefined)</span><span class="s3">\n        </span><span class="s1">setEvaluated(gen, props, ps);</span><span class="s3">\n    </span><span class="s1">return props;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.evaluatedPropsToName = evaluatedPropsToName;</span><span class="s3">\n</span><span class="s1">function setEvaluated(gen, props, ps) {</span><span class="s3">\n    </span><span class="s1">Object.keys(ps).forEach((p) =&gt; gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.setEvaluated = setEvaluated;</span><span class="s3">\n</span><span class="s1">const snippets = {};</span><span class="s3">\n</span><span class="s1">function useFunc(gen, f) {</span><span class="s3">\n    </span><span class="s1">return gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n        </span><span class="s1">ref: f,</span><span class="s3">\n        </span><span class="s1">code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.useFunc = useFunc;</span><span class="s3">\n</span><span class="s1">var Type;</span><span class="s3">\n</span><span class="s1">(function (Type) {</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Num</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Num</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Str</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Str</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(Type || (exports.Type = Type = {}));</span><span class="s3">\n</span><span class="s1">function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {</span><span class="s3">\n    </span><span class="s1">// let path</span><span class="s3">\n    </span><span class="s1">if (dataProp instanceof codegen_1.Name) {</span><span class="s3">\n        </span><span class="s1">const isNumber = dataPropType === Type.Num;</span><span class="s3">\n        </span><span class="s1">return jsPropertySyntax</span><span class="s3">\n            </span><span class="s1">? isNumber</span><span class="s3">\n                </span><span class="s1">? (0, codegen_1._) `</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ ${dataProp} + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n                </span><span class="s1">: (0, codegen_1._) `</span><span class="s3">\&quot;</span><span class="s1">['</span><span class="s3">\&quot; </span><span class="s1">+ ${dataProp} + </span><span class="s3">\&quot;</span><span class="s1">']</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n            </span><span class="s1">: isNumber</span><span class="s3">\n                </span><span class="s1">? (0, codegen_1._) `</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ ${dataProp}`</span><span class="s3">\n                </span><span class="s1">: (0, codegen_1._) `</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ ${dataProp}.replace(/~/g, </span><span class="s3">\&quot;</span><span class="s1">~0</span><span class="s3">\&quot;</span><span class="s1">).replace(/</span><span class="s3">\\\\</span><span class="s1">//g, </span><span class="s3">\&quot;</span><span class="s1">~1</span><span class="s3">\&quot;</span><span class="s1">)`; // TODO maybe use global escapePointer</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ escapeJsonPointer(dataProp);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getErrorPath = getErrorPath;</span><span class="s3">\n</span><span class="s1">function checkStrictMode(it, msg, mode = it.opts.strictSchema) {</span><span class="s3">\n    </span><span class="s1">if (!mode)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">msg = `strict mode: ${msg}`;</span><span class="s3">\n    </span><span class="s1">if (mode === true)</span><span class="s3">\n        </span><span class="s1">throw new Error(msg);</span><span class="s3">\n    </span><span class="s1">it.self.logger.warn(msg);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.checkStrictMode = checkStrictMode;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=util.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;</span><span class="s3">\n</span><span class="s1">function schemaHasRulesForType({ schema, self }, type) {</span><span class="s3">\n    </span><span class="s1">const group = self.RULES.types[type];</span><span class="s3">\n    </span><span class="s1">return group &amp;&amp; group !== true &amp;&amp; shouldUseGroup(schema, group);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.schemaHasRulesForType = schemaHasRulesForType;</span><span class="s3">\n</span><span class="s1">function shouldUseGroup(schema, group) {</span><span class="s3">\n    </span><span class="s1">return group.rules.some((rule) =&gt; shouldUseRule(schema, rule));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.shouldUseGroup = shouldUseGroup;</span><span class="s3">\n</span><span class="s1">function shouldUseRule(schema, rule) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">return (schema[rule.keyword] !== undefined ||</span><span class="s3">\n        </span><span class="s1">((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) =&gt; schema[kwd] !== undefined)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.shouldUseRule = shouldUseRule;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=applicability.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;</span><span class="s3">\n</span><span class="s1">const errors_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../errors</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const boolError = {</span><span class="s3">\n    </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">boolean schema is false</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function topBoolOrEmptySchema(it) {</span><span class="s3">\n    </span><span class="s1">const { gen, schema, validateName } = it;</span><span class="s3">\n    </span><span class="s1">if (schema === false) {</span><span class="s3">\n        </span><span class="s1">falseSchemaError(it, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; schema.$async === true) {</span><span class="s3">\n        </span><span class="s1">gen.return(names_1.default.data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">gen.assign((0, codegen_1._) `${validateName}.errors`, null);</span><span class="s3">\n        </span><span class="s1">gen.return(true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.topBoolOrEmptySchema = topBoolOrEmptySchema;</span><span class="s3">\n</span><span class="s1">function boolOrEmptySchema(it, valid) {</span><span class="s3">\n    </span><span class="s1">const { gen, schema } = it;</span><span class="s3">\n    </span><span class="s1">if (schema === false) {</span><span class="s3">\n        </span><span class="s1">gen.var(valid, false); // TODO var</span><span class="s3">\n        </span><span class="s1">falseSchemaError(it);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">gen.var(valid, true); // TODO var</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.boolOrEmptySchema = boolOrEmptySchema;</span><span class="s3">\n</span><span class="s1">function falseSchemaError(it, overrideAllErrors) {</span><span class="s3">\n    </span><span class="s1">const { gen, data } = it;</span><span class="s3">\n    </span><span class="s1">// TODO maybe some other interface should be used for non-keyword validation errors...</span><span class="s3">\n    </span><span class="s1">const cxt = {</span><span class="s3">\n        </span><span class="s1">gen,</span><span class="s3">\n        </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">false schema</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">data,</span><span class="s3">\n        </span><span class="s1">schema: false,</span><span class="s3">\n        </span><span class="s1">schemaCode: false,</span><span class="s3">\n        </span><span class="s1">schemaValue: false,</span><span class="s3">\n        </span><span class="s1">params: {},</span><span class="s3">\n        </span><span class="s1">it,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">(0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=boolSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;</span><span class="s3">\n</span><span class="s1">const rules_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../rules</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const applicability_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./applicability</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const errors_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../errors</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var DataType;</span><span class="s3">\n</span><span class="s1">(function (DataType) {</span><span class="s3">\n    </span><span class="s1">DataType[DataType[</span><span class="s3">\&quot;</span><span class="s1">Correct</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Correct</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">DataType[DataType[</span><span class="s3">\&quot;</span><span class="s1">Wrong</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Wrong</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(DataType || (exports.DataType = DataType = {}));</span><span class="s3">\n</span><span class="s1">function getSchemaTypes(schema) {</span><span class="s3">\n    </span><span class="s1">const types = getJSONTypes(schema.type);</span><span class="s3">\n    </span><span class="s1">const hasNull = types.includes(</span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (hasNull) {</span><span class="s3">\n        </span><span class="s1">if (schema.nullable === false)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">type: null contradicts nullable: false</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">if (!types.length &amp;&amp; schema.nullable !== undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">nullable</span><span class="s3">\&quot; </span><span class="s1">cannot be used without </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (schema.nullable === true)</span><span class="s3">\n            </span><span class="s1">types.push(</span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return types;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getSchemaTypes = getSchemaTypes;</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents</span><span class="s3">\n</span><span class="s1">function getJSONTypes(ts) {</span><span class="s3">\n    </span><span class="s1">const types = Array.isArray(ts) ? ts : ts ? [ts] : [];</span><span class="s3">\n    </span><span class="s1">if (types.every(rules_1.isJSONType))</span><span class="s3">\n        </span><span class="s1">return types;</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">type must be JSONType or JSONType[]: </span><span class="s3">\&quot; </span><span class="s1">+ types.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getJSONTypes = getJSONTypes;</span><span class="s3">\n</span><span class="s1">function coerceAndCheckDataType(it, types) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, opts } = it;</span><span class="s3">\n    </span><span class="s1">const coerceTo = coerceToTypes(types, opts.coerceTypes);</span><span class="s3">\n    </span><span class="s1">const checkTypes = types.length &gt; 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(coerceTo.length === 0 &amp;&amp; types.length === 1 &amp;&amp; (0, applicability_1.schemaHasRulesForType)(it, types[0]));</span><span class="s3">\n    </span><span class="s1">if (checkTypes) {</span><span class="s3">\n        </span><span class="s1">const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);</span><span class="s3">\n        </span><span class="s1">gen.if(wrongType, () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (coerceTo.length)</span><span class="s3">\n                </span><span class="s1">coerceData(it, types, coerceTo);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">reportTypeError(it);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return checkTypes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.coerceAndCheckDataType = coerceAndCheckDataType;</span><span class="s3">\n</span><span class="s1">const COERCIBLE = new Set([</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">function coerceToTypes(types, coerceTypes) {</span><span class="s3">\n    </span><span class="s1">return coerceTypes</span><span class="s3">\n        </span><span class="s1">? types.filter((t) =&gt; COERCIBLE.has(t) || (coerceTypes === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; t === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">: [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function coerceData(it, types, coerceTo) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, opts } = it;</span><span class="s3">\n    </span><span class="s1">const dataType = gen.let(</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `typeof ${data}`);</span><span class="s3">\n    </span><span class="s1">const coerced = gen.let(</span><span class="s3">\&quot;</span><span class="s1">coerced</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `undefined`);</span><span class="s3">\n    </span><span class="s1">if (opts.coerceTypes === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1._) `${dataType} == 'object' &amp;&amp; Array.isArray(${data}) &amp;&amp; ${data}.length == 1`, () =&gt; gen</span><span class="s3">\n            </span><span class="s1">.assign(data, (0, codegen_1._) `${data}[0]`)</span><span class="s3">\n            </span><span class="s1">.assign(dataType, (0, codegen_1._) `typeof ${data}`)</span><span class="s3">\n            </span><span class="s1">.if(checkDataTypes(types, data, opts.strictNumbers), () =&gt; gen.assign(coerced, data)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${coerced} !== undefined`);</span><span class="s3">\n    </span><span class="s1">for (const t of coerceTo) {</span><span class="s3">\n        </span><span class="s1">if (COERCIBLE.has(t) || (t === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; opts.coerceTypes === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">coerceSpecificType(t);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gen.else();</span><span class="s3">\n    </span><span class="s1">reportTypeError(it);</span><span class="s3">\n    </span><span class="s1">gen.endIf();</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${coerced} !== undefined`, () =&gt; {</span><span class="s3">\n        </span><span class="s1">gen.assign(data, coerced);</span><span class="s3">\n        </span><span class="s1">assignParentData(it, coerced);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function coerceSpecificType(t) {</span><span class="s3">\n        </span><span class="s1">switch (t) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">gen</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${dataType} == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| ${dataType} == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, (0, codegen_1._) `</span><span class="s3">\&quot;\&quot; </span><span class="s1">+ ${data}`)</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${data} === null`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, (0, codegen_1._) `</span><span class="s3">\&quot;\&quot;</span><span class="s1">`);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">gen</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${dataType} == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">|| ${data} === null</span><span class="s3">\n              </span><span class="s1">|| (${dataType} == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ${data} &amp;&amp; ${data} == +${data})`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, (0, codegen_1._) `+${data}`);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">gen</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${dataType} === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">|| ${data} === null</span><span class="s3">\n              </span><span class="s1">|| (${dataType} === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ${data} &amp;&amp; ${data} == +${data} &amp;&amp; !(${data} % 1))`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, (0, codegen_1._) `+${data}`);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">gen</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${data} === </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot; </span><span class="s1">|| ${data} === 0 || ${data} === null`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, false)</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${data} === </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">|| ${data} === 1`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, true);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">gen.elseIf((0, codegen_1._) `${data} === </span><span class="s3">\&quot;\&quot; </span><span class="s1">|| ${data} === 0 || ${data} === false`);</span><span class="s3">\n                </span><span class="s1">gen.assign(coerced, null);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">gen</span><span class="s3">\n                    </span><span class="s1">.elseIf((0, codegen_1._) `${dataType} === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| ${dataType} === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;\n              </span><span class="s1">|| ${dataType} === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">|| ${data} === null`)</span><span class="s3">\n                    </span><span class="s1">.assign(coerced, (0, codegen_1._) `[${data}]`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function assignParentData({ gen, parentData, parentDataProperty }, expr) {</span><span class="s3">\n    </span><span class="s1">// TODO use gen.property</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${parentData} !== undefined`, () =&gt; gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {</span><span class="s3">\n    </span><span class="s1">const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;</span><span class="s3">\n    </span><span class="s1">let cond;</span><span class="s3">\n    </span><span class="s1">switch (dataType) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">return (0, codegen_1._) `${data} ${EQ} null`;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">cond = (0, codegen_1._) `Array.isArray(${data})`;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">cond = (0, codegen_1._) `${data} &amp;&amp; typeof ${data} == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !Array.isArray(${data})`;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">cond = numCond((0, codegen_1._) `!(${data} % 1) &amp;&amp; !isNaN(${data})`);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">cond = numCond();</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);</span><span class="s3">\n    </span><span class="s1">function numCond(_cond = codegen_1.nil) {</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.checkDataType = checkDataType;</span><span class="s3">\n</span><span class="s1">function checkDataTypes(dataTypes, data, strictNums, correct) {</span><span class="s3">\n    </span><span class="s1">if (dataTypes.length === 1) {</span><span class="s3">\n        </span><span class="s1">return checkDataType(dataTypes[0], data, strictNums, correct);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let cond;</span><span class="s3">\n    </span><span class="s1">const types = (0, util_1.toHash)(dataTypes);</span><span class="s3">\n    </span><span class="s1">if (types.array &amp;&amp; types.object) {</span><span class="s3">\n        </span><span class="s1">const notObj = (0, codegen_1._) `typeof ${data} != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n        </span><span class="s1">cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;</span><span class="s3">\n        </span><span class="s1">delete types.null;</span><span class="s3">\n        </span><span class="s1">delete types.array;</span><span class="s3">\n        </span><span class="s1">delete types.object;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">cond = codegen_1.nil;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (types.number)</span><span class="s3">\n        </span><span class="s1">delete types.integer;</span><span class="s3">\n    </span><span class="s1">for (const t in types)</span><span class="s3">\n        </span><span class="s1">cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));</span><span class="s3">\n    </span><span class="s1">return cond;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.checkDataTypes = checkDataTypes;</span><span class="s3">\n</span><span class="s1">const typeError = {</span><span class="s3">\n    </span><span class="s1">message: ({ schema }) =&gt; `must be ${schema}`,</span><span class="s3">\n    </span><span class="s1">params: ({ schema, schemaValue }) =&gt; typeof schema == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function reportTypeError(it) {</span><span class="s3">\n    </span><span class="s1">const cxt = getTypeErrorContext(it);</span><span class="s3">\n    </span><span class="s1">(0, errors_1.reportError)(cxt, typeError);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.reportTypeError = reportTypeError;</span><span class="s3">\n</span><span class="s1">function getTypeErrorContext(it) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, schema } = it;</span><span class="s3">\n    </span><span class="s1">const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">gen,</span><span class="s3">\n        </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">data,</span><span class="s3">\n        </span><span class="s1">schema: schema.type,</span><span class="s3">\n        </span><span class="s1">schemaCode,</span><span class="s3">\n        </span><span class="s1">schemaValue: schemaCode,</span><span class="s3">\n        </span><span class="s1">parentSchema: schema,</span><span class="s3">\n        </span><span class="s1">params: {},</span><span class="s3">\n        </span><span class="s1">it,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=dataType.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.assignDefaults = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function assignDefaults(it, ty) {</span><span class="s3">\n    </span><span class="s1">const { properties, items } = it.schema;</span><span class="s3">\n    </span><span class="s1">if (ty === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; properties) {</span><span class="s3">\n        </span><span class="s1">for (const key in properties) {</span><span class="s3">\n            </span><span class="s1">assignDefault(it, key, properties[key].default);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ty === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; Array.isArray(items)) {</span><span class="s3">\n        </span><span class="s1">items.forEach((sch, i) =&gt; assignDefault(it, i, sch.default));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.assignDefaults = assignDefaults;</span><span class="s3">\n</span><span class="s1">function assignDefault(it, prop, defaultValue) {</span><span class="s3">\n    </span><span class="s1">const { gen, compositeRule, data, opts } = it;</span><span class="s3">\n    </span><span class="s1">if (defaultValue === undefined)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;</span><span class="s3">\n    </span><span class="s1">if (compositeRule) {</span><span class="s3">\n        </span><span class="s1">(0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let condition = (0, codegen_1._) `${childData} === undefined`;</span><span class="s3">\n    </span><span class="s1">if (opts.useDefaults === </span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === </span><span class="s3">\&quot;\&quot;</span><span class="s1">`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `${childData} === undefined` +</span><span class="s3">\n    </span><span class="s1">// (opts.useDefaults === </span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot; </span><span class="s1">? ` || ${childData} === null || ${childData} === </span><span class="s3">\&quot;\&quot;</span><span class="s1">` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=defaults.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;</span><span class="s3">\n</span><span class="s1">const boolSchema_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./boolSchema</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const dataType_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./dataType</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const applicability_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./applicability</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const dataType_2 = require(</span><span class="s3">\&quot;</span><span class="s1">./dataType</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const defaults_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./defaults</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const keyword_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./keyword</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const subschema_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./subschema</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const resolve_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../resolve</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const errors_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../errors</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">// schema compilation - generates validation function, subschemaCode (below) is used for subschemas</span><span class="s3">\n</span><span class="s1">function validateFunctionCode(it) {</span><span class="s3">\n    </span><span class="s1">if (isSchemaObj(it)) {</span><span class="s3">\n        </span><span class="s1">checkKeywords(it);</span><span class="s3">\n        </span><span class="s1">if (schemaCxtHasRules(it)) {</span><span class="s3">\n            </span><span class="s1">topSchemaObjCode(it);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateFunction(it, () =&gt; (0, boolSchema_1.topBoolOrEmptySchema)(it));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateFunctionCode = validateFunctionCode;</span><span class="s3">\n</span><span class="s1">function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {</span><span class="s3">\n    </span><span class="s1">if (opts.code.es5) {</span><span class="s3">\n        </span><span class="s1">gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () =&gt; {</span><span class="s3">\n            </span><span class="s1">gen.code((0, codegen_1._) `</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">; ${funcSourceUrl(schema, opts)}`);</span><span class="s3">\n            </span><span class="s1">destructureValCxtES5(gen, opts);</span><span class="s3">\n            </span><span class="s1">gen.code(body);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =&gt; gen.code(funcSourceUrl(schema, opts)).code(body));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function destructureValCxt(opts) {</span><span class="s3">\n    </span><span class="s1">return (0, codegen_1._) `{${names_1.default.instancePath}=</span><span class="s3">\&quot;\&quot;</span><span class="s1">, ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function destructureValCxtES5(gen, opts) {</span><span class="s3">\n    </span><span class="s1">gen.if(names_1.default.valCxt, () =&gt; {</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);</span><span class="s3">\n        </span><span class="s1">if (opts.dynamicRef)</span><span class="s3">\n            </span><span class="s1">gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);</span><span class="s3">\n    </span><span class="s1">}, () =&gt; {</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.instancePath, (0, codegen_1._) `</span><span class="s3">\&quot;\&quot;</span><span class="s1">`);</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);</span><span class="s3">\n        </span><span class="s1">gen.var(names_1.default.rootData, names_1.default.data);</span><span class="s3">\n        </span><span class="s1">if (opts.dynamicRef)</span><span class="s3">\n            </span><span class="s1">gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function topSchemaObjCode(it) {</span><span class="s3">\n    </span><span class="s1">const { schema, opts, gen } = it;</span><span class="s3">\n    </span><span class="s1">validateFunction(it, () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (opts.$comment &amp;&amp; schema.$comment)</span><span class="s3">\n            </span><span class="s1">commentKeyword(it);</span><span class="s3">\n        </span><span class="s1">checkNoDefault(it);</span><span class="s3">\n        </span><span class="s1">gen.let(names_1.default.vErrors, null);</span><span class="s3">\n        </span><span class="s1">gen.let(names_1.default.errors, 0);</span><span class="s3">\n        </span><span class="s1">if (opts.unevaluated)</span><span class="s3">\n            </span><span class="s1">resetEvaluated(it);</span><span class="s3">\n        </span><span class="s1">typeAndKeywords(it);</span><span class="s3">\n        </span><span class="s1">returnResults(it);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resetEvaluated(it) {</span><span class="s3">\n    </span><span class="s1">// TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated</span><span class="s3">\n    </span><span class="s1">const { gen, validateName } = it;</span><span class="s3">\n    </span><span class="s1">it.evaluated = gen.const(</span><span class="s3">\&quot;</span><span class="s1">evaluated</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${validateName}.evaluated`);</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () =&gt; gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () =&gt; gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function funcSourceUrl(schema, opts) {</span><span class="s3">\n    </span><span class="s1">const schId = typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; schema[opts.schemaId];</span><span class="s3">\n    </span><span class="s1">return schId &amp;&amp; (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// schema compilation - this function is used recursively to generate code for sub-schemas</span><span class="s3">\n</span><span class="s1">function subschemaCode(it, valid) {</span><span class="s3">\n    </span><span class="s1">if (isSchemaObj(it)) {</span><span class="s3">\n        </span><span class="s1">checkKeywords(it);</span><span class="s3">\n        </span><span class="s1">if (schemaCxtHasRules(it)) {</span><span class="s3">\n            </span><span class="s1">subSchemaObjCode(it, valid);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">(0, boolSchema_1.boolOrEmptySchema)(it, valid);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function schemaCxtHasRules({ schema, self }) {</span><span class="s3">\n    </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return !schema;</span><span class="s3">\n    </span><span class="s1">for (const key in schema)</span><span class="s3">\n        </span><span class="s1">if (self.RULES.all[key])</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isSchemaObj(it) {</span><span class="s3">\n    </span><span class="s1">return typeof it.schema != </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function subSchemaObjCode(it, valid) {</span><span class="s3">\n    </span><span class="s1">const { schema, gen, opts } = it;</span><span class="s3">\n    </span><span class="s1">if (opts.$comment &amp;&amp; schema.$comment)</span><span class="s3">\n        </span><span class="s1">commentKeyword(it);</span><span class="s3">\n    </span><span class="s1">updateContext(it);</span><span class="s3">\n    </span><span class="s1">checkAsyncSchema(it);</span><span class="s3">\n    </span><span class="s1">const errsCount = gen.const(</span><span class="s3">\&quot;</span><span class="s1">_errs</span><span class="s3">\&quot;</span><span class="s1">, names_1.default.errors);</span><span class="s3">\n    </span><span class="s1">typeAndKeywords(it, errsCount);</span><span class="s3">\n    </span><span class="s1">// TODO var</span><span class="s3">\n    </span><span class="s1">gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkKeywords(it) {</span><span class="s3">\n    </span><span class="s1">(0, util_1.checkUnknownRules)(it);</span><span class="s3">\n    </span><span class="s1">checkRefsAndKeywords(it);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function typeAndKeywords(it, errsCount) {</span><span class="s3">\n    </span><span class="s1">if (it.opts.jtd)</span><span class="s3">\n        </span><span class="s1">return schemaKeywords(it, [], false, errsCount);</span><span class="s3">\n    </span><span class="s1">const types = (0, dataType_1.getSchemaTypes)(it.schema);</span><span class="s3">\n    </span><span class="s1">const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);</span><span class="s3">\n    </span><span class="s1">schemaKeywords(it, types, !checkedTypes, errsCount);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkRefsAndKeywords(it) {</span><span class="s3">\n    </span><span class="s1">const { schema, errSchemaPath, opts, self } = it;</span><span class="s3">\n    </span><span class="s1">if (schema.$ref &amp;&amp; opts.ignoreKeywordsWithRef &amp;&amp; (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {</span><span class="s3">\n        </span><span class="s1">self.logger.warn(`$ref: keywords ignored in schema at path </span><span class="s3">\&quot;</span><span class="s1">${errSchemaPath}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkNoDefault(it) {</span><span class="s3">\n    </span><span class="s1">const { schema, opts } = it;</span><span class="s3">\n    </span><span class="s1">if (schema.default !== undefined &amp;&amp; opts.useDefaults &amp;&amp; opts.strictSchema) {</span><span class="s3">\n        </span><span class="s1">(0, util_1.checkStrictMode)(it, </span><span class="s3">\&quot;</span><span class="s1">default is ignored in the schema root</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function updateContext(it) {</span><span class="s3">\n    </span><span class="s1">const schId = it.schema[it.opts.schemaId];</span><span class="s3">\n    </span><span class="s1">if (schId)</span><span class="s3">\n        </span><span class="s1">it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkAsyncSchema(it) {</span><span class="s3">\n    </span><span class="s1">if (it.schema.$async &amp;&amp; !it.schemaEnv.$async)</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">async schema in sync schema</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {</span><span class="s3">\n    </span><span class="s1">const msg = schema.$comment;</span><span class="s3">\n    </span><span class="s1">if (opts.$comment === true) {</span><span class="s3">\n        </span><span class="s1">gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (typeof opts.$comment == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;</span><span class="s3">\n        </span><span class="s1">const rootName = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">, { ref: schemaEnv.root });</span><span class="s3">\n        </span><span class="s1">gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function returnResults(it) {</span><span class="s3">\n    </span><span class="s1">const { gen, schemaEnv, validateName, ValidationError, opts } = it;</span><span class="s3">\n    </span><span class="s1">if (schemaEnv.$async) {</span><span class="s3">\n        </span><span class="s1">// TODO assign unevaluated</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () =&gt; gen.return(names_1.default.data), () =&gt; gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);</span><span class="s3">\n        </span><span class="s1">if (opts.unevaluated)</span><span class="s3">\n            </span><span class="s1">assignEvaluated(it);</span><span class="s3">\n        </span><span class="s1">gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function assignEvaluated({ gen, evaluated, props, items }) {</span><span class="s3">\n    </span><span class="s1">if (props instanceof codegen_1.Name)</span><span class="s3">\n        </span><span class="s1">gen.assign((0, codegen_1._) `${evaluated}.props`, props);</span><span class="s3">\n    </span><span class="s1">if (items instanceof codegen_1.Name)</span><span class="s3">\n        </span><span class="s1">gen.assign((0, codegen_1._) `${evaluated}.items`, items);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function schemaKeywords(it, types, typeErrors, errsCount) {</span><span class="s3">\n    </span><span class="s1">const { gen, schema, data, allErrors, opts, self } = it;</span><span class="s3">\n    </span><span class="s1">const { RULES } = self;</span><span class="s3">\n    </span><span class="s1">if (schema.$ref &amp;&amp; (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {</span><span class="s3">\n        </span><span class="s1">gen.block(() =&gt; keywordCode(it, </span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">, RULES.all.$ref.definition)); // TODO typecast</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!opts.jtd)</span><span class="s3">\n        </span><span class="s1">checkStrictTypes(it, types);</span><span class="s3">\n    </span><span class="s1">gen.block(() =&gt; {</span><span class="s3">\n        </span><span class="s1">for (const group of RULES.rules)</span><span class="s3">\n            </span><span class="s1">groupKeywords(group);</span><span class="s3">\n        </span><span class="s1">groupKeywords(RULES.post);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function groupKeywords(group) {</span><span class="s3">\n        </span><span class="s1">if (!(0, applicability_1.shouldUseGroup)(schema, group))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (group.type) {</span><span class="s3">\n            </span><span class="s1">gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));</span><span class="s3">\n            </span><span class="s1">iterateKeywords(it, group);</span><span class="s3">\n            </span><span class="s1">if (types.length === 1 &amp;&amp; types[0] === group.type &amp;&amp; typeErrors) {</span><span class="s3">\n                </span><span class="s1">gen.else();</span><span class="s3">\n                </span><span class="s1">(0, dataType_2.reportTypeError)(it);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">gen.endIf();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">iterateKeywords(it, group);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// TODO make it </span><span class="s3">\&quot;</span><span class="s1">ok</span><span class="s3">\&quot; </span><span class="s1">call?</span><span class="s3">\n        </span><span class="s1">if (!allErrors)</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function iterateKeywords(it, group) {</span><span class="s3">\n    </span><span class="s1">const { gen, schema, opts: { useDefaults }, } = it;</span><span class="s3">\n    </span><span class="s1">if (useDefaults)</span><span class="s3">\n        </span><span class="s1">(0, defaults_1.assignDefaults)(it, group.type);</span><span class="s3">\n    </span><span class="s1">gen.block(() =&gt; {</span><span class="s3">\n        </span><span class="s1">for (const rule of group.rules) {</span><span class="s3">\n            </span><span class="s1">if ((0, applicability_1.shouldUseRule)(schema, rule)) {</span><span class="s3">\n                </span><span class="s1">keywordCode(it, rule.keyword, rule.definition, group.type);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkStrictTypes(it, types) {</span><span class="s3">\n    </span><span class="s1">if (it.schemaEnv.meta || !it.opts.strictTypes)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">checkContextTypes(it, types);</span><span class="s3">\n    </span><span class="s1">if (!it.opts.allowUnionTypes)</span><span class="s3">\n        </span><span class="s1">checkMultipleTypes(it, types);</span><span class="s3">\n    </span><span class="s1">checkKeywordTypes(it, it.dataTypes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkContextTypes(it, types) {</span><span class="s3">\n    </span><span class="s1">if (!types.length)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (!it.dataTypes.length) {</span><span class="s3">\n        </span><span class="s1">it.dataTypes = types;</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">types.forEach((t) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!includesType(it.dataTypes, t)) {</span><span class="s3">\n            </span><span class="s1">strictTypesError(it, `type </span><span class="s3">\&quot;</span><span class="s1">${t}</span><span class="s3">\&quot; </span><span class="s1">not allowed by context </span><span class="s3">\&quot;</span><span class="s1">${it.dataTypes.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">narrowSchemaTypes(it, types);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkMultipleTypes(it, ts) {</span><span class="s3">\n    </span><span class="s1">if (ts.length &gt; 1 &amp;&amp; !(ts.length === 2 &amp;&amp; ts.includes(</span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">))) {</span><span class="s3">\n        </span><span class="s1">strictTypesError(it, </span><span class="s3">\&quot;</span><span class="s1">use allowUnionTypes to allow union type keyword</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkKeywordTypes(it, ts) {</span><span class="s3">\n    </span><span class="s1">const rules = it.self.RULES.all;</span><span class="s3">\n    </span><span class="s1">for (const keyword in rules) {</span><span class="s3">\n        </span><span class="s1">const rule = rules[keyword];</span><span class="s3">\n        </span><span class="s1">if (typeof rule == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (0, applicability_1.shouldUseRule)(it.schema, rule)) {</span><span class="s3">\n            </span><span class="s1">const { type } = rule.definition;</span><span class="s3">\n            </span><span class="s1">if (type.length &amp;&amp; !type.some((t) =&gt; hasApplicableType(ts, t))) {</span><span class="s3">\n                </span><span class="s1">strictTypesError(it, `missing type </span><span class="s3">\&quot;</span><span class="s1">${type.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}</span><span class="s3">\&quot; </span><span class="s1">for keyword </span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasApplicableType(schTs, kwdT) {</span><span class="s3">\n    </span><span class="s1">return schTs.includes(kwdT) || (kwdT === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; schTs.includes(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function includesType(ts, t) {</span><span class="s3">\n    </span><span class="s1">return ts.includes(t) || (t === </span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ts.includes(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function narrowSchemaTypes(it, withTypes) {</span><span class="s3">\n    </span><span class="s1">const ts = [];</span><span class="s3">\n    </span><span class="s1">for (const t of it.dataTypes) {</span><span class="s3">\n        </span><span class="s1">if (includesType(withTypes, t))</span><span class="s3">\n            </span><span class="s1">ts.push(t);</span><span class="s3">\n        </span><span class="s1">else if (withTypes.includes(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; t === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">ts.push(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">it.dataTypes = ts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function strictTypesError(it, msg) {</span><span class="s3">\n    </span><span class="s1">const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;</span><span class="s3">\n    </span><span class="s1">msg += ` at </span><span class="s3">\&quot;</span><span class="s1">${schemaPath}</span><span class="s3">\&quot; </span><span class="s1">(strictTypes)`;</span><span class="s3">\n    </span><span class="s1">(0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class KeywordCxt {</span><span class="s3">\n    </span><span class="s1">constructor(it, def, keyword) {</span><span class="s3">\n        </span><span class="s1">(0, keyword_1.validateKeywordUsage)(it, def, keyword);</span><span class="s3">\n        </span><span class="s1">this.gen = it.gen;</span><span class="s3">\n        </span><span class="s1">this.allErrors = it.allErrors;</span><span class="s3">\n        </span><span class="s1">this.keyword = keyword;</span><span class="s3">\n        </span><span class="s1">this.data = it.data;</span><span class="s3">\n        </span><span class="s1">this.schema = it.schema[keyword];</span><span class="s3">\n        </span><span class="s1">this.$data = def.$data &amp;&amp; it.opts.$data &amp;&amp; this.schema &amp;&amp; this.schema.$data;</span><span class="s3">\n        </span><span class="s1">this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);</span><span class="s3">\n        </span><span class="s1">this.schemaType = def.schemaType;</span><span class="s3">\n        </span><span class="s1">this.parentSchema = it.schema;</span><span class="s3">\n        </span><span class="s1">this.params = {};</span><span class="s3">\n        </span><span class="s1">this.it = it;</span><span class="s3">\n        </span><span class="s1">this.def = def;</span><span class="s3">\n        </span><span class="s1">if (this.$data) {</span><span class="s3">\n            </span><span class="s1">this.schemaCode = it.gen.const(</span><span class="s3">\&quot;</span><span class="s1">vSchema</span><span class="s3">\&quot;</span><span class="s1">, getData(this.$data, it));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.schemaCode = this.schemaValue;</span><span class="s3">\n            </span><span class="s1">if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot; </span><span class="s1">in def ? def.trackErrors : def.errors !== false) {</span><span class="s3">\n            </span><span class="s1">this.errsCount = it.gen.const(</span><span class="s3">\&quot;</span><span class="s1">_errs</span><span class="s3">\&quot;</span><span class="s1">, names_1.default.errors);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result(condition, successAction, failAction) {</span><span class="s3">\n        </span><span class="s1">this.failResult((0, codegen_1.not)(condition), successAction, failAction);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">failResult(condition, successAction, failAction) {</span><span class="s3">\n        </span><span class="s1">this.gen.if(condition);</span><span class="s3">\n        </span><span class="s1">if (failAction)</span><span class="s3">\n            </span><span class="s1">failAction();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.error();</span><span class="s3">\n        </span><span class="s1">if (successAction) {</span><span class="s3">\n            </span><span class="s1">this.gen.else();</span><span class="s3">\n            </span><span class="s1">successAction();</span><span class="s3">\n            </span><span class="s1">if (this.allErrors)</span><span class="s3">\n                </span><span class="s1">this.gen.endIf();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (this.allErrors)</span><span class="s3">\n                </span><span class="s1">this.gen.endIf();</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.gen.else();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">pass(condition, failAction) {</span><span class="s3">\n        </span><span class="s1">this.failResult((0, codegen_1.not)(condition), undefined, failAction);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fail(condition) {</span><span class="s3">\n        </span><span class="s1">if (condition === undefined) {</span><span class="s3">\n            </span><span class="s1">this.error();</span><span class="s3">\n            </span><span class="s1">if (!this.allErrors)</span><span class="s3">\n                </span><span class="s1">this.gen.if(false); // this branch will be removed by gen.optimize</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.gen.if(condition);</span><span class="s3">\n        </span><span class="s1">this.error();</span><span class="s3">\n        </span><span class="s1">if (this.allErrors)</span><span class="s3">\n            </span><span class="s1">this.gen.endIf();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.gen.else();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fail$data(condition) {</span><span class="s3">\n        </span><span class="s1">if (!this.$data)</span><span class="s3">\n            </span><span class="s1">return this.fail(condition);</span><span class="s3">\n        </span><span class="s1">const { schemaCode } = this;</span><span class="s3">\n        </span><span class="s1">this.fail((0, codegen_1._) `${schemaCode} !== undefined &amp;&amp; (${(0, codegen_1.or)(this.invalid$data(), condition)})`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">error(append, errorParams, errorPaths) {</span><span class="s3">\n        </span><span class="s1">if (errorParams) {</span><span class="s3">\n            </span><span class="s1">this.setParams(errorParams);</span><span class="s3">\n            </span><span class="s1">this._error(append, errorPaths);</span><span class="s3">\n            </span><span class="s1">this.setParams({});</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._error(append, errorPaths);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_error(append, errorPaths) {</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">$dataError() {</span><span class="s3">\n        </span><span class="s1">(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reset() {</span><span class="s3">\n        </span><span class="s1">if (this.errsCount === undefined)</span><span class="s3">\n            </span><span class="s1">throw new Error('add </span><span class="s3">\&quot;</span><span class="s1">trackErrors</span><span class="s3">\&quot; </span><span class="s1">to keyword definition');</span><span class="s3">\n        </span><span class="s1">(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ok(cond) {</span><span class="s3">\n        </span><span class="s1">if (!this.allErrors)</span><span class="s3">\n            </span><span class="s1">this.gen.if(cond);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setParams(obj, assign) {</span><span class="s3">\n        </span><span class="s1">if (assign)</span><span class="s3">\n            </span><span class="s1">Object.assign(this.params, obj);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.params = obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">block$data(valid, codeBlock, $dataValid = codegen_1.nil) {</span><span class="s3">\n        </span><span class="s1">this.gen.block(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.check$data(valid, $dataValid);</span><span class="s3">\n            </span><span class="s1">codeBlock();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {</span><span class="s3">\n        </span><span class="s1">if (!this.$data)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const { gen, schemaCode, schemaType, def } = this;</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));</span><span class="s3">\n        </span><span class="s1">if (valid !== codegen_1.nil)</span><span class="s3">\n            </span><span class="s1">gen.assign(valid, true);</span><span class="s3">\n        </span><span class="s1">if (schemaType.length || def.validateSchema) {</span><span class="s3">\n            </span><span class="s1">gen.elseIf(this.invalid$data());</span><span class="s3">\n            </span><span class="s1">this.$dataError();</span><span class="s3">\n            </span><span class="s1">if (valid !== codegen_1.nil)</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">gen.else();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">invalid$data() {</span><span class="s3">\n        </span><span class="s1">const { gen, schemaCode, schemaType, def, it } = this;</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());</span><span class="s3">\n        </span><span class="s1">function wrong$DataType() {</span><span class="s3">\n            </span><span class="s1">if (schemaType.length) {</span><span class="s3">\n                </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n                </span><span class="s1">if (!(schemaCode instanceof codegen_1.Name))</span><span class="s3">\n                    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">const st = Array.isArray(schemaType) ? schemaType : [schemaType];</span><span class="s3">\n                </span><span class="s1">return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return codegen_1.nil;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function invalid$DataSchema() {</span><span class="s3">\n            </span><span class="s1">if (def.validateSchema) {</span><span class="s3">\n                </span><span class="s1">const validateSchemaRef = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">validate$data</span><span class="s3">\&quot;</span><span class="s1">, { ref: def.validateSchema }); // TODO value.code for standalone</span><span class="s3">\n                </span><span class="s1">return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return codegen_1.nil;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subschema(appl, valid) {</span><span class="s3">\n        </span><span class="s1">const subschema = (0, subschema_1.getSubschema)(this.it, appl);</span><span class="s3">\n        </span><span class="s1">(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);</span><span class="s3">\n        </span><span class="s1">(0, subschema_1.extendSubschemaMode)(subschema, appl);</span><span class="s3">\n        </span><span class="s1">const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };</span><span class="s3">\n        </span><span class="s1">subschemaCode(nextContext, valid);</span><span class="s3">\n        </span><span class="s1">return nextContext;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mergeEvaluated(schemaCxt, toName) {</span><span class="s3">\n        </span><span class="s1">const { it, gen } = this;</span><span class="s3">\n        </span><span class="s1">if (!it.opts.unevaluated)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (it.props !== true &amp;&amp; schemaCxt.props !== undefined) {</span><span class="s3">\n            </span><span class="s1">it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (it.items !== true &amp;&amp; schemaCxt.items !== undefined) {</span><span class="s3">\n            </span><span class="s1">it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mergeValidEvaluated(schemaCxt, valid) {</span><span class="s3">\n        </span><span class="s1">const { it, gen } = this;</span><span class="s3">\n        </span><span class="s1">if (it.opts.unevaluated &amp;&amp; (it.props !== true || it.items !== true)) {</span><span class="s3">\n            </span><span class="s1">gen.if(valid, () =&gt; this.mergeEvaluated(schemaCxt, codegen_1.Name));</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.KeywordCxt = KeywordCxt;</span><span class="s3">\n</span><span class="s1">function keywordCode(it, keyword, def, ruleType) {</span><span class="s3">\n    </span><span class="s1">const cxt = new KeywordCxt(it, def, keyword);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot; </span><span class="s1">in def) {</span><span class="s3">\n        </span><span class="s1">def.code(cxt, ruleType);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (cxt.$data &amp;&amp; def.validate) {</span><span class="s3">\n        </span><span class="s1">(0, keyword_1.funcKeywordCode)(cxt, def);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (</span><span class="s3">\&quot;</span><span class="s1">macro</span><span class="s3">\&quot; </span><span class="s1">in def) {</span><span class="s3">\n        </span><span class="s1">(0, keyword_1.macroKeywordCode)(cxt, def);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (def.compile || def.validate) {</span><span class="s3">\n        </span><span class="s1">(0, keyword_1.funcKeywordCode)(cxt, def);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const JSON_POINTER = /^</span><span class="s3">\\</span><span class="s1">/(?:[^~]|~0|~1)*$/;</span><span class="s3">\n</span><span class="s1">const RELATIVE_JSON_POINTER = /^([0-9]+)(#|</span><span class="s3">\\</span><span class="s1">/(?:[^~]|~0|~1)*)?$/;</span><span class="s3">\n</span><span class="s1">function getData($data, { dataLevel, dataNames, dataPathArr }) {</span><span class="s3">\n    </span><span class="s1">let jsonPointer;</span><span class="s3">\n    </span><span class="s1">let data;</span><span class="s3">\n    </span><span class="s1">if ($data === </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return names_1.default.rootData;</span><span class="s3">\n    </span><span class="s1">if ($data[0] === </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (!JSON_POINTER.test($data))</span><span class="s3">\n            </span><span class="s1">throw new Error(`Invalid JSON-pointer: ${$data}`);</span><span class="s3">\n        </span><span class="s1">jsonPointer = $data;</span><span class="s3">\n        </span><span class="s1">data = names_1.default.rootData;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const matches = RELATIVE_JSON_POINTER.exec($data);</span><span class="s3">\n        </span><span class="s1">if (!matches)</span><span class="s3">\n            </span><span class="s1">throw new Error(`Invalid JSON-pointer: ${$data}`);</span><span class="s3">\n        </span><span class="s1">const up = +matches[1];</span><span class="s3">\n        </span><span class="s1">jsonPointer = matches[2];</span><span class="s3">\n        </span><span class="s1">if (jsonPointer === </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (up &gt;= dataLevel)</span><span class="s3">\n                </span><span class="s1">throw new Error(errorMsg(</span><span class="s3">\&quot;</span><span class="s1">property/index</span><span class="s3">\&quot;</span><span class="s1">, up));</span><span class="s3">\n            </span><span class="s1">return dataPathArr[dataLevel - up];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (up &gt; dataLevel)</span><span class="s3">\n            </span><span class="s1">throw new Error(errorMsg(</span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot;</span><span class="s1">, up));</span><span class="s3">\n        </span><span class="s1">data = dataNames[dataLevel - up];</span><span class="s3">\n        </span><span class="s1">if (!jsonPointer)</span><span class="s3">\n            </span><span class="s1">return data;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let expr = data;</span><span class="s3">\n    </span><span class="s1">const segments = jsonPointer.split(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const segment of segments) {</span><span class="s3">\n        </span><span class="s1">if (segment) {</span><span class="s3">\n            </span><span class="s1">data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;</span><span class="s3">\n            </span><span class="s1">expr = (0, codegen_1._) `${expr} &amp;&amp; ${data}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return expr;</span><span class="s3">\n    </span><span class="s1">function errorMsg(pointerType, up) {</span><span class="s3">\n        </span><span class="s1">return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getData = getData;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../vocabularies/code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const errors_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../errors</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function macroKeywordCode(cxt, def) {</span><span class="s3">\n    </span><span class="s1">const { gen, keyword, schema, parentSchema, it } = cxt;</span><span class="s3">\n    </span><span class="s1">const macroSchema = def.macro.call(it.self, schema, parentSchema, it);</span><span class="s3">\n    </span><span class="s1">const schemaRef = useKeyword(gen, keyword, macroSchema);</span><span class="s3">\n    </span><span class="s1">if (it.opts.validateSchema !== false)</span><span class="s3">\n        </span><span class="s1">it.self.validateSchema(macroSchema, true);</span><span class="s3">\n    </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">cxt.subschema({</span><span class="s3">\n        </span><span class="s1">schema: macroSchema,</span><span class="s3">\n        </span><span class="s1">schemaPath: codegen_1.nil,</span><span class="s3">\n        </span><span class="s1">errSchemaPath: `${it.errSchemaPath}/${keyword}`,</span><span class="s3">\n        </span><span class="s1">topSchemaRef: schemaRef,</span><span class="s3">\n        </span><span class="s1">compositeRule: true,</span><span class="s3">\n    </span><span class="s1">}, valid);</span><span class="s3">\n    </span><span class="s1">cxt.pass(valid, () =&gt; cxt.error(true));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.macroKeywordCode = macroKeywordCode;</span><span class="s3">\n</span><span class="s1">function funcKeywordCode(cxt, def) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const { gen, keyword, schema, parentSchema, $data, it } = cxt;</span><span class="s3">\n    </span><span class="s1">checkAsyncKeyword(it, def);</span><span class="s3">\n    </span><span class="s1">const validate = !$data &amp;&amp; def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;</span><span class="s3">\n    </span><span class="s1">const validateRef = useKeyword(gen, keyword, validate);</span><span class="s3">\n    </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">cxt.block$data(valid, validateKeyword);</span><span class="s3">\n    </span><span class="s1">cxt.ok((_a = def.valid) !== null &amp;&amp; _a !== void 0 ? _a : valid);</span><span class="s3">\n    </span><span class="s1">function validateKeyword() {</span><span class="s3">\n        </span><span class="s1">if (def.errors === false) {</span><span class="s3">\n            </span><span class="s1">assignValid();</span><span class="s3">\n            </span><span class="s1">if (def.modifying)</span><span class="s3">\n                </span><span class="s1">modifyData(cxt);</span><span class="s3">\n            </span><span class="s1">reportErrs(() =&gt; cxt.error());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const ruleErrs = def.async ? validateAsync() : validateSync();</span><span class="s3">\n            </span><span class="s1">if (def.modifying)</span><span class="s3">\n                </span><span class="s1">modifyData(cxt);</span><span class="s3">\n            </span><span class="s1">reportErrs(() =&gt; addErrs(cxt, ruleErrs));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function validateAsync() {</span><span class="s3">\n        </span><span class="s1">const ruleErrs = gen.let(</span><span class="s3">\&quot;</span><span class="s1">ruleErrs</span><span class="s3">\&quot;</span><span class="s1">, null);</span><span class="s3">\n        </span><span class="s1">gen.try(() =&gt; assignValid((0, codegen_1._) `await `), (e) =&gt; gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () =&gt; gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () =&gt; gen.throw(e)));</span><span class="s3">\n        </span><span class="s1">return ruleErrs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function validateSync() {</span><span class="s3">\n        </span><span class="s1">const validateErrs = (0, codegen_1._) `${validateRef}.errors`;</span><span class="s3">\n        </span><span class="s1">gen.assign(validateErrs, null);</span><span class="s3">\n        </span><span class="s1">assignValid(codegen_1.nil);</span><span class="s3">\n        </span><span class="s1">return validateErrs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {</span><span class="s3">\n        </span><span class="s1">const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;</span><span class="s3">\n        </span><span class="s1">const passSchema = !((</span><span class="s3">\&quot;</span><span class="s1">compile</span><span class="s3">\&quot; </span><span class="s1">in def &amp;&amp; !$data) || def.schema === false);</span><span class="s3">\n        </span><span class="s1">gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function reportErrs(errors) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1.not)((_a = def.valid) !== null &amp;&amp; _a !== void 0 ? _a : valid), errors);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.funcKeywordCode = funcKeywordCode;</span><span class="s3">\n</span><span class="s1">function modifyData(cxt) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, it } = cxt;</span><span class="s3">\n    </span><span class="s1">gen.if(it.parentData, () =&gt; gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addErrs(cxt, errs) {</span><span class="s3">\n    </span><span class="s1">const { gen } = cxt;</span><span class="s3">\n    </span><span class="s1">gen.if((0, codegen_1._) `Array.isArray(${errs})`, () =&gt; {</span><span class="s3">\n        </span><span class="s1">gen</span><span class="s3">\n            </span><span class="s1">.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)</span><span class="s3">\n            </span><span class="s1">.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);</span><span class="s3">\n        </span><span class="s1">(0, errors_1.extendErrors)(cxt);</span><span class="s3">\n    </span><span class="s1">}, () =&gt; cxt.error());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkAsyncKeyword({ schemaEnv }, def) {</span><span class="s3">\n    </span><span class="s1">if (def.async &amp;&amp; !schemaEnv.$async)</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">async keyword in sync schema</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useKeyword(gen, keyword, result) {</span><span class="s3">\n    </span><span class="s1">if (result === undefined)</span><span class="s3">\n        </span><span class="s1">throw new Error(`keyword </span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">failed to compile`);</span><span class="s3">\n    </span><span class="s1">return gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">, typeof result == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validSchemaType(schema, schemaType, allowUndefined = false) {</span><span class="s3">\n    </span><span class="s1">// TODO add tests</span><span class="s3">\n    </span><span class="s1">return (!schemaType.length ||</span><span class="s3">\n        </span><span class="s1">schemaType.some((st) =&gt; st === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;\n            </span><span class="s1">? Array.isArray(schema)</span><span class="s3">\n            </span><span class="s1">: st === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;\n                </span><span class="s1">? schema &amp;&amp; typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !Array.isArray(schema)</span><span class="s3">\n                </span><span class="s1">: typeof schema == st || (allowUndefined &amp;&amp; typeof schema == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validSchemaType = validSchemaType;</span><span class="s3">\n</span><span class="s1">function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const deps = def.dependencies;</span><span class="s3">\n    </span><span class="s1">if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) =&gt; !Object.prototype.hasOwnProperty.call(schema, kwd))) {</span><span class="s3">\n        </span><span class="s1">throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (def.validateSchema) {</span><span class="s3">\n        </span><span class="s1">const valid = def.validateSchema(schema[keyword]);</span><span class="s3">\n        </span><span class="s1">if (!valid) {</span><span class="s3">\n            </span><span class="s1">const msg = `keyword </span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">value is invalid at path </span><span class="s3">\&quot;</span><span class="s1">${errSchemaPath}</span><span class="s3">\&quot;</span><span class="s1">: ` +</span><span class="s3">\n                </span><span class="s1">self.errorsText(def.validateSchema.errors);</span><span class="s3">\n            </span><span class="s1">if (opts.validateSchema === </span><span class="s3">\&quot;</span><span class="s1">log</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">self.logger.error(msg);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">throw new Error(msg);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateKeywordUsage = validateKeywordUsage;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=keyword.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {</span><span class="s3">\n    </span><span class="s1">if (keyword !== undefined &amp;&amp; schema !== undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error('both </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot; </span><span class="s1">passed, only one allowed');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (keyword !== undefined) {</span><span class="s3">\n        </span><span class="s1">const sch = it.schema[keyword];</span><span class="s3">\n        </span><span class="s1">return schemaProp === undefined</span><span class="s3">\n            </span><span class="s1">? {</span><span class="s3">\n                </span><span class="s1">schema: sch,</span><span class="s3">\n                </span><span class="s1">schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,</span><span class="s3">\n                </span><span class="s1">errSchemaPath: `${it.errSchemaPath}/${keyword}`,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">schema: sch[schemaProp],</span><span class="s3">\n                </span><span class="s1">schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,</span><span class="s3">\n                </span><span class="s1">errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schema !== undefined) {</span><span class="s3">\n        </span><span class="s1">if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">schemaPath</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">errSchemaPath</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">topSchemaRef</span><span class="s3">\&quot; </span><span class="s1">are required with </span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">schema,</span><span class="s3">\n            </span><span class="s1">schemaPath,</span><span class="s3">\n            </span><span class="s1">topSchemaRef,</span><span class="s3">\n            </span><span class="s1">errSchemaPath,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error('either </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot; </span><span class="s1">must be passed');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getSubschema = getSubschema;</span><span class="s3">\n</span><span class="s1">function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {</span><span class="s3">\n    </span><span class="s1">if (data !== undefined &amp;&amp; dataProp !== undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error('both </span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">dataProp</span><span class="s3">\&quot; </span><span class="s1">passed, only one allowed');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { gen } = it;</span><span class="s3">\n    </span><span class="s1">if (dataProp !== undefined) {</span><span class="s3">\n        </span><span class="s1">const { errorPath, dataPathArr, opts } = it;</span><span class="s3">\n        </span><span class="s1">const nextData = gen.let(</span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);</span><span class="s3">\n        </span><span class="s1">dataContextProps(nextData);</span><span class="s3">\n        </span><span class="s1">subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;</span><span class="s3">\n        </span><span class="s1">subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;</span><span class="s3">\n        </span><span class="s1">subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (data !== undefined) {</span><span class="s3">\n        </span><span class="s1">const nextData = data instanceof codegen_1.Name ? data : gen.let(</span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot;</span><span class="s1">, data, true); // replaceable if used once?</span><span class="s3">\n        </span><span class="s1">dataContextProps(nextData);</span><span class="s3">\n        </span><span class="s1">if (propertyName !== undefined)</span><span class="s3">\n            </span><span class="s1">subschema.propertyName = propertyName;</span><span class="s3">\n        </span><span class="s1">// TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (dataTypes)</span><span class="s3">\n        </span><span class="s1">subschema.dataTypes = dataTypes;</span><span class="s3">\n    </span><span class="s1">function dataContextProps(_nextData) {</span><span class="s3">\n        </span><span class="s1">subschema.data = _nextData;</span><span class="s3">\n        </span><span class="s1">subschema.dataLevel = it.dataLevel + 1;</span><span class="s3">\n        </span><span class="s1">subschema.dataTypes = [];</span><span class="s3">\n        </span><span class="s1">it.definedProperties = new Set();</span><span class="s3">\n        </span><span class="s1">subschema.parentData = it.data;</span><span class="s3">\n        </span><span class="s1">subschema.dataNames = [...it.dataNames, _nextData];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.extendSubschemaData = extendSubschemaData;</span><span class="s3">\n</span><span class="s1">function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {</span><span class="s3">\n    </span><span class="s1">if (compositeRule !== undefined)</span><span class="s3">\n        </span><span class="s1">subschema.compositeRule = compositeRule;</span><span class="s3">\n    </span><span class="s1">if (createErrors !== undefined)</span><span class="s3">\n        </span><span class="s1">subschema.createErrors = createErrors;</span><span class="s3">\n    </span><span class="s1">if (allErrors !== undefined)</span><span class="s3">\n        </span><span class="s1">subschema.allErrors = allErrors;</span><span class="s3">\n    </span><span class="s1">subschema.jtdDiscriminator = jtdDiscriminator; // not inherited</span><span class="s3">\n    </span><span class="s1">subschema.jtdMetadata = jtdMetadata; // not inherited</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.extendSubschemaMode = extendSubschemaMode;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=subschema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;</span><span class="s3">\n</span><span class="s1">var validate_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/validate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">KeywordCxt</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return validate_1.KeywordCxt; } });</span><span class="s3">\n</span><span class="s1">var codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1._; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">str</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.str; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">stringify</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.stringify; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">nil</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.nil; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Name</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.Name; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CodeGen</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return codegen_1.CodeGen; } });</span><span class="s3">\n</span><span class="s1">const validation_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./runtime/validation_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ref_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/ref_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const rules_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/rules</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const compile_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_2 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const resolve_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/resolve</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const dataType_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/validate/dataType</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const $dataRefSchema = require(</span><span class="s3">\&quot;</span><span class="s1">./refs/data.json</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const uri_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./runtime/uri</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const defaultRegExp = (str, flags) =&gt; new RegExp(str, flags);</span><span class="s3">\n</span><span class="s1">defaultRegExp.code = </span><span class="s3">\&quot;</span><span class="s1">new RegExp</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const META_IGNORE_OPTIONS = [</span><span class="s3">\&quot;</span><span class="s1">removeAdditional</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">useDefaults</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">coerceTypes</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const EXT_SCOPE_NAMES = new Set([</span><span class="s3">\n    \&quot;</span><span class="s1">validate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">serialize</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">parse</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">wrapper</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">schema</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">formats</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">validate$data</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">obj</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">Error</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">const removedOptions = {</span><span class="s3">\n    </span><span class="s1">errorDataPath: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">format: </span><span class="s3">\&quot;</span><span class="s1">`validateFormats: false` can be used instead.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">nullable: '</span><span class="s3">\&quot;</span><span class="s1">nullable</span><span class="s3">\&quot; </span><span class="s1">keyword is supported by default.',</span><span class="s3">\n    </span><span class="s1">jsonPointers: </span><span class="s3">\&quot;</span><span class="s1">Deprecated jsPropertySyntax can be used instead.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">extendRefs: </span><span class="s3">\&quot;</span><span class="s1">Deprecated ignoreKeywordsWithRef can be used instead.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">missingRefs: </span><span class="s3">\&quot;</span><span class="s1">Pass empty schema with $id that should be ignored to ajv.addSchema.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">processCode: </span><span class="s3">\&quot;</span><span class="s1">Use option `code: {process: (code, schemaEnv: object) =&gt; string}`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">sourceCode: </span><span class="s3">\&quot;</span><span class="s1">Use option `code: {source: true}`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">strictDefaults: </span><span class="s3">\&quot;</span><span class="s1">It is default now, see option `strict`.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">strictKeywords: </span><span class="s3">\&quot;</span><span class="s1">It is default now, see option `strict`.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">uniqueItems: '</span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot; </span><span class="s1">keyword is always validated.',</span><span class="s3">\n    </span><span class="s1">unknownFormats: </span><span class="s3">\&quot;</span><span class="s1">Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">cache: </span><span class="s3">\&quot;</span><span class="s1">Map is used as cache, schema object as key.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">serialize: </span><span class="s3">\&quot;</span><span class="s1">Map is used as cache, schema object as key.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">ajvErrors: </span><span class="s3">\&quot;</span><span class="s1">It is default now.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const deprecatedOptions = {</span><span class="s3">\n    </span><span class="s1">ignoreKeywordsWithRef: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">jsPropertySyntax: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">unicode: '</span><span class="s3">\&quot;</span><span class="s1">minLength</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">maxLength</span><span class="s3">\&quot; </span><span class="s1">account for unicode characters by default.',</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const MAX_EXPRESSION = 200;</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line complexity</span><span class="s3">\n</span><span class="s1">function requiredOptions(o) {</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;</span><span class="s3">\n    </span><span class="s1">const s = o.strict;</span><span class="s3">\n    </span><span class="s1">const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;</span><span class="s3">\n    </span><span class="s1">const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;</span><span class="s3">\n    </span><span class="s1">const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null &amp;&amp; _c !== void 0 ? _c : defaultRegExp;</span><span class="s3">\n    </span><span class="s1">const uriResolver = (_d = o.uriResolver) !== null &amp;&amp; _d !== void 0 ? _d : uri_1.default;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">strictSchema: (_f = (_e = o.strictSchema) !== null &amp;&amp; _e !== void 0 ? _e : s) !== null &amp;&amp; _f !== void 0 ? _f : true,</span><span class="s3">\n        </span><span class="s1">strictNumbers: (_h = (_g = o.strictNumbers) !== null &amp;&amp; _g !== void 0 ? _g : s) !== null &amp;&amp; _h !== void 0 ? _h : true,</span><span class="s3">\n        </span><span class="s1">strictTypes: (_k = (_j = o.strictTypes) !== null &amp;&amp; _j !== void 0 ? _j : s) !== null &amp;&amp; _k !== void 0 ? _k : </span><span class="s3">\&quot;</span><span class="s1">log</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">strictTuples: (_m = (_l = o.strictTuples) !== null &amp;&amp; _l !== void 0 ? _l : s) !== null &amp;&amp; _m !== void 0 ? _m : </span><span class="s3">\&quot;</span><span class="s1">log</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">strictRequired: (_p = (_o = o.strictRequired) !== null &amp;&amp; _o !== void 0 ? _o : s) !== null &amp;&amp; _p !== void 0 ? _p : false,</span><span class="s3">\n        </span><span class="s1">code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },</span><span class="s3">\n        </span><span class="s1">loopRequired: (_q = o.loopRequired) !== null &amp;&amp; _q !== void 0 ? _q : MAX_EXPRESSION,</span><span class="s3">\n        </span><span class="s1">loopEnum: (_r = o.loopEnum) !== null &amp;&amp; _r !== void 0 ? _r : MAX_EXPRESSION,</span><span class="s3">\n        </span><span class="s1">meta: (_s = o.meta) !== null &amp;&amp; _s !== void 0 ? _s : true,</span><span class="s3">\n        </span><span class="s1">messages: (_t = o.messages) !== null &amp;&amp; _t !== void 0 ? _t : true,</span><span class="s3">\n        </span><span class="s1">inlineRefs: (_u = o.inlineRefs) !== null &amp;&amp; _u !== void 0 ? _u : true,</span><span class="s3">\n        </span><span class="s1">schemaId: (_v = o.schemaId) !== null &amp;&amp; _v !== void 0 ? _v : </span><span class="s3">\&quot;</span><span class="s1">$id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">addUsedSchema: (_w = o.addUsedSchema) !== null &amp;&amp; _w !== void 0 ? _w : true,</span><span class="s3">\n        </span><span class="s1">validateSchema: (_x = o.validateSchema) !== null &amp;&amp; _x !== void 0 ? _x : true,</span><span class="s3">\n        </span><span class="s1">validateFormats: (_y = o.validateFormats) !== null &amp;&amp; _y !== void 0 ? _y : true,</span><span class="s3">\n        </span><span class="s1">unicodeRegExp: (_z = o.unicodeRegExp) !== null &amp;&amp; _z !== void 0 ? _z : true,</span><span class="s3">\n        </span><span class="s1">int32range: (_0 = o.int32range) !== null &amp;&amp; _0 !== void 0 ? _0 : true,</span><span class="s3">\n        </span><span class="s1">uriResolver: uriResolver,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Ajv {</span><span class="s3">\n    </span><span class="s1">constructor(opts = {}) {</span><span class="s3">\n        </span><span class="s1">this.schemas = {};</span><span class="s3">\n        </span><span class="s1">this.refs = {};</span><span class="s3">\n        </span><span class="s1">this.formats = {};</span><span class="s3">\n        </span><span class="s1">this._compilations = new Set();</span><span class="s3">\n        </span><span class="s1">this._loading = {};</span><span class="s3">\n        </span><span class="s1">this._cache = new Map();</span><span class="s3">\n        </span><span class="s1">opts = this.opts = { ...opts, ...requiredOptions(opts) };</span><span class="s3">\n        </span><span class="s1">const { es5, lines } = this.opts.code;</span><span class="s3">\n        </span><span class="s1">this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });</span><span class="s3">\n        </span><span class="s1">this.logger = getLogger(opts.logger);</span><span class="s3">\n        </span><span class="s1">const formatOpt = opts.validateFormats;</span><span class="s3">\n        </span><span class="s1">opts.validateFormats = false;</span><span class="s3">\n        </span><span class="s1">this.RULES = (0, rules_1.getRules)();</span><span class="s3">\n        </span><span class="s1">checkOptions.call(this, removedOptions, opts, </span><span class="s3">\&quot;</span><span class="s1">NOT SUPPORTED</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">checkOptions.call(this, deprecatedOptions, opts, </span><span class="s3">\&quot;</span><span class="s1">DEPRECATED</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">warn</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this._metaOpts = getMetaSchemaOptions.call(this);</span><span class="s3">\n        </span><span class="s1">if (opts.formats)</span><span class="s3">\n            </span><span class="s1">addInitialFormats.call(this);</span><span class="s3">\n        </span><span class="s1">this._addVocabularies();</span><span class="s3">\n        </span><span class="s1">this._addDefaultMetaSchema();</span><span class="s3">\n        </span><span class="s1">if (opts.keywords)</span><span class="s3">\n            </span><span class="s1">addInitialKeywords.call(this, opts.keywords);</span><span class="s3">\n        </span><span class="s1">if (typeof opts.meta == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">this.addMetaSchema(opts.meta);</span><span class="s3">\n        </span><span class="s1">addInitialSchemas.call(this);</span><span class="s3">\n        </span><span class="s1">opts.validateFormats = formatOpt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_addVocabularies() {</span><span class="s3">\n        </span><span class="s1">this.addKeyword(</span><span class="s3">\&quot;</span><span class="s1">$async</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_addDefaultMetaSchema() {</span><span class="s3">\n        </span><span class="s1">const { $data, meta, schemaId } = this.opts;</span><span class="s3">\n        </span><span class="s1">let _dataRefSchema = $dataRefSchema;</span><span class="s3">\n        </span><span class="s1">if (schemaId === </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">_dataRefSchema = { ...$dataRefSchema };</span><span class="s3">\n            </span><span class="s1">_dataRefSchema.id = _dataRefSchema.$id;</span><span class="s3">\n            </span><span class="s1">delete _dataRefSchema.$id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (meta &amp;&amp; $data)</span><span class="s3">\n            </span><span class="s1">this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">defaultMeta() {</span><span class="s3">\n        </span><span class="s1">const { meta, schemaId } = this.opts;</span><span class="s3">\n        </span><span class="s1">return (this.opts.defaultMeta = typeof meta == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">? meta[schemaId] || meta : undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validate(schemaKeyRef, // key, ref or schema object</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents</span><span class="s3">\n    </span><span class="s1">data // to be validated</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let v;</span><span class="s3">\n        </span><span class="s1">if (typeof schemaKeyRef == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">v = this.getSchema(schemaKeyRef);</span><span class="s3">\n            </span><span class="s1">if (!v)</span><span class="s3">\n                </span><span class="s1">throw new Error(`no schema with key or ref </span><span class="s3">\&quot;</span><span class="s1">${schemaKeyRef}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">v = this.compile(schemaKeyRef);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const valid = v(data);</span><span class="s3">\n        </span><span class="s1">if (!(</span><span class="s3">\&quot;</span><span class="s1">$async</span><span class="s3">\&quot; </span><span class="s1">in v))</span><span class="s3">\n            </span><span class="s1">this.errors = v.errors;</span><span class="s3">\n        </span><span class="s1">return valid;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compile(schema, _meta) {</span><span class="s3">\n        </span><span class="s1">const sch = this._addSchema(schema, _meta);</span><span class="s3">\n        </span><span class="s1">return (sch.validate || this._compileSchemaEnv(sch));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compileAsync(schema, meta) {</span><span class="s3">\n        </span><span class="s1">if (typeof this.opts.loadSchema != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">options.loadSchema should be a function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const { loadSchema } = this.opts;</span><span class="s3">\n        </span><span class="s1">return runCompileAsync.call(this, schema, meta);</span><span class="s3">\n        </span><span class="s1">async function runCompileAsync(_schema, _meta) {</span><span class="s3">\n            </span><span class="s1">await loadMetaSchema.call(this, _schema.$schema);</span><span class="s3">\n            </span><span class="s1">const sch = this._addSchema(_schema, _meta);</span><span class="s3">\n            </span><span class="s1">return sch.validate || _compileAsync.call(this, sch);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">async function loadMetaSchema($ref) {</span><span class="s3">\n            </span><span class="s1">if ($ref &amp;&amp; !this.getSchema($ref)) {</span><span class="s3">\n                </span><span class="s1">await runCompileAsync.call(this, { $ref }, true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">async function _compileAsync(sch) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">return this._compileSchemaEnv(sch);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">if (!(e instanceof ref_error_1.default))</span><span class="s3">\n                    </span><span class="s1">throw e;</span><span class="s3">\n                </span><span class="s1">checkLoaded.call(this, e);</span><span class="s3">\n                </span><span class="s1">await loadMissingSchema.call(this, e.missingSchema);</span><span class="s3">\n                </span><span class="s1">return _compileAsync.call(this, sch);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function checkLoaded({ missingSchema: ref, missingRef }) {</span><span class="s3">\n            </span><span class="s1">if (this.refs[ref]) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">async function loadMissingSchema(ref) {</span><span class="s3">\n            </span><span class="s1">const _schema = await _loadSchema.call(this, ref);</span><span class="s3">\n            </span><span class="s1">if (!this.refs[ref])</span><span class="s3">\n                </span><span class="s1">await loadMetaSchema.call(this, _schema.$schema);</span><span class="s3">\n            </span><span class="s1">if (!this.refs[ref])</span><span class="s3">\n                </span><span class="s1">this.addSchema(_schema, ref, meta);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">async function _loadSchema(ref) {</span><span class="s3">\n            </span><span class="s1">const p = this._loading[ref];</span><span class="s3">\n            </span><span class="s1">if (p)</span><span class="s3">\n                </span><span class="s1">return p;</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">return await (this._loading[ref] = loadSchema(ref));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">finally {</span><span class="s3">\n                </span><span class="s1">delete this._loading[ref];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Adds schema to the instance</span><span class="s3">\n    </span><span class="s1">addSchema(schema, // If array is passed, `key` will be ignored</span><span class="s3">\n    </span><span class="s1">key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.</span><span class="s3">\n    </span><span class="s1">_meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.</span><span class="s3">\n    </span><span class="s1">_validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(schema)) {</span><span class="s3">\n            </span><span class="s1">for (const sch of schema)</span><span class="s3">\n                </span><span class="s1">this.addSchema(sch, undefined, _meta, _validateSchema);</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (typeof schema === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const { schemaId } = this.opts;</span><span class="s3">\n            </span><span class="s1">id = schema[schemaId];</span><span class="s3">\n            </span><span class="s1">if (id !== undefined &amp;&amp; typeof id != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`schema ${schemaId} must be string`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">key = (0, resolve_1.normalizeId)(key || id);</span><span class="s3">\n        </span><span class="s1">this._checkUnique(key);</span><span class="s3">\n        </span><span class="s1">this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Add schema that will be used to validate other schemas</span><span class="s3">\n    </span><span class="s1">// options in META_IGNORE_OPTIONS are alway set to false</span><span class="s3">\n    </span><span class="s1">addMetaSchema(schema, key, // schema key</span><span class="s3">\n    </span><span class="s1">_validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.addSchema(schema, key, true, _validateSchema);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">//  Validate schema against its meta-schema</span><span class="s3">\n    </span><span class="s1">validateSchema(schema, throwOrLogError) {</span><span class="s3">\n        </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">let $schema;</span><span class="s3">\n        </span><span class="s1">$schema = schema.$schema;</span><span class="s3">\n        </span><span class="s1">if ($schema !== undefined &amp;&amp; typeof $schema != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">$schema must be a string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">$schema = $schema || this.opts.defaultMeta || this.defaultMeta();</span><span class="s3">\n        </span><span class="s1">if (!$schema) {</span><span class="s3">\n            </span><span class="s1">this.logger.warn(</span><span class="s3">\&quot;</span><span class="s1">meta-schema not available</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.errors = null;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const valid = this.validate($schema, schema);</span><span class="s3">\n        </span><span class="s1">if (!valid &amp;&amp; throwOrLogError) {</span><span class="s3">\n            </span><span class="s1">const message = </span><span class="s3">\&quot;</span><span class="s1">schema is invalid: </span><span class="s3">\&quot; </span><span class="s1">+ this.errorsText();</span><span class="s3">\n            </span><span class="s1">if (this.opts.validateSchema === </span><span class="s3">\&quot;</span><span class="s1">log</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">this.logger.error(message);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">throw new Error(message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return valid;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Get compiled schema by `key` or `ref`.</span><span class="s3">\n    </span><span class="s1">// (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)</span><span class="s3">\n    </span><span class="s1">getSchema(keyRef) {</span><span class="s3">\n        </span><span class="s1">let sch;</span><span class="s3">\n        </span><span class="s1">while (typeof (sch = getSchEnv.call(this, keyRef)) == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">keyRef = sch;</span><span class="s3">\n        </span><span class="s1">if (sch === undefined) {</span><span class="s3">\n            </span><span class="s1">const { schemaId } = this.opts;</span><span class="s3">\n            </span><span class="s1">const root = new compile_1.SchemaEnv({ schema: {}, schemaId });</span><span class="s3">\n            </span><span class="s1">sch = compile_1.resolveSchema.call(this, root, keyRef);</span><span class="s3">\n            </span><span class="s1">if (!sch)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.refs[keyRef] = sch;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (sch.validate || this._compileSchemaEnv(sch));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Remove cached schema(s).</span><span class="s3">\n    </span><span class="s1">// If no parameter is passed all schemas but meta-schemas are removed.</span><span class="s3">\n    </span><span class="s1">// If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.</span><span class="s3">\n    </span><span class="s1">// Even if schema is referenced by other schemas it still can be removed as other schemas have local references.</span><span class="s3">\n    </span><span class="s1">removeSchema(schemaKeyRef) {</span><span class="s3">\n        </span><span class="s1">if (schemaKeyRef instanceof RegExp) {</span><span class="s3">\n            </span><span class="s1">this._removeAllSchemas(this.schemas, schemaKeyRef);</span><span class="s3">\n            </span><span class="s1">this._removeAllSchemas(this.refs, schemaKeyRef);</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (typeof schemaKeyRef) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this._removeAllSchemas(this.schemas);</span><span class="s3">\n                </span><span class="s1">this._removeAllSchemas(this.refs);</span><span class="s3">\n                </span><span class="s1">this._cache.clear();</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">const sch = getSchEnv.call(this, schemaKeyRef);</span><span class="s3">\n                </span><span class="s1">if (typeof sch == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">this._cache.delete(sch.schema);</span><span class="s3">\n                </span><span class="s1">delete this.schemas[schemaKeyRef];</span><span class="s3">\n                </span><span class="s1">delete this.refs[schemaKeyRef];</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">const cacheKey = schemaKeyRef;</span><span class="s3">\n                </span><span class="s1">this._cache.delete(cacheKey);</span><span class="s3">\n                </span><span class="s1">let id = schemaKeyRef[this.opts.schemaId];</span><span class="s3">\n                </span><span class="s1">if (id) {</span><span class="s3">\n                    </span><span class="s1">id = (0, resolve_1.normalizeId)(id);</span><span class="s3">\n                    </span><span class="s1">delete this.schemas[id];</span><span class="s3">\n                    </span><span class="s1">delete this.refs[id];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv.removeSchema: invalid parameter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// add </span><span class="s3">\&quot;</span><span class="s1">vocabulary</span><span class="s3">\&quot; </span><span class="s1">- a collection of keywords</span><span class="s3">\n    </span><span class="s1">addVocabulary(definitions) {</span><span class="s3">\n        </span><span class="s1">for (const def of definitions)</span><span class="s3">\n            </span><span class="s1">this.addKeyword(def);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addKeyword(kwdOrDef, def // deprecated</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let keyword;</span><span class="s3">\n        </span><span class="s1">if (typeof kwdOrDef == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">keyword = kwdOrDef;</span><span class="s3">\n            </span><span class="s1">if (typeof def == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">this.logger.warn(</span><span class="s3">\&quot;</span><span class="s1">these parameters are deprecated, see docs for addKeyword</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">def.keyword = keyword;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (typeof kwdOrDef == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; def === undefined) {</span><span class="s3">\n            </span><span class="s1">def = kwdOrDef;</span><span class="s3">\n            </span><span class="s1">keyword = def.keyword;</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(keyword) &amp;&amp; !keyword.length) {</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">addKeywords: keyword must be string or non-empty array</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">invalid addKeywords parameters</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">checkKeyword.call(this, keyword, def);</span><span class="s3">\n        </span><span class="s1">if (!def) {</span><span class="s3">\n            </span><span class="s1">(0, util_1.eachItem)(keyword, (kwd) =&gt; addRule.call(this, kwd));</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">keywordMetaschema.call(this, def);</span><span class="s3">\n        </span><span class="s1">const definition = {</span><span class="s3">\n            </span><span class="s1">...def,</span><span class="s3">\n            </span><span class="s1">type: (0, dataType_1.getJSONTypes)(def.type),</span><span class="s3">\n            </span><span class="s1">schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">(0, util_1.eachItem)(keyword, definition.type.length === 0</span><span class="s3">\n            </span><span class="s1">? (k) =&gt; addRule.call(this, k, definition)</span><span class="s3">\n            </span><span class="s1">: (k) =&gt; definition.type.forEach((t) =&gt; addRule.call(this, k, definition, t)));</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getKeyword(keyword) {</span><span class="s3">\n        </span><span class="s1">const rule = this.RULES.all[keyword];</span><span class="s3">\n        </span><span class="s1">return typeof rule == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">? rule.definition : !!rule;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Remove keyword</span><span class="s3">\n    </span><span class="s1">removeKeyword(keyword) {</span><span class="s3">\n        </span><span class="s1">// TODO return type should be Ajv</span><span class="s3">\n        </span><span class="s1">const { RULES } = this;</span><span class="s3">\n        </span><span class="s1">delete RULES.keywords[keyword];</span><span class="s3">\n        </span><span class="s1">delete RULES.all[keyword];</span><span class="s3">\n        </span><span class="s1">for (const group of RULES.rules) {</span><span class="s3">\n            </span><span class="s1">const i = group.rules.findIndex((rule) =&gt; rule.keyword === keyword);</span><span class="s3">\n            </span><span class="s1">if (i &gt;= 0)</span><span class="s3">\n                </span><span class="s1">group.rules.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Add format</span><span class="s3">\n    </span><span class="s1">addFormat(name, format) {</span><span class="s3">\n        </span><span class="s1">if (typeof format == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">format = new RegExp(format);</span><span class="s3">\n        </span><span class="s1">this.formats[name] = format;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">errorsText(errors = this.errors, // optional array of validation errors</span><span class="s3">\n    </span><span class="s1">{ separator = </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">, dataVar = </span><span class="s3">\&quot;</span><span class="s1">data</span><span class="s3">\&quot; </span><span class="s1">} = {} // optional options with properties `separator` and `dataVar`</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (!errors || errors.length === 0)</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">No errors</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return errors</span><span class="s3">\n            </span><span class="s1">.map((e) =&gt; `${dataVar}${e.instancePath} ${e.message}`)</span><span class="s3">\n            </span><span class="s1">.reduce((text, msg) =&gt; text + separator + msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">$dataMetaSchema(metaSchema, keywordsJsonPointers) {</span><span class="s3">\n        </span><span class="s1">const rules = this.RULES.all;</span><span class="s3">\n        </span><span class="s1">metaSchema = JSON.parse(JSON.stringify(metaSchema));</span><span class="s3">\n        </span><span class="s1">for (const jsonPointer of keywordsJsonPointers) {</span><span class="s3">\n            </span><span class="s1">const segments = jsonPointer.split(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">).slice(1); // first segment is an empty string</span><span class="s3">\n            </span><span class="s1">let keywords = metaSchema;</span><span class="s3">\n            </span><span class="s1">for (const seg of segments)</span><span class="s3">\n                </span><span class="s1">keywords = keywords[seg];</span><span class="s3">\n            </span><span class="s1">for (const key in rules) {</span><span class="s3">\n                </span><span class="s1">const rule = rules[key];</span><span class="s3">\n                </span><span class="s1">if (typeof rule != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">const { $data } = rule.definition;</span><span class="s3">\n                </span><span class="s1">const schema = keywords[key];</span><span class="s3">\n                </span><span class="s1">if ($data &amp;&amp; schema)</span><span class="s3">\n                    </span><span class="s1">keywords[key] = schemaOrData(schema);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return metaSchema;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_removeAllSchemas(schemas, regex) {</span><span class="s3">\n        </span><span class="s1">for (const keyRef in schemas) {</span><span class="s3">\n            </span><span class="s1">const sch = schemas[keyRef];</span><span class="s3">\n            </span><span class="s1">if (!regex || regex.test(keyRef)) {</span><span class="s3">\n                </span><span class="s1">if (typeof sch == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">delete schemas[keyRef];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (sch &amp;&amp; !sch.meta) {</span><span class="s3">\n                    </span><span class="s1">this._cache.delete(sch.schema);</span><span class="s3">\n                    </span><span class="s1">delete schemas[keyRef];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">const { schemaId } = this.opts;</span><span class="s3">\n        </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">id = schema[schemaId];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (this.opts.jtd)</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">schema must be object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">else if (typeof schema != </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">schema must be object or boolean</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let sch = this._cache.get(schema);</span><span class="s3">\n        </span><span class="s1">if (sch !== undefined)</span><span class="s3">\n            </span><span class="s1">return sch;</span><span class="s3">\n        </span><span class="s1">baseId = (0, resolve_1.normalizeId)(id || baseId);</span><span class="s3">\n        </span><span class="s1">const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);</span><span class="s3">\n        </span><span class="s1">sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });</span><span class="s3">\n        </span><span class="s1">this._cache.set(sch.schema, sch);</span><span class="s3">\n        </span><span class="s1">if (addSchema &amp;&amp; !baseId.startsWith(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">// TODO atm it is allowed to overwrite schemas without id (instead of not adding them)</span><span class="s3">\n            </span><span class="s1">if (baseId)</span><span class="s3">\n                </span><span class="s1">this._checkUnique(baseId);</span><span class="s3">\n            </span><span class="s1">this.refs[baseId] = sch;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (validateSchema)</span><span class="s3">\n            </span><span class="s1">this.validateSchema(schema, true);</span><span class="s3">\n        </span><span class="s1">return sch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_checkUnique(id) {</span><span class="s3">\n        </span><span class="s1">if (this.schemas[id] || this.refs[id]) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`schema with key or id </span><span class="s3">\&quot;</span><span class="s1">${id}</span><span class="s3">\&quot; </span><span class="s1">already exists`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_compileSchemaEnv(sch) {</span><span class="s3">\n        </span><span class="s1">if (sch.meta)</span><span class="s3">\n            </span><span class="s1">this._compileMetaSchema(sch);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">compile_1.compileSchema.call(this, sch);</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n        </span><span class="s1">if (!sch.validate)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return sch.validate;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_compileMetaSchema(sch) {</span><span class="s3">\n        </span><span class="s1">const currentOpts = this.opts;</span><span class="s3">\n        </span><span class="s1">this.opts = this._metaOpts;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">compile_1.compileSchema.call(this, sch);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.opts = currentOpts;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Ajv.ValidationError = validation_error_1.default;</span><span class="s3">\n</span><span class="s1">Ajv.MissingRefError = ref_error_1.default;</span><span class="s3">\n</span><span class="s1">exports.default = Ajv;</span><span class="s3">\n</span><span class="s1">function checkOptions(checkOpts, options, msg, log = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key in checkOpts) {</span><span class="s3">\n        </span><span class="s1">const opt = key;</span><span class="s3">\n        </span><span class="s1">if (opt in options)</span><span class="s3">\n            </span><span class="s1">this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getSchEnv(keyRef) {</span><span class="s3">\n    </span><span class="s1">keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line</span><span class="s3">\n    </span><span class="s1">return this.schemas[keyRef] || this.refs[keyRef];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addInitialSchemas() {</span><span class="s3">\n    </span><span class="s1">const optsSchemas = this.opts.schemas;</span><span class="s3">\n    </span><span class="s1">if (!optsSchemas)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(optsSchemas))</span><span class="s3">\n        </span><span class="s1">this.addSchema(optsSchemas);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">for (const key in optsSchemas)</span><span class="s3">\n            </span><span class="s1">this.addSchema(optsSchemas[key], key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addInitialFormats() {</span><span class="s3">\n    </span><span class="s1">for (const name in this.opts.formats) {</span><span class="s3">\n        </span><span class="s1">const format = this.opts.formats[name];</span><span class="s3">\n        </span><span class="s1">if (format)</span><span class="s3">\n            </span><span class="s1">this.addFormat(name, format);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addInitialKeywords(defs) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(defs)) {</span><span class="s3">\n        </span><span class="s1">this.addVocabulary(defs);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.logger.warn(</span><span class="s3">\&quot;</span><span class="s1">keywords option as map is deprecated, pass array</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const keyword in defs) {</span><span class="s3">\n        </span><span class="s1">const def = defs[keyword];</span><span class="s3">\n        </span><span class="s1">if (!def.keyword)</span><span class="s3">\n            </span><span class="s1">def.keyword = keyword;</span><span class="s3">\n        </span><span class="s1">this.addKeyword(def);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getMetaSchemaOptions() {</span><span class="s3">\n    </span><span class="s1">const metaOpts = { ...this.opts };</span><span class="s3">\n    </span><span class="s1">for (const opt of META_IGNORE_OPTIONS)</span><span class="s3">\n        </span><span class="s1">delete metaOpts[opt];</span><span class="s3">\n    </span><span class="s1">return metaOpts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const noLogs = { log() { }, warn() { }, error() { } };</span><span class="s3">\n</span><span class="s1">function getLogger(logger) {</span><span class="s3">\n    </span><span class="s1">if (logger === false)</span><span class="s3">\n        </span><span class="s1">return noLogs;</span><span class="s3">\n    </span><span class="s1">if (logger === undefined)</span><span class="s3">\n        </span><span class="s1">return console;</span><span class="s3">\n    </span><span class="s1">if (logger.log &amp;&amp; logger.warn &amp;&amp; logger.error)</span><span class="s3">\n        </span><span class="s1">return logger;</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">logger must implement log, warn and error methods</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;</span><span class="s3">\n</span><span class="s1">function checkKeyword(keyword, def) {</span><span class="s3">\n    </span><span class="s1">const { RULES } = this;</span><span class="s3">\n    </span><span class="s1">(0, util_1.eachItem)(keyword, (kwd) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (RULES.keywords[kwd])</span><span class="s3">\n            </span><span class="s1">throw new Error(`Keyword ${kwd} is already defined`);</span><span class="s3">\n        </span><span class="s1">if (!KEYWORD_NAME.test(kwd))</span><span class="s3">\n            </span><span class="s1">throw new Error(`Keyword ${kwd} has invalid name`);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!def)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (def.$data &amp;&amp; !(</span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot; </span><span class="s1">in def || </span><span class="s3">\&quot;</span><span class="s1">validate</span><span class="s3">\&quot; </span><span class="s1">in def)) {</span><span class="s3">\n        </span><span class="s1">throw new Error('$data keyword must have </span><span class="s3">\&quot;</span><span class="s1">code</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">validate</span><span class="s3">\&quot; </span><span class="s1">function');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addRule(keyword, definition, dataType) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const post = definition === null || definition === void 0 ? void 0 : definition.post;</span><span class="s3">\n    </span><span class="s1">if (dataType &amp;&amp; post)</span><span class="s3">\n        </span><span class="s1">throw new Error('keyword with </span><span class="s3">\&quot;</span><span class="s1">post</span><span class="s3">\&quot; </span><span class="s1">flag cannot have </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n    </span><span class="s1">const { RULES } = this;</span><span class="s3">\n    </span><span class="s1">let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) =&gt; t === dataType);</span><span class="s3">\n    </span><span class="s1">if (!ruleGroup) {</span><span class="s3">\n        </span><span class="s1">ruleGroup = { type: dataType, rules: [] };</span><span class="s3">\n        </span><span class="s1">RULES.rules.push(ruleGroup);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RULES.keywords[keyword] = true;</span><span class="s3">\n    </span><span class="s1">if (!definition)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const rule = {</span><span class="s3">\n        </span><span class="s1">keyword,</span><span class="s3">\n        </span><span class="s1">definition: {</span><span class="s3">\n            </span><span class="s1">...definition,</span><span class="s3">\n            </span><span class="s1">type: (0, dataType_1.getJSONTypes)(definition.type),</span><span class="s3">\n            </span><span class="s1">schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (definition.before)</span><span class="s3">\n        </span><span class="s1">addBeforeRule.call(this, ruleGroup, rule, definition.before);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">ruleGroup.rules.push(rule);</span><span class="s3">\n    </span><span class="s1">RULES.all[keyword] = rule;</span><span class="s3">\n    </span><span class="s1">(_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) =&gt; this.addKeyword(kwd));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addBeforeRule(ruleGroup, rule, before) {</span><span class="s3">\n    </span><span class="s1">const i = ruleGroup.rules.findIndex((_rule) =&gt; _rule.keyword === before);</span><span class="s3">\n    </span><span class="s1">if (i &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">ruleGroup.rules.splice(i, 0, rule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">ruleGroup.rules.push(rule);</span><span class="s3">\n        </span><span class="s1">this.logger.warn(`rule ${before} is not defined`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function keywordMetaschema(def) {</span><span class="s3">\n    </span><span class="s1">let { metaSchema } = def;</span><span class="s3">\n    </span><span class="s1">if (metaSchema === undefined)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (def.$data &amp;&amp; this.opts.$data)</span><span class="s3">\n        </span><span class="s1">metaSchema = schemaOrData(metaSchema);</span><span class="s3">\n    </span><span class="s1">def.validateSchema = this.compile(metaSchema, true);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const $dataRef = {</span><span class="s3">\n    </span><span class="s1">$ref: </span><span class="s3">\&quot;</span><span class="s1">https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function schemaOrData(schema) {</span><span class="s3">\n    </span><span class="s1">return { anyOf: [schema, $dataRef] };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=core.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">// https://github.com/ajv-validator/ajv/issues/889</span><span class="s3">\n</span><span class="s1">const equal = require(</span><span class="s3">\&quot;</span><span class="s1">fast-deep-equal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">equal.code = 'require(</span><span class="s3">\&quot;</span><span class="s1">ajv/dist/runtime/equal</span><span class="s3">\&quot;</span><span class="s1">).default';</span><span class="s3">\n</span><span class="s1">exports.default = equal;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=equal.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">// https://mathiasbynens.be/notes/javascript-encoding</span><span class="s3">\n</span><span class="s1">// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode</span><span class="s3">\n</span><span class="s1">function ucs2length(str) {</span><span class="s3">\n    </span><span class="s1">const len = str.length;</span><span class="s3">\n    </span><span class="s1">let length = 0;</span><span class="s3">\n    </span><span class="s1">let pos = 0;</span><span class="s3">\n    </span><span class="s1">let value;</span><span class="s3">\n    </span><span class="s1">while (pos &lt; len) {</span><span class="s3">\n        </span><span class="s1">length++;</span><span class="s3">\n        </span><span class="s1">value = str.charCodeAt(pos++);</span><span class="s3">\n        </span><span class="s1">if (value &gt;= 0xd800 &amp;&amp; value &lt;= 0xdbff &amp;&amp; pos &lt; len) {</span><span class="s3">\n            </span><span class="s1">// high surrogate, and there is a next character</span><span class="s3">\n            </span><span class="s1">value = str.charCodeAt(pos);</span><span class="s3">\n            </span><span class="s1">if ((value &amp; 0xfc00) === 0xdc00)</span><span class="s3">\n                </span><span class="s1">pos++; // low surrogate</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.default = ucs2length;</span><span class="s3">\n</span><span class="s1">ucs2length.code = 'require(</span><span class="s3">\&quot;</span><span class="s1">ajv/dist/runtime/ucs2length</span><span class="s3">\&quot;</span><span class="s1">).default';</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ucs2length.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const uri = require(</span><span class="s3">\&quot;</span><span class="s1">fast-uri</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">uri.code = 'require(</span><span class="s3">\&quot;</span><span class="s1">ajv/dist/runtime/uri</span><span class="s3">\&quot;</span><span class="s1">).default';</span><span class="s3">\n</span><span class="s1">exports.default = uri;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=uri.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">class ValidationError extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(errors) {</span><span class="s3">\n        </span><span class="s1">super(</span><span class="s3">\&quot;</span><span class="s1">validation failed</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.errors = errors;</span><span class="s3">\n        </span><span class="s1">this.ajv = this.validation = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.default = ValidationError;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=validation_error.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.validateAdditionalItems = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { len } }) =&gt; (0, codegen_1.str) `must NOT have more than ${len} items`,</span><span class="s3">\n    </span><span class="s1">params: ({ params: { len } }) =&gt; (0, codegen_1._) `{limit: ${len}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">additionalItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { parentSchema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { items } = parentSchema;</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(items)) {</span><span class="s3">\n            </span><span class="s1">(0, util_1.checkStrictMode)(it, '</span><span class="s3">\&quot;</span><span class="s1">additionalItems</span><span class="s3">\&quot; </span><span class="s1">is ignored when </span><span class="s3">\&quot;</span><span class="s1">items</span><span class="s3">\&quot; </span><span class="s1">is not an array of schemas');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">validateAdditionalItems(cxt, items);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function validateAdditionalItems(cxt, items) {</span><span class="s3">\n    </span><span class="s1">const { gen, schema, data, keyword, it } = cxt;</span><span class="s3">\n    </span><span class="s1">it.items = true;</span><span class="s3">\n    </span><span class="s1">const len = gen.const(</span><span class="s3">\&quot;</span><span class="s1">len</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${data}.length`);</span><span class="s3">\n    </span><span class="s1">if (schema === false) {</span><span class="s3">\n        </span><span class="s1">cxt.setParams({ len: items.length });</span><span class="s3">\n        </span><span class="s1">cxt.pass((0, codegen_1._) `${len} &lt;= ${items.length}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !(0, util_1.alwaysValidSchema)(it, schema)) {</span><span class="s3">\n        </span><span class="s1">const valid = gen.var(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${len} &lt;= ${items.length}`); // TODO var</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; validateItems(valid));</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function validateItems(valid) {</span><span class="s3">\n        </span><span class="s1">gen.forRange(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">, items.length, len, (i) =&gt; {</span><span class="s3">\n            </span><span class="s1">cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);</span><span class="s3">\n            </span><span class="s1">if (!it.allErrors)</span><span class="s3">\n                </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; gen.break());</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateAdditionalItems = validateAdditionalItems;</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=additionalItems.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">must NOT have additional properties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params: ({ params }) =&gt; (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">additionalProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">allowUndefined: true,</span><span class="s3">\n    </span><span class="s1">trackErrors: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, parentSchema, data, errsCount, it } = cxt;</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n        </span><span class="s1">if (!errsCount)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const { allErrors, opts } = it;</span><span class="s3">\n        </span><span class="s1">it.props = true;</span><span class="s3">\n        </span><span class="s1">if (opts.removeAdditional !== </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (0, util_1.alwaysValidSchema)(it, schema))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const props = (0, code_1.allSchemaProperties)(parentSchema.properties);</span><span class="s3">\n        </span><span class="s1">const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);</span><span class="s3">\n        </span><span class="s1">checkAdditionalProperties();</span><span class="s3">\n        </span><span class="s1">cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);</span><span class="s3">\n        </span><span class="s1">function checkAdditionalProperties() {</span><span class="s3">\n            </span><span class="s1">gen.forIn(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, data, (key) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!props.length &amp;&amp; !patProps.length)</span><span class="s3">\n                    </span><span class="s1">additionalPropertyCode(key);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">gen.if(isAdditional(key), () =&gt; additionalPropertyCode(key));</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function isAdditional(key) {</span><span class="s3">\n            </span><span class="s1">let definedProp;</span><span class="s3">\n            </span><span class="s1">if (props.length &gt; 8) {</span><span class="s3">\n                </span><span class="s1">// TODO maybe an option instead of hard-coded 8?</span><span class="s3">\n                </span><span class="s1">const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (props.length) {</span><span class="s3">\n                </span><span class="s1">definedProp = (0, codegen_1.or)(...props.map((p) =&gt; (0, codegen_1._) `${key} === ${p}`));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">definedProp = codegen_1.nil;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (patProps.length) {</span><span class="s3">\n                </span><span class="s1">definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) =&gt; (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return (0, codegen_1.not)(definedProp);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function deleteAdditional(key) {</span><span class="s3">\n            </span><span class="s1">gen.code((0, codegen_1._) `delete ${data}[${key}]`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function additionalPropertyCode(key) {</span><span class="s3">\n            </span><span class="s1">if (opts.removeAdditional === </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot; </span><span class="s1">|| (opts.removeAdditional &amp;&amp; schema === false)) {</span><span class="s3">\n                </span><span class="s1">deleteAdditional(key);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (schema === false) {</span><span class="s3">\n                </span><span class="s1">cxt.setParams({ additionalProperty: key });</span><span class="s3">\n                </span><span class="s1">cxt.error();</span><span class="s3">\n                </span><span class="s1">if (!allErrors)</span><span class="s3">\n                    </span><span class="s1">gen.break();</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !(0, util_1.alwaysValidSchema)(it, schema)) {</span><span class="s3">\n                </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (opts.removeAdditional === </span><span class="s3">\&quot;</span><span class="s1">failing</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">applyAdditionalSchema(key, valid, false);</span><span class="s3">\n                    </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; {</span><span class="s3">\n                        </span><span class="s1">cxt.reset();</span><span class="s3">\n                        </span><span class="s1">deleteAdditional(key);</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">applyAdditionalSchema(key, valid);</span><span class="s3">\n                    </span><span class="s1">if (!allErrors)</span><span class="s3">\n                        </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; gen.break());</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function applyAdditionalSchema(key, valid, errors) {</span><span class="s3">\n            </span><span class="s1">const subschema = {</span><span class="s3">\n                </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">additionalProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">dataProp: key,</span><span class="s3">\n                </span><span class="s1">dataPropType: util_1.Type.Str,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">if (errors === false) {</span><span class="s3">\n                </span><span class="s1">Object.assign(subschema, {</span><span class="s3">\n                    </span><span class="s1">compositeRule: true,</span><span class="s3">\n                    </span><span class="s1">createErrors: false,</span><span class="s3">\n                    </span><span class="s1">allErrors: false,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">cxt.subschema(subschema, valid);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=additionalProperties.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">allOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(schema))</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">schema.forEach((sch, i) =&gt; {</span><span class="s3">\n            </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, sch))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const schCxt = cxt.subschema({ keyword: </span><span class="s3">\&quot;</span><span class="s1">allOf</span><span class="s3">\&quot;</span><span class="s1">, schemaProp: i }, valid);</span><span class="s3">\n            </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n            </span><span class="s1">cxt.mergeEvaluated(schCxt);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=allOf.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">anyOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">trackErrors: true,</span><span class="s3">\n    </span><span class="s1">code: code_1.validateUnion,</span><span class="s3">\n    </span><span class="s1">error: { message: </span><span class="s3">\&quot;</span><span class="s1">must match a schema in anyOf</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=anyOf.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { min, max } }) =&gt; max === undefined</span><span class="s3">\n        </span><span class="s1">? (0, codegen_1.str) `must contain at least ${min} valid item(s)`</span><span class="s3">\n        </span><span class="s1">: (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,</span><span class="s3">\n    </span><span class="s1">params: ({ params: { min, max } }) =&gt; max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">contains</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">trackErrors: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, parentSchema, data, it } = cxt;</span><span class="s3">\n        </span><span class="s1">let min;</span><span class="s3">\n        </span><span class="s1">let max;</span><span class="s3">\n        </span><span class="s1">const { minContains, maxContains } = parentSchema;</span><span class="s3">\n        </span><span class="s1">if (it.opts.next) {</span><span class="s3">\n            </span><span class="s1">min = minContains === undefined ? 1 : minContains;</span><span class="s3">\n            </span><span class="s1">max = maxContains;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">min = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const len = gen.const(</span><span class="s3">\&quot;</span><span class="s1">len</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${data}.length`);</span><span class="s3">\n        </span><span class="s1">cxt.setParams({ min, max });</span><span class="s3">\n        </span><span class="s1">if (max === undefined &amp;&amp; min === 0) {</span><span class="s3">\n            </span><span class="s1">(0, util_1.checkStrictMode)(it, `</span><span class="s3">\&quot;</span><span class="s1">minContains</span><span class="s3">\&quot; </span><span class="s1">== 0 without </span><span class="s3">\&quot;</span><span class="s1">maxContains</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">contains</span><span class="s3">\&quot; </span><span class="s1">keyword ignored`);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (max !== undefined &amp;&amp; min &gt; max) {</span><span class="s3">\n            </span><span class="s1">(0, util_1.checkStrictMode)(it, `</span><span class="s3">\&quot;</span><span class="s1">minContains</span><span class="s3">\&quot; </span><span class="s1">&gt; </span><span class="s3">\&quot;</span><span class="s1">maxContains</span><span class="s3">\&quot; </span><span class="s1">is always invalid`);</span><span class="s3">\n            </span><span class="s1">cxt.fail();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, schema)) {</span><span class="s3">\n            </span><span class="s1">let cond = (0, codegen_1._) `${len} &gt;= ${min}`;</span><span class="s3">\n            </span><span class="s1">if (max !== undefined)</span><span class="s3">\n                </span><span class="s1">cond = (0, codegen_1._) `${cond} &amp;&amp; ${len} &lt;= ${max}`;</span><span class="s3">\n            </span><span class="s1">cxt.pass(cond);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">it.items = true;</span><span class="s3">\n        </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (max === undefined &amp;&amp; min === 1) {</span><span class="s3">\n            </span><span class="s1">validateItems(valid, () =&gt; gen.if(valid, () =&gt; gen.break()));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (min === 0) {</span><span class="s3">\n            </span><span class="s1">gen.let(valid, true);</span><span class="s3">\n            </span><span class="s1">if (max !== undefined)</span><span class="s3">\n                </span><span class="s1">gen.if((0, codegen_1._) `${data}.length &gt; 0`, validateItemsWithCount);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">gen.let(valid, false);</span><span class="s3">\n            </span><span class="s1">validateItemsWithCount();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cxt.result(valid, () =&gt; cxt.reset());</span><span class="s3">\n        </span><span class="s1">function validateItemsWithCount() {</span><span class="s3">\n            </span><span class="s1">const schValid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">_valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const count = gen.let(</span><span class="s3">\&quot;</span><span class="s1">count</span><span class="s3">\&quot;</span><span class="s1">, 0);</span><span class="s3">\n            </span><span class="s1">validateItems(schValid, () =&gt; gen.if(schValid, () =&gt; checkLimits(count)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function validateItems(_valid, block) {</span><span class="s3">\n            </span><span class="s1">gen.forRange(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">, 0, len, (i) =&gt; {</span><span class="s3">\n                </span><span class="s1">cxt.subschema({</span><span class="s3">\n                    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">contains</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                    </span><span class="s1">dataProp: i,</span><span class="s3">\n                    </span><span class="s1">dataPropType: util_1.Type.Num,</span><span class="s3">\n                    </span><span class="s1">compositeRule: true,</span><span class="s3">\n                </span><span class="s1">}, _valid);</span><span class="s3">\n                </span><span class="s1">block();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function checkLimits(count) {</span><span class="s3">\n            </span><span class="s1">gen.code((0, codegen_1._) `${count}++`);</span><span class="s3">\n            </span><span class="s1">if (max === undefined) {</span><span class="s3">\n                </span><span class="s1">gen.if((0, codegen_1._) `${count} &gt;= ${min}`, () =&gt; gen.assign(valid, true).break());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">gen.if((0, codegen_1._) `${count} &gt; ${max}`, () =&gt; gen.assign(valid, false).break());</span><span class="s3">\n                </span><span class="s1">if (min === 1)</span><span class="s3">\n                    </span><span class="s1">gen.assign(valid, true);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">gen.if((0, codegen_1._) `${count} &gt;= ${min}`, () =&gt; gen.assign(valid, true));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=contains.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">exports.error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { property, depsCount, deps } }) =&gt; {</span><span class="s3">\n        </span><span class="s1">const property_ies = depsCount === 1 ? </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">params: ({ params: { property, depsCount, deps, missingProperty } }) =&gt; (0, codegen_1._) `{property: ${property},</span><span class="s3">\n    </span><span class="s1">missingProperty: ${missingProperty},</span><span class="s3">\n    </span><span class="s1">depsCount: ${depsCount},</span><span class="s3">\n    </span><span class="s1">deps: ${deps}}`, // TODO change to reference</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">dependencies</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">error: exports.error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const [propDeps, schDeps] = splitDependencies(cxt);</span><span class="s3">\n        </span><span class="s1">validatePropertyDeps(cxt, propDeps);</span><span class="s3">\n        </span><span class="s1">validateSchemaDeps(cxt, schDeps);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function splitDependencies({ schema }) {</span><span class="s3">\n    </span><span class="s1">const propertyDeps = {};</span><span class="s3">\n    </span><span class="s1">const schemaDeps = {};</span><span class="s3">\n    </span><span class="s1">for (const key in schema) {</span><span class="s3">\n        </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;</span><span class="s3">\n        </span><span class="s1">deps[key] = schema[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [propertyDeps, schemaDeps];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, it } = cxt;</span><span class="s3">\n    </span><span class="s1">if (Object.keys(propertyDeps).length === 0)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const missing = gen.let(</span><span class="s3">\&quot;</span><span class="s1">missing</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const prop in propertyDeps) {</span><span class="s3">\n        </span><span class="s1">const deps = propertyDeps[prop];</span><span class="s3">\n        </span><span class="s1">if (deps.length === 0)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);</span><span class="s3">\n        </span><span class="s1">cxt.setParams({</span><span class="s3">\n            </span><span class="s1">property: prop,</span><span class="s3">\n            </span><span class="s1">depsCount: deps.length,</span><span class="s3">\n            </span><span class="s1">deps: deps.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (it.allErrors) {</span><span class="s3">\n            </span><span class="s1">gen.if(hasProperty, () =&gt; {</span><span class="s3">\n                </span><span class="s1">for (const depProp of deps) {</span><span class="s3">\n                    </span><span class="s1">(0, code_1.checkReportMissingProp)(cxt, depProp);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1._) `${hasProperty} &amp;&amp; (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);</span><span class="s3">\n            </span><span class="s1">(0, code_1.reportMissingProp)(cxt, missing);</span><span class="s3">\n            </span><span class="s1">gen.else();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validatePropertyDeps = validatePropertyDeps;</span><span class="s3">\n</span><span class="s1">function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, keyword, it } = cxt;</span><span class="s3">\n    </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const prop in schemaDeps) {</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () =&gt; {</span><span class="s3">\n            </span><span class="s1">const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);</span><span class="s3">\n            </span><span class="s1">cxt.mergeValidEvaluated(schCxt, valid);</span><span class="s3">\n        </span><span class="s1">}, () =&gt; gen.var(valid, true) // TODO var</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateSchemaDeps = validateSchemaDeps;</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=dependencies.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params }) =&gt; (0, codegen_1.str) `must match </span><span class="s3">\&quot;</span><span class="s1">${params.ifClause}</span><span class="s3">\&quot; </span><span class="s1">schema`,</span><span class="s3">\n    </span><span class="s1">params: ({ params }) =&gt; (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">trackErrors: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, parentSchema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if (parentSchema.then === undefined &amp;&amp; parentSchema.else === undefined) {</span><span class="s3">\n            </span><span class="s1">(0, util_1.checkStrictMode)(it, '</span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot; </span><span class="s1">without </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot; </span><span class="s1">is ignored');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const hasThen = hasSchema(it, </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const hasElse = hasSchema(it, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (!hasThen &amp;&amp; !hasElse)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n        </span><span class="s1">const schValid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">_valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">validateIf();</span><span class="s3">\n        </span><span class="s1">cxt.reset();</span><span class="s3">\n        </span><span class="s1">if (hasThen &amp;&amp; hasElse) {</span><span class="s3">\n            </span><span class="s1">const ifClause = gen.let(</span><span class="s3">\&quot;</span><span class="s1">ifClause</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">cxt.setParams({ ifClause });</span><span class="s3">\n            </span><span class="s1">gen.if(schValid, validateClause(</span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">, ifClause), validateClause(</span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">, ifClause));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (hasThen) {</span><span class="s3">\n            </span><span class="s1">gen.if(schValid, validateClause(</span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1.not)(schValid), validateClause(</span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cxt.pass(valid, () =&gt; cxt.error(true));</span><span class="s3">\n        </span><span class="s1">function validateIf() {</span><span class="s3">\n            </span><span class="s1">const schCxt = cxt.subschema({</span><span class="s3">\n                </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">compositeRule: true,</span><span class="s3">\n                </span><span class="s1">createErrors: false,</span><span class="s3">\n                </span><span class="s1">allErrors: false,</span><span class="s3">\n            </span><span class="s1">}, schValid);</span><span class="s3">\n            </span><span class="s1">cxt.mergeEvaluated(schCxt);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function validateClause(keyword, ifClause) {</span><span class="s3">\n            </span><span class="s1">return () =&gt; {</span><span class="s3">\n                </span><span class="s1">const schCxt = cxt.subschema({ keyword }, schValid);</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, schValid);</span><span class="s3">\n                </span><span class="s1">cxt.mergeValidEvaluated(schCxt, valid);</span><span class="s3">\n                </span><span class="s1">if (ifClause)</span><span class="s3">\n                    </span><span class="s1">gen.assign(ifClause, (0, codegen_1._) `${keyword}`);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">cxt.setParams({ ifClause: keyword });</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function hasSchema(it, keyword) {</span><span class="s3">\n    </span><span class="s1">const schema = it.schema[keyword];</span><span class="s3">\n    </span><span class="s1">return schema !== undefined &amp;&amp; !(0, util_1.alwaysValidSchema)(it, schema);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=if.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const additionalItems_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./additionalItems</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const prefixItems_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./prefixItems</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const items_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./items</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const items2020_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./items2020</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const contains_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./contains</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const dependencies_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./dependencies</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const propertyNames_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./propertyNames</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const additionalProperties_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./additionalProperties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const properties_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./properties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const patternProperties_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./patternProperties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const not_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./not</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const anyOf_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./anyOf</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const oneOf_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./oneOf</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const allOf_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./allOf</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const if_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./if</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const thenElse_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./thenElse</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function getApplicator(draft2020 = false) {</span><span class="s3">\n    </span><span class="s1">const applicator = [</span><span class="s3">\n        </span><span class="s1">// any</span><span class="s3">\n        </span><span class="s1">not_1.default,</span><span class="s3">\n        </span><span class="s1">anyOf_1.default,</span><span class="s3">\n        </span><span class="s1">oneOf_1.default,</span><span class="s3">\n        </span><span class="s1">allOf_1.default,</span><span class="s3">\n        </span><span class="s1">if_1.default,</span><span class="s3">\n        </span><span class="s1">thenElse_1.default,</span><span class="s3">\n        </span><span class="s1">// object</span><span class="s3">\n        </span><span class="s1">propertyNames_1.default,</span><span class="s3">\n        </span><span class="s1">additionalProperties_1.default,</span><span class="s3">\n        </span><span class="s1">dependencies_1.default,</span><span class="s3">\n        </span><span class="s1">properties_1.default,</span><span class="s3">\n        </span><span class="s1">patternProperties_1.default,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">// array</span><span class="s3">\n    </span><span class="s1">if (draft2020)</span><span class="s3">\n        </span><span class="s1">applicator.push(prefixItems_1.default, items2020_1.default);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">applicator.push(additionalItems_1.default, items_1.default);</span><span class="s3">\n    </span><span class="s1">applicator.push(contains_1.default);</span><span class="s3">\n    </span><span class="s1">return applicator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.default = getApplicator;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.validateTuple = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">items</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { schema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(schema))</span><span class="s3">\n            </span><span class="s1">return validateTuple(cxt, </span><span class="s3">\&quot;</span><span class="s1">additionalItems</span><span class="s3">\&quot;</span><span class="s1">, schema);</span><span class="s3">\n        </span><span class="s1">it.items = true;</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, schema))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">cxt.ok((0, code_1.validateArray)(cxt));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function validateTuple(cxt, extraItems, schArr = cxt.schema) {</span><span class="s3">\n    </span><span class="s1">const { gen, parentSchema, data, keyword, it } = cxt;</span><span class="s3">\n    </span><span class="s1">checkStrictTuple(parentSchema);</span><span class="s3">\n    </span><span class="s1">if (it.opts.unevaluated &amp;&amp; schArr.length &amp;&amp; it.items !== true) {</span><span class="s3">\n        </span><span class="s1">it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const len = gen.const(</span><span class="s3">\&quot;</span><span class="s1">len</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${data}.length`);</span><span class="s3">\n    </span><span class="s1">schArr.forEach((sch, i) =&gt; {</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, sch))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1._) `${len} &gt; ${i}`, () =&gt; cxt.subschema({</span><span class="s3">\n            </span><span class="s1">keyword,</span><span class="s3">\n            </span><span class="s1">schemaProp: i,</span><span class="s3">\n            </span><span class="s1">dataProp: i,</span><span class="s3">\n        </span><span class="s1">}, valid));</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function checkStrictTuple(sch) {</span><span class="s3">\n        </span><span class="s1">const { opts, errSchemaPath } = it;</span><span class="s3">\n        </span><span class="s1">const l = schArr.length;</span><span class="s3">\n        </span><span class="s1">const fullTuple = l === sch.minItems &amp;&amp; (l === sch.maxItems || sch[extraItems] === false);</span><span class="s3">\n        </span><span class="s1">if (opts.strictTuples &amp;&amp; !fullTuple) {</span><span class="s3">\n            </span><span class="s1">const msg = `</span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path </span><span class="s3">\&quot;</span><span class="s1">${errSchemaPath}</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n            </span><span class="s1">(0, util_1.checkStrictMode)(it, msg, opts.strictTuples);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateTuple = validateTuple;</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=items.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const additionalItems_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./additionalItems</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { len } }) =&gt; (0, codegen_1.str) `must NOT have more than ${len} items`,</span><span class="s3">\n    </span><span class="s1">params: ({ params: { len } }) =&gt; (0, codegen_1._) `{limit: ${len}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">items</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { schema, parentSchema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { prefixItems } = parentSchema;</span><span class="s3">\n        </span><span class="s1">it.items = true;</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, schema))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (prefixItems)</span><span class="s3">\n            </span><span class="s1">(0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">cxt.ok((0, code_1.validateArray)(cxt));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=items2020.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">not</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">trackErrors: true,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, schema)) {</span><span class="s3">\n            </span><span class="s1">cxt.fail();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">cxt.subschema({</span><span class="s3">\n            </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">not</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">compositeRule: true,</span><span class="s3">\n            </span><span class="s1">createErrors: false,</span><span class="s3">\n            </span><span class="s1">allErrors: false,</span><span class="s3">\n        </span><span class="s1">}, valid);</span><span class="s3">\n        </span><span class="s1">cxt.failResult(valid, () =&gt; cxt.reset(), () =&gt; cxt.error());</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">error: { message: </span><span class="s3">\&quot;</span><span class="s1">must NOT be valid</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=not.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">must match exactly one schema in oneOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params: ({ params }) =&gt; (0, codegen_1._) `{passingSchemas: ${params.passing}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">oneOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">trackErrors: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, parentSchema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(schema))</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (it.opts.discriminator &amp;&amp; parentSchema.discriminator)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const schArr = schema;</span><span class="s3">\n        </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, false);</span><span class="s3">\n        </span><span class="s1">const passing = gen.let(</span><span class="s3">\&quot;</span><span class="s1">passing</span><span class="s3">\&quot;</span><span class="s1">, null);</span><span class="s3">\n        </span><span class="s1">const schValid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">_valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">cxt.setParams({ passing });</span><span class="s3">\n        </span><span class="s1">// TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas</span><span class="s3">\n        </span><span class="s1">gen.block(validateOneOf);</span><span class="s3">\n        </span><span class="s1">cxt.result(valid, () =&gt; cxt.reset(), () =&gt; cxt.error(true));</span><span class="s3">\n        </span><span class="s1">function validateOneOf() {</span><span class="s3">\n            </span><span class="s1">schArr.forEach((sch, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">let schCxt;</span><span class="s3">\n                </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, sch)) {</span><span class="s3">\n                    </span><span class="s1">gen.var(schValid, true);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">schCxt = cxt.subschema({</span><span class="s3">\n                        </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">oneOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        </span><span class="s1">schemaProp: i,</span><span class="s3">\n                        </span><span class="s1">compositeRule: true,</span><span class="s3">\n                    </span><span class="s1">}, schValid);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n                    </span><span class="s1">gen</span><span class="s3">\n                        </span><span class="s1">.if((0, codegen_1._) `${schValid} &amp;&amp; ${valid}`)</span><span class="s3">\n                        </span><span class="s1">.assign(valid, false)</span><span class="s3">\n                        </span><span class="s1">.assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)</span><span class="s3">\n                        </span><span class="s1">.else();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">gen.if(schValid, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">gen.assign(valid, true);</span><span class="s3">\n                    </span><span class="s1">gen.assign(passing, i);</span><span class="s3">\n                    </span><span class="s1">if (schCxt)</span><span class="s3">\n                        </span><span class="s1">cxt.mergeEvaluated(schCxt, codegen_1.Name);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=oneOf.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_2 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">patternProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, data, parentSchema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { opts } = it;</span><span class="s3">\n        </span><span class="s1">const patterns = (0, code_1.allSchemaProperties)(schema);</span><span class="s3">\n        </span><span class="s1">const alwaysValidPatterns = patterns.filter((p) =&gt; (0, util_1.alwaysValidSchema)(it, schema[p]));</span><span class="s3">\n        </span><span class="s1">if (patterns.length === 0 ||</span><span class="s3">\n            </span><span class="s1">(alwaysValidPatterns.length === patterns.length &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(!it.opts.unevaluated || it.props === true))) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const checkProperties = opts.strictSchema &amp;&amp; !opts.allowMatchingProperties &amp;&amp; parentSchema.properties;</span><span class="s3">\n        </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (it.props !== true &amp;&amp; !(it.props instanceof codegen_1.Name)) {</span><span class="s3">\n            </span><span class="s1">it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const { props } = it;</span><span class="s3">\n        </span><span class="s1">validatePatternProperties();</span><span class="s3">\n        </span><span class="s1">function validatePatternProperties() {</span><span class="s3">\n            </span><span class="s1">for (const pat of patterns) {</span><span class="s3">\n                </span><span class="s1">if (checkProperties)</span><span class="s3">\n                    </span><span class="s1">checkMatchingProperties(pat);</span><span class="s3">\n                </span><span class="s1">if (it.allErrors) {</span><span class="s3">\n                    </span><span class="s1">validateProperties(pat);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">gen.var(valid, true); // TODO var</span><span class="s3">\n                    </span><span class="s1">validateProperties(pat);</span><span class="s3">\n                    </span><span class="s1">gen.if(valid);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function checkMatchingProperties(pat) {</span><span class="s3">\n            </span><span class="s1">for (const prop in checkProperties) {</span><span class="s3">\n                </span><span class="s1">if (new RegExp(pat).test(prop)) {</span><span class="s3">\n                    </span><span class="s1">(0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function validateProperties(pat) {</span><span class="s3">\n            </span><span class="s1">gen.forIn(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, data, (key) =&gt; {</span><span class="s3">\n                </span><span class="s1">gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">const alwaysValid = alwaysValidPatterns.includes(pat);</span><span class="s3">\n                    </span><span class="s1">if (!alwaysValid) {</span><span class="s3">\n                        </span><span class="s1">cxt.subschema({</span><span class="s3">\n                            </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">patternProperties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                            </span><span class="s1">schemaProp: pat,</span><span class="s3">\n                            </span><span class="s1">dataProp: key,</span><span class="s3">\n                            </span><span class="s1">dataPropType: util_2.Type.Str,</span><span class="s3">\n                        </span><span class="s1">}, valid);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (it.opts.unevaluated &amp;&amp; props !== true) {</span><span class="s3">\n                        </span><span class="s1">gen.assign((0, codegen_1._) `${props}[${key}]`, true);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (!alwaysValid &amp;&amp; !it.allErrors) {</span><span class="s3">\n                        </span><span class="s1">// can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)</span><span class="s3">\n                        </span><span class="s1">// or if all properties were evaluated (props === true)</span><span class="s3">\n                        </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; gen.break());</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=patternProperties.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const items_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./items</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">prefixItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code: (cxt) =&gt; (0, items_1.validateTuple)(cxt, </span><span class="s3">\&quot;</span><span class="s1">items</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=prefixItems.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const validate_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/validate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const additionalProperties_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./additionalProperties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, parentSchema, data, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if (it.opts.removeAdditional === </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parentSchema.additionalProperties === undefined) {</span><span class="s3">\n            </span><span class="s1">additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, </span><span class="s3">\&quot;</span><span class="s1">additionalProperties</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const allProps = (0, code_1.allSchemaProperties)(schema);</span><span class="s3">\n        </span><span class="s1">for (const prop of allProps) {</span><span class="s3">\n            </span><span class="s1">it.definedProperties.add(prop);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (it.opts.unevaluated &amp;&amp; allProps.length &amp;&amp; it.props !== true) {</span><span class="s3">\n            </span><span class="s1">it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const properties = allProps.filter((p) =&gt; !(0, util_1.alwaysValidSchema)(it, schema[p]));</span><span class="s3">\n        </span><span class="s1">if (properties.length === 0)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">for (const prop of properties) {</span><span class="s3">\n            </span><span class="s1">if (hasDefault(prop)) {</span><span class="s3">\n                </span><span class="s1">applyPropertySchema(prop);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));</span><span class="s3">\n                </span><span class="s1">applyPropertySchema(prop);</span><span class="s3">\n                </span><span class="s1">if (!it.allErrors)</span><span class="s3">\n                    </span><span class="s1">gen.else().var(valid, true);</span><span class="s3">\n                </span><span class="s1">gen.endIf();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">cxt.it.definedProperties.add(prop);</span><span class="s3">\n            </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function hasDefault(prop) {</span><span class="s3">\n            </span><span class="s1">return it.opts.useDefaults &amp;&amp; !it.compositeRule &amp;&amp; schema[prop].default !== undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function applyPropertySchema(prop) {</span><span class="s3">\n            </span><span class="s1">cxt.subschema({</span><span class="s3">\n                </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">schemaProp: prop,</span><span class="s3">\n                </span><span class="s1">dataProp: prop,</span><span class="s3">\n            </span><span class="s1">}, valid);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=properties.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">property name must be valid</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params: ({ params }) =&gt; (0, codegen_1._) `{propertyName: ${params.propertyName}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">propertyNames</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, data, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if ((0, util_1.alwaysValidSchema)(it, schema))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">gen.forIn(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, data, (key) =&gt; {</span><span class="s3">\n            </span><span class="s1">cxt.setParams({ propertyName: key });</span><span class="s3">\n            </span><span class="s1">cxt.subschema({</span><span class="s3">\n                </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">propertyNames</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">data: key,</span><span class="s3">\n                </span><span class="s1">dataTypes: [</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n                </span><span class="s1">propertyName: key,</span><span class="s3">\n                </span><span class="s1">compositeRule: true,</span><span class="s3">\n            </span><span class="s1">}, valid);</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; {</span><span class="s3">\n                </span><span class="s1">cxt.error(true);</span><span class="s3">\n                </span><span class="s1">if (!it.allErrors)</span><span class="s3">\n                    </span><span class="s1">gen.break();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=propertyNames.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: [</span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">schemaType: [</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">code({ keyword, parentSchema, it }) {</span><span class="s3">\n        </span><span class="s1">if (parentSchema.if === undefined)</span><span class="s3">\n            </span><span class="s1">(0, util_1.checkStrictMode)(it, `</span><span class="s3">\&quot;</span><span class="s1">${keyword}</span><span class="s3">\&quot; </span><span class="s1">without </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot; </span><span class="s1">is ignored`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=thenElse.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../compile/names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_2 = require(</span><span class="s3">\&quot;</span><span class="s1">../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function checkReportMissingProp(cxt, prop) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, it } = cxt;</span><span class="s3">\n    </span><span class="s1">gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () =&gt; {</span><span class="s3">\n        </span><span class="s1">cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);</span><span class="s3">\n        </span><span class="s1">cxt.error();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.checkReportMissingProp = checkReportMissingProp;</span><span class="s3">\n</span><span class="s1">function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {</span><span class="s3">\n    </span><span class="s1">return (0, codegen_1.or)(...properties.map((prop) =&gt; (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.checkMissingProp = checkMissingProp;</span><span class="s3">\n</span><span class="s1">function reportMissingProp(cxt, missing) {</span><span class="s3">\n    </span><span class="s1">cxt.setParams({ missingProperty: missing }, true);</span><span class="s3">\n    </span><span class="s1">cxt.error();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.reportMissingProp = reportMissingProp;</span><span class="s3">\n</span><span class="s1">function hasPropFunc(gen) {</span><span class="s3">\n    </span><span class="s1">return gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/unbound-method</span><span class="s3">\n        </span><span class="s1">ref: Object.prototype.hasOwnProperty,</span><span class="s3">\n        </span><span class="s1">code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.hasPropFunc = hasPropFunc;</span><span class="s3">\n</span><span class="s1">function isOwnProperty(gen, data, property) {</span><span class="s3">\n    </span><span class="s1">return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.isOwnProperty = isOwnProperty;</span><span class="s3">\n</span><span class="s1">function propertyInData(gen, data, property, ownProperties) {</span><span class="s3">\n    </span><span class="s1">const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;</span><span class="s3">\n    </span><span class="s1">return ownProperties ? (0, codegen_1._) `${cond} &amp;&amp; ${isOwnProperty(gen, data, property)}` : cond;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.propertyInData = propertyInData;</span><span class="s3">\n</span><span class="s1">function noPropertyInData(gen, data, property, ownProperties) {</span><span class="s3">\n    </span><span class="s1">const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;</span><span class="s3">\n    </span><span class="s1">return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.noPropertyInData = noPropertyInData;</span><span class="s3">\n</span><span class="s1">function allSchemaProperties(schemaMap) {</span><span class="s3">\n    </span><span class="s1">return schemaMap ? Object.keys(schemaMap).filter((p) =&gt; p !== </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;</span><span class="s1">) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.allSchemaProperties = allSchemaProperties;</span><span class="s3">\n</span><span class="s1">function schemaProperties(it, schemaMap) {</span><span class="s3">\n    </span><span class="s1">return allSchemaProperties(schemaMap).filter((p) =&gt; !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.schemaProperties = schemaProperties;</span><span class="s3">\n</span><span class="s1">function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {</span><span class="s3">\n    </span><span class="s1">const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;</span><span class="s3">\n    </span><span class="s1">const valCxt = [</span><span class="s3">\n        </span><span class="s1">[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],</span><span class="s3">\n        </span><span class="s1">[names_1.default.parentData, it.parentData],</span><span class="s3">\n        </span><span class="s1">[names_1.default.parentDataProperty, it.parentDataProperty],</span><span class="s3">\n        </span><span class="s1">[names_1.default.rootData, names_1.default.rootData],</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">if (it.opts.dynamicRef)</span><span class="s3">\n        </span><span class="s1">valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);</span><span class="s3">\n    </span><span class="s1">const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;</span><span class="s3">\n    </span><span class="s1">return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.callValidateCode = callValidateCode;</span><span class="s3">\n</span><span class="s1">const newRegExp = (0, codegen_1._) `new RegExp`;</span><span class="s3">\n</span><span class="s1">function usePattern({ gen, it: { opts } }, pattern) {</span><span class="s3">\n    </span><span class="s1">const u = opts.unicodeRegExp ? </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">const { regExp } = opts.code;</span><span class="s3">\n    </span><span class="s1">const rx = regExp(pattern, u);</span><span class="s3">\n    </span><span class="s1">return gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n        </span><span class="s1">key: rx.toString(),</span><span class="s3">\n        </span><span class="s1">ref: rx,</span><span class="s3">\n        </span><span class="s1">code: (0, codegen_1._) `${regExp.code === </span><span class="s3">\&quot;</span><span class="s1">new RegExp</span><span class="s3">\&quot; </span><span class="s1">? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.usePattern = usePattern;</span><span class="s3">\n</span><span class="s1">function validateArray(cxt) {</span><span class="s3">\n    </span><span class="s1">const { gen, data, keyword, it } = cxt;</span><span class="s3">\n    </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (it.allErrors) {</span><span class="s3">\n        </span><span class="s1">const validArr = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n        </span><span class="s1">validateItems(() =&gt; gen.assign(validArr, false));</span><span class="s3">\n        </span><span class="s1">return validArr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gen.var(valid, true);</span><span class="s3">\n    </span><span class="s1">validateItems(() =&gt; gen.break());</span><span class="s3">\n    </span><span class="s1">return valid;</span><span class="s3">\n    </span><span class="s1">function validateItems(notValid) {</span><span class="s3">\n        </span><span class="s1">const len = gen.const(</span><span class="s3">\&quot;</span><span class="s1">len</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${data}.length`);</span><span class="s3">\n        </span><span class="s1">gen.forRange(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">, 0, len, (i) =&gt; {</span><span class="s3">\n            </span><span class="s1">cxt.subschema({</span><span class="s3">\n                </span><span class="s1">keyword,</span><span class="s3">\n                </span><span class="s1">dataProp: i,</span><span class="s3">\n                </span><span class="s1">dataPropType: util_1.Type.Num,</span><span class="s3">\n            </span><span class="s1">}, valid);</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1.not)(valid), notValid);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateArray = validateArray;</span><span class="s3">\n</span><span class="s1">function validateUnion(cxt) {</span><span class="s3">\n    </span><span class="s1">const { gen, schema, keyword, it } = cxt;</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(schema))</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const alwaysValid = schema.some((sch) =&gt; (0, util_1.alwaysValidSchema)(it, sch));</span><span class="s3">\n    </span><span class="s1">if (alwaysValid &amp;&amp; !it.opts.unevaluated)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, false);</span><span class="s3">\n    </span><span class="s1">const schValid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">_valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">gen.block(() =&gt; schema.forEach((_sch, i) =&gt; {</span><span class="s3">\n        </span><span class="s1">const schCxt = cxt.subschema({</span><span class="s3">\n            </span><span class="s1">keyword,</span><span class="s3">\n            </span><span class="s1">schemaProp: i,</span><span class="s3">\n            </span><span class="s1">compositeRule: true,</span><span class="s3">\n        </span><span class="s1">}, schValid);</span><span class="s3">\n        </span><span class="s1">gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);</span><span class="s3">\n        </span><span class="s1">const merged = cxt.mergeValidEvaluated(schCxt, schValid);</span><span class="s3">\n        </span><span class="s1">// can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)</span><span class="s3">\n        </span><span class="s1">// or if all properties and items were evaluated (it.props === true &amp;&amp; it.items === true)</span><span class="s3">\n        </span><span class="s1">if (!merged)</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1.not)(valid));</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">cxt.result(valid, () =&gt; cxt.reset(), () =&gt; cxt.error(true));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.validateUnion = validateUnion;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=code.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code() {</span><span class="s3">\n        </span><span class="s1">throw new Error('NOT SUPPORTED: keyword </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, use </span><span class="s3">\&quot;</span><span class="s1">$id</span><span class="s3">\&quot; </span><span class="s1">for schema ID');</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=id.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const id_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./id</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ref_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ref</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const core = [</span><span class="s3">\n    \&quot;</span><span class="s1">$schema</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$defs</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">$vocabulary</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">{ keyword: </span><span class="s3">\&quot;</span><span class="s1">$comment</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">definitions</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id_1.default,</span><span class="s3">\n    </span><span class="s1">ref_1.default,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">exports.default = core;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.callRef = exports.getValidate = void 0;</span><span class="s3">\n</span><span class="s1">const ref_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/ref_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const names_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/names</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const compile_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema: $ref, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { baseId, schemaEnv: env, validateName, opts, self } = it;</span><span class="s3">\n        </span><span class="s1">const { root } = env;</span><span class="s3">\n        </span><span class="s1">if (($ref === </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">|| $ref === </span><span class="s3">\&quot;</span><span class="s1">#/</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; baseId === root.baseId)</span><span class="s3">\n            </span><span class="s1">return callRootRef();</span><span class="s3">\n        </span><span class="s1">const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);</span><span class="s3">\n        </span><span class="s1">if (schOrEnv === undefined)</span><span class="s3">\n            </span><span class="s1">throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);</span><span class="s3">\n        </span><span class="s1">if (schOrEnv instanceof compile_1.SchemaEnv)</span><span class="s3">\n            </span><span class="s1">return callValidate(schOrEnv);</span><span class="s3">\n        </span><span class="s1">return inlineRefSchema(schOrEnv);</span><span class="s3">\n        </span><span class="s1">function callRootRef() {</span><span class="s3">\n            </span><span class="s1">if (env === root)</span><span class="s3">\n                </span><span class="s1">return callRef(cxt, validateName, env, env.$async);</span><span class="s3">\n            </span><span class="s1">const rootName = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">, { ref: root });</span><span class="s3">\n            </span><span class="s1">return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function callValidate(sch) {</span><span class="s3">\n            </span><span class="s1">const v = getValidate(cxt, sch);</span><span class="s3">\n            </span><span class="s1">callRef(cxt, v, sch, sch.$async);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function inlineRefSchema(sch) {</span><span class="s3">\n            </span><span class="s1">const schName = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">schema</span><span class="s3">\&quot;</span><span class="s1">, opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });</span><span class="s3">\n            </span><span class="s1">const valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const schCxt = cxt.subschema({</span><span class="s3">\n                </span><span class="s1">schema: sch,</span><span class="s3">\n                </span><span class="s1">dataTypes: [],</span><span class="s3">\n                </span><span class="s1">schemaPath: codegen_1.nil,</span><span class="s3">\n                </span><span class="s1">topSchemaRef: schName,</span><span class="s3">\n                </span><span class="s1">errSchemaPath: $ref,</span><span class="s3">\n            </span><span class="s1">}, valid);</span><span class="s3">\n            </span><span class="s1">cxt.mergeEvaluated(schCxt);</span><span class="s3">\n            </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function getValidate(cxt, sch) {</span><span class="s3">\n    </span><span class="s1">const { gen } = cxt;</span><span class="s3">\n    </span><span class="s1">return sch.validate</span><span class="s3">\n        </span><span class="s1">? gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">validate</span><span class="s3">\&quot;</span><span class="s1">, { ref: sch.validate })</span><span class="s3">\n        </span><span class="s1">: (0, codegen_1._) `${gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">wrapper</span><span class="s3">\&quot;</span><span class="s1">, { ref: sch })}.validate`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getValidate = getValidate;</span><span class="s3">\n</span><span class="s1">function callRef(cxt, v, sch, $async) {</span><span class="s3">\n    </span><span class="s1">const { gen, it } = cxt;</span><span class="s3">\n    </span><span class="s1">const { allErrors, schemaEnv: env, opts } = it;</span><span class="s3">\n    </span><span class="s1">const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;</span><span class="s3">\n    </span><span class="s1">if ($async)</span><span class="s3">\n        </span><span class="s1">callAsyncRef();</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">callSyncRef();</span><span class="s3">\n    </span><span class="s1">function callAsyncRef() {</span><span class="s3">\n        </span><span class="s1">if (!env.$async)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">async schema referenced by sync schema</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">gen.try(() =&gt; {</span><span class="s3">\n            </span><span class="s1">gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);</span><span class="s3">\n            </span><span class="s1">addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result</span><span class="s3">\n            </span><span class="s1">if (!allErrors)</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, true);</span><span class="s3">\n        </span><span class="s1">}, (e) =&gt; {</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () =&gt; gen.throw(e));</span><span class="s3">\n            </span><span class="s1">addErrorsFrom(e);</span><span class="s3">\n            </span><span class="s1">if (!allErrors)</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, false);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function callSyncRef() {</span><span class="s3">\n        </span><span class="s1">cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () =&gt; addEvaluatedFrom(v), () =&gt; addErrorsFrom(v));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function addErrorsFrom(source) {</span><span class="s3">\n        </span><span class="s1">const errs = (0, codegen_1._) `${source}.errors`;</span><span class="s3">\n        </span><span class="s1">gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged</span><span class="s3">\n        </span><span class="s1">gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function addEvaluatedFrom(source) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (!it.opts.unevaluated)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;</span><span class="s3">\n        </span><span class="s1">// TODO refactor</span><span class="s3">\n        </span><span class="s1">if (it.props !== true) {</span><span class="s3">\n            </span><span class="s1">if (schEvaluated &amp;&amp; !schEvaluated.dynamicProps) {</span><span class="s3">\n                </span><span class="s1">if (schEvaluated.props !== undefined) {</span><span class="s3">\n                    </span><span class="s1">it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const props = gen.var(</span><span class="s3">\&quot;</span><span class="s1">props</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${source}.evaluated.props`);</span><span class="s3">\n                </span><span class="s1">it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (it.items !== true) {</span><span class="s3">\n            </span><span class="s1">if (schEvaluated &amp;&amp; !schEvaluated.dynamicItems) {</span><span class="s3">\n                </span><span class="s1">if (schEvaluated.items !== undefined) {</span><span class="s3">\n                    </span><span class="s1">it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const items = gen.var(</span><span class="s3">\&quot;</span><span class="s1">items</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${source}.evaluated.items`);</span><span class="s3">\n                </span><span class="s1">it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.callRef = callRef;</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ref.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const types_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../discriminator/types</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const compile_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ref_error_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/ref_error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { discrError, tagName } }) =&gt; discrError === types_1.DiscrError.Tag</span><span class="s3">\n        </span><span class="s1">? `tag </span><span class="s3">\&quot;</span><span class="s1">${tagName}</span><span class="s3">\&quot; </span><span class="s1">must be string`</span><span class="s3">\n        </span><span class="s1">: `value of tag </span><span class="s3">\&quot;</span><span class="s1">${tagName}</span><span class="s3">\&quot; </span><span class="s1">must be in oneOf`,</span><span class="s3">\n    </span><span class="s1">params: ({ params: { discrError, tag, tagName } }) =&gt; (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">discriminator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, schema, parentSchema, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { oneOf } = parentSchema;</span><span class="s3">\n        </span><span class="s1">if (!it.opts.discriminator) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">discriminator: requires discriminator option</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const tagName = schema.propertyName;</span><span class="s3">\n        </span><span class="s1">if (typeof tagName != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">discriminator: requires propertyName</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (schema.mapping)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">discriminator: mapping is not supported</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (!oneOf)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">discriminator: requires oneOf keyword</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, false);</span><span class="s3">\n        </span><span class="s1">const tag = gen.const(</span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);</span><span class="s3">\n        </span><span class="s1">gen.if((0, codegen_1._) `typeof ${tag} == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">`, () =&gt; validateMapping(), () =&gt; cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n        </span><span class="s1">function validateMapping() {</span><span class="s3">\n            </span><span class="s1">const mapping = getMapping();</span><span class="s3">\n            </span><span class="s1">gen.if(false);</span><span class="s3">\n            </span><span class="s1">for (const tagValue in mapping) {</span><span class="s3">\n                </span><span class="s1">gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, applyTagSchema(mapping[tagValue]));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">gen.else();</span><span class="s3">\n            </span><span class="s1">cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });</span><span class="s3">\n            </span><span class="s1">gen.endIf();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function applyTagSchema(schemaProp) {</span><span class="s3">\n            </span><span class="s1">const _valid = gen.name(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const schCxt = cxt.subschema({ keyword: </span><span class="s3">\&quot;</span><span class="s1">oneOf</span><span class="s3">\&quot;</span><span class="s1">, schemaProp }, _valid);</span><span class="s3">\n            </span><span class="s1">cxt.mergeEvaluated(schCxt, codegen_1.Name);</span><span class="s3">\n            </span><span class="s1">return _valid;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function getMapping() {</span><span class="s3">\n            </span><span class="s1">var _a;</span><span class="s3">\n            </span><span class="s1">const oneOfMapping = {};</span><span class="s3">\n            </span><span class="s1">const topRequired = hasRequired(parentSchema);</span><span class="s3">\n            </span><span class="s1">let tagRequired = true;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; oneOf.length; i++) {</span><span class="s3">\n                </span><span class="s1">let sch = oneOf[i];</span><span class="s3">\n                </span><span class="s1">if ((sch === null || sch === void 0 ? void 0 : sch.$ref) &amp;&amp; !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {</span><span class="s3">\n                    </span><span class="s1">const ref = sch.$ref;</span><span class="s3">\n                    </span><span class="s1">sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);</span><span class="s3">\n                    </span><span class="s1">if (sch instanceof compile_1.SchemaEnv)</span><span class="s3">\n                        </span><span class="s1">sch = sch.schema;</span><span class="s3">\n                    </span><span class="s1">if (sch === undefined)</span><span class="s3">\n                        </span><span class="s1">throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];</span><span class="s3">\n                </span><span class="s1">if (typeof propSch != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have </span><span class="s3">\&quot;</span><span class="s1">properties/${tagName}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">tagRequired = tagRequired &amp;&amp; (topRequired || hasRequired(sch));</span><span class="s3">\n                </span><span class="s1">addMappings(propSch, i);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!tagRequired)</span><span class="s3">\n                </span><span class="s1">throw new Error(`discriminator: </span><span class="s3">\&quot;</span><span class="s1">${tagName}</span><span class="s3">\&quot; </span><span class="s1">must be required`);</span><span class="s3">\n            </span><span class="s1">return oneOfMapping;</span><span class="s3">\n            </span><span class="s1">function hasRequired({ required }) {</span><span class="s3">\n                </span><span class="s1">return Array.isArray(required) &amp;&amp; required.includes(tagName);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">function addMappings(sch, i) {</span><span class="s3">\n                </span><span class="s1">if (sch.const) {</span><span class="s3">\n                    </span><span class="s1">addMapping(sch.const, i);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (sch.enum) {</span><span class="s3">\n                    </span><span class="s1">for (const tagValue of sch.enum) {</span><span class="s3">\n                        </span><span class="s1">addMapping(tagValue, i);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`discriminator: </span><span class="s3">\&quot;</span><span class="s1">properties/${tagName}</span><span class="s3">\&quot; </span><span class="s1">must have </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">function addMapping(tagValue, i) {</span><span class="s3">\n                </span><span class="s1">if (typeof tagValue != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| tagValue in oneOfMapping) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`discriminator: </span><span class="s3">\&quot;</span><span class="s1">${tagName}</span><span class="s3">\&quot; </span><span class="s1">values must be unique strings`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">oneOfMapping[tagValue] = i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.DiscrError = void 0;</span><span class="s3">\n</span><span class="s1">var DiscrError;</span><span class="s3">\n</span><span class="s1">(function (DiscrError) {</span><span class="s3">\n    </span><span class="s1">DiscrError[</span><span class="s3">\&quot;</span><span class="s1">Tag</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">DiscrError[</span><span class="s3">\&quot;</span><span class="s1">Mapping</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">mapping</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(DiscrError || (exports.DiscrError = DiscrError = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=types.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const core_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./core</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const validation_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./validation</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const applicator_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./applicator</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const format_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./format</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const metadata_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./metadata</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const draft7Vocabularies = [</span><span class="s3">\n    </span><span class="s1">core_1.default,</span><span class="s3">\n    </span><span class="s1">validation_1.default,</span><span class="s3">\n    </span><span class="s1">(0, applicator_1.default)(),</span><span class="s3">\n    </span><span class="s1">format_1.default,</span><span class="s3">\n    </span><span class="s1">metadata_1.metadataVocabulary,</span><span class="s3">\n    </span><span class="s1">metadata_1.contentVocabulary,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">exports.default = draft7Vocabularies;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=draft7.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ schemaCode }) =&gt; (0, codegen_1.str) `must match format </span><span class="s3">\&quot;</span><span class="s1">${schemaCode}</span><span class="s3">\&quot;</span><span class="s1">`,</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{format: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: [</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt, ruleType) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, $data, schema, schemaCode, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { opts, errSchemaPath, schemaEnv, self } = it;</span><span class="s3">\n        </span><span class="s1">if (!opts.validateFormats)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if ($data)</span><span class="s3">\n            </span><span class="s1">validate$DataFormat();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">validateFormat();</span><span class="s3">\n        </span><span class="s1">function validate$DataFormat() {</span><span class="s3">\n            </span><span class="s1">const fmts = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">formats</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n                </span><span class="s1">ref: self.formats,</span><span class="s3">\n                </span><span class="s1">code: opts.code.formats,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const fDef = gen.const(</span><span class="s3">\&quot;</span><span class="s1">fDef</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${fmts}[${schemaCode}]`);</span><span class="s3">\n            </span><span class="s1">const fType = gen.let(</span><span class="s3">\&quot;</span><span class="s1">fType</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const format = gen.let(</span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">// TODO simplify</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1._) `typeof ${fDef} == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !(${fDef} instanceof RegExp)`, () =&gt; gen.assign(fType, (0, codegen_1._) `${fDef}.type || </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">`).assign(format, (0, codegen_1._) `${fDef}.validate`), () =&gt; gen.assign(fType, (0, codegen_1._) `</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">`).assign(format, fDef));</span><span class="s3">\n            </span><span class="s1">cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));</span><span class="s3">\n            </span><span class="s1">function unknownFmt() {</span><span class="s3">\n                </span><span class="s1">if (opts.strictSchema === false)</span><span class="s3">\n                    </span><span class="s1">return codegen_1.nil;</span><span class="s3">\n                </span><span class="s1">return (0, codegen_1._) `${schemaCode} &amp;&amp; !${format}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">function invalidFmt() {</span><span class="s3">\n                </span><span class="s1">const callFormat = schemaEnv.$async</span><span class="s3">\n                    </span><span class="s1">? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`</span><span class="s3">\n                    </span><span class="s1">: (0, codegen_1._) `${format}(${data})`;</span><span class="s3">\n                </span><span class="s1">const validData = (0, codegen_1._) `(typeof ${format} == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? ${callFormat} : ${format}.test(${data}))`;</span><span class="s3">\n                </span><span class="s1">return (0, codegen_1._) `${format} &amp;&amp; ${format} !== true &amp;&amp; ${fType} === ${ruleType} &amp;&amp; !${validData}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function validateFormat() {</span><span class="s3">\n            </span><span class="s1">const formatDef = self.formats[schema];</span><span class="s3">\n            </span><span class="s1">if (!formatDef) {</span><span class="s3">\n                </span><span class="s1">unknownFormat();</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (formatDef === true)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const [fmtType, format, fmtRef] = getFormat(formatDef);</span><span class="s3">\n            </span><span class="s1">if (fmtType === ruleType)</span><span class="s3">\n                </span><span class="s1">cxt.pass(validCondition());</span><span class="s3">\n            </span><span class="s1">function unknownFormat() {</span><span class="s3">\n                </span><span class="s1">if (opts.strictSchema === false) {</span><span class="s3">\n                    </span><span class="s1">self.logger.warn(unknownMsg());</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">throw new Error(unknownMsg());</span><span class="s3">\n                </span><span class="s1">function unknownMsg() {</span><span class="s3">\n                    </span><span class="s1">return `unknown format </span><span class="s3">\&quot;</span><span class="s1">${schema}</span><span class="s3">\&quot; </span><span class="s1">ignored in schema at path </span><span class="s3">\&quot;</span><span class="s1">${errSchemaPath}</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">function getFormat(fmtDef) {</span><span class="s3">\n                </span><span class="s1">const code = fmtDef instanceof RegExp</span><span class="s3">\n                    </span><span class="s1">? (0, codegen_1.regexpCode)(fmtDef)</span><span class="s3">\n                    </span><span class="s1">: opts.code.formats</span><span class="s3">\n                        </span><span class="s1">? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`</span><span class="s3">\n                        </span><span class="s1">: undefined;</span><span class="s3">\n                </span><span class="s1">const fmt = gen.scopeValue(</span><span class="s3">\&quot;</span><span class="s1">formats</span><span class="s3">\&quot;</span><span class="s1">, { key: schema, ref: fmtDef, code });</span><span class="s3">\n                </span><span class="s1">if (typeof fmtDef == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !(fmtDef instanceof RegExp)) {</span><span class="s3">\n                    </span><span class="s1">return [fmtDef.type || </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return [</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, fmtDef, fmt];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">function validCondition() {</span><span class="s3">\n                </span><span class="s1">if (typeof formatDef == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !(formatDef instanceof RegExp) &amp;&amp; formatDef.async) {</span><span class="s3">\n                    </span><span class="s1">if (!schemaEnv.$async)</span><span class="s3">\n                        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">async format in sync schema</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">return (0, codegen_1._) `await ${fmtRef}(${data})`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return typeof format == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=format.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const format_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./format</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const format = [format_1.default];</span><span class="s3">\n</span><span class="s1">exports.default = format;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.contentVocabulary = exports.metadataVocabulary = void 0;</span><span class="s3">\n</span><span class="s1">exports.metadataVocabulary = [</span><span class="s3">\n    \&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">description</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">deprecated</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">readOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">writeOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">examples</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">exports.contentVocabulary = [</span><span class="s3">\n    \&quot;</span><span class="s1">contentMediaType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">contentEncoding</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">contentSchema</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=metadata.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const equal_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../runtime/equal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">must be equal to constant</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{allowedValue: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, $data, schemaCode, schema } = cxt;</span><span class="s3">\n        </span><span class="s1">if ($data || (schema &amp;&amp; typeof schema == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">cxt.fail((0, codegen_1._) `${schema} !== ${data}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=const.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const equal_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../runtime/equal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">must be equal to one of the allowed values</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{allowedValues: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, $data, schema, schemaCode, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if (!$data &amp;&amp; schema.length === 0)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">enum must have non-empty array</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const useLoop = schema.length &gt;= it.opts.loopEnum;</span><span class="s3">\n        </span><span class="s1">let eql;</span><span class="s3">\n        </span><span class="s1">const getEql = () =&gt; (eql !== null &amp;&amp; eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));</span><span class="s3">\n        </span><span class="s1">let valid;</span><span class="s3">\n        </span><span class="s1">if (useLoop || $data) {</span><span class="s3">\n            </span><span class="s1">valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">cxt.block$data(valid, loopEnum);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n            </span><span class="s1">if (!Array.isArray(schema))</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">ajv implementation error</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const vSchema = gen.const(</span><span class="s3">\&quot;</span><span class="s1">vSchema</span><span class="s3">\&quot;</span><span class="s1">, schemaCode);</span><span class="s3">\n            </span><span class="s1">valid = (0, codegen_1.or)(...schema.map((_x, i) =&gt; equalCode(vSchema, i)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cxt.pass(valid);</span><span class="s3">\n        </span><span class="s1">function loopEnum() {</span><span class="s3">\n            </span><span class="s1">gen.assign(valid, false);</span><span class="s3">\n            </span><span class="s1">gen.forOf(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">, schemaCode, (v) =&gt; gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () =&gt; gen.assign(valid, true).break()));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function equalCode(vSchema, i) {</span><span class="s3">\n            </span><span class="s1">const sch = schema[i];</span><span class="s3">\n            </span><span class="s1">return typeof sch === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; sch !== null</span><span class="s3">\n                </span><span class="s1">? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`</span><span class="s3">\n                </span><span class="s1">: (0, codegen_1._) `${data} === ${sch}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enum.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const limitNumber_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./limitNumber</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const multipleOf_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./multipleOf</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const limitLength_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./limitLength</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const pattern_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./pattern</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const limitProperties_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./limitProperties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const required_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./required</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const limitItems_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./limitItems</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const uniqueItems_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./uniqueItems</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const const_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./const</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const enum_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./enum</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const validation = [</span><span class="s3">\n    </span><span class="s1">// number</span><span class="s3">\n    </span><span class="s1">limitNumber_1.default,</span><span class="s3">\n    </span><span class="s1">multipleOf_1.default,</span><span class="s3">\n    </span><span class="s1">// string</span><span class="s3">\n    </span><span class="s1">limitLength_1.default,</span><span class="s3">\n    </span><span class="s1">pattern_1.default,</span><span class="s3">\n    </span><span class="s1">// object</span><span class="s3">\n    </span><span class="s1">limitProperties_1.default,</span><span class="s3">\n    </span><span class="s1">required_1.default,</span><span class="s3">\n    </span><span class="s1">// array</span><span class="s3">\n    </span><span class="s1">limitItems_1.default,</span><span class="s3">\n    </span><span class="s1">uniqueItems_1.default,</span><span class="s3">\n    </span><span class="s1">// any</span><span class="s3">\n    </span><span class="s1">{ keyword: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, schemaType: [</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">] },</span><span class="s3">\n    </span><span class="s1">{ keyword: </span><span class="s3">\&quot;</span><span class="s1">nullable</span><span class="s3">\&quot;</span><span class="s1">, schemaType: </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">const_1.default,</span><span class="s3">\n    </span><span class="s1">enum_1.default,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">exports.default = validation;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message({ keyword, schemaCode }) {</span><span class="s3">\n        </span><span class="s1">const comp = keyword === </span><span class="s3">\&quot;</span><span class="s1">maxItems</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">more</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">fewer</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{limit: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: [</span><span class="s3">\&quot;</span><span class="s1">maxItems</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">minItems</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { keyword, data, schemaCode } = cxt;</span><span class="s3">\n        </span><span class="s1">const op = keyword === </span><span class="s3">\&quot;</span><span class="s1">maxItems</span><span class="s3">\&quot; </span><span class="s1">? codegen_1.operators.GT : codegen_1.operators.LT;</span><span class="s3">\n        </span><span class="s1">cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=limitItems.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ucs2length_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../runtime/ucs2length</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message({ keyword, schemaCode }) {</span><span class="s3">\n        </span><span class="s1">const comp = keyword === </span><span class="s3">\&quot;</span><span class="s1">maxLength</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">more</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">fewer</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{limit: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: [</span><span class="s3">\&quot;</span><span class="s1">maxLength</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">minLength</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { keyword, data, schemaCode, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const op = keyword === </span><span class="s3">\&quot;</span><span class="s1">maxLength</span><span class="s3">\&quot; </span><span class="s1">? codegen_1.operators.GT : codegen_1.operators.LT;</span><span class="s3">\n        </span><span class="s1">const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;</span><span class="s3">\n        </span><span class="s1">cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=limitLength.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ops = codegen_1.operators;</span><span class="s3">\n</span><span class="s1">const KWDs = {</span><span class="s3">\n    </span><span class="s1">maximum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.LTE, fail: ops.GT },</span><span class="s3">\n    </span><span class="s1">minimum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.GTE, fail: ops.LT },</span><span class="s3">\n    </span><span class="s1">exclusiveMaximum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.LT, fail: ops.GTE },</span><span class="s3">\n    </span><span class="s1">exclusiveMinimum: { okStr: </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, ok: ops.GT, fail: ops.LTE },</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ keyword, schemaCode }) =&gt; (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,</span><span class="s3">\n    </span><span class="s1">params: ({ keyword, schemaCode }) =&gt; (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: Object.keys(KWDs),</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { keyword, data, schemaCode } = cxt;</span><span class="s3">\n        </span><span class="s1">cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=limitNumber.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message({ keyword, schemaCode }) {</span><span class="s3">\n        </span><span class="s1">const comp = keyword === </span><span class="s3">\&quot;</span><span class="s1">maxProperties</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">more</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">fewer</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{limit: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: [</span><span class="s3">\&quot;</span><span class="s1">maxProperties</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">minProperties</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { keyword, data, schemaCode } = cxt;</span><span class="s3">\n        </span><span class="s1">const op = keyword === </span><span class="s3">\&quot;</span><span class="s1">maxProperties</span><span class="s3">\&quot; </span><span class="s1">? codegen_1.operators.GT : codegen_1.operators.LT;</span><span class="s3">\n        </span><span class="s1">cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=limitProperties.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ schemaCode }) =&gt; (0, codegen_1.str) `must be multiple of ${schemaCode}`,</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{multipleOf: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">multipleOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, schemaCode, it } = cxt;</span><span class="s3">\n        </span><span class="s1">// const bdt = bad$DataType(schemaCode, &lt;string&gt;def.schemaType, $data)</span><span class="s3">\n        </span><span class="s1">const prec = it.opts.multipleOfPrecision;</span><span class="s3">\n        </span><span class="s1">const res = gen.let(</span><span class="s3">\&quot;</span><span class="s1">res</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const invalid = prec</span><span class="s3">\n            </span><span class="s1">? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) &gt; 1e-${prec}`</span><span class="s3">\n            </span><span class="s1">: (0, codegen_1._) `${res} !== parseInt(${res})`;</span><span class="s3">\n        </span><span class="s1">cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=multipleOf.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ schemaCode }) =&gt; (0, codegen_1.str) `must match pattern </span><span class="s3">\&quot;</span><span class="s1">${schemaCode}</span><span class="s3">\&quot;</span><span class="s1">`,</span><span class="s3">\n    </span><span class="s1">params: ({ schemaCode }) =&gt; (0, codegen_1._) `{pattern: ${schemaCode}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { data, $data, schema, schemaCode, it } = cxt;</span><span class="s3">\n        </span><span class="s1">// TODO regexp should be wrapped in try/catchs</span><span class="s3">\n        </span><span class="s1">const u = it.opts.unicodeRegExp ? </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);</span><span class="s3">\n        </span><span class="s1">cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=pattern.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const code_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../code</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { missingProperty } }) =&gt; (0, codegen_1.str) `must have required property '${missingProperty}'`,</span><span class="s3">\n    </span><span class="s1">params: ({ params: { missingProperty } }) =&gt; (0, codegen_1._) `{missingProperty: ${missingProperty}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">required</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, schema, schemaCode, data, $data, it } = cxt;</span><span class="s3">\n        </span><span class="s1">const { opts } = it;</span><span class="s3">\n        </span><span class="s1">if (!$data &amp;&amp; schema.length === 0)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const useLoop = schema.length &gt;= opts.loopRequired;</span><span class="s3">\n        </span><span class="s1">if (it.allErrors)</span><span class="s3">\n            </span><span class="s1">allErrorsMode();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">exitOnErrorMode();</span><span class="s3">\n        </span><span class="s1">if (opts.strictRequired) {</span><span class="s3">\n            </span><span class="s1">const props = cxt.parentSchema.properties;</span><span class="s3">\n            </span><span class="s1">const { definedProperties } = cxt.it;</span><span class="s3">\n            </span><span class="s1">for (const requiredKey of schema) {</span><span class="s3">\n                </span><span class="s1">if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined &amp;&amp; !definedProperties.has(requiredKey)) {</span><span class="s3">\n                    </span><span class="s1">const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;</span><span class="s3">\n                    </span><span class="s1">const msg = `required property </span><span class="s3">\&quot;</span><span class="s1">${requiredKey}</span><span class="s3">\&quot; </span><span class="s1">is not defined at </span><span class="s3">\&quot;</span><span class="s1">${schemaPath}</span><span class="s3">\&quot; </span><span class="s1">(strictRequired)`;</span><span class="s3">\n                    </span><span class="s1">(0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function allErrorsMode() {</span><span class="s3">\n            </span><span class="s1">if (useLoop || $data) {</span><span class="s3">\n                </span><span class="s1">cxt.block$data(codegen_1.nil, loopAllRequired);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">for (const prop of schema) {</span><span class="s3">\n                    </span><span class="s1">(0, code_1.checkReportMissingProp)(cxt, prop);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function exitOnErrorMode() {</span><span class="s3">\n            </span><span class="s1">const missing = gen.let(</span><span class="s3">\&quot;</span><span class="s1">missing</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">if (useLoop || $data) {</span><span class="s3">\n                </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n                </span><span class="s1">cxt.block$data(valid, () =&gt; loopUntilMissing(missing, valid));</span><span class="s3">\n                </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));</span><span class="s3">\n                </span><span class="s1">(0, code_1.reportMissingProp)(cxt, missing);</span><span class="s3">\n                </span><span class="s1">gen.else();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function loopAllRequired() {</span><span class="s3">\n            </span><span class="s1">gen.forOf(</span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">, schemaCode, (prop) =&gt; {</span><span class="s3">\n                </span><span class="s1">cxt.setParams({ missingProperty: prop });</span><span class="s3">\n                </span><span class="s1">gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () =&gt; cxt.error());</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function loopUntilMissing(missing, valid) {</span><span class="s3">\n            </span><span class="s1">cxt.setParams({ missingProperty: missing });</span><span class="s3">\n            </span><span class="s1">gen.forOf(missing, schemaCode, () =&gt; {</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));</span><span class="s3">\n                </span><span class="s1">gen.if((0, codegen_1.not)(valid), () =&gt; {</span><span class="s3">\n                    </span><span class="s1">cxt.error();</span><span class="s3">\n                    </span><span class="s1">gen.break();</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}, codegen_1.nil);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=required.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const dataType_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/validate/dataType</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const codegen_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/codegen</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const util_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../compile/util</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const equal_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../../runtime/equal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const error = {</span><span class="s3">\n    </span><span class="s1">message: ({ params: { i, j } }) =&gt; (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,</span><span class="s3">\n    </span><span class="s1">params: ({ params: { i, j } }) =&gt; (0, codegen_1._) `{i: ${i}, j: ${j}}`,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const def = {</span><span class="s3">\n    </span><span class="s1">keyword: </span><span class="s3">\&quot;</span><span class="s1">uniqueItems</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">schemaType: </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">$data: true,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">code(cxt) {</span><span class="s3">\n        </span><span class="s1">const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;</span><span class="s3">\n        </span><span class="s1">if (!$data &amp;&amp; !schema)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const valid = gen.let(</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];</span><span class="s3">\n        </span><span class="s1">cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);</span><span class="s3">\n        </span><span class="s1">cxt.ok(valid);</span><span class="s3">\n        </span><span class="s1">function validateUniqueItems() {</span><span class="s3">\n            </span><span class="s1">const i = gen.let(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `${data}.length`);</span><span class="s3">\n            </span><span class="s1">const j = gen.let(</span><span class="s3">\&quot;</span><span class="s1">j</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">cxt.setParams({ i, j });</span><span class="s3">\n            </span><span class="s1">gen.assign(valid, true);</span><span class="s3">\n            </span><span class="s1">gen.if((0, codegen_1._) `${i} &gt; 1`, () =&gt; (canOptimize() ? loopN : loopN2)(i, j));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function canOptimize() {</span><span class="s3">\n            </span><span class="s1">return itemTypes.length &gt; 0 &amp;&amp; !itemTypes.some((t) =&gt; t === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| t === </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function loopN(i, j) {</span><span class="s3">\n            </span><span class="s1">const item = gen.name(</span><span class="s3">\&quot;</span><span class="s1">item</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);</span><span class="s3">\n            </span><span class="s1">const indices = gen.const(</span><span class="s3">\&quot;</span><span class="s1">indices</span><span class="s3">\&quot;</span><span class="s1">, (0, codegen_1._) `{}`);</span><span class="s3">\n            </span><span class="s1">gen.for((0, codegen_1._) `;${i}--;`, () =&gt; {</span><span class="s3">\n                </span><span class="s1">gen.let(item, (0, codegen_1._) `${data}[${i}]`);</span><span class="s3">\n                </span><span class="s1">gen.if(wrongType, (0, codegen_1._) `continue`);</span><span class="s3">\n                </span><span class="s1">if (itemTypes.length &gt; 1)</span><span class="s3">\n                    </span><span class="s1">gen.if((0, codegen_1._) `typeof ${item} == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">`, (0, codegen_1._) `${item} += </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n                </span><span class="s1">gen</span><span class="s3">\n                    </span><span class="s1">.if((0, codegen_1._) `typeof ${indices}[${item}] == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">`, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);</span><span class="s3">\n                    </span><span class="s1">cxt.error();</span><span class="s3">\n                    </span><span class="s1">gen.assign(valid, false).break();</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">.code((0, codegen_1._) `${indices}[${item}] = ${i}`);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function loopN2(i, j) {</span><span class="s3">\n            </span><span class="s1">const eql = (0, util_1.useFunc)(gen, equal_1.default);</span><span class="s3">\n            </span><span class="s1">const outer = gen.name(</span><span class="s3">\&quot;</span><span class="s1">outer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">gen.label(outer).for((0, codegen_1._) `;${i}--;`, () =&gt; gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () =&gt; gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () =&gt; {</span><span class="s3">\n                </span><span class="s1">cxt.error();</span><span class="s3">\n                </span><span class="s1">gen.assign(valid, false).break(outer);</span><span class="s3">\n            </span><span class="s1">})));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.default = def;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=uniqueItems.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;var MapCache = require('./_MapCache'),</span><span class="s3">\n    </span><span class="s1">setCacheAdd = require('./_setCacheAdd'),</span><span class="s3">\n    </span><span class="s1">setCacheHas = require('./_setCacheHas');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Creates an array cache object to store unique values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {Array} [values] The values to cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function SetCache(values) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = values == null ? 0 : values.length;</span><span class="s3">\n\n  </span><span class="s1">this.__data__ = new MapCache;</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">this.add(values[index]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Add methods to `SetCache`.</span><span class="s3">\n</span><span class="s1">SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;</span><span class="s3">\n</span><span class="s1">SetCache.prototype.has = setCacheHas;</span><span class="s3">\n\n</span><span class="s1">module.exports = SetCache;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.some` for arrays without support for iteratee</span><span class="s3">\n </span><span class="s1">* shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if any element passes the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arraySome(array, predicate) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">if (predicate(array[index], index, array)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = arraySome;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsEqualDeep = require('./_baseIsEqualDeep'),</span><span class="s3">\n    </span><span class="s1">isObjectLike = require('./isObjectLike');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isEqual` which supports partial comparisons</span><span class="s3">\n </span><span class="s1">* and tracks traversed objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @param {boolean} bitmask The bitmask flags.</span><span class="s3">\n </span><span class="s1">*  1 - Unordered comparison</span><span class="s3">\n </span><span class="s1">*  2 - Partial comparison</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed `value` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsEqual(value, other, bitmask, customizer, stack) {</span><span class="s3">\n  </span><span class="s1">if (value === other) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (value == null || other == null || (!isObjectLike(value) &amp;&amp; !isObjectLike(other))) {</span><span class="s3">\n    </span><span class="s1">return value !== value &amp;&amp; other !== other;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIsEqual;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Stack = require('./_Stack'),</span><span class="s3">\n    </span><span class="s1">equalArrays = require('./_equalArrays'),</span><span class="s3">\n    </span><span class="s1">equalByTag = require('./_equalByTag'),</span><span class="s3">\n    </span><span class="s1">equalObjects = require('./_equalObjects'),</span><span class="s3">\n    </span><span class="s1">getTag = require('./_getTag'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray'),</span><span class="s3">\n    </span><span class="s1">isBuffer = require('./isBuffer'),</span><span class="s3">\n    </span><span class="s1">isTypedArray = require('./isTypedArray');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1;</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var argsTag = '[object Arguments]',</span><span class="s3">\n    </span><span class="s1">arrayTag = '[object Array]',</span><span class="s3">\n    </span><span class="s1">objectTag = '[object Object]';</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqual` for arrays and objects which performs</span><span class="s3">\n </span><span class="s1">* deep comparisons and tracks traversed objects enabling objects with circular</span><span class="s3">\n </span><span class="s1">* references to be compared.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed `object` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">var objIsArr = isArray(object),</span><span class="s3">\n      </span><span class="s1">othIsArr = isArray(other),</span><span class="s3">\n      </span><span class="s1">objTag = objIsArr ? arrayTag : getTag(object),</span><span class="s3">\n      </span><span class="s1">othTag = othIsArr ? arrayTag : getTag(other);</span><span class="s3">\n\n  </span><span class="s1">objTag = objTag == argsTag ? objectTag : objTag;</span><span class="s3">\n  </span><span class="s1">othTag = othTag == argsTag ? objectTag : othTag;</span><span class="s3">\n\n  </span><span class="s1">var objIsObj = objTag == objectTag,</span><span class="s3">\n      </span><span class="s1">othIsObj = othTag == objectTag,</span><span class="s3">\n      </span><span class="s1">isSameTag = objTag == othTag;</span><span class="s3">\n\n  </span><span class="s1">if (isSameTag &amp;&amp; isBuffer(object)) {</span><span class="s3">\n    </span><span class="s1">if (!isBuffer(other)) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">objIsArr = true;</span><span class="s3">\n    </span><span class="s1">objIsObj = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isSameTag &amp;&amp; !objIsObj) {</span><span class="s3">\n    </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n    </span><span class="s1">return (objIsArr || isTypedArray(object))</span><span class="s3">\n      </span><span class="s1">? equalArrays(object, other, bitmask, customizer, equalFunc, stack)</span><span class="s3">\n      </span><span class="s1">: equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!(bitmask &amp; COMPARE_PARTIAL_FLAG)) {</span><span class="s3">\n    </span><span class="s1">var objIsWrapped = objIsObj &amp;&amp; hasOwnProperty.call(object, '__wrapped__'),</span><span class="s3">\n        </span><span class="s1">othIsWrapped = othIsObj &amp;&amp; hasOwnProperty.call(other, '__wrapped__');</span><span class="s3">\n\n    </span><span class="s1">if (objIsWrapped || othIsWrapped) {</span><span class="s3">\n      </span><span class="s1">var objUnwrapped = objIsWrapped ? object.value() : object,</span><span class="s3">\n          </span><span class="s1">othUnwrapped = othIsWrapped ? other.value() : other;</span><span class="s3">\n\n      </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n      </span><span class="s1">return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isSameTag) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n  </span><span class="s1">return equalObjects(object, other, bitmask, customizer, equalFunc, stack);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIsEqualDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Checks if a `cache` value for `key` exists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} cache The cache to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function cacheHas(cache, key) {</span><span class="s3">\n  </span><span class="s1">return cache.has(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = cacheHas;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var SetCache = require('./_SetCache'),</span><span class="s3">\n    </span><span class="s1">arraySome = require('./_arraySome'),</span><span class="s3">\n    </span><span class="s1">cacheHas = require('./_cacheHas');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">COMPARE_UNORDERED_FLAG = 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqualDeep` for arrays with support for</span><span class="s3">\n </span><span class="s1">* partial deep comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to compare.</span><span class="s3">\n </span><span class="s1">* @param {Array} other The other array to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} stack Tracks traversed `array` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG,</span><span class="s3">\n      </span><span class="s1">arrLength = array.length,</span><span class="s3">\n      </span><span class="s1">othLength = other.length;</span><span class="s3">\n\n  </span><span class="s1">if (arrLength != othLength &amp;&amp; !(isPartial &amp;&amp; othLength &gt; arrLength)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Check that cyclic values are equal.</span><span class="s3">\n  </span><span class="s1">var arrStacked = stack.get(array);</span><span class="s3">\n  </span><span class="s1">var othStacked = stack.get(other);</span><span class="s3">\n  </span><span class="s1">if (arrStacked &amp;&amp; othStacked) {</span><span class="s3">\n    </span><span class="s1">return arrStacked == other &amp;&amp; othStacked == array;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = true,</span><span class="s3">\n      </span><span class="s1">seen = (bitmask &amp; COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;</span><span class="s3">\n\n  </span><span class="s1">stack.set(array, other);</span><span class="s3">\n  </span><span class="s1">stack.set(other, array);</span><span class="s3">\n\n  </span><span class="s1">// Ignore non-index properties.</span><span class="s3">\n  </span><span class="s1">while (++index &lt; arrLength) {</span><span class="s3">\n    </span><span class="s1">var arrValue = array[index],</span><span class="s3">\n        </span><span class="s1">othValue = other[index];</span><span class="s3">\n\n    </span><span class="s1">if (customizer) {</span><span class="s3">\n      </span><span class="s1">var compared = isPartial</span><span class="s3">\n        </span><span class="s1">? customizer(othValue, arrValue, index, other, array, stack)</span><span class="s3">\n        </span><span class="s1">: customizer(arrValue, othValue, index, array, other, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (compared !== undefined) {</span><span class="s3">\n      </span><span class="s1">if (compared) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Recursively compare arrays (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">if (seen) {</span><span class="s3">\n      </span><span class="s1">if (!arraySome(other, function(othValue, othIndex) {</span><span class="s3">\n            </span><span class="s1">if (!cacheHas(seen, othIndex) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {</span><span class="s3">\n              </span><span class="s1">return seen.push(othIndex);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">result = false;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (!(</span><span class="s3">\n          </span><span class="s1">arrValue === othValue ||</span><span class="s3">\n            </span><span class="s1">equalFunc(arrValue, othValue, bitmask, customizer, stack)</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stack['delete'](array);</span><span class="s3">\n  </span><span class="s1">stack['delete'](other);</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = equalArrays;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Symbol = require('./_Symbol'),</span><span class="s3">\n    </span><span class="s1">Uint8Array = require('./_Uint8Array'),</span><span class="s3">\n    </span><span class="s1">eq = require('./eq'),</span><span class="s3">\n    </span><span class="s1">equalArrays = require('./_equalArrays'),</span><span class="s3">\n    </span><span class="s1">mapToArray = require('./_mapToArray'),</span><span class="s3">\n    </span><span class="s1">setToArray = require('./_setToArray');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">COMPARE_UNORDERED_FLAG = 2;</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var boolTag = '[object Boolean]',</span><span class="s3">\n    </span><span class="s1">dateTag = '[object Date]',</span><span class="s3">\n    </span><span class="s1">errorTag = '[object Error]',</span><span class="s3">\n    </span><span class="s1">mapTag = '[object Map]',</span><span class="s3">\n    </span><span class="s1">numberTag = '[object Number]',</span><span class="s3">\n    </span><span class="s1">regexpTag = '[object RegExp]',</span><span class="s3">\n    </span><span class="s1">setTag = '[object Set]',</span><span class="s3">\n    </span><span class="s1">stringTag = '[object String]',</span><span class="s3">\n    </span><span class="s1">symbolTag = '[object Symbol]';</span><span class="s3">\n\n</span><span class="s1">var arrayBufferTag = '[object ArrayBuffer]',</span><span class="s3">\n    </span><span class="s1">dataViewTag = '[object DataView]';</span><span class="s3">\n\n</span><span class="s1">/** Used to convert symbols to primitives and strings. */</span><span class="s3">\n</span><span class="s1">var symbolProto = Symbol ? Symbol.prototype : undefined,</span><span class="s3">\n    </span><span class="s1">symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqualDeep` for comparing objects of</span><span class="s3">\n </span><span class="s1">* the same `toStringTag`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This function only supports comparing values with tags of</span><span class="s3">\n </span><span class="s1">* `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {string} tag The `toStringTag` of the objects to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} stack Tracks traversed `object` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">switch (tag) {</span><span class="s3">\n    </span><span class="s1">case dataViewTag:</span><span class="s3">\n      </span><span class="s1">if ((object.byteLength != other.byteLength) ||</span><span class="s3">\n          </span><span class="s1">(object.byteOffset != other.byteOffset)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">object = object.buffer;</span><span class="s3">\n      </span><span class="s1">other = other.buffer;</span><span class="s3">\n\n    </span><span class="s1">case arrayBufferTag:</span><span class="s3">\n      </span><span class="s1">if ((object.byteLength != other.byteLength) ||</span><span class="s3">\n          </span><span class="s1">!equalFunc(new Uint8Array(object), new Uint8Array(other))) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n\n    </span><span class="s1">case boolTag:</span><span class="s3">\n    </span><span class="s1">case dateTag:</span><span class="s3">\n    </span><span class="s1">case numberTag:</span><span class="s3">\n      </span><span class="s1">// Coerce booleans to `1` or `0` and dates to milliseconds.</span><span class="s3">\n      </span><span class="s1">// Invalid dates are coerced to `NaN`.</span><span class="s3">\n      </span><span class="s1">return eq(+object, +other);</span><span class="s3">\n\n    </span><span class="s1">case errorTag:</span><span class="s3">\n      </span><span class="s1">return object.name == other.name &amp;&amp; object.message == other.message;</span><span class="s3">\n\n    </span><span class="s1">case regexpTag:</span><span class="s3">\n    </span><span class="s1">case stringTag:</span><span class="s3">\n      </span><span class="s1">// Coerce regexes to strings and treat strings, primitives and objects,</span><span class="s3">\n      </span><span class="s1">// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring</span><span class="s3">\n      </span><span class="s1">// for more details.</span><span class="s3">\n      </span><span class="s1">return object == (other + '');</span><span class="s3">\n\n    </span><span class="s1">case mapTag:</span><span class="s3">\n      </span><span class="s1">var convert = mapToArray;</span><span class="s3">\n\n    </span><span class="s1">case setTag:</span><span class="s3">\n      </span><span class="s1">var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG;</span><span class="s3">\n      </span><span class="s1">convert || (convert = setToArray);</span><span class="s3">\n\n      </span><span class="s1">if (object.size != other.size &amp;&amp; !isPartial) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Assume cyclic values are equal.</span><span class="s3">\n      </span><span class="s1">var stacked = stack.get(object);</span><span class="s3">\n      </span><span class="s1">if (stacked) {</span><span class="s3">\n        </span><span class="s1">return stacked == other;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">bitmask |= COMPARE_UNORDERED_FLAG;</span><span class="s3">\n\n      </span><span class="s1">// Recursively compare objects (susceptible to call stack limits).</span><span class="s3">\n      </span><span class="s1">stack.set(object, other);</span><span class="s3">\n      </span><span class="s1">var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);</span><span class="s3">\n      </span><span class="s1">stack['delete'](object);</span><span class="s3">\n      </span><span class="s1">return result;</span><span class="s3">\n\n    </span><span class="s1">case symbolTag:</span><span class="s3">\n      </span><span class="s1">if (symbolValueOf) {</span><span class="s3">\n        </span><span class="s1">return symbolValueOf.call(object) == symbolValueOf.call(other);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = equalByTag;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var getAllKeys = require('./_getAllKeys');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1;</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqualDeep` for objects with support for</span><span class="s3">\n </span><span class="s1">* partial deep comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} stack Tracks traversed `object` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG,</span><span class="s3">\n      </span><span class="s1">objProps = getAllKeys(object),</span><span class="s3">\n      </span><span class="s1">objLength = objProps.length,</span><span class="s3">\n      </span><span class="s1">othProps = getAllKeys(other),</span><span class="s3">\n      </span><span class="s1">othLength = othProps.length;</span><span class="s3">\n\n  </span><span class="s1">if (objLength != othLength &amp;&amp; !isPartial) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = objLength;</span><span class="s3">\n  </span><span class="s1">while (index--) {</span><span class="s3">\n    </span><span class="s1">var key = objProps[index];</span><span class="s3">\n    </span><span class="s1">if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Check that cyclic values are equal.</span><span class="s3">\n  </span><span class="s1">var objStacked = stack.get(object);</span><span class="s3">\n  </span><span class="s1">var othStacked = stack.get(other);</span><span class="s3">\n  </span><span class="s1">if (objStacked &amp;&amp; othStacked) {</span><span class="s3">\n    </span><span class="s1">return objStacked == other &amp;&amp; othStacked == object;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var result = true;</span><span class="s3">\n  </span><span class="s1">stack.set(object, other);</span><span class="s3">\n  </span><span class="s1">stack.set(other, object);</span><span class="s3">\n\n  </span><span class="s1">var skipCtor = isPartial;</span><span class="s3">\n  </span><span class="s1">while (++index &lt; objLength) {</span><span class="s3">\n    </span><span class="s1">key = objProps[index];</span><span class="s3">\n    </span><span class="s1">var objValue = object[key],</span><span class="s3">\n        </span><span class="s1">othValue = other[key];</span><span class="s3">\n\n    </span><span class="s1">if (customizer) {</span><span class="s3">\n      </span><span class="s1">var compared = isPartial</span><span class="s3">\n        </span><span class="s1">? customizer(othValue, objValue, key, other, object, stack)</span><span class="s3">\n        </span><span class="s1">: customizer(objValue, othValue, key, object, other, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Recursively compare objects (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">if (!(compared === undefined</span><span class="s3">\n          </span><span class="s1">? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))</span><span class="s3">\n          </span><span class="s1">: compared</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">skipCtor || (skipCtor = key == 'constructor');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (result &amp;&amp; !skipCtor) {</span><span class="s3">\n    </span><span class="s1">var objCtor = object.constructor,</span><span class="s3">\n        </span><span class="s1">othCtor = other.constructor;</span><span class="s3">\n\n    </span><span class="s1">// Non `Object` object instances with different constructors are not equal.</span><span class="s3">\n    </span><span class="s1">if (objCtor != othCtor &amp;&amp;</span><span class="s3">\n        </span><span class="s1">('constructor' in object &amp;&amp; 'constructor' in other) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(typeof objCtor == 'function' &amp;&amp; objCtor instanceof objCtor &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof othCtor == 'function' &amp;&amp; othCtor instanceof othCtor)) {</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stack['delete'](object);</span><span class="s3">\n  </span><span class="s1">stack['delete'](other);</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = equalObjects;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Converts `map` to its key-value pairs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} map The map to convert.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the key-value pairs.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapToArray(map) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = Array(map.size);</span><span class="s3">\n\n  </span><span class="s1">map.forEach(function(value, key) {</span><span class="s3">\n    </span><span class="s1">result[++index] = [key, value];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = mapToArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to stand-in for `undefined` hash values. */</span><span class="s3">\n</span><span class="s1">var HASH_UNDEFINED = '__lodash_hash_undefined__';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds `value` to the array cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name add</span><span class="s3">\n </span><span class="s1">* @memberOf SetCache</span><span class="s3">\n </span><span class="s1">* @alias push</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to cache.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the cache instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setCacheAdd(value) {</span><span class="s3">\n  </span><span class="s1">this.__data__.set(value, HASH_UNDEFINED);</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = setCacheAdd;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is in the array cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name has</span><span class="s3">\n </span><span class="s1">* @memberOf SetCache</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns `true` if `value` is found, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setCacheHas(value) {</span><span class="s3">\n  </span><span class="s1">return this.__data__.has(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = setCacheHas;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Converts `set` to an array of its values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} set The set to convert.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setToArray(set) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = Array(set.size);</span><span class="s3">\n\n  </span><span class="s1">set.forEach(function(value) {</span><span class="s3">\n    </span><span class="s1">result[++index] = value;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = setToArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsEqual = require('./_baseIsEqual');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs a deep comparison between two values to determine if they are</span><span class="s3">\n </span><span class="s1">* equivalent.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method supports comparing arrays, array buffers, booleans,</span><span class="s3">\n </span><span class="s1">* date objects, error objects, maps, numbers, `Object` objects, regexes,</span><span class="s3">\n </span><span class="s1">* sets, strings, symbols, and typed arrays. `Object` objects are compared</span><span class="s3">\n </span><span class="s1">* by their own, not inherited, enumerable properties. Functions and DOM</span><span class="s3">\n </span><span class="s1">* nodes are compared by strict equality, i.e. `===`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">* var other = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isEqual(object, other);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* object === other;</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isEqual(value, other) {</span><span class="s3">\n  </span><span class="s1">return baseIsEqual(value, other);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isEqual;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>