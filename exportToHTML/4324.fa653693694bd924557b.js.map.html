<html>
<head>
<title>4324.fa653693694bd924557b.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
4324.fa653693694bd924557b.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;4324.fa653693694bd924557b.js?v=fa653693694bd924557b&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAM,gBAAgB,qBAAM,IAAI,qBAAM,sBAAsB,qBAAM;;AAE1F;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,IAAI;AACJ,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ,UAAU;AAC7B,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,UAAU;AACvB;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,YAAY,QAAQ,IAAI,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACx7Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,4BAA4B,GAAG,4BAA4B;AAC7F,cAAc,mBAAO,CAAC,KAAO;AAC7B;AACA;AACA,cAAc,mBAAO,CAAC,KAAe;AACrC,aAAa,mBAAO,CAAC,KAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,+BAA+B;;;;;;;;;AC3ElB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,KAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,SAAS;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0HAA0H,gBAAgB;AAC1I;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;;AC3JF;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,+BAA+B,GAAG,kBAAkB,GAAG,yBAAyB,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,oCAAoC,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,mCAAmC,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,mCAAmC,GAAG,iCAAiC,GAAG,yBAAyB,GAAG,+BAA+B,GAAG,eAAe,GAAG,aAAa,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,aAAa,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,eAAe,GAAG,WAAW;AACzwC,uBAAuB,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,oCAAoC,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,aAAa;AACjT,mBAAmB,mBAAO,CAAC,KAAY;AACvC,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,iDAAgD,EAAE,qCAAqC,oCAAoC,EAAC;AAC5H,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,oDAAmD,EAAE,qCAAqC,uCAAuC,EAAC;AAClI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,uDAAsD,EAAE,qCAAqC,0CAA0C,EAAC;AACxI,oBAAoB,mBAAO,CAAC,KAAa;AACzC,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH,yCAAwC,EAAE,qCAAqC,6BAA6B,EAAC;AAC7G,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,iBAAiB,mBAAO,CAAC,GAAU;AACnC,yCAAwC,EAAE,qCAAqC,0BAA0B,EAAC;AAC1G,2CAA0C,EAAE,qCAAqC,4BAA4B,EAAC;AAC9G,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C,2DAA0D,EAAE,qCAAqC,kDAAkD,EAAC;AACpJ,qDAAoD,EAAE,qCAAqC,4CAA4C,EAAC;AACxI,kCAAkC,mBAAO,CAAC,KAA2B;AACrE,6DAA4D,EAAE,qCAAqC,+DAA+D,EAAC;AACnK,+DAA8D,EAAE,qCAAqC,iEAAiE,EAAC;AACvK,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,yDAAwD,EAAE,qCAAqC,iDAAiD,EAAC;AACjJ,+DAA8D,EAAE,qCAAqC,uDAAuD,EAAC;AAC7J,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,yDAAwD,EAAE,qCAAqC,iDAAiD,EAAC;AACjJ,gEAA+D,EAAE,qCAAqC,wDAAwD,EAAC;AAC/J,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,yDAAwD,EAAE,qCAAqC,iDAAiD,EAAC;AACjJ,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,sDAAqD,EAAE,qCAAqC,2CAA2C,EAAC;AACxI,qDAAoD,EAAE,qCAAqC,0CAA0C,EAAC;AACtI,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,2DAA0D,EAAE,qCAAqC,gDAAgD,EAAC;AAClJ,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,gDAA+C,EAAE,qCAAqC,qCAAqC,EAAC;AAC5H,yCAAwC,EAAE,qCAAqC,8BAA8B,EAAC;AAC9G,+CAA8C,EAAE,qCAAqC,oCAAoC,EAAC;AAC1H,+CAA8C,EAAE,qCAAqC,oCAAoC,EAAC;AAC1H,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,oDAAmD,EAAE,qCAAqC,yCAAyC,EAAC;AACpI,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,gEAA+D,EAAE,qCAAqC,qDAAqD,EAAC;AAC5J,8DAA6D,EAAE,qCAAqC,mDAAmD,EAAC;AACxJ,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW;;;;;;;;;AChFE;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB;AAC3D,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAM;AACzB,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA,aAAa,YAAY;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;AC/FlB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,oCAAoC,GAAG,2CAA2C,GAAG,sCAAsC,GAAG,0BAA0B,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,aAAa,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,qBAAqB;AACviB,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAM;AACzB,mBAAmB,mBAAO,CAAC,KAAY;AACvC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,iBAAiB,mBAAO,CAAC,GAAU;AACnC,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yBAAyB,0BAA0B,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,2CAA2C,2CAA2C;AACjI;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,mCAAmC,oCAAoC,oCAAoC;AAC5G;AACA;AACA;AACA;AACA,oEAAoE,IAAI;AACxE,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB,UAAU,qBAAqB;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB,uBAAuB,cAAc;AAChL;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,uBAAuB,uBAAuB,cAAc;AACxK;AACA;AACA,4GAA4G,uBAAuB;AACnI;AACA;AACA;AACA;AACA,8GAA8G,sBAAsB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,oDAAoD;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,uBAAuB,yBAAyB,cAAc;AACxH;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB,UAAU,qBAAqB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oCAAoC;AACtF;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA,iEAAiE,gBAAgB,UAAU,qBAAqB,sBAAsB,eAAe;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe,yBAAyB,cAAc;AAChH;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iCAAiC;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA,2CAA2C,gBAAgB,KAAK,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,KAAK,WAAW,8BAA8B,uBAAuB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA,4CAA4C,gBAAgB,KAAK,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,uBAAuB,GAAG,mBAAmB;AAC/G,iDAAiD,wBAAwB,KAAK,WAAW,QAAQ,wCAAwC,KAAK,MAAM;AACpJ;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,GAAG;AAC3G;AACA;AACA;AACA;AACA,+EAA+E,IAAI;AACnF,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,+BAA+B;AAC9G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;;;;;;;;;AC3rClB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;;;;;;;;;ACfzC;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,aAAa;AAC/B,cAAc,mBAAO,CAAC,KAAO;AAC7B;AACA;AACA,0BAA0B;AAC1B,+BAA+B;AAC/B,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;;AC/Ha;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AACtH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;;;;;;;;;AClCN;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,iBAAiB,GAAG,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;AC7YH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;ACvJhB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,6BAA6B,GAAG,qBAAqB;AAC3F,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAM;AACzB,iBAAiB,mBAAO,CAAC,GAAU;AACnC,oBAAoB,mBAAO,CAAC,KAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,4CAA4C;AAChJ;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2CAA2C;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC;;;;;;;;;ACpMtB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,6BAA6B,GAAG,qBAAqB;AAC5F,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAM;AACzB,oBAAoB,mBAAO,CAAC,KAAa;AACzC,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;AClHvB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,gCAAgC,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,kBAAkB;AAC5qB,WAAW,mBAAO,CAAC,KAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,cAAc,eAAe,eAAe;;;;;;;;;ACjThC;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;;ACtBF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,cAAc,mBAAO,CAAC,KAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;ACnEJ;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,iCAAiC;AACvE,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;;;;;;;;;;;;;;;;;;;;;;AC3EnC;AACA;AACA;AACA;AAC4C;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;AACtB;;;;AC5BA;AACA;AACA;AACA;AACgF;AACzE,qCAAqC,mCAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,KAAK,aAAa,OAAO;AAC/F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5EA;AACA;AACA;AACA;AACgF;AACzE,qCAAqC,mCAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACyD;AACP;AACA;AAC3C;AACP,8BAA8B,sBAAsB;AACpD,8BAA8B,sBAAsB;AACpD,uBAAuB,gCAAuB;AAC9C;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACyB;AACA;AACA;AACI;AAC7B;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACqD;AACrD;AACA;AACA;AACA;AACyC;AAClC;AACP,YAAY,0BAA0B;AACtC,yCAAyC,aAAa;AACtD;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AAC+B;AACoB;AACtB;AACJ;AACA;AACI;AAC7B&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash.mergewith/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/browser/main.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/browser/ril.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/api.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/cancellation.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/connection.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/disposable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/events.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/is.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/linkedMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/messageReader.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/messageWriter.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/messages.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/ral.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/semaphore.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/disposable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/socket/reader.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/socket/writer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/socket/connection.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/socket/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/logger.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/connection.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-ws-jsonrpc/lib/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Lodash (Custom Build) &lt;https://lodash.com/&gt;</span><span class="s3">\n </span><span class="s1">* Build: `lodash modularize exports=</span><span class="s3">\&quot;</span><span class="s1">npm</span><span class="s3">\&quot; </span><span class="s1">-o ./`</span><span class="s3">\n </span><span class="s1">* Copyright OpenJS Foundation and other contributors &lt;https://openjsf.org/&gt;</span><span class="s3">\n </span><span class="s1">* Released under MIT license &lt;https://lodash.com/license&gt;</span><span class="s3">\n </span><span class="s1">* Based on Underscore.js 1.8.3 &lt;http://underscorejs.org/LICENSE&gt;</span><span class="s3">\n </span><span class="s1">* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/** Used as the size to enable large array optimizations. */</span><span class="s3">\n</span><span class="s1">var LARGE_ARRAY_SIZE = 200;</span><span class="s3">\n\n</span><span class="s1">/** Used to stand-in for `undefined` hash values. */</span><span class="s3">\n</span><span class="s1">var HASH_UNDEFINED = '__lodash_hash_undefined__';</span><span class="s3">\n\n</span><span class="s1">/** Used to detect hot functions by number of calls within a span of milliseconds. */</span><span class="s3">\n</span><span class="s1">var HOT_COUNT = 800,</span><span class="s3">\n    </span><span class="s1">HOT_SPAN = 16;</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var MAX_SAFE_INTEGER = 9007199254740991;</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var argsTag = '[object Arguments]',</span><span class="s3">\n    </span><span class="s1">arrayTag = '[object Array]',</span><span class="s3">\n    </span><span class="s1">asyncTag = '[object AsyncFunction]',</span><span class="s3">\n    </span><span class="s1">boolTag = '[object Boolean]',</span><span class="s3">\n    </span><span class="s1">dateTag = '[object Date]',</span><span class="s3">\n    </span><span class="s1">errorTag = '[object Error]',</span><span class="s3">\n    </span><span class="s1">funcTag = '[object Function]',</span><span class="s3">\n    </span><span class="s1">genTag = '[object GeneratorFunction]',</span><span class="s3">\n    </span><span class="s1">mapTag = '[object Map]',</span><span class="s3">\n    </span><span class="s1">numberTag = '[object Number]',</span><span class="s3">\n    </span><span class="s1">nullTag = '[object Null]',</span><span class="s3">\n    </span><span class="s1">objectTag = '[object Object]',</span><span class="s3">\n    </span><span class="s1">proxyTag = '[object Proxy]',</span><span class="s3">\n    </span><span class="s1">regexpTag = '[object RegExp]',</span><span class="s3">\n    </span><span class="s1">setTag = '[object Set]',</span><span class="s3">\n    </span><span class="s1">stringTag = '[object String]',</span><span class="s3">\n    </span><span class="s1">undefinedTag = '[object Undefined]',</span><span class="s3">\n    </span><span class="s1">weakMapTag = '[object WeakMap]';</span><span class="s3">\n\n</span><span class="s1">var arrayBufferTag = '[object ArrayBuffer]',</span><span class="s3">\n    </span><span class="s1">dataViewTag = '[object DataView]',</span><span class="s3">\n    </span><span class="s1">float32Tag = '[object Float32Array]',</span><span class="s3">\n    </span><span class="s1">float64Tag = '[object Float64Array]',</span><span class="s3">\n    </span><span class="s1">int8Tag = '[object Int8Array]',</span><span class="s3">\n    </span><span class="s1">int16Tag = '[object Int16Array]',</span><span class="s3">\n    </span><span class="s1">int32Tag = '[object Int32Array]',</span><span class="s3">\n    </span><span class="s1">uint8Tag = '[object Uint8Array]',</span><span class="s3">\n    </span><span class="s1">uint8ClampedTag = '[object Uint8ClampedArray]',</span><span class="s3">\n    </span><span class="s1">uint16Tag = '[object Uint16Array]',</span><span class="s3">\n    </span><span class="s1">uint32Tag = '[object Uint32Array]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used to match `RegExp`</span><span class="s3">\n </span><span class="s1">* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var reRegExpChar = /[</span><span class="s3">\\\\</span><span class="s1">^$.*+?()[</span><span class="s3">\\</span><span class="s1">]{}|]/g;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect host constructors (Safari). */</span><span class="s3">\n</span><span class="s1">var reIsHostCtor = /^</span><span class="s3">\\</span><span class="s1">[object .+?Constructor</span><span class="s3">\\</span><span class="s1">]$/;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect unsigned integer values. */</span><span class="s3">\n</span><span class="s1">var reIsUint = /^(?:0|[1-9]</span><span class="s3">\\</span><span class="s1">d*)$/;</span><span class="s3">\n\n</span><span class="s1">/** Used to identify `toStringTag` values of typed arrays. */</span><span class="s3">\n</span><span class="s1">var typedArrayTags = {};</span><span class="s3">\n</span><span class="s1">typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[uint32Tag] = true;</span><span class="s3">\n</span><span class="s1">typedArrayTags[argsTag] = typedArrayTags[arrayTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[errorTag] = typedArrayTags[funcTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[mapTag] = typedArrayTags[numberTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[objectTag] = typedArrayTags[regexpTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[setTag] = typedArrayTags[stringTag] =</span><span class="s3">\n</span><span class="s1">typedArrayTags[weakMapTag] = false;</span><span class="s3">\n\n</span><span class="s1">/** Detect free variable `global` from Node.js. */</span><span class="s3">\n</span><span class="s1">var freeGlobal = typeof global == 'object' &amp;&amp; global &amp;&amp; global.Object === Object &amp;&amp; global;</span><span class="s3">\n\n</span><span class="s1">/** Detect free variable `self`. */</span><span class="s3">\n</span><span class="s1">var freeSelf = typeof self == 'object' &amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self;</span><span class="s3">\n\n</span><span class="s1">/** Used as a reference to the global object. */</span><span class="s3">\n</span><span class="s1">var root = freeGlobal || freeSelf || Function('return this')();</span><span class="s3">\n\n</span><span class="s1">/** Detect free variable `exports`. */</span><span class="s3">\n</span><span class="s1">var freeExports = typeof exports == 'object' &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;</span><span class="s3">\n\n</span><span class="s1">/** Detect free variable `module`. */</span><span class="s3">\n</span><span class="s1">var freeModule = freeExports &amp;&amp; typeof module == 'object' &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; module;</span><span class="s3">\n\n</span><span class="s1">/** Detect the popular CommonJS extension `module.exports`. */</span><span class="s3">\n</span><span class="s1">var moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports;</span><span class="s3">\n\n</span><span class="s1">/** Detect free variable `process` from Node.js. */</span><span class="s3">\n</span><span class="s1">var freeProcess = moduleExports &amp;&amp; freeGlobal.process;</span><span class="s3">\n\n</span><span class="s1">/** Used to access faster Node.js helpers. */</span><span class="s3">\n</span><span class="s1">var nodeUtil = (function() {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// Use `util.types` for Node.js 10+.</span><span class="s3">\n    </span><span class="s1">var types = freeModule &amp;&amp; freeModule.require &amp;&amp; freeModule.require('util').types;</span><span class="s3">\n\n    </span><span class="s1">if (types) {</span><span class="s3">\n      </span><span class="s1">return types;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Legacy `process.binding('util')` for Node.js &lt; 10.</span><span class="s3">\n    </span><span class="s1">return freeProcess &amp;&amp; freeProcess.binding &amp;&amp; freeProcess.binding('util');</span><span class="s3">\n  </span><span class="s1">} catch (e) {}</span><span class="s3">\n</span><span class="s1">}());</span><span class="s3">\n\n</span><span class="s1">/* Node.js helper references. */</span><span class="s3">\n</span><span class="s1">var nodeIsTypedArray = nodeUtil &amp;&amp; nodeUtil.isTypedArray;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A faster alternative to `Function#apply`, this function invokes `func`</span><span class="s3">\n </span><span class="s1">* with the `this` binding of `thisArg` and the arguments of `args`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to invoke.</span><span class="s3">\n </span><span class="s1">* @param {*} thisArg The `this` binding of `func`.</span><span class="s3">\n </span><span class="s1">* @param {Array} args The arguments to invoke `func` with.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the result of `func`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function apply(func, thisArg, args) {</span><span class="s3">\n  </span><span class="s1">switch (args.length) {</span><span class="s3">\n    </span><span class="s1">case 0: return func.call(thisArg);</span><span class="s3">\n    </span><span class="s1">case 1: return func.call(thisArg, args[0]);</span><span class="s3">\n    </span><span class="s1">case 2: return func.call(thisArg, args[0], args[1]);</span><span class="s3">\n    </span><span class="s1">case 3: return func.call(thisArg, args[0], args[1], args[2]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return func.apply(thisArg, args);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.times` without support for iteratee shorthands</span><span class="s3">\n </span><span class="s1">* or max array length checks.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {number} n The number of times to invoke `iteratee`.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the array of results.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseTimes(n, iteratee) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = Array(n);</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; n) {</span><span class="s3">\n    </span><span class="s1">result[index] = iteratee(index);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.unary` without support for storing metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to cap arguments for.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new capped function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseUnary(func) {</span><span class="s3">\n  </span><span class="s1">return function(value) {</span><span class="s3">\n    </span><span class="s1">return func(value);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the value at `key` of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} [object] The object to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the property value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getValue(object, key) {</span><span class="s3">\n  </span><span class="s1">return object == null ? undefined : object[key];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a unary function that invokes `func` with its argument transformed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to wrap.</span><span class="s3">\n </span><span class="s1">* @param {Function} transform The argument transform.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function overArg(func, transform) {</span><span class="s3">\n  </span><span class="s1">return function(arg) {</span><span class="s3">\n    </span><span class="s1">return func(transform(arg));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var arrayProto = Array.prototype,</span><span class="s3">\n    </span><span class="s1">funcProto = Function.prototype,</span><span class="s3">\n    </span><span class="s1">objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect overreaching core-js shims. */</span><span class="s3">\n</span><span class="s1">var coreJsData = root['__core-js_shared__'];</span><span class="s3">\n\n</span><span class="s1">/** Used to resolve the decompiled source of functions. */</span><span class="s3">\n</span><span class="s1">var funcToString = funcProto.toString;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect methods masquerading as native. */</span><span class="s3">\n</span><span class="s1">var maskSrcKey = (function() {</span><span class="s3">\n  </span><span class="s1">var uid = /[^.]+$/.exec(coreJsData &amp;&amp; coreJsData.keys &amp;&amp; coreJsData.keys.IE_PROTO || '');</span><span class="s3">\n  </span><span class="s1">return uid ? ('Symbol(src)_1.' + uid) : '';</span><span class="s3">\n</span><span class="s1">}());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used to resolve the</span><span class="s3">\n </span><span class="s1">* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)</span><span class="s3">\n </span><span class="s1">* of values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var nativeObjectToString = objectProto.toString;</span><span class="s3">\n\n</span><span class="s1">/** Used to infer the `Object` constructor. */</span><span class="s3">\n</span><span class="s1">var objectCtorString = funcToString.call(Object);</span><span class="s3">\n\n</span><span class="s1">/** Used to detect if a method is native. */</span><span class="s3">\n</span><span class="s1">var reIsNative = RegExp('^' +</span><span class="s3">\n  </span><span class="s1">funcToString.call(hasOwnProperty).replace(reRegExpChar, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n  </span><span class="s1">.replace(/hasOwnProperty|(function).*?(?=</span><span class="s3">\\\\\\</span><span class="s1">()| for .+?(?=</span><span class="s3">\\\\\\</span><span class="s1">])/g, '$1.*?') + '$'</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">/** Built-in value references. */</span><span class="s3">\n</span><span class="s1">var Buffer = moduleExports ? root.Buffer : undefined,</span><span class="s3">\n    </span><span class="s1">Symbol = root.Symbol,</span><span class="s3">\n    </span><span class="s1">Uint8Array = root.Uint8Array,</span><span class="s3">\n    </span><span class="s1">allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,</span><span class="s3">\n    </span><span class="s1">getPrototype = overArg(Object.getPrototypeOf, Object),</span><span class="s3">\n    </span><span class="s1">objectCreate = Object.create,</span><span class="s3">\n    </span><span class="s1">propertyIsEnumerable = objectProto.propertyIsEnumerable,</span><span class="s3">\n    </span><span class="s1">splice = arrayProto.splice,</span><span class="s3">\n    </span><span class="s1">symToStringTag = Symbol ? Symbol.toStringTag : undefined;</span><span class="s3">\n\n</span><span class="s1">var defineProperty = (function() {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">var func = getNative(Object, 'defineProperty');</span><span class="s3">\n    </span><span class="s1">func({}, '', {});</span><span class="s3">\n    </span><span class="s1">return func;</span><span class="s3">\n  </span><span class="s1">} catch (e) {}</span><span class="s3">\n</span><span class="s1">}());</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,</span><span class="s3">\n    </span><span class="s1">nativeMax = Math.max,</span><span class="s3">\n    </span><span class="s1">nativeNow = Date.now;</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references that are verified to be native. */</span><span class="s3">\n</span><span class="s1">var Map = getNative(root, 'Map'),</span><span class="s3">\n    </span><span class="s1">nativeCreate = getNative(Object, 'create');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.create` without support for assigning</span><span class="s3">\n </span><span class="s1">* properties to the created object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} proto The object to inherit from.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var baseCreate = (function() {</span><span class="s3">\n  </span><span class="s1">function object() {}</span><span class="s3">\n  </span><span class="s1">return function(proto) {</span><span class="s3">\n    </span><span class="s1">if (!isObject(proto)) {</span><span class="s3">\n      </span><span class="s1">return {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (objectCreate) {</span><span class="s3">\n      </span><span class="s1">return objectCreate(proto);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">object.prototype = proto;</span><span class="s3">\n    </span><span class="s1">var result = new object;</span><span class="s3">\n    </span><span class="s1">object.prototype = undefined;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a hash object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Hash(entries) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = entries == null ? 0 : entries.length;</span><span class="s3">\n\n  </span><span class="s1">this.clear();</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var entry = entries[index];</span><span class="s3">\n    </span><span class="s1">this.set(entry[0], entry[1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes all key-value entries from the hash.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name clear</span><span class="s3">\n </span><span class="s1">* @memberOf Hash</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hashClear() {</span><span class="s3">\n  </span><span class="s1">this.__data__ = nativeCreate ? nativeCreate(null) : {};</span><span class="s3">\n  </span><span class="s1">this.size = 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes `key` and its value from the hash.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name delete</span><span class="s3">\n </span><span class="s1">* @memberOf Hash</span><span class="s3">\n </span><span class="s1">* @param {Object} hash The hash to modify.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hashDelete(key) {</span><span class="s3">\n  </span><span class="s1">var result = this.has(key) &amp;&amp; delete this.__data__[key];</span><span class="s3">\n  </span><span class="s1">this.size -= result ? 1 : 0;</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the hash value for `key`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name get</span><span class="s3">\n </span><span class="s1">* @memberOf Hash</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hashGet(key) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n  </span><span class="s1">if (nativeCreate) {</span><span class="s3">\n    </span><span class="s1">var result = data[key];</span><span class="s3">\n    </span><span class="s1">return result === HASH_UNDEFINED ? undefined : result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return hasOwnProperty.call(data, key) ? data[key] : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a hash value for `key` exists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name has</span><span class="s3">\n </span><span class="s1">* @memberOf Hash</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hashHas(key) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n  </span><span class="s1">return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the hash `key` to `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name set</span><span class="s3">\n </span><span class="s1">* @memberOf Hash</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the hash instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hashSet(key, value) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n  </span><span class="s1">this.size += this.has(key) ? 0 : 1;</span><span class="s3">\n  </span><span class="s1">data[key] = (nativeCreate &amp;&amp; value === undefined) ? HASH_UNDEFINED : value;</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Add methods to `Hash`.</span><span class="s3">\n</span><span class="s1">Hash.prototype.clear = hashClear;</span><span class="s3">\n</span><span class="s1">Hash.prototype['delete'] = hashDelete;</span><span class="s3">\n</span><span class="s1">Hash.prototype.get = hashGet;</span><span class="s3">\n</span><span class="s1">Hash.prototype.has = hashHas;</span><span class="s3">\n</span><span class="s1">Hash.prototype.set = hashSet;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an list cache object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ListCache(entries) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = entries == null ? 0 : entries.length;</span><span class="s3">\n\n  </span><span class="s1">this.clear();</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var entry = entries[index];</span><span class="s3">\n    </span><span class="s1">this.set(entry[0], entry[1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes all key-value entries from the list cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name clear</span><span class="s3">\n </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function listCacheClear() {</span><span class="s3">\n  </span><span class="s1">this.__data__ = [];</span><span class="s3">\n  </span><span class="s1">this.size = 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes `key` and its value from the list cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name delete</span><span class="s3">\n </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function listCacheDelete(key) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n      </span><span class="s1">index = assocIndexOf(data, key);</span><span class="s3">\n\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var lastIndex = data.length - 1;</span><span class="s3">\n  </span><span class="s1">if (index == lastIndex) {</span><span class="s3">\n    </span><span class="s1">data.pop();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">splice.call(data, index, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">--this.size;</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the list cache value for `key`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name get</span><span class="s3">\n </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function listCacheGet(key) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n      </span><span class="s1">index = assocIndexOf(data, key);</span><span class="s3">\n\n  </span><span class="s1">return index &lt; 0 ? undefined : data[index][1];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a list cache value for `key` exists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name has</span><span class="s3">\n </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function listCacheHas(key) {</span><span class="s3">\n  </span><span class="s1">return assocIndexOf(this.__data__, key) &gt; -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the list cache `key` to `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name set</span><span class="s3">\n </span><span class="s1">* @memberOf ListCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the list cache instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function listCacheSet(key, value) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n      </span><span class="s1">index = assocIndexOf(data, key);</span><span class="s3">\n\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n    </span><span class="s1">++this.size;</span><span class="s3">\n    </span><span class="s1">data.push([key, value]);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">data[index][1] = value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Add methods to `ListCache`.</span><span class="s3">\n</span><span class="s1">ListCache.prototype.clear = listCacheClear;</span><span class="s3">\n</span><span class="s1">ListCache.prototype['delete'] = listCacheDelete;</span><span class="s3">\n</span><span class="s1">ListCache.prototype.get = listCacheGet;</span><span class="s3">\n</span><span class="s1">ListCache.prototype.has = listCacheHas;</span><span class="s3">\n</span><span class="s1">ListCache.prototype.set = listCacheSet;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a map cache object to store key-value pairs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function MapCache(entries) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = entries == null ? 0 : entries.length;</span><span class="s3">\n\n  </span><span class="s1">this.clear();</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var entry = entries[index];</span><span class="s3">\n    </span><span class="s1">this.set(entry[0], entry[1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes all key-value entries from the map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name clear</span><span class="s3">\n </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapCacheClear() {</span><span class="s3">\n  </span><span class="s1">this.size = 0;</span><span class="s3">\n  </span><span class="s1">this.__data__ = {</span><span class="s3">\n    </span><span class="s1">'hash': new Hash,</span><span class="s3">\n    </span><span class="s1">'map': new (Map || ListCache),</span><span class="s3">\n    </span><span class="s1">'string': new Hash</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes `key` and its value from the map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name delete</span><span class="s3">\n </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapCacheDelete(key) {</span><span class="s3">\n  </span><span class="s1">var result = getMapData(this, key)['delete'](key);</span><span class="s3">\n  </span><span class="s1">this.size -= result ? 1 : 0;</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the map value for `key`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name get</span><span class="s3">\n </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapCacheGet(key) {</span><span class="s3">\n  </span><span class="s1">return getMapData(this, key).get(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a map value for `key` exists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name has</span><span class="s3">\n </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapCacheHas(key) {</span><span class="s3">\n  </span><span class="s1">return getMapData(this, key).has(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the map `key` to `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name set</span><span class="s3">\n </span><span class="s1">* @memberOf MapCache</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the map cache instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapCacheSet(key, value) {</span><span class="s3">\n  </span><span class="s1">var data = getMapData(this, key),</span><span class="s3">\n      </span><span class="s1">size = data.size;</span><span class="s3">\n\n  </span><span class="s1">data.set(key, value);</span><span class="s3">\n  </span><span class="s1">this.size += data.size == size ? 0 : 1;</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Add methods to `MapCache`.</span><span class="s3">\n</span><span class="s1">MapCache.prototype.clear = mapCacheClear;</span><span class="s3">\n</span><span class="s1">MapCache.prototype['delete'] = mapCacheDelete;</span><span class="s3">\n</span><span class="s1">MapCache.prototype.get = mapCacheGet;</span><span class="s3">\n</span><span class="s1">MapCache.prototype.has = mapCacheHas;</span><span class="s3">\n</span><span class="s1">MapCache.prototype.set = mapCacheSet;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a stack cache object to store key-value pairs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {Array} [entries] The key-value pairs to cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Stack(entries) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__ = new ListCache(entries);</span><span class="s3">\n  </span><span class="s1">this.size = data.size;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes all key-value entries from the stack.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name clear</span><span class="s3">\n </span><span class="s1">* @memberOf Stack</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stackClear() {</span><span class="s3">\n  </span><span class="s1">this.__data__ = new ListCache;</span><span class="s3">\n  </span><span class="s1">this.size = 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes `key` and its value from the stack.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name delete</span><span class="s3">\n </span><span class="s1">* @memberOf Stack</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to remove.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the entry was removed, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stackDelete(key) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__,</span><span class="s3">\n      </span><span class="s1">result = data['delete'](key);</span><span class="s3">\n\n  </span><span class="s1">this.size = data.size;</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the stack value for `key`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name get</span><span class="s3">\n </span><span class="s1">* @memberOf Stack</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the entry value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stackGet(key) {</span><span class="s3">\n  </span><span class="s1">return this.__data__.get(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a stack value for `key` exists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name has</span><span class="s3">\n </span><span class="s1">* @memberOf Stack</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stackHas(key) {</span><span class="s3">\n  </span><span class="s1">return this.__data__.has(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the stack `key` to `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name set</span><span class="s3">\n </span><span class="s1">* @memberOf Stack</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to set.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the stack cache instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stackSet(key, value) {</span><span class="s3">\n  </span><span class="s1">var data = this.__data__;</span><span class="s3">\n  </span><span class="s1">if (data instanceof ListCache) {</span><span class="s3">\n    </span><span class="s1">var pairs = data.__data__;</span><span class="s3">\n    </span><span class="s1">if (!Map || (pairs.length &lt; LARGE_ARRAY_SIZE - 1)) {</span><span class="s3">\n      </span><span class="s1">pairs.push([key, value]);</span><span class="s3">\n      </span><span class="s1">this.size = ++data.size;</span><span class="s3">\n      </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">data = this.__data__ = new MapCache(pairs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">data.set(key, value);</span><span class="s3">\n  </span><span class="s1">this.size = data.size;</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Add methods to `Stack`.</span><span class="s3">\n</span><span class="s1">Stack.prototype.clear = stackClear;</span><span class="s3">\n</span><span class="s1">Stack.prototype['delete'] = stackDelete;</span><span class="s3">\n</span><span class="s1">Stack.prototype.get = stackGet;</span><span class="s3">\n</span><span class="s1">Stack.prototype.has = stackHas;</span><span class="s3">\n</span><span class="s1">Stack.prototype.set = stackSet;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of the enumerable property names of the array-like `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to query.</span><span class="s3">\n </span><span class="s1">* @param {boolean} inherited Specify returning inherited property names.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the array of property names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arrayLikeKeys(value, inherited) {</span><span class="s3">\n  </span><span class="s1">var isArr = isArray(value),</span><span class="s3">\n      </span><span class="s1">isArg = !isArr &amp;&amp; isArguments(value),</span><span class="s3">\n      </span><span class="s1">isBuff = !isArr &amp;&amp; !isArg &amp;&amp; isBuffer(value),</span><span class="s3">\n      </span><span class="s1">isType = !isArr &amp;&amp; !isArg &amp;&amp; !isBuff &amp;&amp; isTypedArray(value),</span><span class="s3">\n      </span><span class="s1">skipIndexes = isArr || isArg || isBuff || isType,</span><span class="s3">\n      </span><span class="s1">result = skipIndexes ? baseTimes(value.length, String) : [],</span><span class="s3">\n      </span><span class="s1">length = result.length;</span><span class="s3">\n\n  </span><span class="s1">for (var key in value) {</span><span class="s3">\n    </span><span class="s1">if ((inherited || hasOwnProperty.call(value, key)) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(skipIndexes &amp;&amp; (</span><span class="s3">\n           </span><span class="s1">// Safari 9 has enumerable `arguments.length` in strict mode.</span><span class="s3">\n           </span><span class="s1">key == 'length' ||</span><span class="s3">\n           </span><span class="s1">// Node.js 0.10 has enumerable non-index properties on buffers.</span><span class="s3">\n           </span><span class="s1">(isBuff &amp;&amp; (key == 'offset' || key == 'parent')) ||</span><span class="s3">\n           </span><span class="s1">// PhantomJS 2 has enumerable non-index properties on typed arrays.</span><span class="s3">\n           </span><span class="s1">(isType &amp;&amp; (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||</span><span class="s3">\n           </span><span class="s1">// Skip index properties.</span><span class="s3">\n           </span><span class="s1">isIndex(key, length)</span><span class="s3">\n        </span><span class="s1">))) {</span><span class="s3">\n      </span><span class="s1">result.push(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is like `assignValue` except that it doesn't assign</span><span class="s3">\n </span><span class="s1">* `undefined` values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to assign.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to assign.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function assignMergeValue(object, key, value) {</span><span class="s3">\n  </span><span class="s1">if ((value !== undefined &amp;&amp; !eq(object[key], value)) ||</span><span class="s3">\n      </span><span class="s1">(value === undefined &amp;&amp; !(key in object))) {</span><span class="s3">\n    </span><span class="s1">baseAssignValue(object, key, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns `value` to `key` of `object` if the existing value is not equivalent</span><span class="s3">\n </span><span class="s1">* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to assign.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to assign.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function assignValue(object, key, value) {</span><span class="s3">\n  </span><span class="s1">var objValue = object[key];</span><span class="s3">\n  </span><span class="s1">if (!(hasOwnProperty.call(object, key) &amp;&amp; eq(objValue, value)) ||</span><span class="s3">\n      </span><span class="s1">(value === undefined &amp;&amp; !(key in object))) {</span><span class="s3">\n    </span><span class="s1">baseAssignValue(object, key, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the index at which the `key` is found in `array` of key-value pairs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} key The key to search for.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function assocIndexOf(array, key) {</span><span class="s3">\n  </span><span class="s1">var length = array.length;</span><span class="s3">\n  </span><span class="s1">while (length--) {</span><span class="s3">\n    </span><span class="s1">if (eq(array[length][0], key)) {</span><span class="s3">\n      </span><span class="s1">return length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `assignValue` and `assignMergeValue` without</span><span class="s3">\n </span><span class="s1">* value checks.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to assign.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to assign.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseAssignValue(object, key, value) {</span><span class="s3">\n  </span><span class="s1">if (key == '__proto__' &amp;&amp; defineProperty) {</span><span class="s3">\n    </span><span class="s1">defineProperty(object, key, {</span><span class="s3">\n      </span><span class="s1">'configurable': true,</span><span class="s3">\n      </span><span class="s1">'enumerable': true,</span><span class="s3">\n      </span><span class="s1">'value': value,</span><span class="s3">\n      </span><span class="s1">'writable': true</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">object[key] = value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `baseForOwn` which iterates over `object`</span><span class="s3">\n </span><span class="s1">* properties returned by `keysFunc` and invokes `iteratee` for each property.</span><span class="s3">\n </span><span class="s1">* Iteratee functions may exit iteration early by explicitly returning `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {Function} keysFunc The function to get the keys of `object`.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var baseFor = createBaseFor();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `getTag` without fallbacks for buggy environments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to query.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the `toStringTag`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseGetTag(value) {</span><span class="s3">\n  </span><span class="s1">if (value == null) {</span><span class="s3">\n    </span><span class="s1">return value === undefined ? undefinedTag : nullTag;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (symToStringTag &amp;&amp; symToStringTag in Object(value))</span><span class="s3">\n    </span><span class="s1">? getRawTag(value)</span><span class="s3">\n    </span><span class="s1">: objectToString(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isArguments`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an `arguments` object,</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsArguments(value) {</span><span class="s3">\n  </span><span class="s1">return isObjectLike(value) &amp;&amp; baseGetTag(value) == argsTag;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isNative` without bad shim checks.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a native function,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsNative(value) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(value) || isMasked(value)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var pattern = isFunction(value) ? reIsNative : reIsHostCtor;</span><span class="s3">\n  </span><span class="s1">return pattern.test(toSource(value));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isTypedArray` without Node.js optimizations.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsTypedArray(value) {</span><span class="s3">\n  </span><span class="s1">return isObjectLike(value) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isLength(value.length) &amp;&amp; !!typedArrayTags[baseGetTag(value)];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the array of property names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseKeysIn(object) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(object)) {</span><span class="s3">\n    </span><span class="s1">return nativeKeysIn(object);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var isProto = isPrototype(object),</span><span class="s3">\n      </span><span class="s1">result = [];</span><span class="s3">\n\n  </span><span class="s1">for (var key in object) {</span><span class="s3">\n    </span><span class="s1">if (!(key == 'constructor' &amp;&amp; (isProto || !hasOwnProperty.call(object, key)))) {</span><span class="s3">\n      </span><span class="s1">result.push(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.merge` without support for multiple sources.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {Object} source The source object.</span><span class="s3">\n </span><span class="s1">* @param {number} srcIndex The index of `source`.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize merged values.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed source values and their merged</span><span class="s3">\n </span><span class="s1">*  counterparts.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMerge(object, source, srcIndex, customizer, stack) {</span><span class="s3">\n  </span><span class="s1">if (object === source) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">baseFor(source, function(srcValue, key) {</span><span class="s3">\n    </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n    </span><span class="s1">if (isObject(srcValue)) {</span><span class="s3">\n      </span><span class="s1">baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">var newValue = customizer</span><span class="s3">\n        </span><span class="s1">? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)</span><span class="s3">\n        </span><span class="s1">: undefined;</span><span class="s3">\n\n      </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n        </span><span class="s1">newValue = srcValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">assignMergeValue(object, key, newValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, keysIn);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseMerge` for arrays and objects which performs</span><span class="s3">\n </span><span class="s1">* deep merges and tracks traversed objects enabling objects with circular</span><span class="s3">\n </span><span class="s1">* references to be merged.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {Object} source The source object.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to merge.</span><span class="s3">\n </span><span class="s1">* @param {number} srcIndex The index of `source`.</span><span class="s3">\n </span><span class="s1">* @param {Function} mergeFunc The function to merge values.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize assigned values.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed source values and their merged</span><span class="s3">\n </span><span class="s1">*  counterparts.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {</span><span class="s3">\n  </span><span class="s1">var objValue = safeGet(object, key),</span><span class="s3">\n      </span><span class="s1">srcValue = safeGet(source, key),</span><span class="s3">\n      </span><span class="s1">stacked = stack.get(srcValue);</span><span class="s3">\n\n  </span><span class="s1">if (stacked) {</span><span class="s3">\n    </span><span class="s1">assignMergeValue(object, key, stacked);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var newValue = customizer</span><span class="s3">\n    </span><span class="s1">? customizer(objValue, srcValue, (key + ''), object, source, stack)</span><span class="s3">\n    </span><span class="s1">: undefined;</span><span class="s3">\n\n  </span><span class="s1">var isCommon = newValue === undefined;</span><span class="s3">\n\n  </span><span class="s1">if (isCommon) {</span><span class="s3">\n    </span><span class="s1">var isArr = isArray(srcValue),</span><span class="s3">\n        </span><span class="s1">isBuff = !isArr &amp;&amp; isBuffer(srcValue),</span><span class="s3">\n        </span><span class="s1">isTyped = !isArr &amp;&amp; !isBuff &amp;&amp; isTypedArray(srcValue);</span><span class="s3">\n\n    </span><span class="s1">newValue = srcValue;</span><span class="s3">\n    </span><span class="s1">if (isArr || isBuff || isTyped) {</span><span class="s3">\n      </span><span class="s1">if (isArray(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = objValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (isArrayLikeObject(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = copyArray(objValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (isBuff) {</span><span class="s3">\n        </span><span class="s1">isCommon = false;</span><span class="s3">\n        </span><span class="s1">newValue = cloneBuffer(srcValue, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (isTyped) {</span><span class="s3">\n        </span><span class="s1">isCommon = false;</span><span class="s3">\n        </span><span class="s1">newValue = cloneTypedArray(srcValue, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">newValue = [];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isPlainObject(srcValue) || isArguments(srcValue)) {</span><span class="s3">\n      </span><span class="s1">newValue = objValue;</span><span class="s3">\n      </span><span class="s1">if (isArguments(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = toPlainObject(objValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (!isObject(objValue) || isFunction(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = initCloneObject(srcValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">isCommon = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isCommon) {</span><span class="s3">\n    </span><span class="s1">// Recursively merge objects and arrays (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">stack.set(srcValue, newValue);</span><span class="s3">\n    </span><span class="s1">mergeFunc(newValue, srcValue, srcIndex, customizer, stack);</span><span class="s3">\n    </span><span class="s1">stack['delete'](srcValue);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">assignMergeValue(object, key, newValue);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.rest` which doesn't validate or coerce arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to apply a rest parameter to.</span><span class="s3">\n </span><span class="s1">* @param {number} [start=func.length-1] The start position of the rest parameter.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseRest(func, start) {</span><span class="s3">\n  </span><span class="s1">return setToString(overRest(func, start, identity), func + '');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `setToString` without support for hot loop shorting.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to modify.</span><span class="s3">\n </span><span class="s1">* @param {Function} string The `toString` result.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns `func`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var baseSetToString = !defineProperty ? identity : function(func, string) {</span><span class="s3">\n  </span><span class="s1">return defineProperty(func, 'toString', {</span><span class="s3">\n    </span><span class="s1">'configurable': true,</span><span class="s3">\n    </span><span class="s1">'enumerable': false,</span><span class="s3">\n    </span><span class="s1">'value': constant(string),</span><span class="s3">\n    </span><span class="s1">'writable': true</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a clone of  `buffer`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Buffer} buffer The buffer to clone.</span><span class="s3">\n </span><span class="s1">* @param {boolean} [isDeep] Specify a deep clone.</span><span class="s3">\n </span><span class="s1">* @returns {Buffer} Returns the cloned buffer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function cloneBuffer(buffer, isDeep) {</span><span class="s3">\n  </span><span class="s1">if (isDeep) {</span><span class="s3">\n    </span><span class="s1">return buffer.slice();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var length = buffer.length,</span><span class="s3">\n      </span><span class="s1">result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);</span><span class="s3">\n\n  </span><span class="s1">buffer.copy(result);</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a clone of `arrayBuffer`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {ArrayBuffer} arrayBuffer The array buffer to clone.</span><span class="s3">\n </span><span class="s1">* @returns {ArrayBuffer} Returns the cloned array buffer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function cloneArrayBuffer(arrayBuffer) {</span><span class="s3">\n  </span><span class="s1">var result = new arrayBuffer.constructor(arrayBuffer.byteLength);</span><span class="s3">\n  </span><span class="s1">new Uint8Array(result).set(new Uint8Array(arrayBuffer));</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a clone of `typedArray`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} typedArray The typed array to clone.</span><span class="s3">\n </span><span class="s1">* @param {boolean} [isDeep] Specify a deep clone.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the cloned typed array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function cloneTypedArray(typedArray, isDeep) {</span><span class="s3">\n  </span><span class="s1">var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;</span><span class="s3">\n  </span><span class="s1">return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copies the values of `source` to `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} source The array to copy values from.</span><span class="s3">\n </span><span class="s1">* @param {Array} [array=[]] The array to copy values to.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns `array`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function copyArray(source, array) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = source.length;</span><span class="s3">\n\n  </span><span class="s1">array || (array = Array(length));</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">array[index] = source[index];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copies properties of `source` to `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} source The object to copy properties from.</span><span class="s3">\n </span><span class="s1">* @param {Array} props The property identifiers to copy.</span><span class="s3">\n </span><span class="s1">* @param {Object} [object={}] The object to copy properties to.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize copied values.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function copyObject(source, props, object, customizer) {</span><span class="s3">\n  </span><span class="s1">var isNew = !object;</span><span class="s3">\n  </span><span class="s1">object || (object = {});</span><span class="s3">\n\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = props.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var key = props[index];</span><span class="s3">\n\n    </span><span class="s1">var newValue = customizer</span><span class="s3">\n      </span><span class="s1">? customizer(object[key], source[key], key, object, source)</span><span class="s3">\n      </span><span class="s1">: undefined;</span><span class="s3">\n\n    </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n      </span><span class="s1">newValue = source[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isNew) {</span><span class="s3">\n      </span><span class="s1">baseAssignValue(object, key, newValue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">assignValue(object, key, newValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function like `_.assign`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} assigner The function to assign values.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new assigner function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createAssigner(assigner) {</span><span class="s3">\n  </span><span class="s1">return baseRest(function(object, sources) {</span><span class="s3">\n    </span><span class="s1">var index = -1,</span><span class="s3">\n        </span><span class="s1">length = sources.length,</span><span class="s3">\n        </span><span class="s1">customizer = length &gt; 1 ? sources[length - 1] : undefined,</span><span class="s3">\n        </span><span class="s1">guard = length &gt; 2 ? sources[2] : undefined;</span><span class="s3">\n\n    </span><span class="s1">customizer = (assigner.length &gt; 3 &amp;&amp; typeof customizer == 'function')</span><span class="s3">\n      </span><span class="s1">? (length--, customizer)</span><span class="s3">\n      </span><span class="s1">: undefined;</span><span class="s3">\n\n    </span><span class="s1">if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) {</span><span class="s3">\n      </span><span class="s1">customizer = length &lt; 3 ? undefined : customizer;</span><span class="s3">\n      </span><span class="s1">length = 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">object = Object(object);</span><span class="s3">\n    </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n      </span><span class="s1">var source = sources[index];</span><span class="s3">\n      </span><span class="s1">if (source) {</span><span class="s3">\n        </span><span class="s1">assigner(object, source, index, customizer);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a base function for methods like `_.forIn` and `_.forOwn`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {boolean} [fromRight] Specify iterating from right to left.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new base function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createBaseFor(fromRight) {</span><span class="s3">\n  </span><span class="s1">return function(object, iteratee, keysFunc) {</span><span class="s3">\n    </span><span class="s1">var index = -1,</span><span class="s3">\n        </span><span class="s1">iterable = Object(object),</span><span class="s3">\n        </span><span class="s1">props = keysFunc(object),</span><span class="s3">\n        </span><span class="s1">length = props.length;</span><span class="s3">\n\n    </span><span class="s1">while (length--) {</span><span class="s3">\n      </span><span class="s1">var key = props[fromRight ? length : ++index];</span><span class="s3">\n      </span><span class="s1">if (iteratee(iterable[key], key, iterable) === false) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the data for `map`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} map The map to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The reference key.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the map data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getMapData(map, key) {</span><span class="s3">\n  </span><span class="s1">var data = map.__data__;</span><span class="s3">\n  </span><span class="s1">return isKeyable(key)</span><span class="s3">\n    </span><span class="s1">? data[typeof key == 'string' ? 'string' : 'hash']</span><span class="s3">\n    </span><span class="s1">: data.map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the native function at `key` of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the method to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the function if it's native, else `undefined`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getNative(object, key) {</span><span class="s3">\n  </span><span class="s1">var value = getValue(object, key);</span><span class="s3">\n  </span><span class="s1">return baseIsNative(value) ? value : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to query.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the raw `toStringTag`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getRawTag(value) {</span><span class="s3">\n  </span><span class="s1">var isOwn = hasOwnProperty.call(value, symToStringTag),</span><span class="s3">\n      </span><span class="s1">tag = value[symToStringTag];</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">value[symToStringTag] = undefined;</span><span class="s3">\n    </span><span class="s1">var unmasked = true;</span><span class="s3">\n  </span><span class="s1">} catch (e) {}</span><span class="s3">\n\n  </span><span class="s1">var result = nativeObjectToString.call(value);</span><span class="s3">\n  </span><span class="s1">if (unmasked) {</span><span class="s3">\n    </span><span class="s1">if (isOwn) {</span><span class="s3">\n      </span><span class="s1">value[symToStringTag] = tag;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">delete value[symToStringTag];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Initializes an object clone.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to clone.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the initialized clone.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function initCloneObject(object) {</span><span class="s3">\n  </span><span class="s1">return (typeof object.constructor == 'function' &amp;&amp; !isPrototype(object))</span><span class="s3">\n    </span><span class="s1">? baseCreate(getPrototype(object))</span><span class="s3">\n    </span><span class="s1">: {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is a valid array-like index.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isIndex(value, length) {</span><span class="s3">\n  </span><span class="s1">var type = typeof value;</span><span class="s3">\n  </span><span class="s1">length = length == null ? MAX_SAFE_INTEGER : length;</span><span class="s3">\n\n  </span><span class="s1">return !!length &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(type == 'number' ||</span><span class="s3">\n      </span><span class="s1">(type != 'symbol' &amp;&amp; reIsUint.test(value))) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given arguments are from an iteratee call.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The potential iteratee value argument.</span><span class="s3">\n </span><span class="s1">* @param {*} index The potential iteratee index or key argument.</span><span class="s3">\n </span><span class="s1">* @param {*} object The potential iteratee object argument.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the arguments are from an iteratee call,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isIterateeCall(value, index, object) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(object)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var type = typeof index;</span><span class="s3">\n  </span><span class="s1">if (type == 'number'</span><span class="s3">\n        </span><span class="s1">? (isArrayLike(object) &amp;&amp; isIndex(index, object.length))</span><span class="s3">\n        </span><span class="s1">: (type == 'string' &amp;&amp; index in object)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return eq(object[index], value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is suitable for use as unique object key.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is suitable, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isKeyable(value) {</span><span class="s3">\n  </span><span class="s1">var type = typeof value;</span><span class="s3">\n  </span><span class="s1">return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')</span><span class="s3">\n    </span><span class="s1">? (value !== '__proto__')</span><span class="s3">\n    </span><span class="s1">: (value === null);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `func` has its source masked.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `func` is masked, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isMasked(func) {</span><span class="s3">\n  </span><span class="s1">return !!maskSrcKey &amp;&amp; (maskSrcKey in func);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is likely a prototype object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a prototype, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isPrototype(value) {</span><span class="s3">\n  </span><span class="s1">var Ctor = value &amp;&amp; value.constructor,</span><span class="s3">\n      </span><span class="s1">proto = (typeof Ctor == 'function' &amp;&amp; Ctor.prototype) || objectProto;</span><span class="s3">\n\n  </span><span class="s1">return value === proto;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is like</span><span class="s3">\n </span><span class="s1">* [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)</span><span class="s3">\n </span><span class="s1">* except that it includes inherited enumerable properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the array of property names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function nativeKeysIn(object) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n  </span><span class="s1">if (object != null) {</span><span class="s3">\n    </span><span class="s1">for (var key in Object(object)) {</span><span class="s3">\n      </span><span class="s1">result.push(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a string using `Object.prototype.toString`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the converted string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function objectToString(value) {</span><span class="s3">\n  </span><span class="s1">return nativeObjectToString.call(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseRest` which transforms the rest array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to apply a rest parameter to.</span><span class="s3">\n </span><span class="s1">* @param {number} [start=func.length-1] The start position of the rest parameter.</span><span class="s3">\n </span><span class="s1">* @param {Function} transform The rest array transform.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function overRest(func, start, transform) {</span><span class="s3">\n  </span><span class="s1">start = nativeMax(start === undefined ? (func.length - 1) : start, 0);</span><span class="s3">\n  </span><span class="s1">return function() {</span><span class="s3">\n    </span><span class="s1">var args = arguments,</span><span class="s3">\n        </span><span class="s1">index = -1,</span><span class="s3">\n        </span><span class="s1">length = nativeMax(args.length - start, 0),</span><span class="s3">\n        </span><span class="s1">array = Array(length);</span><span class="s3">\n\n    </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n      </span><span class="s1">array[index] = args[start + index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = -1;</span><span class="s3">\n    </span><span class="s1">var otherArgs = Array(start + 1);</span><span class="s3">\n    </span><span class="s1">while (++index &lt; start) {</span><span class="s3">\n      </span><span class="s1">otherArgs[index] = args[index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">otherArgs[start] = transform(array);</span><span class="s3">\n    </span><span class="s1">return apply(func, this, otherArgs);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the value at `key`, unless `key` is </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the property value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function safeGet(object, key) {</span><span class="s3">\n  </span><span class="s1">if (key === 'constructor' &amp;&amp; typeof object[key] === 'function') {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (key == '__proto__') {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return object[key];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the `toString` method of `func` to return `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to modify.</span><span class="s3">\n </span><span class="s1">* @param {Function} string The `toString` result.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns `func`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var setToString = shortOut(baseSetToString);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function that'll short out and invoke `identity` instead</span><span class="s3">\n </span><span class="s1">* of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`</span><span class="s3">\n </span><span class="s1">* milliseconds.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to restrict.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new shortable function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function shortOut(func) {</span><span class="s3">\n  </span><span class="s1">var count = 0,</span><span class="s3">\n      </span><span class="s1">lastCalled = 0;</span><span class="s3">\n\n  </span><span class="s1">return function() {</span><span class="s3">\n    </span><span class="s1">var stamp = nativeNow(),</span><span class="s3">\n        </span><span class="s1">remaining = HOT_SPAN - (stamp - lastCalled);</span><span class="s3">\n\n    </span><span class="s1">lastCalled = stamp;</span><span class="s3">\n    </span><span class="s1">if (remaining &gt; 0) {</span><span class="s3">\n      </span><span class="s1">if (++count &gt;= HOT_COUNT) {</span><span class="s3">\n        </span><span class="s1">return arguments[0];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">count = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return func.apply(undefined, arguments);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `func` to its source code.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to convert.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the source code.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toSource(func) {</span><span class="s3">\n  </span><span class="s1">if (func != null) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return funcToString.call(func);</span><span class="s3">\n    </span><span class="s1">} catch (e) {}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return (func + '');</span><span class="s3">\n    </span><span class="s1">} catch (e) {}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return '';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs a</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* comparison between two values to determine if they are equivalent.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">* var other = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq(object, object);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq(object, other);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq('a', 'a');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq('a', Object('a'));</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.eq(NaN, NaN);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function eq(value, other) {</span><span class="s3">\n  </span><span class="s1">return value === other || (value !== value &amp;&amp; other !== other);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is likely an `arguments` object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an `arguments` object,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArguments(function() { return arguments; }());</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArguments([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {</span><span class="s3">\n  </span><span class="s1">return isObjectLike(value) &amp;&amp; hasOwnProperty.call(value, 'callee') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!propertyIsEnumerable.call(value, 'callee');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as an `Array` object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an array, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray(document.body.children);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArray(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var isArray = Array.isArray;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is array-like. A value is considered array-like if it's</span><span class="s3">\n </span><span class="s1">* not a function and has a `value.length` that's an integer greater than or</span><span class="s3">\n </span><span class="s1">* equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is array-like, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLike([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLike(document.body.children);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLike('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLike(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isArrayLike(value) {</span><span class="s3">\n  </span><span class="s1">return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.isArrayLike` except that it also checks if `value`</span><span class="s3">\n </span><span class="s1">* is an object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an array-like object,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject(document.body.children);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isArrayLikeObject(value) {</span><span class="s3">\n  </span><span class="s1">return isObjectLike(value) &amp;&amp; isArrayLike(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is a buffer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.3.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a buffer, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isBuffer(new Buffer(2));</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isBuffer(new Uint8Array(2));</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var isBuffer = nativeIsBuffer || stubFalse;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a `Function` object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a function, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isFunction(_);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isFunction(/abc/);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isFunction(value) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(value)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// The use of `Object#toString` avoids issues with the `typeof` operator</span><span class="s3">\n  </span><span class="s1">// in Safari 9 which returns 'object' for typed arrays and other constructors.</span><span class="s3">\n  </span><span class="s1">var tag = baseGetTag(value);</span><span class="s3">\n  </span><span class="s1">return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is a valid array-like length.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method is loosely based on</span><span class="s3">\n </span><span class="s1">* [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a valid length, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isLength(3);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isLength(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isLength(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isLength('3');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isLength(value) {</span><span class="s3">\n  </span><span class="s1">return typeof value == 'number' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is the</span><span class="s3">\n </span><span class="s1">* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)</span><span class="s3">\n </span><span class="s1">* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an object, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject({});</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObject(null);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isObject(value) {</span><span class="s3">\n  </span><span class="s1">var type = typeof value;</span><span class="s3">\n  </span><span class="s1">return value != null &amp;&amp; (type == 'object' || type == 'function');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is object-like. A value is object-like if it's not `null`</span><span class="s3">\n </span><span class="s1">* and has a `typeof` result of </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is object-like, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike({});</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isObjectLike(null);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isObjectLike(value) {</span><span class="s3">\n  </span><span class="s1">return value != null &amp;&amp; typeof value == 'object';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is a plain object, that is, an object created by the</span><span class="s3">\n </span><span class="s1">* `Object` constructor or one with a `[[Prototype]]` of `null`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.8.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a plain object, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.a = 1;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isPlainObject(new Foo);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isPlainObject([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isPlainObject({ 'x': 0, 'y': 0 });</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isPlainObject(Object.create(null));</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isPlainObject(value) {</span><span class="s3">\n  </span><span class="s1">if (!isObjectLike(value) || baseGetTag(value) != objectTag) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var proto = getPrototype(value);</span><span class="s3">\n  </span><span class="s1">if (proto === null) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var Ctor = hasOwnProperty.call(proto, 'constructor') &amp;&amp; proto.constructor;</span><span class="s3">\n  </span><span class="s1">return typeof Ctor == 'function' &amp;&amp; Ctor instanceof Ctor &amp;&amp;</span><span class="s3">\n    </span><span class="s1">funcToString.call(Ctor) == objectCtorString;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a typed array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isTypedArray(new Uint8Array);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isTypedArray([]);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a plain object flattening inherited enumerable string</span><span class="s3">\n </span><span class="s1">* keyed properties of `value` to own properties of the plain object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the converted plain object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.b = 2;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Foo.prototype.c = 3;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.assign({ 'a': 1 }, new Foo);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2 }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.assign({ 'a': 1 }, _.toPlainObject(new Foo));</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2, 'c': 3 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toPlainObject(value) {</span><span class="s3">\n  </span><span class="s1">return copyObject(value, keysIn(value));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of the own and inherited enumerable property names of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** Non-object values are coerced to objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the array of property names.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.a = 1;</span><span class="s3">\n </span><span class="s1">*   this.b = 2;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Foo.prototype.c = 3;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.keysIn(new Foo);</span><span class="s3">\n </span><span class="s1">* // =&gt; ['a', 'b', 'c'] (iteration order is not guaranteed)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function keysIn(object) {</span><span class="s3">\n  </span><span class="s1">return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.merge` except that it accepts `customizer` which</span><span class="s3">\n </span><span class="s1">* is invoked to produce the merged values of the destination and source</span><span class="s3">\n </span><span class="s1">* properties. If `customizer` returns `undefined`, merging is handled by the</span><span class="s3">\n </span><span class="s1">* method instead. The `customizer` is invoked with six arguments:</span><span class="s3">\n </span><span class="s1">* (objValue, srcValue, key, object, source, stack).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} sources The source objects.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize assigned values.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function customizer(objValue, srcValue) {</span><span class="s3">\n </span><span class="s1">*   if (_.isArray(objValue)) {</span><span class="s3">\n </span><span class="s1">*     return objValue.concat(srcValue);</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': [1], 'b': [2] };</span><span class="s3">\n </span><span class="s1">* var other = { 'a': [3], 'b': [4] };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.mergeWith(object, other, customizer);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': [1, 3], 'b': [2, 4] }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {</span><span class="s3">\n  </span><span class="s1">baseMerge(object, source, srcIndex, customizer);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function that returns `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 2.4.0</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to return from the new function.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new constant function.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = _.times(2, _.constant({ 'a': 1 }));</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* console.log(objects);</span><span class="s3">\n </span><span class="s1">* // =&gt; [{ 'a': 1 }, { 'a': 1 }]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* console.log(objects[0] === objects[1]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function constant(value) {</span><span class="s3">\n  </span><span class="s1">return function() {</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns the first argument it receives.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @param {*} value Any value.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns `value`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* console.log(_.identity(object) === object);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function identity(value) {</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.13.0</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.times(2, _.stubFalse);</span><span class="s3">\n </span><span class="s1">* // =&gt; [false, false]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stubFalse() {</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = mergeWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {</span><span class="s3">\n    </span><span class="s1">if (k2 === undefined) k2 = k;</span><span class="s3">\n    </span><span class="s1">var desc = Object.getOwnPropertyDescriptor(m, k);</span><span class="s3">\n    </span><span class="s1">if (!desc || (</span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">in desc ? !m.__esModule : desc.writable || desc.configurable)) {</span><span class="s3">\n      </span><span class="s1">desc = { enumerable: true, get: function() { return m[k]; } };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(o, k2, desc);</span><span class="s3">\n</span><span class="s1">}) : (function(o, m, k, k2) {</span><span class="s3">\n    </span><span class="s1">if (k2 === undefined) k2 = k;</span><span class="s3">\n    </span><span class="s1">o[k2] = m[k];</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">var __exportStar = (this &amp;&amp; this.__exportStar) || function(m, exports) {</span><span class="s3">\n    </span><span class="s1">for (var p in m) if (p !== </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;</span><span class="s3">\n</span><span class="s1">const ril_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ril</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">// Install the browser runtime abstract.</span><span class="s3">\n</span><span class="s1">ril_1.default.install();</span><span class="s3">\n</span><span class="s1">const api_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../common/api</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">__exportStar(require(</span><span class="s3">\&quot;</span><span class="s1">../common/api</span><span class="s3">\&quot;</span><span class="s1">), exports);</span><span class="s3">\n</span><span class="s1">class BrowserMessageReader extends api_1.AbstractMessageReader {</span><span class="s3">\n    </span><span class="s1">constructor(port) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._onData = new api_1.Emitter();</span><span class="s3">\n        </span><span class="s1">this._messageListener = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">this._onData.fire(event.data);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">port.addEventListener('error', (event) =&gt; this.fireError(event));</span><span class="s3">\n        </span><span class="s1">port.onmessage = this._messageListener;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">listen(callback) {</span><span class="s3">\n        </span><span class="s1">return this._onData.event(callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.BrowserMessageReader = BrowserMessageReader;</span><span class="s3">\n</span><span class="s1">class BrowserMessageWriter extends api_1.AbstractMessageWriter {</span><span class="s3">\n    </span><span class="s1">constructor(port) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.port = port;</span><span class="s3">\n        </span><span class="s1">this.errorCount = 0;</span><span class="s3">\n        </span><span class="s1">port.addEventListener('error', (event) =&gt; this.fireError(event));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">write(msg) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">this.port.postMessage(msg);</span><span class="s3">\n            </span><span class="s1">return Promise.resolve();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (error) {</span><span class="s3">\n            </span><span class="s1">this.handleError(error, msg);</span><span class="s3">\n            </span><span class="s1">return Promise.reject(error);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">handleError(error, msg) {</span><span class="s3">\n        </span><span class="s1">this.errorCount++;</span><span class="s3">\n        </span><span class="s1">this.fireError(error, msg, this.errorCount);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">end() {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.BrowserMessageWriter = BrowserMessageWriter;</span><span class="s3">\n</span><span class="s1">function createMessageConnection(reader, writer, logger, options) {</span><span class="s3">\n    </span><span class="s1">if (logger === undefined) {</span><span class="s3">\n        </span><span class="s1">logger = api_1.NullLogger;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (api_1.ConnectionStrategy.is(options)) {</span><span class="s3">\n        </span><span class="s1">options = { connectionStrategy: options };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (0, api_1.createMessageConnection)(reader, writer, logger, options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.createMessageConnection = createMessageConnection;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">const api_1 = require(</span><span class="s3">\&quot;</span><span class="s1">../common/api</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">class MessageBuffer extends api_1.AbstractMessageBuffer {</span><span class="s3">\n    </span><span class="s1">constructor(encoding = 'utf-8') {</span><span class="s3">\n        </span><span class="s1">super(encoding);</span><span class="s3">\n        </span><span class="s1">this.asciiDecoder = new TextDecoder('ascii');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">emptyBuffer() {</span><span class="s3">\n        </span><span class="s1">return MessageBuffer.emptyBuffer;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fromString(value, _encoding) {</span><span class="s3">\n        </span><span class="s1">return (new TextEncoder()).encode(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString(value, encoding) {</span><span class="s3">\n        </span><span class="s1">if (encoding === 'ascii') {</span><span class="s3">\n            </span><span class="s1">return this.asciiDecoder.decode(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return (new TextDecoder(encoding)).decode(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">asNative(buffer, length) {</span><span class="s3">\n        </span><span class="s1">if (length === undefined) {</span><span class="s3">\n            </span><span class="s1">return buffer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return buffer.slice(0, length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">allocNative(length) {</span><span class="s3">\n        </span><span class="s1">return new Uint8Array(length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">MessageBuffer.emptyBuffer = new Uint8Array(0);</span><span class="s3">\n</span><span class="s1">class ReadableStreamWrapper {</span><span class="s3">\n    </span><span class="s1">constructor(socket) {</span><span class="s3">\n        </span><span class="s1">this.socket = socket;</span><span class="s3">\n        </span><span class="s1">this._onData = new api_1.Emitter();</span><span class="s3">\n        </span><span class="s1">this._messageListener = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">const blob = event.data;</span><span class="s3">\n            </span><span class="s1">blob.arrayBuffer().then((buffer) =&gt; {</span><span class="s3">\n                </span><span class="s1">this._onData.fire(new Uint8Array(buffer));</span><span class="s3">\n            </span><span class="s1">}, () =&gt; {</span><span class="s3">\n                </span><span class="s1">(0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('message', this._messageListener);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onClose(listener) {</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('close', listener);</span><span class="s3">\n        </span><span class="s1">return api_1.Disposable.create(() =&gt; this.socket.removeEventListener('close', listener));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onError(listener) {</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('error', listener);</span><span class="s3">\n        </span><span class="s1">return api_1.Disposable.create(() =&gt; this.socket.removeEventListener('error', listener));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onEnd(listener) {</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('end', listener);</span><span class="s3">\n        </span><span class="s1">return api_1.Disposable.create(() =&gt; this.socket.removeEventListener('end', listener));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onData(listener) {</span><span class="s3">\n        </span><span class="s1">return this._onData.event(listener);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class WritableStreamWrapper {</span><span class="s3">\n    </span><span class="s1">constructor(socket) {</span><span class="s3">\n        </span><span class="s1">this.socket = socket;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onClose(listener) {</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('close', listener);</span><span class="s3">\n        </span><span class="s1">return api_1.Disposable.create(() =&gt; this.socket.removeEventListener('close', listener));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onError(listener) {</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('error', listener);</span><span class="s3">\n        </span><span class="s1">return api_1.Disposable.create(() =&gt; this.socket.removeEventListener('error', listener));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onEnd(listener) {</span><span class="s3">\n        </span><span class="s1">this.socket.addEventListener('end', listener);</span><span class="s3">\n        </span><span class="s1">return api_1.Disposable.create(() =&gt; this.socket.removeEventListener('end', listener));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">write(data, encoding) {</span><span class="s3">\n        </span><span class="s1">if (typeof data === 'string') {</span><span class="s3">\n            </span><span class="s1">if (encoding !== undefined &amp;&amp; encoding !== 'utf-8') {</span><span class="s3">\n                </span><span class="s1">throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.socket.send(data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.socket.send(data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return Promise.resolve();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">end() {</span><span class="s3">\n        </span><span class="s1">this.socket.close();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const _textEncoder = new TextEncoder();</span><span class="s3">\n</span><span class="s1">const _ril = Object.freeze({</span><span class="s3">\n    </span><span class="s1">messageBuffer: Object.freeze({</span><span class="s3">\n        </span><span class="s1">create: (encoding) =&gt; new MessageBuffer(encoding)</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">applicationJson: Object.freeze({</span><span class="s3">\n        </span><span class="s1">encoder: Object.freeze({</span><span class="s3">\n            </span><span class="s1">name: 'application/json',</span><span class="s3">\n            </span><span class="s1">encode: (msg, options) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (options.charset !== 'utf-8') {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">decoder: Object.freeze({</span><span class="s3">\n            </span><span class="s1">name: 'application/json',</span><span class="s3">\n            </span><span class="s1">decode: (buffer, options) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!(buffer instanceof Uint8Array)) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`In a Browser environments only Uint8Arrays are supported.`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">stream: Object.freeze({</span><span class="s3">\n        </span><span class="s1">asReadableStream: (socket) =&gt; new ReadableStreamWrapper(socket),</span><span class="s3">\n        </span><span class="s1">asWritableStream: (socket) =&gt; new WritableStreamWrapper(socket)</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">console: console,</span><span class="s3">\n    </span><span class="s1">timer: Object.freeze({</span><span class="s3">\n        </span><span class="s1">setTimeout(callback, ms, ...args) {</span><span class="s3">\n            </span><span class="s1">const handle = setTimeout(callback, ms, ...args);</span><span class="s3">\n            </span><span class="s1">return { dispose: () =&gt; clearTimeout(handle) };</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">setImmediate(callback, ...args) {</span><span class="s3">\n            </span><span class="s1">const handle = setTimeout(callback, 0, ...args);</span><span class="s3">\n            </span><span class="s1">return { dispose: () =&gt; clearTimeout(handle) };</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">setInterval(callback, ms, ...args) {</span><span class="s3">\n            </span><span class="s1">const handle = setInterval(callback, ms, ...args);</span><span class="s3">\n            </span><span class="s1">return { dispose: () =&gt; clearInterval(handle) };</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function RIL() {</span><span class="s3">\n    </span><span class="s1">return _ril;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function (RIL) {</span><span class="s3">\n    </span><span class="s1">function install() {</span><span class="s3">\n        </span><span class="s1">api_1.RAL.install(_ril);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RIL.install = install;</span><span class="s3">\n</span><span class="s1">})(RIL || (RIL = {}));</span><span class="s3">\n</span><span class="s1">exports.default = RIL;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../typings/thenable.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;</span><span class="s3">\n</span><span class="s1">exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;</span><span class="s3">\n</span><span class="s1">const messages_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./messages</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Message</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.Message; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType0</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType0; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType1</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType1; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType2</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType2; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType3</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType3; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType4</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType4; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType5</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType5; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType6</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType6; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType7</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType7; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType8</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType8; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">RequestType9</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.RequestType9; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ResponseError</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.ResponseError; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ErrorCodes</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.ErrorCodes; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType0</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType0; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType1</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType1; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType2</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType2; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType3</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType3; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType4</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType4; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType5</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType5; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType6</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType6; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType7</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType7; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType8</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType8; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NotificationType9</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.NotificationType9; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ParameterStructures</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messages_1.ParameterStructures; } });</span><span class="s3">\n</span><span class="s1">const linkedMap_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./linkedMap</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">LinkedMap</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">LRUCache</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Touch</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return linkedMap_1.Touch; } });</span><span class="s3">\n</span><span class="s1">const disposable_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./disposable</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Disposable</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return disposable_1.Disposable; } });</span><span class="s3">\n</span><span class="s1">const events_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./events</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Event</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return events_1.Event; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Emitter</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return events_1.Emitter; } });</span><span class="s3">\n</span><span class="s1">const cancellation_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./cancellation</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CancellationTokenSource</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CancellationToken</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });</span><span class="s3">\n</span><span class="s1">const sharedArrayCancellation_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./sharedArrayCancellation</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">SharedArraySenderStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">SharedArrayReceiverStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });</span><span class="s3">\n</span><span class="s1">const messageReader_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./messageReader</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">MessageReader</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageReader_1.MessageReader; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">AbstractMessageReader</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ReadableStreamMessageReader</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });</span><span class="s3">\n</span><span class="s1">const messageWriter_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./messageWriter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">MessageWriter</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">AbstractMessageWriter</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">WriteableStreamMessageWriter</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });</span><span class="s3">\n</span><span class="s1">const messageBuffer_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./messageBuffer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">AbstractMessageBuffer</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });</span><span class="s3">\n</span><span class="s1">const connection_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./connection</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ConnectionStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ConnectionOptions</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">NullLogger</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.NullLogger; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">createMessageConnection</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.createMessageConnection; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ProgressToken</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.ProgressToken; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ProgressType</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.ProgressType; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">Trace</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.Trace; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">TraceValues</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.TraceValues; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">TraceFormat</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.TraceFormat; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">SetTraceNotification</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">LogTraceNotification</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ConnectionErrors</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">ConnectionError</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.ConnectionError; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CancellationReceiverStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CancellationSenderStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">CancellationStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">MessageStrategy</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: true, get: function () { return connection_1.MessageStrategy; } });</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">exports.RAL = ral_1.default;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/*---------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">*  Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">*  Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">*--------------------------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.CancellationTokenSource = exports.CancellationToken = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const Is = require(</span><span class="s3">\&quot;</span><span class="s1">./is</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const events_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./events</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var CancellationToken;</span><span class="s3">\n</span><span class="s1">(function (CancellationToken) {</span><span class="s3">\n    </span><span class="s1">CancellationToken.None = Object.freeze({</span><span class="s3">\n        </span><span class="s1">isCancellationRequested: false,</span><span class="s3">\n        </span><span class="s1">onCancellationRequested: events_1.Event.None</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">CancellationToken.Cancelled = Object.freeze({</span><span class="s3">\n        </span><span class="s1">isCancellationRequested: true,</span><span class="s3">\n        </span><span class="s1">onCancellationRequested: events_1.Event.None</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; (candidate === CancellationToken.None</span><span class="s3">\n            </span><span class="s1">|| candidate === CancellationToken.Cancelled</span><span class="s3">\n            </span><span class="s1">|| (Is.boolean(candidate.isCancellationRequested) &amp;&amp; !!candidate.onCancellationRequested));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CancellationToken.is = is;</span><span class="s3">\n</span><span class="s1">})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));</span><span class="s3">\n</span><span class="s1">const shortcutEvent = Object.freeze(function (callback, context) {</span><span class="s3">\n    </span><span class="s1">const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);</span><span class="s3">\n    </span><span class="s1">return { dispose() { handle.dispose(); } };</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class MutableToken {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this._isCancelled = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">if (!this._isCancelled) {</span><span class="s3">\n            </span><span class="s1">this._isCancelled = true;</span><span class="s3">\n            </span><span class="s1">if (this._emitter) {</span><span class="s3">\n                </span><span class="s1">this._emitter.fire(undefined);</span><span class="s3">\n                </span><span class="s1">this.dispose();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isCancellationRequested() {</span><span class="s3">\n        </span><span class="s1">return this._isCancelled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onCancellationRequested() {</span><span class="s3">\n        </span><span class="s1">if (this._isCancelled) {</span><span class="s3">\n            </span><span class="s1">return shortcutEvent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this._emitter) {</span><span class="s3">\n            </span><span class="s1">this._emitter = new events_1.Emitter();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._emitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this._emitter) {</span><span class="s3">\n            </span><span class="s1">this._emitter.dispose();</span><span class="s3">\n            </span><span class="s1">this._emitter = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CancellationTokenSource {</span><span class="s3">\n    </span><span class="s1">get token() {</span><span class="s3">\n        </span><span class="s1">if (!this._token) {</span><span class="s3">\n            </span><span class="s1">// be lazy and create the token only when</span><span class="s3">\n            </span><span class="s1">// actually needed</span><span class="s3">\n            </span><span class="s1">this._token = new MutableToken();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._token;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">if (!this._token) {</span><span class="s3">\n            </span><span class="s1">// save an object by returning the default</span><span class="s3">\n            </span><span class="s1">// cancelled token when cancellation happens</span><span class="s3">\n            </span><span class="s1">// before someone asks for the token</span><span class="s3">\n            </span><span class="s1">this._token = CancellationToken.Cancelled;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._token.cancel();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (!this._token) {</span><span class="s3">\n            </span><span class="s1">// ensure to initialize with an empty token if we had none</span><span class="s3">\n            </span><span class="s1">this._token = CancellationToken.None;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this._token instanceof MutableToken) {</span><span class="s3">\n            </span><span class="s1">// actually dispose</span><span class="s3">\n            </span><span class="s1">this._token.dispose();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.CancellationTokenSource = CancellationTokenSource;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const Is = require(</span><span class="s3">\&quot;</span><span class="s1">./is</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const messages_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./messages</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const linkedMap_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./linkedMap</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const events_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./events</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const cancellation_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./cancellation</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var CancelNotification;</span><span class="s3">\n</span><span class="s1">(function (CancelNotification) {</span><span class="s3">\n    </span><span class="s1">CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');</span><span class="s3">\n</span><span class="s1">})(CancelNotification || (CancelNotification = {}));</span><span class="s3">\n</span><span class="s1">var ProgressToken;</span><span class="s3">\n</span><span class="s1">(function (ProgressToken) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value === 'string' || typeof value === 'number';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ProgressToken.is = is;</span><span class="s3">\n</span><span class="s1">})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));</span><span class="s3">\n</span><span class="s1">var ProgressNotification;</span><span class="s3">\n</span><span class="s1">(function (ProgressNotification) {</span><span class="s3">\n    </span><span class="s1">ProgressNotification.type = new messages_1.NotificationType('$/progress');</span><span class="s3">\n</span><span class="s1">})(ProgressNotification || (ProgressNotification = {}));</span><span class="s3">\n</span><span class="s1">class ProgressType {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ProgressType = ProgressType;</span><span class="s3">\n</span><span class="s1">var StarRequestHandler;</span><span class="s3">\n</span><span class="s1">(function (StarRequestHandler) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return Is.func(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">StarRequestHandler.is = is;</span><span class="s3">\n</span><span class="s1">})(StarRequestHandler || (StarRequestHandler = {}));</span><span class="s3">\n</span><span class="s1">exports.NullLogger = Object.freeze({</span><span class="s3">\n    </span><span class="s1">error: () =&gt; { },</span><span class="s3">\n    </span><span class="s1">warn: () =&gt; { },</span><span class="s3">\n    </span><span class="s1">info: () =&gt; { },</span><span class="s3">\n    </span><span class="s1">log: () =&gt; { }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">var Trace;</span><span class="s3">\n</span><span class="s1">(function (Trace) {</span><span class="s3">\n    </span><span class="s1">Trace[Trace[</span><span class="s3">\&quot;</span><span class="s1">Off</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Off</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Trace[Trace[</span><span class="s3">\&quot;</span><span class="s1">Messages</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Messages</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Trace[Trace[</span><span class="s3">\&quot;</span><span class="s1">Compact</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">Compact</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Trace[Trace[</span><span class="s3">\&quot;</span><span class="s1">Verbose</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">Verbose</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(Trace || (exports.Trace = Trace = {}));</span><span class="s3">\n</span><span class="s1">var TraceValues;</span><span class="s3">\n</span><span class="s1">(function (TraceValues) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Turn tracing off.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TraceValues.Off = 'off';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Trace messages only.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TraceValues.Messages = 'messages';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compact message tracing.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TraceValues.Compact = 'compact';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Verbose message tracing.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TraceValues.Verbose = 'verbose';</span><span class="s3">\n</span><span class="s1">})(TraceValues || (exports.TraceValues = TraceValues = {}));</span><span class="s3">\n</span><span class="s1">(function (Trace) {</span><span class="s3">\n    </span><span class="s1">function fromString(value) {</span><span class="s3">\n        </span><span class="s1">if (!Is.string(value)) {</span><span class="s3">\n            </span><span class="s1">return Trace.Off;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">value = value.toLowerCase();</span><span class="s3">\n        </span><span class="s1">switch (value) {</span><span class="s3">\n            </span><span class="s1">case 'off':</span><span class="s3">\n                </span><span class="s1">return Trace.Off;</span><span class="s3">\n            </span><span class="s1">case 'messages':</span><span class="s3">\n                </span><span class="s1">return Trace.Messages;</span><span class="s3">\n            </span><span class="s1">case 'compact':</span><span class="s3">\n                </span><span class="s1">return Trace.Compact;</span><span class="s3">\n            </span><span class="s1">case 'verbose':</span><span class="s3">\n                </span><span class="s1">return Trace.Verbose;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return Trace.Off;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Trace.fromString = fromString;</span><span class="s3">\n    </span><span class="s1">function toString(value) {</span><span class="s3">\n        </span><span class="s1">switch (value) {</span><span class="s3">\n            </span><span class="s1">case Trace.Off:</span><span class="s3">\n                </span><span class="s1">return 'off';</span><span class="s3">\n            </span><span class="s1">case Trace.Messages:</span><span class="s3">\n                </span><span class="s1">return 'messages';</span><span class="s3">\n            </span><span class="s1">case Trace.Compact:</span><span class="s3">\n                </span><span class="s1">return 'compact';</span><span class="s3">\n            </span><span class="s1">case Trace.Verbose:</span><span class="s3">\n                </span><span class="s1">return 'verbose';</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return 'off';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Trace.toString = toString;</span><span class="s3">\n</span><span class="s1">})(Trace || (exports.Trace = Trace = {}));</span><span class="s3">\n</span><span class="s1">var TraceFormat;</span><span class="s3">\n</span><span class="s1">(function (TraceFormat) {</span><span class="s3">\n    </span><span class="s1">TraceFormat[</span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">text</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">TraceFormat[</span><span class="s3">\&quot;</span><span class="s1">JSON</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));</span><span class="s3">\n</span><span class="s1">(function (TraceFormat) {</span><span class="s3">\n    </span><span class="s1">function fromString(value) {</span><span class="s3">\n        </span><span class="s1">if (!Is.string(value)) {</span><span class="s3">\n            </span><span class="s1">return TraceFormat.Text;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">value = value.toLowerCase();</span><span class="s3">\n        </span><span class="s1">if (value === 'json') {</span><span class="s3">\n            </span><span class="s1">return TraceFormat.JSON;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return TraceFormat.Text;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TraceFormat.fromString = fromString;</span><span class="s3">\n</span><span class="s1">})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));</span><span class="s3">\n</span><span class="s1">var SetTraceNotification;</span><span class="s3">\n</span><span class="s1">(function (SetTraceNotification) {</span><span class="s3">\n    </span><span class="s1">SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');</span><span class="s3">\n</span><span class="s1">})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));</span><span class="s3">\n</span><span class="s1">var LogTraceNotification;</span><span class="s3">\n</span><span class="s1">(function (LogTraceNotification) {</span><span class="s3">\n    </span><span class="s1">LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');</span><span class="s3">\n</span><span class="s1">})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));</span><span class="s3">\n</span><span class="s1">var ConnectionErrors;</span><span class="s3">\n</span><span class="s1">(function (ConnectionErrors) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The connection is closed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ConnectionErrors[ConnectionErrors[</span><span class="s3">\&quot;</span><span class="s1">Closed</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Closed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The connection got disposed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ConnectionErrors[ConnectionErrors[</span><span class="s3">\&quot;</span><span class="s1">Disposed</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">Disposed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The connection is already in listening mode.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ConnectionErrors[ConnectionErrors[</span><span class="s3">\&quot;</span><span class="s1">AlreadyListening</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">AlreadyListening</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));</span><span class="s3">\n</span><span class="s1">class ConnectionError extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(code, message) {</span><span class="s3">\n        </span><span class="s1">super(message);</span><span class="s3">\n        </span><span class="s1">this.code = code;</span><span class="s3">\n        </span><span class="s1">Object.setPrototypeOf(this, ConnectionError.prototype);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ConnectionError = ConnectionError;</span><span class="s3">\n</span><span class="s1">var ConnectionStrategy;</span><span class="s3">\n</span><span class="s1">(function (ConnectionStrategy) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.func(candidate.cancelUndispatched);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ConnectionStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));</span><span class="s3">\n</span><span class="s1">var IdCancellationReceiverStrategy;</span><span class="s3">\n</span><span class="s1">(function (IdCancellationReceiverStrategy) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; (candidate.kind === undefined || candidate.kind === 'id') &amp;&amp; Is.func(candidate.createCancellationTokenSource) &amp;&amp; (candidate.dispose === undefined || Is.func(candidate.dispose));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">IdCancellationReceiverStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));</span><span class="s3">\n</span><span class="s1">var RequestCancellationReceiverStrategy;</span><span class="s3">\n</span><span class="s1">(function (RequestCancellationReceiverStrategy) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; candidate.kind === 'request' &amp;&amp; Is.func(candidate.createCancellationTokenSource) &amp;&amp; (candidate.dispose === undefined || Is.func(candidate.dispose));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RequestCancellationReceiverStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));</span><span class="s3">\n</span><span class="s1">var CancellationReceiverStrategy;</span><span class="s3">\n</span><span class="s1">(function (CancellationReceiverStrategy) {</span><span class="s3">\n    </span><span class="s1">CancellationReceiverStrategy.Message = Object.freeze({</span><span class="s3">\n        </span><span class="s1">createCancellationTokenSource(_) {</span><span class="s3">\n            </span><span class="s1">return new cancellation_1.CancellationTokenSource();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CancellationReceiverStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));</span><span class="s3">\n</span><span class="s1">var CancellationSenderStrategy;</span><span class="s3">\n</span><span class="s1">(function (CancellationSenderStrategy) {</span><span class="s3">\n    </span><span class="s1">CancellationSenderStrategy.Message = Object.freeze({</span><span class="s3">\n        </span><span class="s1">sendCancellation(conn, id) {</span><span class="s3">\n            </span><span class="s1">return conn.sendNotification(CancelNotification.type, { id });</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">cleanup(_) { }</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.func(candidate.sendCancellation) &amp;&amp; Is.func(candidate.cleanup);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CancellationSenderStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));</span><span class="s3">\n</span><span class="s1">var CancellationStrategy;</span><span class="s3">\n</span><span class="s1">(function (CancellationStrategy) {</span><span class="s3">\n    </span><span class="s1">CancellationStrategy.Message = Object.freeze({</span><span class="s3">\n        </span><span class="s1">receiver: CancellationReceiverStrategy.Message,</span><span class="s3">\n        </span><span class="s1">sender: CancellationSenderStrategy.Message</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; CancellationReceiverStrategy.is(candidate.receiver) &amp;&amp; CancellationSenderStrategy.is(candidate.sender);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CancellationStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));</span><span class="s3">\n</span><span class="s1">var MessageStrategy;</span><span class="s3">\n</span><span class="s1">(function (MessageStrategy) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.func(candidate.handleMessage);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MessageStrategy.is = is;</span><span class="s3">\n</span><span class="s1">})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));</span><span class="s3">\n</span><span class="s1">var ConnectionOptions;</span><span class="s3">\n</span><span class="s1">(function (ConnectionOptions) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ConnectionOptions.is = is;</span><span class="s3">\n</span><span class="s1">})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));</span><span class="s3">\n</span><span class="s1">var ConnectionState;</span><span class="s3">\n</span><span class="s1">(function (ConnectionState) {</span><span class="s3">\n    </span><span class="s1">ConnectionState[ConnectionState[</span><span class="s3">\&quot;</span><span class="s1">New</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">New</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ConnectionState[ConnectionState[</span><span class="s3">\&quot;</span><span class="s1">Listening</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">Listening</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ConnectionState[ConnectionState[</span><span class="s3">\&quot;</span><span class="s1">Closed</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">Closed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ConnectionState[ConnectionState[</span><span class="s3">\&quot;</span><span class="s1">Disposed</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">Disposed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(ConnectionState || (ConnectionState = {}));</span><span class="s3">\n</span><span class="s1">function createMessageConnection(messageReader, messageWriter, _logger, options) {</span><span class="s3">\n    </span><span class="s1">const logger = _logger !== undefined ? _logger : exports.NullLogger;</span><span class="s3">\n    </span><span class="s1">let sequenceNumber = 0;</span><span class="s3">\n    </span><span class="s1">let notificationSequenceNumber = 0;</span><span class="s3">\n    </span><span class="s1">let unknownResponseSequenceNumber = 0;</span><span class="s3">\n    </span><span class="s1">const version = '2.0';</span><span class="s3">\n    </span><span class="s1">let starRequestHandler = undefined;</span><span class="s3">\n    </span><span class="s1">const requestHandlers = new Map();</span><span class="s3">\n    </span><span class="s1">let starNotificationHandler = undefined;</span><span class="s3">\n    </span><span class="s1">const notificationHandlers = new Map();</span><span class="s3">\n    </span><span class="s1">const progressHandlers = new Map();</span><span class="s3">\n    </span><span class="s1">let timer;</span><span class="s3">\n    </span><span class="s1">let messageQueue = new linkedMap_1.LinkedMap();</span><span class="s3">\n    </span><span class="s1">let responsePromises = new Map();</span><span class="s3">\n    </span><span class="s1">let knownCanceledRequests = new Set();</span><span class="s3">\n    </span><span class="s1">let requestTokens = new Map();</span><span class="s3">\n    </span><span class="s1">let trace = Trace.Off;</span><span class="s3">\n    </span><span class="s1">let traceFormat = TraceFormat.Text;</span><span class="s3">\n    </span><span class="s1">let tracer;</span><span class="s3">\n    </span><span class="s1">let state = ConnectionState.New;</span><span class="s3">\n    </span><span class="s1">const errorEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">const closeEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">const unhandledNotificationEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">const unhandledProgressEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">const disposeEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">const cancellationStrategy = (options &amp;&amp; options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;</span><span class="s3">\n    </span><span class="s1">function createRequestQueueKey(id) {</span><span class="s3">\n        </span><span class="s1">if (id === null) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`Can't send requests with id null since the response can't be correlated.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return 'req-' + id.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function createResponseQueueKey(id) {</span><span class="s3">\n        </span><span class="s1">if (id === null) {</span><span class="s3">\n            </span><span class="s1">return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return 'res-' + id.toString();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function createNotificationQueueKey() {</span><span class="s3">\n        </span><span class="s1">return 'not-' + (++notificationSequenceNumber).toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function addMessageToQueue(queue, message) {</span><span class="s3">\n        </span><span class="s1">if (messages_1.Message.isRequest(message)) {</span><span class="s3">\n            </span><span class="s1">queue.set(createRequestQueueKey(message.id), message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (messages_1.Message.isResponse(message)) {</span><span class="s3">\n            </span><span class="s1">queue.set(createResponseQueueKey(message.id), message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">queue.set(createNotificationQueueKey(), message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function cancelUndispatched(_message) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function isListening() {</span><span class="s3">\n        </span><span class="s1">return state === ConnectionState.Listening;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function isClosed() {</span><span class="s3">\n        </span><span class="s1">return state === ConnectionState.Closed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function isDisposed() {</span><span class="s3">\n        </span><span class="s1">return state === ConnectionState.Disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function closeHandler() {</span><span class="s3">\n        </span><span class="s1">if (state === ConnectionState.New || state === ConnectionState.Listening) {</span><span class="s3">\n            </span><span class="s1">state = ConnectionState.Closed;</span><span class="s3">\n            </span><span class="s1">closeEmitter.fire(undefined);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If the connection is disposed don't sent close events.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function readErrorHandler(error) {</span><span class="s3">\n        </span><span class="s1">errorEmitter.fire([error, undefined, undefined]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function writeErrorHandler(data) {</span><span class="s3">\n        </span><span class="s1">errorEmitter.fire(data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">messageReader.onClose(closeHandler);</span><span class="s3">\n    </span><span class="s1">messageReader.onError(readErrorHandler);</span><span class="s3">\n    </span><span class="s1">messageWriter.onClose(closeHandler);</span><span class="s3">\n    </span><span class="s1">messageWriter.onError(writeErrorHandler);</span><span class="s3">\n    </span><span class="s1">function triggerMessageQueue() {</span><span class="s3">\n        </span><span class="s1">if (timer || messageQueue.size === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">timer = (0, ral_1.default)().timer.setImmediate(() =&gt; {</span><span class="s3">\n            </span><span class="s1">timer = undefined;</span><span class="s3">\n            </span><span class="s1">processMessageQueue();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function handleMessage(message) {</span><span class="s3">\n        </span><span class="s1">if (messages_1.Message.isRequest(message)) {</span><span class="s3">\n            </span><span class="s1">handleRequest(message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (messages_1.Message.isNotification(message)) {</span><span class="s3">\n            </span><span class="s1">handleNotification(message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (messages_1.Message.isResponse(message)) {</span><span class="s3">\n            </span><span class="s1">handleResponse(message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">handleInvalidMessage(message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function processMessageQueue() {</span><span class="s3">\n        </span><span class="s1">if (messageQueue.size === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const message = messageQueue.shift();</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const messageStrategy = options?.messageStrategy;</span><span class="s3">\n            </span><span class="s1">if (MessageStrategy.is(messageStrategy)) {</span><span class="s3">\n                </span><span class="s1">messageStrategy.handleMessage(message, handleMessage);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">handleMessage(message);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">triggerMessageQueue();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const callback = (message) =&gt; {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// We have received a cancellation message. Check if the message is still in the queue</span><span class="s3">\n            </span><span class="s1">// and cancel it if allowed to do so.</span><span class="s3">\n            </span><span class="s1">if (messages_1.Message.isNotification(message) &amp;&amp; message.method === CancelNotification.type.method) {</span><span class="s3">\n                </span><span class="s1">const cancelId = message.params.id;</span><span class="s3">\n                </span><span class="s1">const key = createRequestQueueKey(cancelId);</span><span class="s3">\n                </span><span class="s1">const toCancel = messageQueue.get(key);</span><span class="s3">\n                </span><span class="s1">if (messages_1.Message.isRequest(toCancel)) {</span><span class="s3">\n                    </span><span class="s1">const strategy = options?.connectionStrategy;</span><span class="s3">\n                    </span><span class="s1">const response = (strategy &amp;&amp; strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);</span><span class="s3">\n                    </span><span class="s1">if (response &amp;&amp; (response.error !== undefined || response.result !== undefined)) {</span><span class="s3">\n                        </span><span class="s1">messageQueue.delete(key);</span><span class="s3">\n                        </span><span class="s1">requestTokens.delete(cancelId);</span><span class="s3">\n                        </span><span class="s1">response.id = toCancel.id;</span><span class="s3">\n                        </span><span class="s1">traceSendingResponse(response, message.method, Date.now());</span><span class="s3">\n                        </span><span class="s1">messageWriter.write(response).catch(() =&gt; logger.error(`Sending response for canceled message failed.`));</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const cancellationToken = requestTokens.get(cancelId);</span><span class="s3">\n                </span><span class="s1">// The request is already running. Cancel the token</span><span class="s3">\n                </span><span class="s1">if (cancellationToken !== undefined) {</span><span class="s3">\n                    </span><span class="s1">cancellationToken.cancel();</span><span class="s3">\n                    </span><span class="s1">traceReceivedNotification(message);</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Remember the cancel but still queue the message to</span><span class="s3">\n                    </span><span class="s1">// clean up state in process message.</span><span class="s3">\n                    </span><span class="s1">knownCanceledRequests.add(cancelId);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">addMessageToQueue(messageQueue, message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">triggerMessageQueue();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">function handleRequest(requestMessage) {</span><span class="s3">\n        </span><span class="s1">if (isDisposed()) {</span><span class="s3">\n            </span><span class="s1">// we return here silently since we fired an event when the</span><span class="s3">\n            </span><span class="s1">// connection got disposed.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function reply(resultOrError, method, startTime) {</span><span class="s3">\n            </span><span class="s1">const message = {</span><span class="s3">\n                </span><span class="s1">jsonrpc: version,</span><span class="s3">\n                </span><span class="s1">id: requestMessage.id</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">if (resultOrError instanceof messages_1.ResponseError) {</span><span class="s3">\n                </span><span class="s1">message.error = resultOrError.toJson();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">message.result = resultOrError === undefined ? null : resultOrError;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">traceSendingResponse(message, method, startTime);</span><span class="s3">\n            </span><span class="s1">messageWriter.write(message).catch(() =&gt; logger.error(`Sending response failed.`));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function replyError(error, method, startTime) {</span><span class="s3">\n            </span><span class="s1">const message = {</span><span class="s3">\n                </span><span class="s1">jsonrpc: version,</span><span class="s3">\n                </span><span class="s1">id: requestMessage.id,</span><span class="s3">\n                </span><span class="s1">error: error.toJson()</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">traceSendingResponse(message, method, startTime);</span><span class="s3">\n            </span><span class="s1">messageWriter.write(message).catch(() =&gt; logger.error(`Sending response failed.`));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function replySuccess(result, method, startTime) {</span><span class="s3">\n            </span><span class="s1">// The JSON RPC defines that a response must either have a result or an error</span><span class="s3">\n            </span><span class="s1">// So we can't treat undefined as a valid response result.</span><span class="s3">\n            </span><span class="s1">if (result === undefined) {</span><span class="s3">\n                </span><span class="s1">result = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const message = {</span><span class="s3">\n                </span><span class="s1">jsonrpc: version,</span><span class="s3">\n                </span><span class="s1">id: requestMessage.id,</span><span class="s3">\n                </span><span class="s1">result: result</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">traceSendingResponse(message, method, startTime);</span><span class="s3">\n            </span><span class="s1">messageWriter.write(message).catch(() =&gt; logger.error(`Sending response failed.`));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">traceReceivedRequest(requestMessage);</span><span class="s3">\n        </span><span class="s1">const element = requestHandlers.get(requestMessage.method);</span><span class="s3">\n        </span><span class="s1">let type;</span><span class="s3">\n        </span><span class="s1">let requestHandler;</span><span class="s3">\n        </span><span class="s1">if (element) {</span><span class="s3">\n            </span><span class="s1">type = element.type;</span><span class="s3">\n            </span><span class="s1">requestHandler = element.handler;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const startTime = Date.now();</span><span class="s3">\n        </span><span class="s1">if (requestHandler || starRequestHandler) {</span><span class="s3">\n            </span><span class="s1">const tokenKey = requestMessage.id ?? String(Date.now()); //</span><span class="s3">\n            </span><span class="s1">const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)</span><span class="s3">\n                </span><span class="s1">? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)</span><span class="s3">\n                </span><span class="s1">: cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);</span><span class="s3">\n            </span><span class="s1">if (requestMessage.id !== null &amp;&amp; knownCanceledRequests.has(requestMessage.id)) {</span><span class="s3">\n                </span><span class="s1">cancellationSource.cancel();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (requestMessage.id !== null) {</span><span class="s3">\n                </span><span class="s1">requestTokens.set(tokenKey, cancellationSource);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">let handlerResult;</span><span class="s3">\n                </span><span class="s1">if (requestHandler) {</span><span class="s3">\n                    </span><span class="s1">if (requestMessage.params === undefined) {</span><span class="s3">\n                        </span><span class="s1">if (type !== undefined &amp;&amp; type.numberOfParams !== 0) {</span><span class="s3">\n                            </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);</span><span class="s3">\n                            </span><span class="s1">return;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">handlerResult = requestHandler(cancellationSource.token);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (Array.isArray(requestMessage.params)) {</span><span class="s3">\n                        </span><span class="s1">if (type !== undefined &amp;&amp; type.parameterStructures === messages_1.ParameterStructures.byName) {</span><span class="s3">\n                            </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);</span><span class="s3">\n                            </span><span class="s1">return;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">if (type !== undefined &amp;&amp; type.parameterStructures === messages_1.ParameterStructures.byPosition) {</span><span class="s3">\n                            </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);</span><span class="s3">\n                            </span><span class="s1">return;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">handlerResult = requestHandler(requestMessage.params, cancellationSource.token);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (starRequestHandler) {</span><span class="s3">\n                    </span><span class="s1">handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const promise = handlerResult;</span><span class="s3">\n                </span><span class="s1">if (!handlerResult) {</span><span class="s3">\n                    </span><span class="s1">requestTokens.delete(tokenKey);</span><span class="s3">\n                    </span><span class="s1">replySuccess(handlerResult, requestMessage.method, startTime);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (promise.then) {</span><span class="s3">\n                    </span><span class="s1">promise.then((resultOrError) =&gt; {</span><span class="s3">\n                        </span><span class="s1">requestTokens.delete(tokenKey);</span><span class="s3">\n                        </span><span class="s1">reply(resultOrError, requestMessage.method, startTime);</span><span class="s3">\n                    </span><span class="s1">}, error =&gt; {</span><span class="s3">\n                        </span><span class="s1">requestTokens.delete(tokenKey);</span><span class="s3">\n                        </span><span class="s1">if (error instanceof messages_1.ResponseError) {</span><span class="s3">\n                            </span><span class="s1">replyError(error, requestMessage.method, startTime);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else if (error &amp;&amp; Is.string(error.message)) {</span><span class="s3">\n                            </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">requestTokens.delete(tokenKey);</span><span class="s3">\n                    </span><span class="s1">reply(handlerResult, requestMessage.method, startTime);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (error) {</span><span class="s3">\n                </span><span class="s1">requestTokens.delete(tokenKey);</span><span class="s3">\n                </span><span class="s1">if (error instanceof messages_1.ResponseError) {</span><span class="s3">\n                    </span><span class="s1">reply(error, requestMessage.method, startTime);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (error &amp;&amp; Is.string(error.message)) {</span><span class="s3">\n                    </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function handleResponse(responseMessage) {</span><span class="s3">\n        </span><span class="s1">if (isDisposed()) {</span><span class="s3">\n            </span><span class="s1">// See handle request.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (responseMessage.id === null) {</span><span class="s3">\n            </span><span class="s1">if (responseMessage.error) {</span><span class="s3">\n                </span><span class="s1">logger.error(`Received response message without id: Error is: </span><span class="s3">\\</span><span class="s1">n${JSON.stringify(responseMessage.error, undefined, 4)}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">logger.error(`Received response message without id. No further error information provided.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const key = responseMessage.id;</span><span class="s3">\n            </span><span class="s1">const responsePromise = responsePromises.get(key);</span><span class="s3">\n            </span><span class="s1">traceReceivedResponse(responseMessage, responsePromise);</span><span class="s3">\n            </span><span class="s1">if (responsePromise !== undefined) {</span><span class="s3">\n                </span><span class="s1">responsePromises.delete(key);</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">if (responseMessage.error) {</span><span class="s3">\n                        </span><span class="s1">const error = responseMessage.error;</span><span class="s3">\n                        </span><span class="s1">responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (responseMessage.result !== undefined) {</span><span class="s3">\n                        </span><span class="s1">responsePromise.resolve(responseMessage.result);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">throw new Error('Should never happen.');</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (error) {</span><span class="s3">\n                    </span><span class="s1">if (error.message) {</span><span class="s3">\n                        </span><span class="s1">logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function handleNotification(message) {</span><span class="s3">\n        </span><span class="s1">if (isDisposed()) {</span><span class="s3">\n            </span><span class="s1">// See handle request.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let type = undefined;</span><span class="s3">\n        </span><span class="s1">let notificationHandler;</span><span class="s3">\n        </span><span class="s1">if (message.method === CancelNotification.type.method) {</span><span class="s3">\n            </span><span class="s1">const cancelId = message.params.id;</span><span class="s3">\n            </span><span class="s1">knownCanceledRequests.delete(cancelId);</span><span class="s3">\n            </span><span class="s1">traceReceivedNotification(message);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const element = notificationHandlers.get(message.method);</span><span class="s3">\n            </span><span class="s1">if (element) {</span><span class="s3">\n                </span><span class="s1">notificationHandler = element.handler;</span><span class="s3">\n                </span><span class="s1">type = element.type;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (notificationHandler || starNotificationHandler) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">traceReceivedNotification(message);</span><span class="s3">\n                </span><span class="s1">if (notificationHandler) {</span><span class="s3">\n                    </span><span class="s1">if (message.params === undefined) {</span><span class="s3">\n                        </span><span class="s1">if (type !== undefined) {</span><span class="s3">\n                            </span><span class="s1">if (type.numberOfParams !== 0 &amp;&amp; type.parameterStructures !== messages_1.ParameterStructures.byName) {</span><span class="s3">\n                                </span><span class="s1">logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">notificationHandler();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (Array.isArray(message.params)) {</span><span class="s3">\n                        </span><span class="s1">// There are JSON-RPC libraries that send progress message as positional params although</span><span class="s3">\n                        </span><span class="s1">// specified as named. So convert them if this is the case.</span><span class="s3">\n                        </span><span class="s1">const params = message.params;</span><span class="s3">\n                        </span><span class="s1">if (message.method === ProgressNotification.type.method &amp;&amp; params.length === 2 &amp;&amp; ProgressToken.is(params[0])) {</span><span class="s3">\n                            </span><span class="s1">notificationHandler({ token: params[0], value: params[1] });</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">if (type !== undefined) {</span><span class="s3">\n                                </span><span class="s1">if (type.parameterStructures === messages_1.ParameterStructures.byName) {</span><span class="s3">\n                                    </span><span class="s1">logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">if (type.numberOfParams !== message.params.length) {</span><span class="s3">\n                                    </span><span class="s1">logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">notificationHandler(...params);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">if (type !== undefined &amp;&amp; type.parameterStructures === messages_1.ParameterStructures.byPosition) {</span><span class="s3">\n                            </span><span class="s1">logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">notificationHandler(message.params);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (starNotificationHandler) {</span><span class="s3">\n                    </span><span class="s1">starNotificationHandler(message.method, message.params);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (error) {</span><span class="s3">\n                </span><span class="s1">if (error.message) {</span><span class="s3">\n                    </span><span class="s1">logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">logger.error(`Notification handler '${message.method}' failed unexpectedly.`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">unhandledNotificationEmitter.fire(message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function handleInvalidMessage(message) {</span><span class="s3">\n        </span><span class="s1">if (!message) {</span><span class="s3">\n            </span><span class="s1">logger.error('Received empty message.');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">logger.error(`Received message which is neither a response nor a notification message:</span><span class="s3">\\</span><span class="s1">n${JSON.stringify(message, null, 4)}`);</span><span class="s3">\n        </span><span class="s1">// Test whether we find an id to reject the promise</span><span class="s3">\n        </span><span class="s1">const responseMessage = message;</span><span class="s3">\n        </span><span class="s1">if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {</span><span class="s3">\n            </span><span class="s1">const key = responseMessage.id;</span><span class="s3">\n            </span><span class="s1">const responseHandler = responsePromises.get(key);</span><span class="s3">\n            </span><span class="s1">if (responseHandler) {</span><span class="s3">\n                </span><span class="s1">responseHandler.reject(new Error('The received response has neither a result nor an error property.'));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function stringifyTrace(params) {</span><span class="s3">\n        </span><span class="s1">if (params === undefined || params === null) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (trace) {</span><span class="s3">\n            </span><span class="s1">case Trace.Verbose:</span><span class="s3">\n                </span><span class="s1">return JSON.stringify(params, null, 4);</span><span class="s3">\n            </span><span class="s1">case Trace.Compact:</span><span class="s3">\n                </span><span class="s1">return JSON.stringify(params);</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function traceSendingRequest(message) {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (traceFormat === TraceFormat.Text) {</span><span class="s3">\n            </span><span class="s1">let data = undefined;</span><span class="s3">\n            </span><span class="s1">if ((trace === Trace.Verbose || trace === Trace.Compact) &amp;&amp; message.params) {</span><span class="s3">\n                </span><span class="s1">data = `Params: ${stringifyTrace(message.params)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">logLSPMessage('send-request', message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function traceSendingNotification(message) {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (traceFormat === TraceFormat.Text) {</span><span class="s3">\n            </span><span class="s1">let data = undefined;</span><span class="s3">\n            </span><span class="s1">if (trace === Trace.Verbose || trace === Trace.Compact) {</span><span class="s3">\n                </span><span class="s1">if (message.params) {</span><span class="s3">\n                    </span><span class="s1">data = `Params: ${stringifyTrace(message.params)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">data = 'No parameters provided.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">tracer.log(`Sending notification '${message.method}'.`, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">logLSPMessage('send-notification', message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function traceSendingResponse(message, method, startTime) {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (traceFormat === TraceFormat.Text) {</span><span class="s3">\n            </span><span class="s1">let data = undefined;</span><span class="s3">\n            </span><span class="s1">if (trace === Trace.Verbose || trace === Trace.Compact) {</span><span class="s3">\n                </span><span class="s1">if (message.error &amp;&amp; message.error.data) {</span><span class="s3">\n                    </span><span class="s1">data = `Error data: ${stringifyTrace(message.error.data)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (message.result) {</span><span class="s3">\n                        </span><span class="s1">data = `Result: ${stringifyTrace(message.result)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (message.error === undefined) {</span><span class="s3">\n                        </span><span class="s1">data = 'No result returned.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">logLSPMessage('send-response', message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function traceReceivedRequest(message) {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (traceFormat === TraceFormat.Text) {</span><span class="s3">\n            </span><span class="s1">let data = undefined;</span><span class="s3">\n            </span><span class="s1">if ((trace === Trace.Verbose || trace === Trace.Compact) &amp;&amp; message.params) {</span><span class="s3">\n                </span><span class="s1">data = `Params: ${stringifyTrace(message.params)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">tracer.log(`Received request '${message.method} - (${message.id})'.`, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">logLSPMessage('receive-request', message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function traceReceivedNotification(message) {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (traceFormat === TraceFormat.Text) {</span><span class="s3">\n            </span><span class="s1">let data = undefined;</span><span class="s3">\n            </span><span class="s1">if (trace === Trace.Verbose || trace === Trace.Compact) {</span><span class="s3">\n                </span><span class="s1">if (message.params) {</span><span class="s3">\n                    </span><span class="s1">data = `Params: ${stringifyTrace(message.params)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">data = 'No parameters provided.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">tracer.log(`Received notification '${message.method}'.`, data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">logLSPMessage('receive-notification', message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function traceReceivedResponse(message, responsePromise) {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (traceFormat === TraceFormat.Text) {</span><span class="s3">\n            </span><span class="s1">let data = undefined;</span><span class="s3">\n            </span><span class="s1">if (trace === Trace.Verbose || trace === Trace.Compact) {</span><span class="s3">\n                </span><span class="s1">if (message.error &amp;&amp; message.error.data) {</span><span class="s3">\n                    </span><span class="s1">data = `Error data: ${stringifyTrace(message.error.data)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (message.result) {</span><span class="s3">\n                        </span><span class="s1">data = `Result: ${stringifyTrace(message.result)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (message.error === undefined) {</span><span class="s3">\n                        </span><span class="s1">data = 'No result returned.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (responsePromise) {</span><span class="s3">\n                </span><span class="s1">const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';</span><span class="s3">\n                </span><span class="s1">tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">tracer.log(`Received response ${message.id} without active response promise.`, data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">logLSPMessage('receive-response', message);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function logLSPMessage(type, message) {</span><span class="s3">\n        </span><span class="s1">if (!tracer || trace === Trace.Off) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const lspMessage = {</span><span class="s3">\n            </span><span class="s1">isLSPMessage: true,</span><span class="s3">\n            </span><span class="s1">type,</span><span class="s3">\n            </span><span class="s1">message,</span><span class="s3">\n            </span><span class="s1">timestamp: Date.now()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">tracer.log(lspMessage);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function throwIfClosedOrDisposed() {</span><span class="s3">\n        </span><span class="s1">if (isClosed()) {</span><span class="s3">\n            </span><span class="s1">throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isDisposed()) {</span><span class="s3">\n            </span><span class="s1">throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function throwIfListening() {</span><span class="s3">\n        </span><span class="s1">if (isListening()) {</span><span class="s3">\n            </span><span class="s1">throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function throwIfNotListening() {</span><span class="s3">\n        </span><span class="s1">if (!isListening()) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Call listen() first.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function undefinedToNull(param) {</span><span class="s3">\n        </span><span class="s1">if (param === undefined) {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return param;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function nullToUndefined(param) {</span><span class="s3">\n        </span><span class="s1">if (param === null) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return param;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function isNamedParam(param) {</span><span class="s3">\n        </span><span class="s1">return param !== undefined &amp;&amp; param !== null &amp;&amp; !Array.isArray(param) &amp;&amp; typeof param === 'object';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function computeSingleParam(parameterStructures, param) {</span><span class="s3">\n        </span><span class="s1">switch (parameterStructures) {</span><span class="s3">\n            </span><span class="s1">case messages_1.ParameterStructures.auto:</span><span class="s3">\n                </span><span class="s1">if (isNamedParam(param)) {</span><span class="s3">\n                    </span><span class="s1">return nullToUndefined(param);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return [undefinedToNull(param)];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case messages_1.ParameterStructures.byName:</span><span class="s3">\n                </span><span class="s1">if (!isNamedParam(param)) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`Received parameters by name but param is not an object literal.`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return nullToUndefined(param);</span><span class="s3">\n            </span><span class="s1">case messages_1.ParameterStructures.byPosition:</span><span class="s3">\n                </span><span class="s1">return [undefinedToNull(param)];</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function computeMessageParams(type, params) {</span><span class="s3">\n        </span><span class="s1">let result;</span><span class="s3">\n        </span><span class="s1">const numberOfParams = type.numberOfParams;</span><span class="s3">\n        </span><span class="s1">switch (numberOfParams) {</span><span class="s3">\n            </span><span class="s1">case 0:</span><span class="s3">\n                </span><span class="s1">result = undefined;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 1:</span><span class="s3">\n                </span><span class="s1">result = computeSingleParam(type.parameterStructures, params[0]);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">result = [];</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; params.length &amp;&amp; i &lt; numberOfParams; i++) {</span><span class="s3">\n                    </span><span class="s1">result.push(undefinedToNull(params[i]));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (params.length &lt; numberOfParams) {</span><span class="s3">\n                    </span><span class="s1">for (let i = params.length; i &lt; numberOfParams; i++) {</span><span class="s3">\n                        </span><span class="s1">result.push(null);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const connection = {</span><span class="s3">\n        </span><span class="s1">sendNotification: (type, ...args) =&gt; {</span><span class="s3">\n            </span><span class="s1">throwIfClosedOrDisposed();</span><span class="s3">\n            </span><span class="s1">let method;</span><span class="s3">\n            </span><span class="s1">let messageParams;</span><span class="s3">\n            </span><span class="s1">if (Is.string(type)) {</span><span class="s3">\n                </span><span class="s1">method = type;</span><span class="s3">\n                </span><span class="s1">const first = args[0];</span><span class="s3">\n                </span><span class="s1">let paramStart = 0;</span><span class="s3">\n                </span><span class="s1">let parameterStructures = messages_1.ParameterStructures.auto;</span><span class="s3">\n                </span><span class="s1">if (messages_1.ParameterStructures.is(first)) {</span><span class="s3">\n                    </span><span class="s1">paramStart = 1;</span><span class="s3">\n                    </span><span class="s1">parameterStructures = first;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let paramEnd = args.length;</span><span class="s3">\n                </span><span class="s1">const numberOfParams = paramEnd - paramStart;</span><span class="s3">\n                </span><span class="s1">switch (numberOfParams) {</span><span class="s3">\n                    </span><span class="s1">case 0:</span><span class="s3">\n                        </span><span class="s1">messageParams = undefined;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case 1:</span><span class="s3">\n                        </span><span class="s1">messageParams = computeSingleParam(parameterStructures, args[paramStart]);</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">default:</span><span class="s3">\n                        </span><span class="s1">if (parameterStructures === messages_1.ParameterStructures.byName) {</span><span class="s3">\n                            </span><span class="s1">throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">messageParams = args.slice(paramStart, paramEnd).map(value =&gt; undefinedToNull(value));</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const params = args;</span><span class="s3">\n                </span><span class="s1">method = type.method;</span><span class="s3">\n                </span><span class="s1">messageParams = computeMessageParams(type, params);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const notificationMessage = {</span><span class="s3">\n                </span><span class="s1">jsonrpc: version,</span><span class="s3">\n                </span><span class="s1">method: method,</span><span class="s3">\n                </span><span class="s1">params: messageParams</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">traceSendingNotification(notificationMessage);</span><span class="s3">\n            </span><span class="s1">return messageWriter.write(notificationMessage).catch((error) =&gt; {</span><span class="s3">\n                </span><span class="s1">logger.error(`Sending notification failed.`);</span><span class="s3">\n                </span><span class="s1">throw error;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onNotification: (type, handler) =&gt; {</span><span class="s3">\n            </span><span class="s1">throwIfClosedOrDisposed();</span><span class="s3">\n            </span><span class="s1">let method;</span><span class="s3">\n            </span><span class="s1">if (Is.func(type)) {</span><span class="s3">\n                </span><span class="s1">starNotificationHandler = type;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (handler) {</span><span class="s3">\n                </span><span class="s1">if (Is.string(type)) {</span><span class="s3">\n                    </span><span class="s1">method = type;</span><span class="s3">\n                    </span><span class="s1">notificationHandlers.set(type, { type: undefined, handler });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">method = type.method;</span><span class="s3">\n                    </span><span class="s1">notificationHandlers.set(type.method, { type, handler });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (method !== undefined) {</span><span class="s3">\n                        </span><span class="s1">notificationHandlers.delete(method);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">starNotificationHandler = undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onProgress: (_type, token, handler) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (progressHandlers.has(token)) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`Progress handler for token ${token} already registered`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">progressHandlers.set(token, handler);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\n                    </span><span class="s1">progressHandlers.delete(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">sendProgress: (_type, token, value) =&gt; {</span><span class="s3">\n            </span><span class="s1">// This should not await but simple return to ensure that we don't have another</span><span class="s3">\n            </span><span class="s1">// async scheduling. Otherwise one send could overtake another send.</span><span class="s3">\n            </span><span class="s1">return connection.sendNotification(ProgressNotification.type, { token, value });</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onUnhandledProgress: unhandledProgressEmitter.event,</span><span class="s3">\n        </span><span class="s1">sendRequest: (type, ...args) =&gt; {</span><span class="s3">\n            </span><span class="s1">throwIfClosedOrDisposed();</span><span class="s3">\n            </span><span class="s1">throwIfNotListening();</span><span class="s3">\n            </span><span class="s1">let method;</span><span class="s3">\n            </span><span class="s1">let messageParams;</span><span class="s3">\n            </span><span class="s1">let token = undefined;</span><span class="s3">\n            </span><span class="s1">if (Is.string(type)) {</span><span class="s3">\n                </span><span class="s1">method = type;</span><span class="s3">\n                </span><span class="s1">const first = args[0];</span><span class="s3">\n                </span><span class="s1">const last = args[args.length - 1];</span><span class="s3">\n                </span><span class="s1">let paramStart = 0;</span><span class="s3">\n                </span><span class="s1">let parameterStructures = messages_1.ParameterStructures.auto;</span><span class="s3">\n                </span><span class="s1">if (messages_1.ParameterStructures.is(first)) {</span><span class="s3">\n                    </span><span class="s1">paramStart = 1;</span><span class="s3">\n                    </span><span class="s1">parameterStructures = first;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let paramEnd = args.length;</span><span class="s3">\n                </span><span class="s1">if (cancellation_1.CancellationToken.is(last)) {</span><span class="s3">\n                    </span><span class="s1">paramEnd = paramEnd - 1;</span><span class="s3">\n                    </span><span class="s1">token = last;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const numberOfParams = paramEnd - paramStart;</span><span class="s3">\n                </span><span class="s1">switch (numberOfParams) {</span><span class="s3">\n                    </span><span class="s1">case 0:</span><span class="s3">\n                        </span><span class="s1">messageParams = undefined;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case 1:</span><span class="s3">\n                        </span><span class="s1">messageParams = computeSingleParam(parameterStructures, args[paramStart]);</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">default:</span><span class="s3">\n                        </span><span class="s1">if (parameterStructures === messages_1.ParameterStructures.byName) {</span><span class="s3">\n                            </span><span class="s1">throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">messageParams = args.slice(paramStart, paramEnd).map(value =&gt; undefinedToNull(value));</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const params = args;</span><span class="s3">\n                </span><span class="s1">method = type.method;</span><span class="s3">\n                </span><span class="s1">messageParams = computeMessageParams(type, params);</span><span class="s3">\n                </span><span class="s1">const numberOfParams = type.numberOfParams;</span><span class="s3">\n                </span><span class="s1">token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const id = sequenceNumber++;</span><span class="s3">\n            </span><span class="s1">let disposable;</span><span class="s3">\n            </span><span class="s1">if (token) {</span><span class="s3">\n                </span><span class="s1">disposable = token.onCancellationRequested(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">const p = cancellationStrategy.sender.sendCancellation(connection, id);</span><span class="s3">\n                    </span><span class="s1">if (p === undefined) {</span><span class="s3">\n                        </span><span class="s1">logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);</span><span class="s3">\n                        </span><span class="s1">return Promise.resolve();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">return p.catch(() =&gt; {</span><span class="s3">\n                            </span><span class="s1">logger.log(`Sending cancellation messages for id ${id} failed`);</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const requestMessage = {</span><span class="s3">\n                </span><span class="s1">jsonrpc: version,</span><span class="s3">\n                </span><span class="s1">id: id,</span><span class="s3">\n                </span><span class="s1">method: method,</span><span class="s3">\n                </span><span class="s1">params: messageParams</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">traceSendingRequest(requestMessage);</span><span class="s3">\n            </span><span class="s1">if (typeof cancellationStrategy.sender.enableCancellation === 'function') {</span><span class="s3">\n                </span><span class="s1">cancellationStrategy.sender.enableCancellation(requestMessage);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return new Promise(async (resolve, reject) =&gt; {</span><span class="s3">\n                </span><span class="s1">const resolveWithCleanup = (r) =&gt; {</span><span class="s3">\n                    </span><span class="s1">resolve(r);</span><span class="s3">\n                    </span><span class="s1">cancellationStrategy.sender.cleanup(id);</span><span class="s3">\n                    </span><span class="s1">disposable?.dispose();</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">const rejectWithCleanup = (r) =&gt; {</span><span class="s3">\n                    </span><span class="s1">reject(r);</span><span class="s3">\n                    </span><span class="s1">cancellationStrategy.sender.cleanup(id);</span><span class="s3">\n                    </span><span class="s1">disposable?.dispose();</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">await messageWriter.write(requestMessage);</span><span class="s3">\n                    </span><span class="s1">responsePromises.set(id, responsePromise);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (error) {</span><span class="s3">\n                    </span><span class="s1">logger.error(`Sending request failed.`);</span><span class="s3">\n                    </span><span class="s1">// Writing the message failed. So we need to reject the promise.</span><span class="s3">\n                    </span><span class="s1">responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));</span><span class="s3">\n                    </span><span class="s1">throw error;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onRequest: (type, handler) =&gt; {</span><span class="s3">\n            </span><span class="s1">throwIfClosedOrDisposed();</span><span class="s3">\n            </span><span class="s1">let method = null;</span><span class="s3">\n            </span><span class="s1">if (StarRequestHandler.is(type)) {</span><span class="s3">\n                </span><span class="s1">method = undefined;</span><span class="s3">\n                </span><span class="s1">starRequestHandler = type;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (Is.string(type)) {</span><span class="s3">\n                </span><span class="s1">method = null;</span><span class="s3">\n                </span><span class="s1">if (handler !== undefined) {</span><span class="s3">\n                    </span><span class="s1">method = type;</span><span class="s3">\n                    </span><span class="s1">requestHandlers.set(type, { handler: handler, type: undefined });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (handler !== undefined) {</span><span class="s3">\n                    </span><span class="s1">method = type.method;</span><span class="s3">\n                    </span><span class="s1">requestHandlers.set(type.method, { type, handler });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (method === null) {</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (method !== undefined) {</span><span class="s3">\n                        </span><span class="s1">requestHandlers.delete(method);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">starRequestHandler = undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">hasPendingResponse: () =&gt; {</span><span class="s3">\n            </span><span class="s1">return responsePromises.size &gt; 0;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">trace: async (_value, _tracer, sendNotificationOrTraceOptions) =&gt; {</span><span class="s3">\n            </span><span class="s1">let _sendNotification = false;</span><span class="s3">\n            </span><span class="s1">let _traceFormat = TraceFormat.Text;</span><span class="s3">\n            </span><span class="s1">if (sendNotificationOrTraceOptions !== undefined) {</span><span class="s3">\n                </span><span class="s1">if (Is.boolean(sendNotificationOrTraceOptions)) {</span><span class="s3">\n                    </span><span class="s1">_sendNotification = sendNotificationOrTraceOptions;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">_sendNotification = sendNotificationOrTraceOptions.sendNotification || false;</span><span class="s3">\n                    </span><span class="s1">_traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">trace = _value;</span><span class="s3">\n            </span><span class="s1">traceFormat = _traceFormat;</span><span class="s3">\n            </span><span class="s1">if (trace === Trace.Off) {</span><span class="s3">\n                </span><span class="s1">tracer = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">tracer = _tracer;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (_sendNotification &amp;&amp; !isClosed() &amp;&amp; !isDisposed()) {</span><span class="s3">\n                </span><span class="s1">await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onError: errorEmitter.event,</span><span class="s3">\n        </span><span class="s1">onClose: closeEmitter.event,</span><span class="s3">\n        </span><span class="s1">onUnhandledNotification: unhandledNotificationEmitter.event,</span><span class="s3">\n        </span><span class="s1">onDispose: disposeEmitter.event,</span><span class="s3">\n        </span><span class="s1">end: () =&gt; {</span><span class="s3">\n            </span><span class="s1">messageWriter.end();</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (isDisposed()) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">state = ConnectionState.Disposed;</span><span class="s3">\n            </span><span class="s1">disposeEmitter.fire(undefined);</span><span class="s3">\n            </span><span class="s1">const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');</span><span class="s3">\n            </span><span class="s1">for (const promise of responsePromises.values()) {</span><span class="s3">\n                </span><span class="s1">promise.reject(error);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">responsePromises = new Map();</span><span class="s3">\n            </span><span class="s1">requestTokens = new Map();</span><span class="s3">\n            </span><span class="s1">knownCanceledRequests = new Set();</span><span class="s3">\n            </span><span class="s1">messageQueue = new linkedMap_1.LinkedMap();</span><span class="s3">\n            </span><span class="s1">// Test for backwards compatibility</span><span class="s3">\n            </span><span class="s1">if (Is.func(messageWriter.dispose)) {</span><span class="s3">\n                </span><span class="s1">messageWriter.dispose();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (Is.func(messageReader.dispose)) {</span><span class="s3">\n                </span><span class="s1">messageReader.dispose();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">listen: () =&gt; {</span><span class="s3">\n            </span><span class="s1">throwIfClosedOrDisposed();</span><span class="s3">\n            </span><span class="s1">throwIfListening();</span><span class="s3">\n            </span><span class="s1">state = ConnectionState.Listening;</span><span class="s3">\n            </span><span class="s1">messageReader.listen(callback);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">inspect: () =&gt; {</span><span class="s3">\n            </span><span class="s1">// eslint-disable-next-line no-console</span><span class="s3">\n            </span><span class="s1">(0, ral_1.default)().console.log('inspect');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">connection.onNotification(LogTraceNotification.type, (params) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (trace === Trace.Off || !tracer) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const verbose = trace === Trace.Verbose || trace === Trace.Compact;</span><span class="s3">\n        </span><span class="s1">tracer.log(params.message, verbose ? params.verbose : undefined);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">connection.onNotification(ProgressNotification.type, (params) =&gt; {</span><span class="s3">\n        </span><span class="s1">const handler = progressHandlers.get(params.token);</span><span class="s3">\n        </span><span class="s1">if (handler) {</span><span class="s3">\n            </span><span class="s1">handler(params.value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">unhandledProgressEmitter.fire(params);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return connection;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.createMessageConnection = createMessageConnection;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/*---------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">*  Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">*  Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">*--------------------------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.Disposable = void 0;</span><span class="s3">\n</span><span class="s1">var Disposable;</span><span class="s3">\n</span><span class="s1">(function (Disposable) {</span><span class="s3">\n    </span><span class="s1">function create(func) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">dispose: func</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Disposable.create = create;</span><span class="s3">\n</span><span class="s1">})(Disposable || (exports.Disposable = Disposable = {}));</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.Emitter = exports.Event = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Event;</span><span class="s3">\n</span><span class="s1">(function (Event) {</span><span class="s3">\n    </span><span class="s1">const _disposable = { dispose() { } };</span><span class="s3">\n    </span><span class="s1">Event.None = function () { return _disposable; };</span><span class="s3">\n</span><span class="s1">})(Event || (exports.Event = Event = {}));</span><span class="s3">\n</span><span class="s1">class CallbackList {</span><span class="s3">\n    </span><span class="s1">add(callback, context = null, bucket) {</span><span class="s3">\n        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n            </span><span class="s1">this._callbacks = [];</span><span class="s3">\n            </span><span class="s1">this._contexts = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._callbacks.push(callback);</span><span class="s3">\n        </span><span class="s1">this._contexts.push(context);</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(bucket)) {</span><span class="s3">\n            </span><span class="s1">bucket.push({ dispose: () =&gt; this.remove(callback, context) });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(callback, context = null) {</span><span class="s3">\n        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let foundCallbackWithDifferentContext = false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0, len = this._callbacks.length; i &lt; len; i++) {</span><span class="s3">\n            </span><span class="s1">if (this._callbacks[i] === callback) {</span><span class="s3">\n                </span><span class="s1">if (this._contexts[i] === context) {</span><span class="s3">\n                    </span><span class="s1">// callback &amp; context match =&gt; remove it</span><span class="s3">\n                    </span><span class="s1">this._callbacks.splice(i, 1);</span><span class="s3">\n                    </span><span class="s1">this._contexts.splice(i, 1);</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">foundCallbackWithDifferentContext = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (foundCallbackWithDifferentContext) {</span><span class="s3">\n            </span><span class="s1">throw new Error('When adding a listener with a context, you should remove it with the same context');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">invoke(...args) {</span><span class="s3">\n        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);</span><span class="s3">\n        </span><span class="s1">for (let i = 0, len = callbacks.length; i &lt; len; i++) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">ret.push(callbacks[i].apply(contexts[i], args));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">// eslint-disable-next-line no-console</span><span class="s3">\n                </span><span class="s1">(0, ral_1.default)().console.error(e);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ret;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEmpty() {</span><span class="s3">\n        </span><span class="s1">return !this._callbacks || this._callbacks.length === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this._callbacks = undefined;</span><span class="s3">\n        </span><span class="s1">this._contexts = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Emitter {</span><span class="s3">\n    </span><span class="s1">constructor(_options) {</span><span class="s3">\n        </span><span class="s1">this._options = _options;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* For the public to allow to subscribe</span><span class="s3">\n     </span><span class="s1">* to events from this Emitter</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get event() {</span><span class="s3">\n        </span><span class="s1">if (!this._event) {</span><span class="s3">\n            </span><span class="s1">this._event = (listener, thisArgs, disposables) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n                    </span><span class="s1">this._callbacks = new CallbackList();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this._options &amp;&amp; this._options.onFirstListenerAdd &amp;&amp; this._callbacks.isEmpty()) {</span><span class="s3">\n                    </span><span class="s1">this._options.onFirstListenerAdd(this);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this._callbacks.add(listener, thisArgs);</span><span class="s3">\n                </span><span class="s1">const result = {</span><span class="s3">\n                    </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\n                        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n                            </span><span class="s1">// disposable is disposed after emitter is disposed.</span><span class="s3">\n                            </span><span class="s1">return;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">this._callbacks.remove(listener, thisArgs);</span><span class="s3">\n                        </span><span class="s1">result.dispose = Emitter._noop;</span><span class="s3">\n                        </span><span class="s1">if (this._options &amp;&amp; this._options.onLastListenerRemove &amp;&amp; this._callbacks.isEmpty()) {</span><span class="s3">\n                            </span><span class="s1">this._options.onLastListenerRemove(this);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">if (Array.isArray(disposables)) {</span><span class="s3">\n                    </span><span class="s1">disposables.push(result);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* To be kept private to fire an event to</span><span class="s3">\n     </span><span class="s1">* subscribers</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">fire(event) {</span><span class="s3">\n        </span><span class="s1">if (this._callbacks) {</span><span class="s3">\n            </span><span class="s1">this._callbacks.invoke.call(this._callbacks, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this._callbacks) {</span><span class="s3">\n            </span><span class="s1">this._callbacks.dispose();</span><span class="s3">\n            </span><span class="s1">this._callbacks = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Emitter = Emitter;</span><span class="s3">\n</span><span class="s1">Emitter._noop = function () { };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;</span><span class="s3">\n</span><span class="s1">function boolean(value) {</span><span class="s3">\n    </span><span class="s1">return value === true || value === false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.boolean = boolean;</span><span class="s3">\n</span><span class="s1">function string(value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'string' || value instanceof String;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.string = string;</span><span class="s3">\n</span><span class="s1">function number(value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'number' || value instanceof Number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.number = number;</span><span class="s3">\n</span><span class="s1">function error(value) {</span><span class="s3">\n    </span><span class="s1">return value instanceof Error;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.error = error;</span><span class="s3">\n</span><span class="s1">function func(value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'function';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.func = func;</span><span class="s3">\n</span><span class="s1">function array(value) {</span><span class="s3">\n    </span><span class="s1">return Array.isArray(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.array = array;</span><span class="s3">\n</span><span class="s1">function stringArray(value) {</span><span class="s3">\n    </span><span class="s1">return array(value) &amp;&amp; value.every(elem =&gt; string(elem));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.stringArray = stringArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/*---------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">*  Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">*  Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">*--------------------------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">var _a;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;</span><span class="s3">\n</span><span class="s1">var Touch;</span><span class="s3">\n</span><span class="s1">(function (Touch) {</span><span class="s3">\n    </span><span class="s1">Touch.None = 0;</span><span class="s3">\n    </span><span class="s1">Touch.First = 1;</span><span class="s3">\n    </span><span class="s1">Touch.AsOld = Touch.First;</span><span class="s3">\n    </span><span class="s1">Touch.Last = 2;</span><span class="s3">\n    </span><span class="s1">Touch.AsNew = Touch.Last;</span><span class="s3">\n</span><span class="s1">})(Touch || (exports.Touch = Touch = {}));</span><span class="s3">\n</span><span class="s1">class LinkedMap {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this[_a] = 'LinkedMap';</span><span class="s3">\n        </span><span class="s1">this._map = new Map();</span><span class="s3">\n        </span><span class="s1">this._head = undefined;</span><span class="s3">\n        </span><span class="s1">this._tail = undefined;</span><span class="s3">\n        </span><span class="s1">this._size = 0;</span><span class="s3">\n        </span><span class="s1">this._state = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this._map.clear();</span><span class="s3">\n        </span><span class="s1">this._head = undefined;</span><span class="s3">\n        </span><span class="s1">this._tail = undefined;</span><span class="s3">\n        </span><span class="s1">this._size = 0;</span><span class="s3">\n        </span><span class="s1">this._state++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEmpty() {</span><span class="s3">\n        </span><span class="s1">return !this._head &amp;&amp; !this._tail;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get size() {</span><span class="s3">\n        </span><span class="s1">return this._size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get first() {</span><span class="s3">\n        </span><span class="s1">return this._head?.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get last() {</span><span class="s3">\n        </span><span class="s1">return this._tail?.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">has(key) {</span><span class="s3">\n        </span><span class="s1">return this._map.has(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get(key, touch = Touch.None) {</span><span class="s3">\n        </span><span class="s1">const item = this._map.get(key);</span><span class="s3">\n        </span><span class="s1">if (!item) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (touch !== Touch.None) {</span><span class="s3">\n            </span><span class="s1">this.touch(item, touch);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return item.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(key, value, touch = Touch.None) {</span><span class="s3">\n        </span><span class="s1">let item = this._map.get(key);</span><span class="s3">\n        </span><span class="s1">if (item) {</span><span class="s3">\n            </span><span class="s1">item.value = value;</span><span class="s3">\n            </span><span class="s1">if (touch !== Touch.None) {</span><span class="s3">\n                </span><span class="s1">this.touch(item, touch);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">item = { key, value, next: undefined, previous: undefined };</span><span class="s3">\n            </span><span class="s1">switch (touch) {</span><span class="s3">\n                </span><span class="s1">case Touch.None:</span><span class="s3">\n                    </span><span class="s1">this.addItemLast(item);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case Touch.First:</span><span class="s3">\n                    </span><span class="s1">this.addItemFirst(item);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case Touch.Last:</span><span class="s3">\n                    </span><span class="s1">this.addItemLast(item);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                    </span><span class="s1">this.addItemLast(item);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._map.set(key, item);</span><span class="s3">\n            </span><span class="s1">this._size++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete(key) {</span><span class="s3">\n        </span><span class="s1">return !!this.remove(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(key) {</span><span class="s3">\n        </span><span class="s1">const item = this._map.get(key);</span><span class="s3">\n        </span><span class="s1">if (!item) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._map.delete(key);</span><span class="s3">\n        </span><span class="s1">this.removeItem(item);</span><span class="s3">\n        </span><span class="s1">this._size--;</span><span class="s3">\n        </span><span class="s1">return item.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">shift() {</span><span class="s3">\n        </span><span class="s1">if (!this._head &amp;&amp; !this._tail) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this._head || !this._tail) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const item = this._head;</span><span class="s3">\n        </span><span class="s1">this._map.delete(item.key);</span><span class="s3">\n        </span><span class="s1">this.removeItem(item);</span><span class="s3">\n        </span><span class="s1">this._size--;</span><span class="s3">\n        </span><span class="s1">return item.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forEach(callbackfn, thisArg) {</span><span class="s3">\n        </span><span class="s1">const state = this._state;</span><span class="s3">\n        </span><span class="s1">let current = this._head;</span><span class="s3">\n        </span><span class="s1">while (current) {</span><span class="s3">\n            </span><span class="s1">if (thisArg) {</span><span class="s3">\n                </span><span class="s1">callbackfn.bind(thisArg)(current.value, current.key, this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">callbackfn(current.value, current.key, this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this._state !== state) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`LinkedMap got modified during iteration.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">current = current.next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">keys() {</span><span class="s3">\n        </span><span class="s1">const state = this._state;</span><span class="s3">\n        </span><span class="s1">let current = this._head;</span><span class="s3">\n        </span><span class="s1">const iterator = {</span><span class="s3">\n            </span><span class="s1">[Symbol.iterator]: () =&gt; {</span><span class="s3">\n                </span><span class="s1">return iterator;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">next: () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this._state !== state) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`LinkedMap got modified during iteration.`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (current) {</span><span class="s3">\n                    </span><span class="s1">const result = { value: current.key, done: false };</span><span class="s3">\n                    </span><span class="s1">current = current.next;</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return { value: undefined, done: true };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return iterator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">values() {</span><span class="s3">\n        </span><span class="s1">const state = this._state;</span><span class="s3">\n        </span><span class="s1">let current = this._head;</span><span class="s3">\n        </span><span class="s1">const iterator = {</span><span class="s3">\n            </span><span class="s1">[Symbol.iterator]: () =&gt; {</span><span class="s3">\n                </span><span class="s1">return iterator;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">next: () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this._state !== state) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`LinkedMap got modified during iteration.`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (current) {</span><span class="s3">\n                    </span><span class="s1">const result = { value: current.value, done: false };</span><span class="s3">\n                    </span><span class="s1">current = current.next;</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return { value: undefined, done: true };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return iterator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">entries() {</span><span class="s3">\n        </span><span class="s1">const state = this._state;</span><span class="s3">\n        </span><span class="s1">let current = this._head;</span><span class="s3">\n        </span><span class="s1">const iterator = {</span><span class="s3">\n            </span><span class="s1">[Symbol.iterator]: () =&gt; {</span><span class="s3">\n                </span><span class="s1">return iterator;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">next: () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this._state !== state) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`LinkedMap got modified during iteration.`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (current) {</span><span class="s3">\n                    </span><span class="s1">const result = { value: [current.key, current.value], done: false };</span><span class="s3">\n                    </span><span class="s1">current = current.next;</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return { value: undefined, done: true };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return iterator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">[(_a = Symbol.toStringTag, Symbol.iterator)]() {</span><span class="s3">\n        </span><span class="s1">return this.entries();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">trimOld(newSize) {</span><span class="s3">\n        </span><span class="s1">if (newSize &gt;= this.size) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (newSize === 0) {</span><span class="s3">\n            </span><span class="s1">this.clear();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let current = this._head;</span><span class="s3">\n        </span><span class="s1">let currentSize = this.size;</span><span class="s3">\n        </span><span class="s1">while (current &amp;&amp; currentSize &gt; newSize) {</span><span class="s3">\n            </span><span class="s1">this._map.delete(current.key);</span><span class="s3">\n            </span><span class="s1">current = current.next;</span><span class="s3">\n            </span><span class="s1">currentSize--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._head = current;</span><span class="s3">\n        </span><span class="s1">this._size = currentSize;</span><span class="s3">\n        </span><span class="s1">if (current) {</span><span class="s3">\n            </span><span class="s1">current.previous = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._state++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addItemFirst(item) {</span><span class="s3">\n        </span><span class="s1">// First time Insert</span><span class="s3">\n        </span><span class="s1">if (!this._head &amp;&amp; !this._tail) {</span><span class="s3">\n            </span><span class="s1">this._tail = item;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!this._head) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">item.next = this._head;</span><span class="s3">\n            </span><span class="s1">this._head.previous = item;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._head = item;</span><span class="s3">\n        </span><span class="s1">this._state++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addItemLast(item) {</span><span class="s3">\n        </span><span class="s1">// First time Insert</span><span class="s3">\n        </span><span class="s1">if (!this._head &amp;&amp; !this._tail) {</span><span class="s3">\n            </span><span class="s1">this._head = item;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!this._tail) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">item.previous = this._tail;</span><span class="s3">\n            </span><span class="s1">this._tail.next = item;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._tail = item;</span><span class="s3">\n        </span><span class="s1">this._state++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeItem(item) {</span><span class="s3">\n        </span><span class="s1">if (item === this._head &amp;&amp; item === this._tail) {</span><span class="s3">\n            </span><span class="s1">this._head = undefined;</span><span class="s3">\n            </span><span class="s1">this._tail = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (item === this._head) {</span><span class="s3">\n            </span><span class="s1">// This can only happened if size === 1 which is handle</span><span class="s3">\n            </span><span class="s1">// by the case above.</span><span class="s3">\n            </span><span class="s1">if (!item.next) {</span><span class="s3">\n                </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">item.next.previous = undefined;</span><span class="s3">\n            </span><span class="s1">this._head = item.next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (item === this._tail) {</span><span class="s3">\n            </span><span class="s1">// This can only happened if size === 1 which is handle</span><span class="s3">\n            </span><span class="s1">// by the case above.</span><span class="s3">\n            </span><span class="s1">if (!item.previous) {</span><span class="s3">\n                </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">item.previous.next = undefined;</span><span class="s3">\n            </span><span class="s1">this._tail = item.previous;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const next = item.next;</span><span class="s3">\n            </span><span class="s1">const previous = item.previous;</span><span class="s3">\n            </span><span class="s1">if (!next || !previous) {</span><span class="s3">\n                </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next.previous = previous;</span><span class="s3">\n            </span><span class="s1">previous.next = next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">item.next = undefined;</span><span class="s3">\n        </span><span class="s1">item.previous = undefined;</span><span class="s3">\n        </span><span class="s1">this._state++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">touch(item, touch) {</span><span class="s3">\n        </span><span class="s1">if (!this._head || !this._tail) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid list');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if ((touch !== Touch.First &amp;&amp; touch !== Touch.Last)) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (touch === Touch.First) {</span><span class="s3">\n            </span><span class="s1">if (item === this._head) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const next = item.next;</span><span class="s3">\n            </span><span class="s1">const previous = item.previous;</span><span class="s3">\n            </span><span class="s1">// Unlink the item</span><span class="s3">\n            </span><span class="s1">if (item === this._tail) {</span><span class="s3">\n                </span><span class="s1">// previous must be defined since item was not head but is tail</span><span class="s3">\n                </span><span class="s1">// So there are more than on item in the map</span><span class="s3">\n                </span><span class="s1">previous.next = undefined;</span><span class="s3">\n                </span><span class="s1">this._tail = previous;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// Both next and previous are not undefined since item was neither head nor tail.</span><span class="s3">\n                </span><span class="s1">next.previous = previous;</span><span class="s3">\n                </span><span class="s1">previous.next = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Insert the node at head</span><span class="s3">\n            </span><span class="s1">item.previous = undefined;</span><span class="s3">\n            </span><span class="s1">item.next = this._head;</span><span class="s3">\n            </span><span class="s1">this._head.previous = item;</span><span class="s3">\n            </span><span class="s1">this._head = item;</span><span class="s3">\n            </span><span class="s1">this._state++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (touch === Touch.Last) {</span><span class="s3">\n            </span><span class="s1">if (item === this._tail) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const next = item.next;</span><span class="s3">\n            </span><span class="s1">const previous = item.previous;</span><span class="s3">\n            </span><span class="s1">// Unlink the item.</span><span class="s3">\n            </span><span class="s1">if (item === this._head) {</span><span class="s3">\n                </span><span class="s1">// next must be defined since item was not tail but is head</span><span class="s3">\n                </span><span class="s1">// So there are more than on item in the map</span><span class="s3">\n                </span><span class="s1">next.previous = undefined;</span><span class="s3">\n                </span><span class="s1">this._head = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// Both next and previous are not undefined since item was neither head nor tail.</span><span class="s3">\n                </span><span class="s1">next.previous = previous;</span><span class="s3">\n                </span><span class="s1">previous.next = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">item.next = undefined;</span><span class="s3">\n            </span><span class="s1">item.previous = this._tail;</span><span class="s3">\n            </span><span class="s1">this._tail.next = item;</span><span class="s3">\n            </span><span class="s1">this._tail = item;</span><span class="s3">\n            </span><span class="s1">this._state++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">const data = [];</span><span class="s3">\n        </span><span class="s1">this.forEach((value, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">data.push([key, value]);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return data;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fromJSON(data) {</span><span class="s3">\n        </span><span class="s1">this.clear();</span><span class="s3">\n        </span><span class="s1">for (const [key, value] of data) {</span><span class="s3">\n            </span><span class="s1">this.set(key, value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.LinkedMap = LinkedMap;</span><span class="s3">\n</span><span class="s1">class LRUCache extends LinkedMap {</span><span class="s3">\n    </span><span class="s1">constructor(limit, ratio = 1) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._limit = limit;</span><span class="s3">\n        </span><span class="s1">this._ratio = Math.min(Math.max(0, ratio), 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get limit() {</span><span class="s3">\n        </span><span class="s1">return this._limit;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set limit(limit) {</span><span class="s3">\n        </span><span class="s1">this._limit = limit;</span><span class="s3">\n        </span><span class="s1">this.checkTrim();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get ratio() {</span><span class="s3">\n        </span><span class="s1">return this._ratio;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set ratio(ratio) {</span><span class="s3">\n        </span><span class="s1">this._ratio = Math.min(Math.max(0, ratio), 1);</span><span class="s3">\n        </span><span class="s1">this.checkTrim();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get(key, touch = Touch.AsNew) {</span><span class="s3">\n        </span><span class="s1">return super.get(key, touch);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">peek(key) {</span><span class="s3">\n        </span><span class="s1">return super.get(key, Touch.None);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(key, value) {</span><span class="s3">\n        </span><span class="s1">super.set(key, value, Touch.Last);</span><span class="s3">\n        </span><span class="s1">this.checkTrim();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkTrim() {</span><span class="s3">\n        </span><span class="s1">if (this.size &gt; this._limit) {</span><span class="s3">\n            </span><span class="s1">this.trimOld(Math.round(this._limit * this._ratio));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.LRUCache = LRUCache;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/*---------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">*  Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">*  Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">*--------------------------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.AbstractMessageBuffer = void 0;</span><span class="s3">\n</span><span class="s1">const CR = 13;</span><span class="s3">\n</span><span class="s1">const LF = 10;</span><span class="s3">\n</span><span class="s1">const CRLF = '</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n</span><span class="s1">class AbstractMessageBuffer {</span><span class="s3">\n    </span><span class="s1">constructor(encoding = 'utf-8') {</span><span class="s3">\n        </span><span class="s1">this._encoding = encoding;</span><span class="s3">\n        </span><span class="s1">this._chunks = [];</span><span class="s3">\n        </span><span class="s1">this._totalLength = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get encoding() {</span><span class="s3">\n        </span><span class="s1">return this._encoding;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">append(chunk) {</span><span class="s3">\n        </span><span class="s1">const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;</span><span class="s3">\n        </span><span class="s1">this._chunks.push(toAppend);</span><span class="s3">\n        </span><span class="s1">this._totalLength += toAppend.byteLength;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tryReadHeaders(lowerCaseKeys = false) {</span><span class="s3">\n        </span><span class="s1">if (this._chunks.length === 0) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let state = 0;</span><span class="s3">\n        </span><span class="s1">let chunkIndex = 0;</span><span class="s3">\n        </span><span class="s1">let offset = 0;</span><span class="s3">\n        </span><span class="s1">let chunkBytesRead = 0;</span><span class="s3">\n        </span><span class="s1">row: while (chunkIndex &lt; this._chunks.length) {</span><span class="s3">\n            </span><span class="s1">const chunk = this._chunks[chunkIndex];</span><span class="s3">\n            </span><span class="s1">offset = 0;</span><span class="s3">\n            </span><span class="s1">column: while (offset &lt; chunk.length) {</span><span class="s3">\n                </span><span class="s1">const value = chunk[offset];</span><span class="s3">\n                </span><span class="s1">switch (value) {</span><span class="s3">\n                    </span><span class="s1">case CR:</span><span class="s3">\n                        </span><span class="s1">switch (state) {</span><span class="s3">\n                            </span><span class="s1">case 0:</span><span class="s3">\n                                </span><span class="s1">state = 1;</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">case 2:</span><span class="s3">\n                                </span><span class="s1">state = 3;</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">default:</span><span class="s3">\n                                </span><span class="s1">state = 0;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case LF:</span><span class="s3">\n                        </span><span class="s1">switch (state) {</span><span class="s3">\n                            </span><span class="s1">case 1:</span><span class="s3">\n                                </span><span class="s1">state = 2;</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">case 3:</span><span class="s3">\n                                </span><span class="s1">state = 4;</span><span class="s3">\n                                </span><span class="s1">offset++;</span><span class="s3">\n                                </span><span class="s1">break row;</span><span class="s3">\n                            </span><span class="s1">default:</span><span class="s3">\n                                </span><span class="s1">state = 0;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">default:</span><span class="s3">\n                        </span><span class="s1">state = 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">offset++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">chunkBytesRead += chunk.byteLength;</span><span class="s3">\n            </span><span class="s1">chunkIndex++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (state !== 4) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The buffer contains the two CRLF at the end. So we will</span><span class="s3">\n        </span><span class="s1">// have two empty lines after the split at the end as well.</span><span class="s3">\n        </span><span class="s1">const buffer = this._read(chunkBytesRead + offset);</span><span class="s3">\n        </span><span class="s1">const result = new Map();</span><span class="s3">\n        </span><span class="s1">const headers = this.toString(buffer, 'ascii').split(CRLF);</span><span class="s3">\n        </span><span class="s1">if (headers.length &lt; 2) {</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; headers.length - 2; i++) {</span><span class="s3">\n            </span><span class="s1">const header = headers[i];</span><span class="s3">\n            </span><span class="s1">const index = header.indexOf(':');</span><span class="s3">\n            </span><span class="s1">if (index === -1) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`Message header must separate key and value using ':'</span><span class="s3">\\</span><span class="s1">n${header}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const key = header.substr(0, index);</span><span class="s3">\n            </span><span class="s1">const value = header.substr(index + 1).trim();</span><span class="s3">\n            </span><span class="s1">result.set(lowerCaseKeys ? key.toLowerCase() : key, value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tryReadBody(length) {</span><span class="s3">\n        </span><span class="s1">if (this._totalLength &lt; length) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._read(length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get numberOfBytes() {</span><span class="s3">\n        </span><span class="s1">return this._totalLength;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_read(byteCount) {</span><span class="s3">\n        </span><span class="s1">if (byteCount === 0) {</span><span class="s3">\n            </span><span class="s1">return this.emptyBuffer();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (byteCount &gt; this._totalLength) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`Cannot read so many bytes!`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._chunks[0].byteLength === byteCount) {</span><span class="s3">\n            </span><span class="s1">// super fast path, precisely first chunk must be returned</span><span class="s3">\n            </span><span class="s1">const chunk = this._chunks[0];</span><span class="s3">\n            </span><span class="s1">this._chunks.shift();</span><span class="s3">\n            </span><span class="s1">this._totalLength -= byteCount;</span><span class="s3">\n            </span><span class="s1">return this.asNative(chunk);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._chunks[0].byteLength &gt; byteCount) {</span><span class="s3">\n            </span><span class="s1">// fast path, the reading is entirely within the first chunk</span><span class="s3">\n            </span><span class="s1">const chunk = this._chunks[0];</span><span class="s3">\n            </span><span class="s1">const result = this.asNative(chunk, byteCount);</span><span class="s3">\n            </span><span class="s1">this._chunks[0] = chunk.slice(byteCount);</span><span class="s3">\n            </span><span class="s1">this._totalLength -= byteCount;</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const result = this.allocNative(byteCount);</span><span class="s3">\n        </span><span class="s1">let resultOffset = 0;</span><span class="s3">\n        </span><span class="s1">let chunkIndex = 0;</span><span class="s3">\n        </span><span class="s1">while (byteCount &gt; 0) {</span><span class="s3">\n            </span><span class="s1">const chunk = this._chunks[chunkIndex];</span><span class="s3">\n            </span><span class="s1">if (chunk.byteLength &gt; byteCount) {</span><span class="s3">\n                </span><span class="s1">// this chunk will survive</span><span class="s3">\n                </span><span class="s1">const chunkPart = chunk.slice(0, byteCount);</span><span class="s3">\n                </span><span class="s1">result.set(chunkPart, resultOffset);</span><span class="s3">\n                </span><span class="s1">resultOffset += byteCount;</span><span class="s3">\n                </span><span class="s1">this._chunks[chunkIndex] = chunk.slice(byteCount);</span><span class="s3">\n                </span><span class="s1">this._totalLength -= byteCount;</span><span class="s3">\n                </span><span class="s1">byteCount -= byteCount;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// this chunk will be entirely read</span><span class="s3">\n                </span><span class="s1">result.set(chunk, resultOffset);</span><span class="s3">\n                </span><span class="s1">resultOffset += chunk.byteLength;</span><span class="s3">\n                </span><span class="s1">this._chunks.shift();</span><span class="s3">\n                </span><span class="s1">this._totalLength -= chunk.byteLength;</span><span class="s3">\n                </span><span class="s1">byteCount -= chunk.byteLength;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.AbstractMessageBuffer = AbstractMessageBuffer;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const Is = require(</span><span class="s3">\&quot;</span><span class="s1">./is</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const events_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./events</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const semaphore_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./semaphore</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var MessageReader;</span><span class="s3">\n</span><span class="s1">(function (MessageReader) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.func(candidate.listen) &amp;&amp; Is.func(candidate.dispose) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Is.func(candidate.onError) &amp;&amp; Is.func(candidate.onClose) &amp;&amp; Is.func(candidate.onPartialMessage);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MessageReader.is = is;</span><span class="s3">\n</span><span class="s1">})(MessageReader || (exports.MessageReader = MessageReader = {}));</span><span class="s3">\n</span><span class="s1">class AbstractMessageReader {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.errorEmitter = new events_1.Emitter();</span><span class="s3">\n        </span><span class="s1">this.closeEmitter = new events_1.Emitter();</span><span class="s3">\n        </span><span class="s1">this.partialMessageEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this.errorEmitter.dispose();</span><span class="s3">\n        </span><span class="s1">this.closeEmitter.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onError() {</span><span class="s3">\n        </span><span class="s1">return this.errorEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fireError(error) {</span><span class="s3">\n        </span><span class="s1">this.errorEmitter.fire(this.asError(error));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onClose() {</span><span class="s3">\n        </span><span class="s1">return this.closeEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fireClose() {</span><span class="s3">\n        </span><span class="s1">this.closeEmitter.fire(undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onPartialMessage() {</span><span class="s3">\n        </span><span class="s1">return this.partialMessageEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">firePartialMessage(info) {</span><span class="s3">\n        </span><span class="s1">this.partialMessageEmitter.fire(info);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">asError(error) {</span><span class="s3">\n        </span><span class="s1">if (error instanceof Error) {</span><span class="s3">\n            </span><span class="s1">return error;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.AbstractMessageReader = AbstractMessageReader;</span><span class="s3">\n</span><span class="s1">var ResolvedMessageReaderOptions;</span><span class="s3">\n</span><span class="s1">(function (ResolvedMessageReaderOptions) {</span><span class="s3">\n    </span><span class="s1">function fromOptions(options) {</span><span class="s3">\n        </span><span class="s1">let charset;</span><span class="s3">\n        </span><span class="s1">let result;</span><span class="s3">\n        </span><span class="s1">let contentDecoder;</span><span class="s3">\n        </span><span class="s1">const contentDecoders = new Map();</span><span class="s3">\n        </span><span class="s1">let contentTypeDecoder;</span><span class="s3">\n        </span><span class="s1">const contentTypeDecoders = new Map();</span><span class="s3">\n        </span><span class="s1">if (options === undefined || typeof options === 'string') {</span><span class="s3">\n            </span><span class="s1">charset = options ?? 'utf-8';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">charset = options.charset ?? 'utf-8';</span><span class="s3">\n            </span><span class="s1">if (options.contentDecoder !== undefined) {</span><span class="s3">\n                </span><span class="s1">contentDecoder = options.contentDecoder;</span><span class="s3">\n                </span><span class="s1">contentDecoders.set(contentDecoder.name, contentDecoder);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (options.contentDecoders !== undefined) {</span><span class="s3">\n                </span><span class="s1">for (const decoder of options.contentDecoders) {</span><span class="s3">\n                    </span><span class="s1">contentDecoders.set(decoder.name, decoder);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (options.contentTypeDecoder !== undefined) {</span><span class="s3">\n                </span><span class="s1">contentTypeDecoder = options.contentTypeDecoder;</span><span class="s3">\n                </span><span class="s1">contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (options.contentTypeDecoders !== undefined) {</span><span class="s3">\n                </span><span class="s1">for (const decoder of options.contentTypeDecoders) {</span><span class="s3">\n                    </span><span class="s1">contentTypeDecoders.set(decoder.name, decoder);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (contentTypeDecoder === undefined) {</span><span class="s3">\n            </span><span class="s1">contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;</span><span class="s3">\n            </span><span class="s1">contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ResolvedMessageReaderOptions.fromOptions = fromOptions;</span><span class="s3">\n</span><span class="s1">})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));</span><span class="s3">\n</span><span class="s1">class ReadableStreamMessageReader extends AbstractMessageReader {</span><span class="s3">\n    </span><span class="s1">constructor(readable, options) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.readable = readable;</span><span class="s3">\n        </span><span class="s1">this.options = ResolvedMessageReaderOptions.fromOptions(options);</span><span class="s3">\n        </span><span class="s1">this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);</span><span class="s3">\n        </span><span class="s1">this._partialMessageTimeout = 10000;</span><span class="s3">\n        </span><span class="s1">this.nextMessageLength = -1;</span><span class="s3">\n        </span><span class="s1">this.messageToken = 0;</span><span class="s3">\n        </span><span class="s1">this.readSemaphore = new semaphore_1.Semaphore(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set partialMessageTimeout(timeout) {</span><span class="s3">\n        </span><span class="s1">this._partialMessageTimeout = timeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get partialMessageTimeout() {</span><span class="s3">\n        </span><span class="s1">return this._partialMessageTimeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">listen(callback) {</span><span class="s3">\n        </span><span class="s1">this.nextMessageLength = -1;</span><span class="s3">\n        </span><span class="s1">this.messageToken = 0;</span><span class="s3">\n        </span><span class="s1">this.partialMessageTimer = undefined;</span><span class="s3">\n        </span><span class="s1">this.callback = callback;</span><span class="s3">\n        </span><span class="s1">const result = this.readable.onData((data) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.onData(data);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.readable.onError((error) =&gt; this.fireError(error));</span><span class="s3">\n        </span><span class="s1">this.readable.onClose(() =&gt; this.fireClose());</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onData(data) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">this.buffer.append(data);</span><span class="s3">\n            </span><span class="s1">while (true) {</span><span class="s3">\n                </span><span class="s1">if (this.nextMessageLength === -1) {</span><span class="s3">\n                    </span><span class="s1">const headers = this.buffer.tryReadHeaders(true);</span><span class="s3">\n                    </span><span class="s1">if (!headers) {</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const contentLength = headers.get('content-length');</span><span class="s3">\n                    </span><span class="s1">if (!contentLength) {</span><span class="s3">\n                        </span><span class="s1">this.fireError(new Error(`Header must provide a Content-Length property.</span><span class="s3">\\</span><span class="s1">n${JSON.stringify(Object.fromEntries(headers))}`));</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const length = parseInt(contentLength);</span><span class="s3">\n                    </span><span class="s1">if (isNaN(length)) {</span><span class="s3">\n                        </span><span class="s1">this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">this.nextMessageLength = length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const body = this.buffer.tryReadBody(this.nextMessageLength);</span><span class="s3">\n                </span><span class="s1">if (body === undefined) {</span><span class="s3">\n                    </span><span class="s1">/** We haven't received the full message yet. */</span><span class="s3">\n                    </span><span class="s1">this.setPartialMessageTimer();</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.clearPartialMessageTimer();</span><span class="s3">\n                </span><span class="s1">this.nextMessageLength = -1;</span><span class="s3">\n                </span><span class="s1">// Make sure that we convert one received message after the</span><span class="s3">\n                </span><span class="s1">// other. Otherwise it could happen that a decoding of a second</span><span class="s3">\n                </span><span class="s1">// smaller message finished before the decoding of a first larger</span><span class="s3">\n                </span><span class="s1">// message and then we would deliver the second message first.</span><span class="s3">\n                </span><span class="s1">this.readSemaphore.lock(async () =&gt; {</span><span class="s3">\n                    </span><span class="s1">const bytes = this.options.contentDecoder !== undefined</span><span class="s3">\n                        </span><span class="s1">? await this.options.contentDecoder.decode(body)</span><span class="s3">\n                        </span><span class="s1">: body;</span><span class="s3">\n                    </span><span class="s1">const message = await this.options.contentTypeDecoder.decode(bytes, this.options);</span><span class="s3">\n                    </span><span class="s1">this.callback(message);</span><span class="s3">\n                </span><span class="s1">}).catch((error) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.fireError(error);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (error) {</span><span class="s3">\n            </span><span class="s1">this.fireError(error);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clearPartialMessageTimer() {</span><span class="s3">\n        </span><span class="s1">if (this.partialMessageTimer) {</span><span class="s3">\n            </span><span class="s1">this.partialMessageTimer.dispose();</span><span class="s3">\n            </span><span class="s1">this.partialMessageTimer = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setPartialMessageTimer() {</span><span class="s3">\n        </span><span class="s1">this.clearPartialMessageTimer();</span><span class="s3">\n        </span><span class="s1">if (this._partialMessageTimeout &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.partialMessageTimer = undefined;</span><span class="s3">\n            </span><span class="s1">if (token === this.messageToken) {</span><span class="s3">\n                </span><span class="s1">this.firePartialMessage({ messageToken: token, waitingTime: timeout });</span><span class="s3">\n                </span><span class="s1">this.setPartialMessageTimer();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ReadableStreamMessageReader = ReadableStreamMessageReader;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const Is = require(</span><span class="s3">\&quot;</span><span class="s1">./is</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const semaphore_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./semaphore</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const events_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./events</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const ContentLength = 'Content-Length: ';</span><span class="s3">\n</span><span class="s1">const CRLF = '</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n</span><span class="s1">var MessageWriter;</span><span class="s3">\n</span><span class="s1">(function (MessageWriter) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.func(candidate.dispose) &amp;&amp; Is.func(candidate.onClose) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Is.func(candidate.onError) &amp;&amp; Is.func(candidate.write);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MessageWriter.is = is;</span><span class="s3">\n</span><span class="s1">})(MessageWriter || (exports.MessageWriter = MessageWriter = {}));</span><span class="s3">\n</span><span class="s1">class AbstractMessageWriter {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.errorEmitter = new events_1.Emitter();</span><span class="s3">\n        </span><span class="s1">this.closeEmitter = new events_1.Emitter();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this.errorEmitter.dispose();</span><span class="s3">\n        </span><span class="s1">this.closeEmitter.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onError() {</span><span class="s3">\n        </span><span class="s1">return this.errorEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fireError(error, message, count) {</span><span class="s3">\n        </span><span class="s1">this.errorEmitter.fire([this.asError(error), message, count]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onClose() {</span><span class="s3">\n        </span><span class="s1">return this.closeEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fireClose() {</span><span class="s3">\n        </span><span class="s1">this.closeEmitter.fire(undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">asError(error) {</span><span class="s3">\n        </span><span class="s1">if (error instanceof Error) {</span><span class="s3">\n            </span><span class="s1">return error;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.AbstractMessageWriter = AbstractMessageWriter;</span><span class="s3">\n</span><span class="s1">var ResolvedMessageWriterOptions;</span><span class="s3">\n</span><span class="s1">(function (ResolvedMessageWriterOptions) {</span><span class="s3">\n    </span><span class="s1">function fromOptions(options) {</span><span class="s3">\n        </span><span class="s1">if (options === undefined || typeof options === 'string') {</span><span class="s3">\n            </span><span class="s1">return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ResolvedMessageWriterOptions.fromOptions = fromOptions;</span><span class="s3">\n</span><span class="s1">})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));</span><span class="s3">\n</span><span class="s1">class WriteableStreamMessageWriter extends AbstractMessageWriter {</span><span class="s3">\n    </span><span class="s1">constructor(writable, options) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.writable = writable;</span><span class="s3">\n        </span><span class="s1">this.options = ResolvedMessageWriterOptions.fromOptions(options);</span><span class="s3">\n        </span><span class="s1">this.errorCount = 0;</span><span class="s3">\n        </span><span class="s1">this.writeSemaphore = new semaphore_1.Semaphore(1);</span><span class="s3">\n        </span><span class="s1">this.writable.onError((error) =&gt; this.fireError(error));</span><span class="s3">\n        </span><span class="s1">this.writable.onClose(() =&gt; this.fireClose());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async write(msg) {</span><span class="s3">\n        </span><span class="s1">return this.writeSemaphore.lock(async () =&gt; {</span><span class="s3">\n            </span><span class="s1">const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.options.contentEncoder !== undefined) {</span><span class="s3">\n                    </span><span class="s1">return this.options.contentEncoder.encode(buffer);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return buffer;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return payload.then((buffer) =&gt; {</span><span class="s3">\n                </span><span class="s1">const headers = [];</span><span class="s3">\n                </span><span class="s1">headers.push(ContentLength, buffer.byteLength.toString(), CRLF);</span><span class="s3">\n                </span><span class="s1">headers.push(CRLF);</span><span class="s3">\n                </span><span class="s1">return this.doWrite(msg, headers, buffer);</span><span class="s3">\n            </span><span class="s1">}, (error) =&gt; {</span><span class="s3">\n                </span><span class="s1">this.fireError(error);</span><span class="s3">\n                </span><span class="s1">throw error;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async doWrite(msg, headers, data) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">await this.writable.write(headers.join(''), 'ascii');</span><span class="s3">\n            </span><span class="s1">return this.writable.write(data);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (error) {</span><span class="s3">\n            </span><span class="s1">this.handleError(error, msg);</span><span class="s3">\n            </span><span class="s1">return Promise.reject(error);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">handleError(error, msg) {</span><span class="s3">\n        </span><span class="s1">this.errorCount++;</span><span class="s3">\n        </span><span class="s1">this.fireError(error, msg, this.errorCount);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">end() {</span><span class="s3">\n        </span><span class="s1">this.writable.end();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;</span><span class="s3">\n</span><span class="s1">const is = require(</span><span class="s3">\&quot;</span><span class="s1">./is</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Predefined error codes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var ErrorCodes;</span><span class="s3">\n</span><span class="s1">(function (ErrorCodes) {</span><span class="s3">\n    </span><span class="s1">// Defined by JSON RPC</span><span class="s3">\n    </span><span class="s1">ErrorCodes.ParseError = -32700;</span><span class="s3">\n    </span><span class="s1">ErrorCodes.InvalidRequest = -32600;</span><span class="s3">\n    </span><span class="s1">ErrorCodes.MethodNotFound = -32601;</span><span class="s3">\n    </span><span class="s1">ErrorCodes.InvalidParams = -32602;</span><span class="s3">\n    </span><span class="s1">ErrorCodes.InternalError = -32603;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This is the start range of JSON RPC reserved error codes.</span><span class="s3">\n     </span><span class="s1">* It doesn't denote a real error code. No application error codes should</span><span class="s3">\n     </span><span class="s1">* be defined between the start and end range. For backwards</span><span class="s3">\n     </span><span class="s1">* compatibility the `ServerNotInitialized` and the `UnknownErrorCode`</span><span class="s3">\n     </span><span class="s1">* are left in the range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @since 3.16.0</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;</span><span class="s3">\n    </span><span class="s1">/** @deprecated use  jsonrpcReservedErrorRangeStart */</span><span class="s3">\n    </span><span class="s1">ErrorCodes.serverErrorStart = -32099;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* An error occurred when write a message to the transport layer.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.MessageWriteError = -32099;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* An error occurred when reading a message from the transport layer.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.MessageReadError = -32098;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The connection got disposed or lost and all pending responses got</span><span class="s3">\n     </span><span class="s1">* rejected.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.PendingResponseRejected = -32097;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The connection is inactive and a use of it failed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.ConnectionInactive = -32096;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Error code indicating that a server received a notification or</span><span class="s3">\n     </span><span class="s1">* request before the server has received the `initialize` request.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.ServerNotInitialized = -32002;</span><span class="s3">\n    </span><span class="s1">ErrorCodes.UnknownErrorCode = -32001;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This is the end range of JSON RPC reserved error codes.</span><span class="s3">\n     </span><span class="s1">* It doesn't denote a real error code.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @since 3.16.0</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;</span><span class="s3">\n    </span><span class="s1">/** @deprecated use  jsonrpcReservedErrorRangeEnd */</span><span class="s3">\n    </span><span class="s1">ErrorCodes.serverErrorEnd = -32000;</span><span class="s3">\n</span><span class="s1">})(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An error object return in a response in case a request</span><span class="s3">\n </span><span class="s1">* has failed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ResponseError extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(code, message, data) {</span><span class="s3">\n        </span><span class="s1">super(message);</span><span class="s3">\n        </span><span class="s1">this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;</span><span class="s3">\n        </span><span class="s1">this.data = data;</span><span class="s3">\n        </span><span class="s1">Object.setPrototypeOf(this, ResponseError.prototype);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toJson() {</span><span class="s3">\n        </span><span class="s1">const result = {</span><span class="s3">\n            </span><span class="s1">code: this.code,</span><span class="s3">\n            </span><span class="s1">message: this.message</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.data !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.data = this.data;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ResponseError = ResponseError;</span><span class="s3">\n</span><span class="s1">class ParameterStructures {</span><span class="s3">\n    </span><span class="s1">constructor(kind) {</span><span class="s3">\n        </span><span class="s1">this.kind = kind;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static is(value) {</span><span class="s3">\n        </span><span class="s1">return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.kind;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ParameterStructures = ParameterStructures;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The parameter structure is automatically inferred on the number of parameters</span><span class="s3">\n </span><span class="s1">* and the parameter type in case of a single param.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ParameterStructures.auto = new ParameterStructures('auto');</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Forces `byPosition` parameter structure. This is useful if you have a single</span><span class="s3">\n </span><span class="s1">* parameter which has a literal type.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ParameterStructures.byPosition = new ParameterStructures('byPosition');</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Forces `byName` parameter structure. This is only useful when having a single</span><span class="s3">\n </span><span class="s1">* parameter. The library will report errors if used with a different number of</span><span class="s3">\n </span><span class="s1">* parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ParameterStructures.byName = new ParameterStructures('byName');</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An abstract implementation of a MessageType.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method, numberOfParams) {</span><span class="s3">\n        </span><span class="s1">this.method = method;</span><span class="s3">\n        </span><span class="s1">this.numberOfParams = numberOfParams;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parameterStructures() {</span><span class="s3">\n        </span><span class="s1">return ParameterStructures.auto;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.AbstractMessageSignature = AbstractMessageSignature;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Classes to type request response pairs</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RequestType0 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType0 = RequestType0;</span><span class="s3">\n</span><span class="s1">class RequestType extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method, _parameterStructures = ParameterStructures.auto) {</span><span class="s3">\n        </span><span class="s1">super(method, 1);</span><span class="s3">\n        </span><span class="s1">this._parameterStructures = _parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parameterStructures() {</span><span class="s3">\n        </span><span class="s1">return this._parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType = RequestType;</span><span class="s3">\n</span><span class="s1">class RequestType1 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method, _parameterStructures = ParameterStructures.auto) {</span><span class="s3">\n        </span><span class="s1">super(method, 1);</span><span class="s3">\n        </span><span class="s1">this._parameterStructures = _parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parameterStructures() {</span><span class="s3">\n        </span><span class="s1">return this._parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType1 = RequestType1;</span><span class="s3">\n</span><span class="s1">class RequestType2 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType2 = RequestType2;</span><span class="s3">\n</span><span class="s1">class RequestType3 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 3);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType3 = RequestType3;</span><span class="s3">\n</span><span class="s1">class RequestType4 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType4 = RequestType4;</span><span class="s3">\n</span><span class="s1">class RequestType5 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType5 = RequestType5;</span><span class="s3">\n</span><span class="s1">class RequestType6 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 6);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType6 = RequestType6;</span><span class="s3">\n</span><span class="s1">class RequestType7 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 7);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType7 = RequestType7;</span><span class="s3">\n</span><span class="s1">class RequestType8 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 8);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType8 = RequestType8;</span><span class="s3">\n</span><span class="s1">class RequestType9 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 9);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.RequestType9 = RequestType9;</span><span class="s3">\n</span><span class="s1">class NotificationType extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method, _parameterStructures = ParameterStructures.auto) {</span><span class="s3">\n        </span><span class="s1">super(method, 1);</span><span class="s3">\n        </span><span class="s1">this._parameterStructures = _parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parameterStructures() {</span><span class="s3">\n        </span><span class="s1">return this._parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType = NotificationType;</span><span class="s3">\n</span><span class="s1">class NotificationType0 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType0 = NotificationType0;</span><span class="s3">\n</span><span class="s1">class NotificationType1 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method, _parameterStructures = ParameterStructures.auto) {</span><span class="s3">\n        </span><span class="s1">super(method, 1);</span><span class="s3">\n        </span><span class="s1">this._parameterStructures = _parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parameterStructures() {</span><span class="s3">\n        </span><span class="s1">return this._parameterStructures;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType1 = NotificationType1;</span><span class="s3">\n</span><span class="s1">class NotificationType2 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType2 = NotificationType2;</span><span class="s3">\n</span><span class="s1">class NotificationType3 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 3);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType3 = NotificationType3;</span><span class="s3">\n</span><span class="s1">class NotificationType4 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType4 = NotificationType4;</span><span class="s3">\n</span><span class="s1">class NotificationType5 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType5 = NotificationType5;</span><span class="s3">\n</span><span class="s1">class NotificationType6 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 6);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType6 = NotificationType6;</span><span class="s3">\n</span><span class="s1">class NotificationType7 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 7);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType7 = NotificationType7;</span><span class="s3">\n</span><span class="s1">class NotificationType8 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 8);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType8 = NotificationType8;</span><span class="s3">\n</span><span class="s1">class NotificationType9 extends AbstractMessageSignature {</span><span class="s3">\n    </span><span class="s1">constructor(method) {</span><span class="s3">\n        </span><span class="s1">super(method, 9);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.NotificationType9 = NotificationType9;</span><span class="s3">\n</span><span class="s1">var Message;</span><span class="s3">\n</span><span class="s1">(function (Message) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Tests if the given message is a request message</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function isRequest(message) {</span><span class="s3">\n        </span><span class="s1">const candidate = message;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; is.string(candidate.method) &amp;&amp; (is.string(candidate.id) || is.number(candidate.id));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Message.isRequest = isRequest;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Tests if the given message is a notification message</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function isNotification(message) {</span><span class="s3">\n        </span><span class="s1">const candidate = message;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; is.string(candidate.method) &amp;&amp; message.id === void 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Message.isNotification = isNotification;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Tests if the given message is a response message</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function isResponse(message) {</span><span class="s3">\n        </span><span class="s1">const candidate = message;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; (candidate.result !== void 0 || !!candidate.error) &amp;&amp; (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Message.isResponse = isResponse;</span><span class="s3">\n</span><span class="s1">})(Message || (exports.Message = Message = {}));</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">let _ral;</span><span class="s3">\n</span><span class="s1">function RAL() {</span><span class="s3">\n    </span><span class="s1">if (_ral === undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error(`No runtime abstraction layer installed`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _ral;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function (RAL) {</span><span class="s3">\n    </span><span class="s1">function install(ral) {</span><span class="s3">\n        </span><span class="s1">if (ral === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`No runtime abstraction layer provided`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">_ral = ral;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RAL.install = install;</span><span class="s3">\n</span><span class="s1">})(RAL || (RAL = {}));</span><span class="s3">\n</span><span class="s1">exports.default = RAL;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.Semaphore = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">class Semaphore {</span><span class="s3">\n    </span><span class="s1">constructor(capacity = 1) {</span><span class="s3">\n        </span><span class="s1">if (capacity &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Capacity must be greater than 0');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._capacity = capacity;</span><span class="s3">\n        </span><span class="s1">this._active = 0;</span><span class="s3">\n        </span><span class="s1">this._waiting = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lock(thunk) {</span><span class="s3">\n        </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n            </span><span class="s1">this._waiting.push({ thunk, resolve, reject });</span><span class="s3">\n            </span><span class="s1">this.runNext();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get active() {</span><span class="s3">\n        </span><span class="s1">return this._active;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">runNext() {</span><span class="s3">\n        </span><span class="s1">if (this._waiting.length === 0 || this._active === this._capacity) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">(0, ral_1.default)().timer.setImmediate(() =&gt; this.doRunNext());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">doRunNext() {</span><span class="s3">\n        </span><span class="s1">if (this._waiting.length === 0 || this._active === this._capacity) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const next = this._waiting.shift();</span><span class="s3">\n        </span><span class="s1">this._active++;</span><span class="s3">\n        </span><span class="s1">if (this._active &gt; this._capacity) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`To many thunks active`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const result = next.thunk();</span><span class="s3">\n            </span><span class="s1">if (result instanceof Promise) {</span><span class="s3">\n                </span><span class="s1">result.then((value) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this._active--;</span><span class="s3">\n                    </span><span class="s1">next.resolve(value);</span><span class="s3">\n                    </span><span class="s1">this.runNext();</span><span class="s3">\n                </span><span class="s1">}, (err) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this._active--;</span><span class="s3">\n                    </span><span class="s1">next.reject(err);</span><span class="s3">\n                    </span><span class="s1">this.runNext();</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this._active--;</span><span class="s3">\n                </span><span class="s1">next.resolve(result);</span><span class="s3">\n                </span><span class="s1">this.runNext();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">this._active--;</span><span class="s3">\n            </span><span class="s1">next.reject(err);</span><span class="s3">\n            </span><span class="s1">this.runNext();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Semaphore = Semaphore;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;</span><span class="s3">\n</span><span class="s1">const cancellation_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./cancellation</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var CancellationState;</span><span class="s3">\n</span><span class="s1">(function (CancellationState) {</span><span class="s3">\n    </span><span class="s1">CancellationState.Continue = 0;</span><span class="s3">\n    </span><span class="s1">CancellationState.Cancelled = 1;</span><span class="s3">\n</span><span class="s1">})(CancellationState || (CancellationState = {}));</span><span class="s3">\n</span><span class="s1">class SharedArraySenderStrategy {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.buffers = new Map();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">enableCancellation(request) {</span><span class="s3">\n        </span><span class="s1">if (request.id === null) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const buffer = new SharedArrayBuffer(4);</span><span class="s3">\n        </span><span class="s1">const data = new Int32Array(buffer, 0, 1);</span><span class="s3">\n        </span><span class="s1">data[0] = CancellationState.Continue;</span><span class="s3">\n        </span><span class="s1">this.buffers.set(request.id, buffer);</span><span class="s3">\n        </span><span class="s1">request.$cancellationData = buffer;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async sendCancellation(_conn, id) {</span><span class="s3">\n        </span><span class="s1">const buffer = this.buffers.get(id);</span><span class="s3">\n        </span><span class="s1">if (buffer === undefined) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const data = new Int32Array(buffer, 0, 1);</span><span class="s3">\n        </span><span class="s1">Atomics.store(data, 0, CancellationState.Cancelled);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cleanup(id) {</span><span class="s3">\n        </span><span class="s1">this.buffers.delete(id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this.buffers.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.SharedArraySenderStrategy = SharedArraySenderStrategy;</span><span class="s3">\n</span><span class="s1">class SharedArrayBufferCancellationToken {</span><span class="s3">\n    </span><span class="s1">constructor(buffer) {</span><span class="s3">\n        </span><span class="s1">this.data = new Int32Array(buffer, 0, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isCancellationRequested() {</span><span class="s3">\n        </span><span class="s1">return Atomics.load(this.data, 0) === CancellationState.Cancelled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onCancellationRequested() {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SharedArrayBufferCancellationTokenSource {</span><span class="s3">\n    </span><span class="s1">constructor(buffer) {</span><span class="s3">\n        </span><span class="s1">this.token = new SharedArrayBufferCancellationToken(buffer);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SharedArrayReceiverStrategy {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.kind = 'request';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createCancellationTokenSource(request) {</span><span class="s3">\n        </span><span class="s1">const buffer = request.$cancellationData;</span><span class="s3">\n        </span><span class="s1">if (buffer === undefined) {</span><span class="s3">\n            </span><span class="s1">return new cancellation_1.CancellationTokenSource();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new SharedArrayBufferCancellationTokenSource(buffer);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">import { Disposable } from 'vscode-jsonrpc';</span><span class="s3">\r\n</span><span class="s1">export class DisposableCollection {</span><span class="s3">\r\n    </span><span class="s1">constructor() {</span><span class="s3">\r\n        </span><span class="s1">this.disposables = [];</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">dispose() {</span><span class="s3">\r\n        </span><span class="s1">while (this.disposables.length !== 0) {</span><span class="s3">\r\n            </span><span class="s1">this.disposables.pop().dispose();</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">push(disposable) {</span><span class="s3">\r\n        </span><span class="s1">const disposables = this.disposables;</span><span class="s3">\r\n        </span><span class="s1">disposables.push(disposable);</span><span class="s3">\r\n        </span><span class="s1">return {</span><span class="s3">\r\n            </span><span class="s1">dispose() {</span><span class="s3">\r\n                </span><span class="s1">const index = disposables.indexOf(disposable);</span><span class="s3">\r\n                </span><span class="s1">if (index !== -1) {</span><span class="s3">\r\n                    </span><span class="s1">disposables.splice(index, 1);</span><span class="s3">\r\n                </span><span class="s1">}</span><span class="s3">\r\n            </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">};</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">export { Disposable };</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=disposable.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">import { AbstractMessageReader } from 'vscode-jsonrpc/lib/common/messageReader';</span><span class="s3">\r\n</span><span class="s1">export class WebSocketMessageReader extends AbstractMessageReader {</span><span class="s3">\r\n    </span><span class="s1">constructor(socket) {</span><span class="s3">\r\n        </span><span class="s1">super();</span><span class="s3">\r\n        </span><span class="s1">this.socket = socket;</span><span class="s3">\r\n        </span><span class="s1">this.state = 'initial';</span><span class="s3">\r\n        </span><span class="s1">this.events = [];</span><span class="s3">\r\n        </span><span class="s1">this.socket.onMessage(message =&gt; this.readMessage(message));</span><span class="s3">\r\n        </span><span class="s1">this.socket.onError(error =&gt; this.fireError(error));</span><span class="s3">\r\n        </span><span class="s1">this.socket.onClose((code, reason) =&gt; {</span><span class="s3">\r\n            </span><span class="s1">if (code !== 1000) {</span><span class="s3">\r\n                </span><span class="s1">const error = {</span><span class="s3">\r\n                    </span><span class="s1">name: '' + code,</span><span class="s3">\r\n                    </span><span class="s1">message: `Error during socket reconnect: code = ${code}, reason = ${reason}`</span><span class="s3">\r\n                </span><span class="s1">};</span><span class="s3">\r\n                </span><span class="s1">this.fireError(error);</span><span class="s3">\r\n            </span><span class="s1">}</span><span class="s3">\r\n            </span><span class="s1">this.fireClose();</span><span class="s3">\r\n        </span><span class="s1">});</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">listen(callback) {</span><span class="s3">\r\n        </span><span class="s1">if (this.state === 'initial') {</span><span class="s3">\r\n            </span><span class="s1">this.state = 'listening';</span><span class="s3">\r\n            </span><span class="s1">this.callback = callback;</span><span class="s3">\r\n            </span><span class="s1">while (this.events.length !== 0) {</span><span class="s3">\r\n                </span><span class="s1">const event = this.events.pop();</span><span class="s3">\r\n                </span><span class="s1">if (event.message) {</span><span class="s3">\r\n                    </span><span class="s1">this.readMessage(event.message);</span><span class="s3">\r\n                </span><span class="s1">}</span><span class="s3">\r\n                </span><span class="s1">else if (event.error) {</span><span class="s3">\r\n                    </span><span class="s1">this.fireError(event.error);</span><span class="s3">\r\n                </span><span class="s1">}</span><span class="s3">\r\n                </span><span class="s1">else {</span><span class="s3">\r\n                    </span><span class="s1">this.fireClose();</span><span class="s3">\r\n                </span><span class="s1">}</span><span class="s3">\r\n            </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">return {</span><span class="s3">\r\n            </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\r\n                </span><span class="s1">if (this.callback === callback) {</span><span class="s3">\r\n                    </span><span class="s1">this.callback = undefined;</span><span class="s3">\r\n                </span><span class="s1">}</span><span class="s3">\r\n            </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">};</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">readMessage(message) {</span><span class="s3">\r\n        </span><span class="s1">if (this.state === 'initial') {</span><span class="s3">\r\n            </span><span class="s1">this.events.splice(0, 0, { message });</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">else if (this.state === 'listening') {</span><span class="s3">\r\n            </span><span class="s1">const data = JSON.parse(message);</span><span class="s3">\r\n            </span><span class="s1">this.callback(data);</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">fireError(error) {</span><span class="s3">\r\n        </span><span class="s1">if (this.state === 'initial') {</span><span class="s3">\r\n            </span><span class="s1">this.events.splice(0, 0, { error });</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">else if (this.state === 'listening') {</span><span class="s3">\r\n            </span><span class="s1">super.fireError(error);</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">fireClose() {</span><span class="s3">\r\n        </span><span class="s1">if (this.state === 'initial') {</span><span class="s3">\r\n            </span><span class="s1">this.events.splice(0, 0, {});</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">else if (this.state === 'listening') {</span><span class="s3">\r\n            </span><span class="s1">super.fireClose();</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">this.state = 'closed';</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=reader.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">import { AbstractMessageWriter } from 'vscode-jsonrpc/lib/common/messageWriter';</span><span class="s3">\r\n</span><span class="s1">export class WebSocketMessageWriter extends AbstractMessageWriter {</span><span class="s3">\r\n    </span><span class="s1">constructor(socket) {</span><span class="s3">\r\n        </span><span class="s1">super();</span><span class="s3">\r\n        </span><span class="s1">this.socket = socket;</span><span class="s3">\r\n        </span><span class="s1">this.errorCount = 0;</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">end() {</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">async write(msg) {</span><span class="s3">\r\n        </span><span class="s1">try {</span><span class="s3">\r\n            </span><span class="s1">const content = JSON.stringify(msg);</span><span class="s3">\r\n            </span><span class="s1">this.socket.send(content);</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n        </span><span class="s1">catch (e) {</span><span class="s3">\r\n            </span><span class="s1">this.errorCount++;</span><span class="s3">\r\n            </span><span class="s1">this.fireError(e, msg, this.errorCount);</span><span class="s3">\r\n        </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=writer.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">import { createMessageConnection } from 'vscode-jsonrpc';</span><span class="s3">\r\n</span><span class="s1">import { WebSocketMessageReader } from './reader';</span><span class="s3">\r\n</span><span class="s1">import { WebSocketMessageWriter } from './writer';</span><span class="s3">\r\n</span><span class="s1">export function createWebSocketConnection(socket, logger) {</span><span class="s3">\r\n    </span><span class="s1">const messageReader = new WebSocketMessageReader(socket);</span><span class="s3">\r\n    </span><span class="s1">const messageWriter = new WebSocketMessageWriter(socket);</span><span class="s3">\r\n    </span><span class="s1">const connection = createMessageConnection(messageReader, messageWriter, logger);</span><span class="s3">\r\n    </span><span class="s1">connection.onClose(() =&gt; connection.dispose());</span><span class="s3">\r\n    </span><span class="s1">return connection;</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=connection.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">export * from './socket';</span><span class="s3">\r\n</span><span class="s1">export * from './reader';</span><span class="s3">\r\n</span><span class="s1">export * from './writer';</span><span class="s3">\r\n</span><span class="s1">export * from './connection';</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export class ConsoleLogger {</span><span class="s3">\r\n    </span><span class="s1">error(message) {</span><span class="s3">\r\n        </span><span class="s1">console.error(message);</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">warn(message) {</span><span class="s3">\r\n        </span><span class="s1">console.warn(message);</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">info(message) {</span><span class="s3">\r\n        </span><span class="s1">console.info(message);</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">log(message) {</span><span class="s3">\r\n        </span><span class="s1">console.log(message);</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n    </span><span class="s1">debug(message) {</span><span class="s3">\r\n        </span><span class="s1">console.debug(message);</span><span class="s3">\r\n    </span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=logger.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">import { createWebSocketConnection } from './socket';</span><span class="s3">\r\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">import { ConsoleLogger } from './logger';</span><span class="s3">\r\n</span><span class="s1">export function listen(options) {</span><span class="s3">\r\n    </span><span class="s1">const { webSocket, onConnection } = options;</span><span class="s3">\r\n    </span><span class="s1">const logger = options.logger || new ConsoleLogger();</span><span class="s3">\r\n    </span><span class="s1">webSocket.onopen = () =&gt; {</span><span class="s3">\r\n        </span><span class="s1">const socket = toSocket(webSocket);</span><span class="s3">\r\n        </span><span class="s1">const connection = createWebSocketConnection(socket, logger);</span><span class="s3">\r\n        </span><span class="s1">onConnection(connection);</span><span class="s3">\r\n    </span><span class="s1">};</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">export function toSocket(webSocket) {</span><span class="s3">\r\n    </span><span class="s1">return {</span><span class="s3">\r\n        </span><span class="s1">send: content =&gt; webSocket.send(content),</span><span class="s3">\r\n        </span><span class="s1">onMessage: cb =&gt; {</span><span class="s3">\r\n            </span><span class="s1">webSocket.onmessage = event =&gt; cb(event.data);</span><span class="s3">\r\n        </span><span class="s1">},</span><span class="s3">\r\n        </span><span class="s1">onError: cb =&gt; {</span><span class="s3">\r\n            </span><span class="s1">webSocket.onerror = event =&gt; {</span><span class="s3">\r\n                </span><span class="s1">if ('message' in event) {</span><span class="s3">\r\n                    </span><span class="s1">cb(event.message);</span><span class="s3">\r\n                </span><span class="s1">}</span><span class="s3">\r\n            </span><span class="s1">};</span><span class="s3">\r\n        </span><span class="s1">},</span><span class="s3">\r\n        </span><span class="s1">onClose: cb =&gt; {</span><span class="s3">\r\n            </span><span class="s1">webSocket.onclose = event =&gt; cb(event.code, event.reason);</span><span class="s3">\r\n        </span><span class="s1">},</span><span class="s3">\r\n        </span><span class="s1">dispose: () =&gt; webSocket.close()</span><span class="s3">\r\n    </span><span class="s1">};</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=connection.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\r\n </span><span class="s1">* Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.</span><span class="s3">\r\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\r\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\r\n</span><span class="s1">export * from 'vscode-jsonrpc';</span><span class="s3">\r\n</span><span class="s1">export * from 'vscode-jsonrpc/lib/common/messages';</span><span class="s3">\r\n</span><span class="s1">export * from './disposable';</span><span class="s3">\r\n</span><span class="s1">export * from './socket';</span><span class="s3">\r\n</span><span class="s1">export * from './logger';</span><span class="s3">\r\n</span><span class="s1">export * from './connection';</span><span class="s3">\r\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>