<html>
<head>
<title>306.dd9ffcf982b0c863872b.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
306.dd9ffcf982b0c863872b.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;306.dd9ffcf982b0c863872b.js?v=dd9ffcf982b0c863872b&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;AAAyC;AACa;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAA8C,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,UAAU,GAAG,qBAAqB,IAAI,WAAW,IAAI,aAAa;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,EAAE,wBAAwB,qBAAqB,WAAW,EAAE,YAAY;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB,EAAE;AAC9C;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA,+CAA+C,8BAA8B,0BAA0B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,WAAW;AACX;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,mCAAmC,EAAE,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,gCAAgC;AAChC,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB,qBAAqB;AACrB,qBAAqB;AACrB,gBAAgB;AAChB,kBAAkB;AAClB,gBAAgB;AAChB,wBAAwB;AACxB,qBAAqB;AACrB,0BAA0B;AAC1B,qBAAqB;AACrB,wBAAwB;AACxB,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B,KAAK,GAAG,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe,SAAS;AAC7C,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uBAAuB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA,SAAS;AACT;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B,UAAU,SAAS,uCAAuC,EAAE;AACxF;AACA,4BAA4B,UAAU,EAAE,MAAM;AAC9C,SAAS;AACT,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wCAAwC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,mCAAmC,aAAa,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB;AACxB;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY,WAAW,EAAE,YAAY,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;;AAEA,wBAAwB,OAAO,mBAAmB,OAAO;AACzD;AACA;AACA;AACA;AACA,mBAAmB,OAAO,GAAG,sCAAsC;AACnE;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB,KAAK,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU,oBAAoB,GAAG,uBAAuB;AACzE,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wBAAwB,GAAG,gCAAgC;AAC3G;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,qGAAqG;AACrG;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,YAAY,WAAW,kBAAkB;AACrG;AACA,6DAA6D,iBAAiB,WAAW,kBAAkB;AAC3G,yCAAyC,wBAAwB,IAAI,YAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,GAAG;AACvB,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB,oBAAoB,WAAW,2BAA2B,SAAS;AACnI,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe,eAAe,sCAAsC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,kDAAkD,cAAc;AAChE;AACA,4BAA4B,8BAA8B;AAC1D,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,EAAE,2BAA2B,GAAG,sCAAsC;AACpH;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK,EAAE,0BAA0B,GAAG,sCAAsC;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mDAAQ;AACzB;AACA,oCAAoC,mDAAQ;AAC5C,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA,gGAAgG,mDAAQ;AACxG,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA,oCAAoC,YAAY;AAChD;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,wCAAwC;AACxC,8BAA8B,KAAK,GAAG,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sDAAsD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAoF;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wNAAwN;AACtO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT,eAAe,yDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,oPAAoP;AAClQ;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B,EAAE,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD,kBAAkB,SAAS;AAC3B;AACA,uBAAuB,OAAO,IAAI,wCAAwC;AAC1E,SAAS;AACT;AACA,qBAAqB,oDAAoD,6DAA6D,GAAG,WAAW;AACpJ,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,UAAU,eAAe,GAAG,SAAS,GAAG,QAAQ,KAAK,sBAAsB,+BAA+B,0BAA0B,OAAO,cAAc,KAAK,EAAE,gDAAgD;AACjP;AACA;AACA;AACA;AACA,qCAAqC,WAAW,IAAI,mCAAmC;AACvF,qEAAqE,UAAU;AAC/E,yBAAyB,QAAQ,WAAW,eAAe,GAAG,OAAO,UAAU,cAAc;AAC7F;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,EAAE,6BAA6B,YAAY,OAAO;AAClF;AACA,iCAAiC,EAAE,6BAA6B,OAAO,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA,4DAA4D,EAAE,IAAI,eAAe;AACjF,2BAA2B,SAAS;AACpC,aAAa,sBAAsB;AACnC,YAAY,gCAAgC;AAC5C,eAAe,uBAAuB;AACtC,UAAU,kBAAkB;AAC5B,eAAe,0BAA0B;AACzC,aAAa,QAAQ,EAAE;AACvB,aAAa,QAAQ,OAAO,EAAE;AAC9B;AACA,MAAM;AACN,UAAU,EAAE;AACZ,kBAAkB,mBAAmB,QAAQ,EAAE;AAC/C,kBAAkB,6BAA6B,OAAO;AACtD,qBAAqB,gBAAgB;AACrC,eAAe,uBAAuB;AACtC,iBAAiB,sBAAsB;AACvC,cAAc,yBAAyB,EAAE;AACzC,aAAa,EAAE,qBAAqB,OAAO,EAAE;AAC7C,wBAAwB,mCAAmC,OAAO,EAAE;AACpE,kBAAkB,sBAAsB,QAAQ;AAChD,eAAe,UAAU,EAAE;AAC3B,eAAe,0BAA0B;AACzC,CAAC;AACD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,GAAG,EAAE,2BAA2B,EAAE,qBAAqB;AACjF;AACA,yBAAyB,2BAA2B;AACpD,kCAAkC,kBAAkB,EAAE,2BAA2B,EAAE,GAAG;AACtF;AACA,sDAAsD,YAAY,IAAI,UAAU,sBAAsB,YAAY,IAAI,UAAU;AAChI,qCAAqC,IAAI,kBAAkB,MAAM,oBAAoB,GAAG;AACxF,qBAAqB,IAAI,kBAAkB,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAA6C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU,SAAS,UAAU;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA,cAAc,8EAA8E;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc,uBAAuB,aAAa;AAChF;AACA,gCAAgC,aAAa,IAAI,cAAc;AAC/D;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD,qDAAqD,UAAU,GAAG,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD,SAAS;AACT;AACA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAyC;AACtE,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uBAAuB,KAAK,WAAW,GAAG,MAAM,KAAK,WAAW;AACvI;AACA,0EAA0E,uBAAuB,KAAK,UAAU;AAChH;AACA,uEAAuE,uBAAuB,KAAK,UAAU;AAC7G;AACA,wEAAwE,uBAAuB,KAAK,UAAU;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,2EAA2E,UAAU;AACrI;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA,yCAAyC,KAAK;AAC9C,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA,yCAAyC,KAAK,SAAS,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAA6C;AACrE;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,6DAA6D;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gCAAgC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kCAAkC,EAAE,2BAA2B,kCAAkC,OAAO;AAChL;AACA,yDAAyD,WAAW,MAAM,kBAAkB,sBAAsB,QAAQ;AAC1H,0CAA0C,qBAAqB;AAC/D;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F,mBAAmB,iBAAiB;AACpC;AACA,mDAAmD,QAAQ,MAAM,QAAQ,sBAAsB,yBAAyB,yBAAyB,QAAQ;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,eAAe,OAAO,eAAe;AAC1I;AACA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAe;AAC7C,+CAA+C,2CAA2C,GAAG,sBAAsB,IAAI,WAAW,EAAE,qBAAqB,iBAAiB,OAAO;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,cAAc,cAAc,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA,4DAA4D;AAC5D;AACA,qBAAqB;AACrB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/generator/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { NodeProp } from '@lezer/common';</span><span class="s3">\n</span><span class="s1">import { LRParser, LocalTokenGroup } from '@lezer/lr';</span><span class="s3">\n\n</span><span class="s1">class Node {</span><span class="s3">\n    </span><span class="s1">constructor(start) {</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class GrammarDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, rules, topRules, tokens, localTokens, context, externalTokens, externalSpecializers, externalPropSources, precedences, mainSkip, scopedSkip, dialects, externalProps, autoDelim) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.rules = rules;</span><span class="s3">\n        </span><span class="s1">this.topRules = topRules;</span><span class="s3">\n        </span><span class="s1">this.tokens = tokens;</span><span class="s3">\n        </span><span class="s1">this.localTokens = localTokens;</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n        </span><span class="s1">this.externalTokens = externalTokens;</span><span class="s3">\n        </span><span class="s1">this.externalSpecializers = externalSpecializers;</span><span class="s3">\n        </span><span class="s1">this.externalPropSources = externalPropSources;</span><span class="s3">\n        </span><span class="s1">this.precedences = precedences;</span><span class="s3">\n        </span><span class="s1">this.mainSkip = mainSkip;</span><span class="s3">\n        </span><span class="s1">this.scopedSkip = scopedSkip;</span><span class="s3">\n        </span><span class="s1">this.dialects = dialects;</span><span class="s3">\n        </span><span class="s1">this.externalProps = externalProps;</span><span class="s3">\n        </span><span class="s1">this.autoDelim = autoDelim;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return Object.values(this.rules).join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RuleDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, props, params, expr) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n        </span><span class="s1">this.params = params;</span><span class="s3">\n        </span><span class="s1">this.expr = expr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.id.name + (this.params.length ? `&lt;${this.params.join()}&gt;` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ this.expr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class PrecDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, items) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.items = items;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenPrecDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, items) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.items = items;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenConflictDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, a, b) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.a = a;</span><span class="s3">\n        </span><span class="s1">this.b = b;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, precedences, conflicts, rules, literals) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.precedences = precedences;</span><span class="s3">\n        </span><span class="s1">this.conflicts = conflicts;</span><span class="s3">\n        </span><span class="s1">this.rules = rules;</span><span class="s3">\n        </span><span class="s1">this.literals = literals;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LocalTokenDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, precedences, rules, fallback) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.precedences = precedences;</span><span class="s3">\n        </span><span class="s1">this.rules = rules;</span><span class="s3">\n        </span><span class="s1">this.fallback = fallback;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LiteralDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, literal, props) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.literal = literal;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ContextDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, source) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ExternalTokenDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, source, tokens) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n        </span><span class="s1">this.tokens = tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ExternalSpecializeDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, type, token, id, source, tokens) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.token = token;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n        </span><span class="s1">this.tokens = tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ExternalPropSourceDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, source) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ExternalPropDeclaration extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, externalID, source) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.externalID = externalID;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Identifier extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, name) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return this.name; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Expression extends Node {</span><span class="s3">\n    </span><span class="s1">walk(f) { return f(this); }</span><span class="s3">\n    </span><span class="s1">eq(_other) { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Expression.prototype.prec = 10;</span><span class="s3">\n</span><span class="s1">class NameExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, args) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.args = args;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return this.id.name + (this.args.length ? `&lt;${this.args.join()}&gt;` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">); }</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return this.id.name == other.id.name &amp;&amp; exprsEq(this.args, other.args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(f) {</span><span class="s3">\n        </span><span class="s1">let args = walkExprs(this.args, f);</span><span class="s3">\n        </span><span class="s1">return f(args == this.args ? this : new NameExpression(this.start, this.id, args));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SpecializeExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, type, props, token, content) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n        </span><span class="s1">this.token = token;</span><span class="s3">\n        </span><span class="s1">this.content = content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return `@${this.type}[${this.props.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}]&lt;${this.token}, ${this.content}&gt;`; }</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return this.type == other.type &amp;&amp; Prop.eqProps(this.props, other.props) &amp;&amp; exprEq(this.token, other.token) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">exprEq(this.content, other.content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(f) {</span><span class="s3">\n        </span><span class="s1">let token = this.token.walk(f), content = this.content.walk(f);</span><span class="s3">\n        </span><span class="s1">return f(token == this.token &amp;&amp; content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class InlineRuleExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, rule) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.rule = rule;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let rule = this.rule;</span><span class="s3">\n        </span><span class="s1">return `${rule.id}${rule.props.length ? `[${rule.props.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}]` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">} { ${rule.expr} }`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">let rule = this.rule, oRule = other.rule;</span><span class="s3">\n        </span><span class="s1">return exprEq(rule.expr, oRule.expr) &amp;&amp; rule.id.name == oRule.id.name &amp;&amp; Prop.eqProps(rule.props, oRule.props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(f) {</span><span class="s3">\n        </span><span class="s1">let rule = this.rule, expr = rule.expr.walk(f);</span><span class="s3">\n        </span><span class="s1">return f(expr == rule.expr ? this :</span><span class="s3">\n            </span><span class="s1">new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ChoiceExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, exprs) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.exprs = exprs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return this.exprs.map(e =&gt; maybeParens(e, this)).join(</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return exprsEq(this.exprs, other.exprs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(f) {</span><span class="s3">\n        </span><span class="s1">let exprs = walkExprs(this.exprs, f);</span><span class="s3">\n        </span><span class="s1">return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">ChoiceExpression.prototype.prec = 1;</span><span class="s3">\n</span><span class="s1">class SequenceExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, exprs, markers, empty = false) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.exprs = exprs;</span><span class="s3">\n        </span><span class="s1">this.markers = markers;</span><span class="s3">\n        </span><span class="s1">this.empty = empty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return this.empty ? </span><span class="s3">\&quot;</span><span class="s1">()</span><span class="s3">\&quot; </span><span class="s1">: this.exprs.map(e =&gt; maybeParens(e, this)).join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">); }</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return exprsEq(this.exprs, other.exprs) &amp;&amp; this.markers.every((m, i) =&gt; {</span><span class="s3">\n            </span><span class="s1">let om = other.markers[i];</span><span class="s3">\n            </span><span class="s1">return m.length == om.length &amp;&amp; m.every((x, i) =&gt; x.eq(om[i]));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(f) {</span><span class="s3">\n        </span><span class="s1">let exprs = walkExprs(this.exprs, f);</span><span class="s3">\n        </span><span class="s1">return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers, this.empty &amp;&amp; !exprs.length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">SequenceExpression.prototype.prec = 2;</span><span class="s3">\n</span><span class="s1">class ConflictMarker extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, id, type) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return (this.type == </span><span class="s3">\&quot;</span><span class="s1">ambig</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">) + this.id.name; }</span><span class="s3">\n    </span><span class="s1">eq(other) { return this.id.name == other.id.name &amp;&amp; this.type == other.type; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RepeatExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, expr, kind) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.expr = expr;</span><span class="s3">\n        </span><span class="s1">this.kind = kind;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return maybeParens(this.expr, this) + this.kind; }</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return exprEq(this.expr, other.expr) &amp;&amp; this.kind == other.kind;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(f) {</span><span class="s3">\n        </span><span class="s1">let expr = this.expr.walk(f);</span><span class="s3">\n        </span><span class="s1">return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">RepeatExpression.prototype.prec = 3;</span><span class="s3">\n</span><span class="s1">class LiteralExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">// value.length is always &gt; 0</span><span class="s3">\n    </span><span class="s1">constructor(start, value) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return JSON.stringify(this.value); }</span><span class="s3">\n    </span><span class="s1">eq(other) { return this.value == other.value; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SetExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, ranges, inverted) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.inverted = inverted;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return `[${this.inverted ? </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${this.ranges.map(([a, b]) =&gt; {</span><span class="s3">\n            </span><span class="s1">return String.fromCodePoint(a) + (b == a + 1 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ String.fromCodePoint(b));</span><span class="s3">\n        </span><span class="s1">})}]`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return this.inverted == other.inverted &amp;&amp; this.ranges.length == other.ranges.length &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.ranges.every(([a, b], i) =&gt; { let [x, y] = other.ranges[i]; return a == x &amp;&amp; b == y; });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class AnyExpression extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">; }</span><span class="s3">\n    </span><span class="s1">eq() { return true; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function walkExprs(exprs, f) {</span><span class="s3">\n    </span><span class="s1">let result = null;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; exprs.length; i++) {</span><span class="s3">\n        </span><span class="s1">let expr = exprs[i].walk(f);</span><span class="s3">\n        </span><span class="s1">if (expr != exprs[i] &amp;&amp; !result)</span><span class="s3">\n            </span><span class="s1">result = exprs.slice(0, i);</span><span class="s3">\n        </span><span class="s1">if (result)</span><span class="s3">\n            </span><span class="s1">result.push(expr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result || exprs;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const CharClasses = {</span><span class="s3">\n    </span><span class="s1">asciiLetter: [[65, 91], [97, 123]],</span><span class="s3">\n    </span><span class="s1">asciiLowercase: [[97, 123]],</span><span class="s3">\n    </span><span class="s1">asciiUppercase: [[65, 91]],</span><span class="s3">\n    </span><span class="s1">digit: [[48, 58]],</span><span class="s3">\n    </span><span class="s1">whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],</span><span class="s3">\n        </span><span class="s1">[8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]],</span><span class="s3">\n    </span><span class="s1">eof: [[0xffff, 0xffff]]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class CharClass extends Expression {</span><span class="s3">\n    </span><span class="s1">constructor(start, type) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">+ this.type; }</span><span class="s3">\n    </span><span class="s1">eq(expr) { return this.type == expr.type; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function exprEq(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.constructor == b.constructor &amp;&amp; a.eq(b);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function exprsEq(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.length == b.length &amp;&amp; a.every((e, i) =&gt; exprEq(e, b[i]));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Prop extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, at, name, value) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.at = at;</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return this.name == other.name &amp;&amp; this.value.length == other.value.length &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.value.every((v, i) =&gt; v.value == other.value[i].value &amp;&amp; v.name == other.value[i].name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let result = (this.at ? </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + this.name;</span><span class="s3">\n        </span><span class="s1">if (this.value.length) {</span><span class="s3">\n            </span><span class="s1">result += </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">for (let { name, value } of this.value)</span><span class="s3">\n                </span><span class="s1">result += name ? `{${name}}` : /[^</span><span class="s3">\\</span><span class="s1">w-]/.test(value) ? JSON.stringify(value) : value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static eqProps(a, b) {</span><span class="s3">\n        </span><span class="s1">return a.length == b.length &amp;&amp; a.every((p, i) =&gt; p.eq(b[i]));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class PropPart extends Node {</span><span class="s3">\n    </span><span class="s1">constructor(start, value, name) {</span><span class="s3">\n        </span><span class="s1">super(start);</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function maybeParens(node, parent) {</span><span class="s3">\n    </span><span class="s1">return node.prec &lt; parent.prec ? </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ node.toString() + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">: node.toString();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The type of error raised when the parser generator finds an issue.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class GenError extends Error {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasProps(props) {</span><span class="s3">\n    </span><span class="s1">for (let _p in props)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let termHash = 0;</span><span class="s3">\n</span><span class="s1">class Term {</span><span class="s3">\n    </span><span class="s1">constructor(name, flags, nodeName, props = {}) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.flags = flags;</span><span class="s3">\n        </span><span class="s1">this.nodeName = nodeName;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n        </span><span class="s1">this.hash = ++termHash; // Used for sorting and hashing during parser generation</span><span class="s3">\n        </span><span class="s1">this.id = -1; // Assigned in a later stage, used in actual output</span><span class="s3">\n        </span><span class="s1">// Filled in only after the rules are simplified, used in automaton.ts</span><span class="s3">\n        </span><span class="s1">this.rules = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return this.name; }</span><span class="s3">\n    </span><span class="s1">get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated; }</span><span class="s3">\n    </span><span class="s1">get terminal() { return (this.flags &amp; 1 /* TermFlag.Terminal */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">get eof() { return (this.flags &amp; 4 /* TermFlag.Eof */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">get error() { return </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot; </span><span class="s1">in this.props; }</span><span class="s3">\n    </span><span class="s1">get top() { return (this.flags &amp; 2 /* TermFlag.Top */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">get interesting() { return this.flags &gt; 0 || this.nodeName != null; }</span><span class="s3">\n    </span><span class="s1">get repeated() { return (this.flags &amp; 16 /* TermFlag.Repeated */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">set preserve(value) { this.flags = value ? this.flags | 8 /* TermFlag.Preserve */ : this.flags &amp; ~8 /* TermFlag.Preserve */; }</span><span class="s3">\n    </span><span class="s1">get preserve() { return (this.flags &amp; 8 /* TermFlag.Preserve */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">set inline(value) { this.flags = value ? this.flags | 32 /* TermFlag.Inline */ : this.flags &amp; ~32 /* TermFlag.Inline */; }</span><span class="s3">\n    </span><span class="s1">get inline() { return (this.flags &amp; 32 /* TermFlag.Inline */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">cmp(other) { return this.hash - other.hash; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TermSet {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.terms = [];</span><span class="s3">\n        </span><span class="s1">// Map from term names to Term instances</span><span class="s3">\n        </span><span class="s1">this.names = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.tops = [];</span><span class="s3">\n        </span><span class="s1">this.eof = this.term(</span><span class="s3">\&quot;</span><span class="s1">␄</span><span class="s3">\&quot;</span><span class="s1">, null, 1 /* TermFlag.Terminal */ | 4 /* TermFlag.Eof */);</span><span class="s3">\n        </span><span class="s1">this.error = this.term(</span><span class="s3">\&quot;</span><span class="s1">⚠</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">⚠</span><span class="s3">\&quot;</span><span class="s1">, 8 /* TermFlag.Preserve */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">term(name, nodeName, flags = 0, props = {}) {</span><span class="s3">\n        </span><span class="s1">let term = new Term(name, flags, nodeName, props);</span><span class="s3">\n        </span><span class="s1">this.terms.push(term);</span><span class="s3">\n        </span><span class="s1">this.names[name] = term;</span><span class="s3">\n        </span><span class="s1">return term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">makeTop(nodeName, props) {</span><span class="s3">\n        </span><span class="s1">const term = this.term(</span><span class="s3">\&quot;</span><span class="s1">@top</span><span class="s3">\&quot;</span><span class="s1">, nodeName, 2 /* TermFlag.Top */, props);</span><span class="s3">\n        </span><span class="s1">this.tops.push(term);</span><span class="s3">\n        </span><span class="s1">return term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">makeTerminal(name, nodeName, props = {}) {</span><span class="s3">\n        </span><span class="s1">return this.term(name, nodeName, 1 /* TermFlag.Terminal */, props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">makeNonTerminal(name, nodeName, props = {}) {</span><span class="s3">\n        </span><span class="s1">return this.term(name, nodeName, 0, props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">makeRepeat(name) {</span><span class="s3">\n        </span><span class="s1">return this.term(name, null, 16 /* TermFlag.Repeated */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">uniqueName(name) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let cur = i ? `${name}-${i}` : name;</span><span class="s3">\n            </span><span class="s1">if (!this.names[cur])</span><span class="s3">\n                </span><span class="s1">return cur;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(rules) {</span><span class="s3">\n        </span><span class="s1">for (let rule of rules)</span><span class="s3">\n            </span><span class="s1">rule.name.rules.push(rule);</span><span class="s3">\n        </span><span class="s1">this.terms = this.terms.filter(t =&gt; t.terminal || t.preserve || rules.some(r =&gt; r.name == t || r.parts.includes(t)));</span><span class="s3">\n        </span><span class="s1">let names = {};</span><span class="s3">\n        </span><span class="s1">let nodeTypes = [this.error];</span><span class="s3">\n        </span><span class="s1">this.error.id = 0 /* T.Err */;</span><span class="s3">\n        </span><span class="s1">let nextID = 0 /* T.Err */ + 1;</span><span class="s3">\n        </span><span class="s1">// Assign ids to terms that represent node types</span><span class="s3">\n        </span><span class="s1">for (let term of this.terms)</span><span class="s3">\n            </span><span class="s1">if (term.id &lt; 0 &amp;&amp; term.nodeType &amp;&amp; !term.repeated) {</span><span class="s3">\n                </span><span class="s1">term.id = nextID++;</span><span class="s3">\n                </span><span class="s1">nodeTypes.push(term);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Put all repeated terms after the regular node types</span><span class="s3">\n        </span><span class="s1">let minRepeatTerm = nextID;</span><span class="s3">\n        </span><span class="s1">for (let term of this.terms)</span><span class="s3">\n            </span><span class="s1">if (term.repeated) {</span><span class="s3">\n                </span><span class="s1">term.id = nextID++;</span><span class="s3">\n                </span><span class="s1">nodeTypes.push(term);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Then comes the EOF term</span><span class="s3">\n        </span><span class="s1">this.eof.id = nextID++;</span><span class="s3">\n        </span><span class="s1">// And then the remaining (non-node, non-repeat) terms.</span><span class="s3">\n        </span><span class="s1">for (let term of this.terms) {</span><span class="s3">\n            </span><span class="s1">if (term.id &lt; 0)</span><span class="s3">\n                </span><span class="s1">term.id = nextID++;</span><span class="s3">\n            </span><span class="s1">if (term.name)</span><span class="s3">\n                </span><span class="s1">names[term.id] = term.name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (nextID &gt;= 0xfffe)</span><span class="s3">\n            </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">Too many terms</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return { nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cmpSet(a, b, cmp) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return a.length - b.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n        </span><span class="s1">let diff = cmp(a[i], b[i]);</span><span class="s3">\n        </span><span class="s1">if (diff)</span><span class="s3">\n            </span><span class="s1">return diff;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const none$3 = [];</span><span class="s3">\n</span><span class="s1">class Conflicts {</span><span class="s3">\n    </span><span class="s1">constructor(precedence, ambigGroups = none$3, cut = 0) {</span><span class="s3">\n        </span><span class="s1">this.precedence = precedence;</span><span class="s3">\n        </span><span class="s1">this.ambigGroups = ambigGroups;</span><span class="s3">\n        </span><span class="s1">this.cut = cut;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">join(other) {</span><span class="s3">\n        </span><span class="s1">if (this == Conflicts.none || this == other)</span><span class="s3">\n            </span><span class="s1">return other;</span><span class="s3">\n        </span><span class="s1">if (other == Conflicts.none)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups), Math.max(this.cut, other.cut));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cmp(other) {</span><span class="s3">\n        </span><span class="s1">return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) =&gt; a &lt; b ? -1 : a &gt; b ? 1 : 0) ||</span><span class="s3">\n            </span><span class="s1">this.cut - other.cut;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Conflicts.none = new Conflicts(0);</span><span class="s3">\n</span><span class="s1">function union(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length == 0 || a == b)</span><span class="s3">\n        </span><span class="s1">return b;</span><span class="s3">\n    </span><span class="s1">if (b.length == 0)</span><span class="s3">\n        </span><span class="s1">return a;</span><span class="s3">\n    </span><span class="s1">let result = a.slice();</span><span class="s3">\n    </span><span class="s1">for (let value of b)</span><span class="s3">\n        </span><span class="s1">if (!a.includes(value))</span><span class="s3">\n            </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">return result.sort();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let ruleID = 0;</span><span class="s3">\n</span><span class="s1">class Rule {</span><span class="s3">\n    </span><span class="s1">constructor(name, parts, conflicts, skip) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.parts = parts;</span><span class="s3">\n        </span><span class="s1">this.conflicts = conflicts;</span><span class="s3">\n        </span><span class="s1">this.skip = skip;</span><span class="s3">\n        </span><span class="s1">this.id = ruleID++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cmp(rule) {</span><span class="s3">\n        </span><span class="s1">return this.id - rule.id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cmpNoName(rule) {</span><span class="s3">\n        </span><span class="s1">return this.parts.length - rule.parts.length ||</span><span class="s3">\n            </span><span class="s1">this.skip.hash - rule.skip.hash ||</span><span class="s3">\n            </span><span class="s1">this.parts.reduce((r, s, i) =&gt; r || s.cmp(rule.parts[i]), 0) ||</span><span class="s3">\n            </span><span class="s1">cmpSet(this.conflicts, rule.conflicts, (a, b) =&gt; a.cmp(b));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.name + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">+ this.parts.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isRepeatWrap() {</span><span class="s3">\n        </span><span class="s1">return this.name.repeated &amp;&amp; this.parts.length == 2 &amp;&amp; this.parts[0] == this.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sameReduce(other) {</span><span class="s3">\n        </span><span class="s1">return this.name == other.name &amp;&amp; this.parts.length == other.parts.length &amp;&amp; this.isRepeatWrap == other.isRepeatWrap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const MAX_CHAR = 0xffff;</span><span class="s3">\n</span><span class="s1">class Edge {</span><span class="s3">\n    </span><span class="s1">constructor(from, to, target) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.target = target;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return `-&gt; ${this.target.id}[label=${JSON.stringify(this.from &lt; 0 ? </span><span class="s3">\&quot;</span><span class="s1">ε</span><span class="s3">\&quot; </span><span class="s1">: charFor(this.from) +</span><span class="s3">\n            </span><span class="s1">(this.to &gt; this.from + 1 ? </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ charFor(this.to - 1) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">))}]`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function charFor(n) {</span><span class="s3">\n    </span><span class="s1">return n &gt; MAX_CHAR ? </span><span class="s3">\&quot;</span><span class="s1">∞</span><span class="s3">\&quot;\n        </span><span class="s1">: n == 10 ? </span><span class="s3">\&quot;\\\\</span><span class="s1">n</span><span class="s3">\&quot;\n            </span><span class="s1">: n == 13 ? </span><span class="s3">\&quot;\\\\</span><span class="s1">r</span><span class="s3">\&quot;\n                </span><span class="s1">: n &lt; 32 || n &gt;= 0xd800 &amp;&amp; n &lt; 0xdfff ? </span><span class="s3">\&quot;\\\\</span><span class="s1">u{</span><span class="s3">\&quot; </span><span class="s1">+ n.toString(16) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;\n                    </span><span class="s1">: String.fromCharCode(n);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function minimize(states, start) {</span><span class="s3">\n    </span><span class="s1">let partition = Object.create(null);</span><span class="s3">\n    </span><span class="s1">let byAccepting = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let state of states) {</span><span class="s3">\n        </span><span class="s1">let id = ids(state.accepting);</span><span class="s3">\n        </span><span class="s1">let group = byAccepting[id] || (byAccepting[id] = []);</span><span class="s3">\n        </span><span class="s1">group.push(state);</span><span class="s3">\n        </span><span class="s1">partition[state.id] = group;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let split = false, newPartition = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let state of states) {</span><span class="s3">\n            </span><span class="s1">if (newPartition[state.id])</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let group = partition[state.id];</span><span class="s3">\n            </span><span class="s1">if (group.length == 1) {</span><span class="s3">\n                </span><span class="s1">newPartition[group[0].id] = group;</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let parts = [];</span><span class="s3">\n            </span><span class="s1">groups: for (let state of group) {</span><span class="s3">\n                </span><span class="s1">for (let p of parts) {</span><span class="s3">\n                    </span><span class="s1">if (isEquivalent(state, p[0], partition)) {</span><span class="s3">\n                        </span><span class="s1">p.push(state);</span><span class="s3">\n                        </span><span class="s1">continue groups;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">parts.push([state]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (parts.length &gt; 1)</span><span class="s3">\n                </span><span class="s1">split = true;</span><span class="s3">\n            </span><span class="s1">for (let p of parts)</span><span class="s3">\n                </span><span class="s1">for (let s of p)</span><span class="s3">\n                    </span><span class="s1">newPartition[s.id] = p;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!split)</span><span class="s3">\n            </span><span class="s1">return applyMinimization(states, start, partition);</span><span class="s3">\n        </span><span class="s1">partition = newPartition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isEquivalent(a, b, partition) {</span><span class="s3">\n    </span><span class="s1">if (a.edges.length != b.edges.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.edges.length; i++) {</span><span class="s3">\n        </span><span class="s1">let eA = a.edges[i], eB = b.edges[i];</span><span class="s3">\n        </span><span class="s1">if (eA.from != eB.from || eA.to != eB.to || partition[eA.target.id] != partition[eB.target.id])</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function applyMinimization(states, start, partition) {</span><span class="s3">\n    </span><span class="s1">for (let state of states) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; state.edges.length; i++) {</span><span class="s3">\n            </span><span class="s1">let edge = state.edges[i], target = partition[edge.target.id][0];</span><span class="s3">\n            </span><span class="s1">if (target != edge.target)</span><span class="s3">\n                </span><span class="s1">state.edges[i] = new Edge(edge.from, edge.to, target);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return partition[start.id][0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let stateID = 1;</span><span class="s3">\n</span><span class="s1">let State$1 = class State {</span><span class="s3">\n    </span><span class="s1">constructor(accepting = [], id = stateID++) {</span><span class="s3">\n        </span><span class="s1">this.accepting = accepting;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.edges = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">edge(from, to, target) {</span><span class="s3">\n        </span><span class="s1">this.edges.push(new Edge(from, to, target));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nullEdge(target) { this.edge(-1, -1, target); }</span><span class="s3">\n    </span><span class="s1">compile() {</span><span class="s3">\n        </span><span class="s1">let labeled = Object.create(null), localID = 0;</span><span class="s3">\n        </span><span class="s1">let startState = explore(this.closure().sort((a, b) =&gt; a.id - b.id));</span><span class="s3">\n        </span><span class="s1">return minimize(Object.values(labeled), startState);</span><span class="s3">\n        </span><span class="s1">function explore(states) {</span><span class="s3">\n            </span><span class="s1">let newState = labeled[ids(states)] =</span><span class="s3">\n                </span><span class="s1">new State(states.reduce((a, s) =&gt; union(a, s.accepting), []), localID++);</span><span class="s3">\n            </span><span class="s1">let out = [];</span><span class="s3">\n            </span><span class="s1">for (let state of states)</span><span class="s3">\n                </span><span class="s1">for (let edge of state.edges) {</span><span class="s3">\n                    </span><span class="s1">if (edge.from &gt;= 0)</span><span class="s3">\n                        </span><span class="s1">out.push(edge);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let transitions = mergeEdges(out);</span><span class="s3">\n            </span><span class="s1">for (let merged of transitions) {</span><span class="s3">\n                </span><span class="s1">let targets = merged.targets.sort((a, b) =&gt; a.id - b.id);</span><span class="s3">\n                </span><span class="s1">newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return newState;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">closure() {</span><span class="s3">\n        </span><span class="s1">let result = [], seen = Object.create(null);</span><span class="s3">\n        </span><span class="s1">function explore(state) {</span><span class="s3">\n            </span><span class="s1">if (seen[state.id])</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">seen[state.id] = true;</span><span class="s3">\n            </span><span class="s1">// States with only epsilon edges and no accepting term that</span><span class="s3">\n            </span><span class="s1">// isn't also in the next states are left out to help reduce the</span><span class="s3">\n            </span><span class="s1">// number of unique state combinations</span><span class="s3">\n            </span><span class="s1">if (state.edges.some(e =&gt; e.from &gt;= 0) ||</span><span class="s3">\n                </span><span class="s1">(state.accepting.length &gt; 0 &amp;&amp; !state.edges.some(e =&gt; sameSet$1(state.accepting, e.target.accepting))))</span><span class="s3">\n                </span><span class="s1">result.push(state);</span><span class="s3">\n            </span><span class="s1">for (let edge of state.edges)</span><span class="s3">\n                </span><span class="s1">if (edge.from &lt; 0)</span><span class="s3">\n                    </span><span class="s1">explore(edge.target);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">explore(this);</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findConflicts(occurTogether) {</span><span class="s3">\n        </span><span class="s1">let conflicts = [], cycleTerms = this.cycleTerms();</span><span class="s3">\n        </span><span class="s1">function add(a, b, soft, aEdges, bEdges) {</span><span class="s3">\n            </span><span class="s1">if (a.id &lt; b.id) {</span><span class="s3">\n                </span><span class="s1">[a, b] = [b, a];</span><span class="s3">\n                </span><span class="s1">soft = -soft;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let found = conflicts.find(c =&gt; c.a == a &amp;&amp; c.b == b);</span><span class="s3">\n            </span><span class="s1">if (!found)</span><span class="s3">\n                </span><span class="s1">conflicts.push(new Conflict$1(a, b, soft, exampleFromEdges(aEdges), bEdges &amp;&amp; exampleFromEdges(bEdges)));</span><span class="s3">\n            </span><span class="s1">else if (found.soft != soft)</span><span class="s3">\n                </span><span class="s1">found.soft = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.reachable((state, edges) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (state.accepting.length == 0)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; state.accepting.length; i++)</span><span class="s3">\n                </span><span class="s1">for (let j = i + 1; j &lt; state.accepting.length; j++)</span><span class="s3">\n                    </span><span class="s1">add(state.accepting[i], state.accepting[j], 0, edges);</span><span class="s3">\n            </span><span class="s1">state.reachable((s, es) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (s != state)</span><span class="s3">\n                    </span><span class="s1">for (let term of s.accepting) {</span><span class="s3">\n                        </span><span class="s1">let hasCycle = cycleTerms.includes(term);</span><span class="s3">\n                        </span><span class="s1">for (let orig of state.accepting)</span><span class="s3">\n                            </span><span class="s1">if (term != orig)</span><span class="s3">\n                                </span><span class="s1">add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ? 0 : 1, edges, edges.concat(es));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return conflicts;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cycleTerms() {</span><span class="s3">\n        </span><span class="s1">let work = [];</span><span class="s3">\n        </span><span class="s1">this.reachable(state =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let { target } of state.edges)</span><span class="s3">\n                </span><span class="s1">work.push(state, target);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let table = new Map;</span><span class="s3">\n        </span><span class="s1">let haveCycle = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; work.length;) {</span><span class="s3">\n            </span><span class="s1">let from = work[i++], to = work[i++];</span><span class="s3">\n            </span><span class="s1">let entry = table.get(from);</span><span class="s3">\n            </span><span class="s1">if (!entry)</span><span class="s3">\n                </span><span class="s1">table.set(from, entry = []);</span><span class="s3">\n            </span><span class="s1">if (entry.includes(to))</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (from == to) {</span><span class="s3">\n                </span><span class="s1">if (!haveCycle.includes(from))</span><span class="s3">\n                    </span><span class="s1">haveCycle.push(from);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">for (let next of entry)</span><span class="s3">\n                    </span><span class="s1">work.push(from, next);</span><span class="s3">\n                </span><span class="s1">entry.push(to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let state of haveCycle) {</span><span class="s3">\n            </span><span class="s1">for (let term of state.accepting) {</span><span class="s3">\n                </span><span class="s1">if (!result.includes(term))</span><span class="s3">\n                    </span><span class="s1">result.push(term);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reachable(f) {</span><span class="s3">\n        </span><span class="s1">let seen = [], edges = [];</span><span class="s3">\n        </span><span class="s1">(function explore(s) {</span><span class="s3">\n            </span><span class="s1">f(s, edges);</span><span class="s3">\n            </span><span class="s1">seen.push(s);</span><span class="s3">\n            </span><span class="s1">for (let edge of s.edges)</span><span class="s3">\n                </span><span class="s1">if (!seen.includes(edge.target)) {</span><span class="s3">\n                    </span><span class="s1">edges.push(edge);</span><span class="s3">\n                    </span><span class="s1">explore(edge.target);</span><span class="s3">\n                    </span><span class="s1">edges.pop();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let out = </span><span class="s3">\&quot;</span><span class="s1">digraph {</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.reachable(state =&gt; {</span><span class="s3">\n            </span><span class="s1">if (state.accepting.length)</span><span class="s3">\n                </span><span class="s1">out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n            </span><span class="s1">for (let edge of state.edges)</span><span class="s3">\n                </span><span class="s1">out += `  ${state.id} ${edge};</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return out + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Tokenizer data is represented as a single flat array. This</span><span class="s3">\n    </span><span class="s1">// contains regions for each tokenizer state. Region offsets are</span><span class="s3">\n    </span><span class="s1">// used to identify states.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Each state is laid out as:</span><span class="s3">\n    </span><span class="s1">//  - Token group mask</span><span class="s3">\n    </span><span class="s1">//  - Offset of the end of the accepting data</span><span class="s3">\n    </span><span class="s1">//  - Number of outgoing edges in the state</span><span class="s3">\n    </span><span class="s1">//  - Pairs of token masks and term ids that indicate the accepting</span><span class="s3">\n    </span><span class="s1">//    states, sorted by precedence</span><span class="s3">\n    </span><span class="s1">//  - Triples for the edges: each with a low and high bound and the</span><span class="s3">\n    </span><span class="s1">//    offset of the next state.</span><span class="s3">\n    </span><span class="s1">toArray(groupMasks, precedence) {</span><span class="s3">\n        </span><span class="s1">let offsets = []; // Used to 'link' the states after building the arrays</span><span class="s3">\n        </span><span class="s1">let data = [];</span><span class="s3">\n        </span><span class="s1">this.reachable(state =&gt; {</span><span class="s3">\n            </span><span class="s1">let start = data.length;</span><span class="s3">\n            </span><span class="s1">let acceptEnd = start + 3 + state.accepting.length * 2;</span><span class="s3">\n            </span><span class="s1">offsets[state.id] = start;</span><span class="s3">\n            </span><span class="s1">data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length);</span><span class="s3">\n            </span><span class="s1">state.accepting.sort((a, b) =&gt; precedence.indexOf(a.id) - precedence.indexOf(b.id));</span><span class="s3">\n            </span><span class="s1">for (let term of state.accepting)</span><span class="s3">\n                </span><span class="s1">data.push(term.id, groupMasks[term.id] || 0xffff);</span><span class="s3">\n            </span><span class="s1">for (let edge of state.edges)</span><span class="s3">\n                </span><span class="s1">data.push(edge.from, edge.to, -edge.target.id - 1);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Replace negative numbers with resolved state offsets</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; data.length; i++)</span><span class="s3">\n            </span><span class="s1">if (data[i] &lt; 0)</span><span class="s3">\n                </span><span class="s1">data[i] = offsets[-data[i] - 1];</span><span class="s3">\n        </span><span class="s1">if (data.length &gt; Math.pow(2, 16))</span><span class="s3">\n            </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">Tokenizer tables too big to represent with 16-bit offsets.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return Uint16Array.from(data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stateMask(groupMasks) {</span><span class="s3">\n        </span><span class="s1">let mask = 0;</span><span class="s3">\n        </span><span class="s1">this.reachable(state =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let term of state.accepting)</span><span class="s3">\n                </span><span class="s1">mask |= (groupMasks[term.id] || 0xffff);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return mask;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">let Conflict$1 = class Conflict {</span><span class="s3">\n    </span><span class="s1">constructor(a, b, </span><span class="s3">\n    </span><span class="s1">// Conflicts between two non-cyclic tokens are marked as</span><span class="s3">\n    </span><span class="s1">// 'soft', with a negative number if a is shorter than</span><span class="s3">\n    </span><span class="s1">// b, and a positive if b is shorter than a.</span><span class="s3">\n    </span><span class="s1">soft, exampleA, exampleB) {</span><span class="s3">\n        </span><span class="s1">this.a = a;</span><span class="s3">\n        </span><span class="s1">this.b = b;</span><span class="s3">\n        </span><span class="s1">this.soft = soft;</span><span class="s3">\n        </span><span class="s1">this.exampleA = exampleA;</span><span class="s3">\n        </span><span class="s1">this.exampleB = exampleB;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function exampleFromEdges(edges) {</span><span class="s3">\n    </span><span class="s1">let str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; edges.length; i++)</span><span class="s3">\n        </span><span class="s1">str += String.fromCharCode(edges[i].from);</span><span class="s3">\n    </span><span class="s1">return str;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ids(elts) {</span><span class="s3">\n    </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let elt of elts) {</span><span class="s3">\n        </span><span class="s1">if (result.length)</span><span class="s3">\n            </span><span class="s1">result += </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">result += elt.id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameSet$1(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (a[i] != b[i])</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class MergedEdge {</span><span class="s3">\n    </span><span class="s1">constructor(from, to, targets) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.targets = targets;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Merge multiple edges (tagged by character ranges) into a set of</span><span class="s3">\n</span><span class="s1">// mutually exclusive ranges pointing at all target states for that</span><span class="s3">\n</span><span class="s1">// range</span><span class="s3">\n</span><span class="s1">function mergeEdges(edges) {</span><span class="s3">\n    </span><span class="s1">let separate = [], result = [];</span><span class="s3">\n    </span><span class="s1">for (let edge of edges) {</span><span class="s3">\n        </span><span class="s1">if (!separate.includes(edge.from))</span><span class="s3">\n            </span><span class="s1">separate.push(edge.from);</span><span class="s3">\n        </span><span class="s1">if (!separate.includes(edge.to))</span><span class="s3">\n            </span><span class="s1">separate.push(edge.to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">separate.sort((a, b) =&gt; a - b);</span><span class="s3">\n    </span><span class="s1">for (let i = 1; i &lt; separate.length; i++) {</span><span class="s3">\n        </span><span class="s1">let from = separate[i - 1], to = separate[i];</span><span class="s3">\n        </span><span class="s1">let found = [];</span><span class="s3">\n        </span><span class="s1">for (let edge of edges)</span><span class="s3">\n            </span><span class="s1">if (edge.to &gt; from &amp;&amp; edge.from &lt; to) {</span><span class="s3">\n                </span><span class="s1">for (let target of edge.target.closure())</span><span class="s3">\n                    </span><span class="s1">if (!found.includes(target))</span><span class="s3">\n                        </span><span class="s1">found.push(target);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (found.length)</span><span class="s3">\n            </span><span class="s1">result.push(new MergedEdge(from, to, found));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let eof = edges.filter(e =&gt; e.from == 65535 /* Seq.End */ &amp;&amp; e.to == 65535 /* Seq.End */);</span><span class="s3">\n    </span><span class="s1">if (eof.length) {</span><span class="s3">\n        </span><span class="s1">let found = [];</span><span class="s3">\n        </span><span class="s1">for (let edge of eof)</span><span class="s3">\n            </span><span class="s1">for (let target of edge.target.closure())</span><span class="s3">\n                </span><span class="s1">if (!found.includes(target))</span><span class="s3">\n                    </span><span class="s1">found.push(target);</span><span class="s3">\n        </span><span class="s1">if (found.length)</span><span class="s3">\n            </span><span class="s1">result.push(new MergedEdge(65535 /* Seq.End */, 65535 /* Seq.End */, found));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Note that this is the parser for grammar files, not the generated parser</span><span class="s3">\n</span><span class="s1">let word = /[</span><span class="s3">\\</span><span class="s1">w_-]+/gy;</span><span class="s3">\n</span><span class="s1">// Some engines (specifically SpiderMonkey) have still not implemented </span><span class="s3">\\</span><span class="s1">p</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">word = /[</span><span class="s3">\\</span><span class="s1">p{Alphabetic}</span><span class="s3">\\</span><span class="s1">d_-]+/ugy;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">catch (_) { }</span><span class="s3">\n</span><span class="s1">const none$2 = [];</span><span class="s3">\n</span><span class="s1">class Input {</span><span class="s3">\n    </span><span class="s1">constructor(string, fileName = null) {</span><span class="s3">\n        </span><span class="s1">this.string = string;</span><span class="s3">\n        </span><span class="s1">this.fileName = fileName;</span><span class="s3">\n        </span><span class="s1">this.type = </span><span class="s3">\&quot;</span><span class="s1">sof</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.value = null;</span><span class="s3">\n        </span><span class="s1">this.start = 0;</span><span class="s3">\n        </span><span class="s1">this.end = 0;</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineInfo(pos) {</span><span class="s3">\n        </span><span class="s1">for (let line = 1, cur = 0;;) {</span><span class="s3">\n            </span><span class="s1">let next = this.string.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, cur);</span><span class="s3">\n            </span><span class="s1">if (next &gt; -1 &amp;&amp; next &lt; pos) {</span><span class="s3">\n                </span><span class="s1">++line;</span><span class="s3">\n                </span><span class="s1">cur = next + 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return { line, ch: pos - cur };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">message(msg, pos = -1) {</span><span class="s3">\n        </span><span class="s1">let posInfo = this.fileName || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (pos &gt; -1) {</span><span class="s3">\n            </span><span class="s1">let info = this.lineInfo(pos);</span><span class="s3">\n            </span><span class="s1">posInfo += (posInfo ? </span><span class="s3">\&quot; \&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + info.line + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ info.ch;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return posInfo ? msg + ` (${posInfo})` : msg;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">raise(msg, pos = -1) {</span><span class="s3">\n        </span><span class="s1">throw new GenError(this.message(msg, pos));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">match(pos, re) {</span><span class="s3">\n        </span><span class="s1">let match = re.exec(this.string.slice(pos));</span><span class="s3">\n        </span><span class="s1">return match ? pos + match[0].length : -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">let start = this.match(this.end, /^(</span><span class="s3">\\</span><span class="s1">s|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/.*|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">*[^]*?</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">/)*/);</span><span class="s3">\n        </span><span class="s1">if (start == this.string.length)</span><span class="s3">\n            </span><span class="s1">return this.set(</span><span class="s3">\&quot;</span><span class="s1">eof</span><span class="s3">\&quot;</span><span class="s1">, null, start, start);</span><span class="s3">\n        </span><span class="s1">let next = this.string[start];</span><span class="s3">\n        </span><span class="s1">if (next == '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n            </span><span class="s1">let end = this.match(start + 1, /^(</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\&quot;\\\\</span><span class="s1">])*</span><span class="s3">\&quot;</span><span class="s1">/);</span><span class="s3">\n            </span><span class="s1">if (end == -1)</span><span class="s3">\n                </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">Unterminated string literal</span><span class="s3">\&quot;</span><span class="s1">, start);</span><span class="s3">\n            </span><span class="s1">return this.set(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, readString(this.string.slice(start + 1, end - 1)), start, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let end = this.match(start + 1, /^(</span><span class="s3">\\\\</span><span class="s1">.|[^'</span><span class="s3">\\\\</span><span class="s1">])*'/);</span><span class="s3">\n            </span><span class="s1">if (end == -1)</span><span class="s3">\n                </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">Unterminated string literal</span><span class="s3">\&quot;</span><span class="s1">, start);</span><span class="s3">\n            </span><span class="s1">return this.set(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, readString(this.string.slice(start + 1, end - 1)), start, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">word.lastIndex = start + 1;</span><span class="s3">\n            </span><span class="s1">let m = word.exec(this.string);</span><span class="s3">\n            </span><span class="s1">if (!m)</span><span class="s3">\n                </span><span class="s1">return this.raise(</span><span class="s3">\&quot;</span><span class="s1">@ without a name</span><span class="s3">\&quot;</span><span class="s1">, start);</span><span class="s3">\n            </span><span class="s1">return this.set(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, m[0], start, start + 1 + m[0].length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((next == </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">|| next == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; this.string[start + 1] == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let end = this.match(start + 2, /^(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">])*</span><span class="s3">\\</span><span class="s1">]/);</span><span class="s3">\n            </span><span class="s1">if (end == -1)</span><span class="s3">\n                </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">Unterminated character set</span><span class="s3">\&quot;</span><span class="s1">, start);</span><span class="s3">\n            </span><span class="s1">return this.set(</span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">, this.string.slice(start + 2, end - 1), start, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (/[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]()!~+*?{}&lt;&gt;</span><span class="s3">\\</span><span class="s1">.,|:$=]/.test(next)) {</span><span class="s3">\n            </span><span class="s1">return this.set(next, null, start, start + 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">word.lastIndex = start;</span><span class="s3">\n            </span><span class="s1">let m = word.exec(this.string);</span><span class="s3">\n            </span><span class="s1">if (!m)</span><span class="s3">\n                </span><span class="s1">return this.raise(</span><span class="s3">\&quot;</span><span class="s1">Unexpected character </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(next), start);</span><span class="s3">\n            </span><span class="s1">return this.set(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, m[0], start, start + m[0].length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(type, value, start, end) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n        </span><span class="s1">this.end = end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eat(type, value = null) {</span><span class="s3">\n        </span><span class="s1">if (this.type == type &amp;&amp; (value == null || this.value === value)) {</span><span class="s3">\n            </span><span class="s1">this.next();</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unexpected() {</span><span class="s3">\n        </span><span class="s1">return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">expect(type, value = null) {</span><span class="s3">\n        </span><span class="s1">let val = this.value;</span><span class="s3">\n        </span><span class="s1">if (this.type != type || !(value == null || val === value))</span><span class="s3">\n            </span><span class="s1">this.unexpected();</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">return val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parse() {</span><span class="s3">\n        </span><span class="s1">return parseGrammar(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseGrammar(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">let rules = [];</span><span class="s3">\n    </span><span class="s1">let prec = null;</span><span class="s3">\n    </span><span class="s1">let tokens = null;</span><span class="s3">\n    </span><span class="s1">let localTokens = [];</span><span class="s3">\n    </span><span class="s1">let mainSkip = null;</span><span class="s3">\n    </span><span class="s1">let scopedSkip = [];</span><span class="s3">\n    </span><span class="s1">let dialects = [];</span><span class="s3">\n    </span><span class="s1">let context = null;</span><span class="s3">\n    </span><span class="s1">let external = [];</span><span class="s3">\n    </span><span class="s1">let specialized = [];</span><span class="s3">\n    </span><span class="s1">let props = [];</span><span class="s3">\n    </span><span class="s1">let propSources = [];</span><span class="s3">\n    </span><span class="s1">let tops = [];</span><span class="s3">\n    </span><span class="s1">let sawTop = false;</span><span class="s3">\n    </span><span class="s1">let autoDelim = false;</span><span class="s3">\n    </span><span class="s1">while (input.type != </span><span class="s3">\&quot;</span><span class="s1">eof</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let start = input.start;</span><span class="s3">\n        </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">if (input.type != </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">input.raise(`Top rules must have a name`, input.start);</span><span class="s3">\n            </span><span class="s1">tops.push(parseRule(input, parseIdent(input)));</span><span class="s3">\n            </span><span class="s1">sawTop = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; input.value == </span><span class="s3">\&quot;</span><span class="s1">tokens</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (tokens)</span><span class="s3">\n                </span><span class="s1">input.raise(`Multiple @tokens declaractions`, input.start);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">tokens = parseTokens(input);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">tokens</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">localTokens.push(parseLocalTokens(input, start));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">context</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">if (context)</span><span class="s3">\n                </span><span class="s1">input.raise(`Multiple @context declarations`, start);</span><span class="s3">\n            </span><span class="s1">let id = parseIdent(input);</span><span class="s3">\n            </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">let source = input.expect(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">context = new ContextDeclaration(start, id, source);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">external</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">tokens</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">external.push(parseExternalTokens(input, start));</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">props.push(parseExternalProp(input, start));</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">specialized.push(parseExternalSpecialize(input, </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot;</span><span class="s1">, start));</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">specialize</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">specialized.push(parseExternalSpecialize(input, </span><span class="s3">\&quot;</span><span class="s1">specialize</span><span class="s3">\&quot;</span><span class="s1">, start));</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">propSource</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">propSources.push(parseExternalPropSource(input, start));</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">input.unexpected();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dialects</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">for (let first = true; !input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">); first = false) {</span><span class="s3">\n                </span><span class="s1">if (!first)</span><span class="s3">\n                    </span><span class="s1">input.eat(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">dialects.push(parseIdent(input));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; input.value == </span><span class="s3">\&quot;</span><span class="s1">precedence</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (prec)</span><span class="s3">\n                </span><span class="s1">input.raise(`Multiple precedence declarations`, input.start);</span><span class="s3">\n            </span><span class="s1">prec = parsePrecedence(input);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">detectDelim</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">autoDelim = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">skip</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">let skip = parseBracedExpr(input);</span><span class="s3">\n            </span><span class="s1">if (input.type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">input.next();</span><span class="s3">\n                </span><span class="s1">let rules = [], topRules = [];</span><span class="s3">\n                </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                    </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                        </span><span class="s1">topRules.push(parseRule(input, parseIdent(input)));</span><span class="s3">\n                        </span><span class="s1">sawTop = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">rules.push(parseRule(input));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">scopedSkip.push({ expr: skip, topRules, rules });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (mainSkip)</span><span class="s3">\n                    </span><span class="s1">input.raise(`Multiple top-level skip declarations`, input.start);</span><span class="s3">\n                </span><span class="s1">mainSkip = skip;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">rules.push(parseRule(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!sawTop)</span><span class="s3">\n        </span><span class="s1">return input.raise(`Missing @top declaration`);</span><span class="s3">\n    </span><span class="s1">return new GrammarDeclaration(start, rules, tops, tokens, localTokens, context, external, specialized, propSources, prec, mainSkip, scopedSkip, dialects, props, autoDelim);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseRule(input, named) {</span><span class="s3">\n    </span><span class="s1">let start = named ? named.start : input.start;</span><span class="s3">\n    </span><span class="s1">let id = named || parseIdent(input);</span><span class="s3">\n    </span><span class="s1">let props = parseProps(input);</span><span class="s3">\n    </span><span class="s1">let params = [];</span><span class="s3">\n    </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">if (params.length)</span><span class="s3">\n                </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">params.push(parseIdent(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let expr = parseBracedExpr(input);</span><span class="s3">\n    </span><span class="s1">return new RuleDeclaration(start, id, props, params, expr);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseProps(input) {</span><span class="s3">\n    </span><span class="s1">if (input.type != </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return none$2;</span><span class="s3">\n    </span><span class="s1">let props = [];</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (props.length)</span><span class="s3">\n            </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">props.push(parseProp(input));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return props;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseProp(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start, value = [], name = input.value, at = input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">input.unexpected();</span><span class="s3">\n    </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (input.type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">value.push(new PropPart(input.start, input.value, null));</span><span class="s3">\n                </span><span class="s1">input.next();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">value.push(new PropPart(input.start, </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">, null));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">value.push(new PropPart(input.start, null, input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n                </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new Prop(start, at, name, value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseBracedExpr(input) {</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let expr = parseExprChoice(input);</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return expr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const SET_MARKER = </span><span class="s3">\&quot;\\</span><span class="s1">ufdda</span><span class="s3">\&quot;</span><span class="s1">; // (Invalid unicode character)</span><span class="s3">\n</span><span class="s1">function parseExprInner(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">return new SequenceExpression(start, none$2, [none$2, none$2]);</span><span class="s3">\n        </span><span class="s1">let expr = parseExprChoice(input);</span><span class="s3">\n        </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return expr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let value = input.value;</span><span class="s3">\n        </span><span class="s1">input.next();</span><span class="s3">\n        </span><span class="s1">if (value.length == 0)</span><span class="s3">\n            </span><span class="s1">return new SequenceExpression(start, none$2, [none$2, none$2]);</span><span class="s3">\n        </span><span class="s1">return new LiteralExpression(start, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">return new AnyExpression(start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let content = input.value, invert = input.string[input.start] == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let unescaped = readString(content.replace(/</span><span class="s3">\\\\</span><span class="s1">.|-|</span><span class="s3">\&quot;</span><span class="s1">/g, (m) =&gt; {</span><span class="s3">\n            </span><span class="s1">return m == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">? SET_MARKER : m == '</span><span class="s3">\&quot;</span><span class="s1">' ? '</span><span class="s3">\\\\\&quot;</span><span class="s1">' : m;</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">let ranges = [];</span><span class="s3">\n        </span><span class="s1">for (let pos = 0; pos &lt; unescaped.length;) {</span><span class="s3">\n            </span><span class="s1">let code = unescaped.codePointAt(pos);</span><span class="s3">\n            </span><span class="s1">pos += code &gt; 0xffff ? 2 : 1;</span><span class="s3">\n            </span><span class="s1">if (pos &lt; unescaped.length - 1 &amp;&amp; unescaped[pos] == SET_MARKER) {</span><span class="s3">\n                </span><span class="s1">let end = unescaped.codePointAt(pos + 1);</span><span class="s3">\n                </span><span class="s1">pos += end &gt; 0xffff ? 3 : 2;</span><span class="s3">\n                </span><span class="s1">if (end &lt; code)</span><span class="s3">\n                    </span><span class="s1">input.raise(</span><span class="s3">\&quot;</span><span class="s1">Invalid character range</span><span class="s3">\&quot;</span><span class="s1">, input.start);</span><span class="s3">\n                </span><span class="s1">addRange(input, ranges, code, end + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (code == SET_MARKER.charCodeAt(0))</span><span class="s3">\n                    </span><span class="s1">code = 45;</span><span class="s3">\n                </span><span class="s1">addRange(input, ranges, code, code + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">input.next();</span><span class="s3">\n        </span><span class="s1">return new SetExpression(start, ranges.sort((a, b) =&gt; a[0] - b[0]), invert);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (input.value == </span><span class="s3">\&quot;</span><span class="s1">specialize</span><span class="s3">\&quot; </span><span class="s1">|| input.value == </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">let { start, value } = input;</span><span class="s3">\n        </span><span class="s1">input.next();</span><span class="s3">\n        </span><span class="s1">let props = parseProps(input);</span><span class="s3">\n        </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let token = parseExprChoice(input), content;</span><span class="s3">\n        </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">content = parseExprChoice(input);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (token instanceof LiteralExpression) {</span><span class="s3">\n            </span><span class="s1">content = token;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">input.raise(`@${value} requires two arguments when its first argument isn't a literal string`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return new SpecializeExpression(start, value, props, token, content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; CharClasses.hasOwnProperty(input.value)) {</span><span class="s3">\n        </span><span class="s1">let cls = new CharClass(input.start, input.value);</span><span class="s3">\n        </span><span class="s1">input.next();</span><span class="s3">\n        </span><span class="s1">return cls;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let rule = parseRule(input, new Identifier(start, </span><span class="s3">\&quot;</span><span class="s1">_anon</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">if (rule.params.length)</span><span class="s3">\n            </span><span class="s1">input.raise(`Inline rules can't have parameters`, rule.start);</span><span class="s3">\n        </span><span class="s1">return new InlineRuleExpression(start, rule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let id = parseIdent(input);</span><span class="s3">\n        </span><span class="s1">if (input.type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let rule = parseRule(input, id);</span><span class="s3">\n            </span><span class="s1">if (rule.params.length)</span><span class="s3">\n                </span><span class="s1">input.raise(`Inline rules can't have parameters`, rule.start);</span><span class="s3">\n            </span><span class="s1">return new InlineRuleExpression(start, rule);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; id.name == </span><span class="s3">\&quot;</span><span class="s1">std</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; CharClasses.hasOwnProperty(input.value)) {</span><span class="s3">\n                </span><span class="s1">let cls = new CharClass(start, input.value);</span><span class="s3">\n                </span><span class="s1">input.next();</span><span class="s3">\n                </span><span class="s1">return cls;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return new NameExpression(start, id, parseArgs(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseArgs(input) {</span><span class="s3">\n    </span><span class="s1">let args = [];</span><span class="s3">\n    </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">if (args.length)</span><span class="s3">\n                </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">args.push(parseExprChoice(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return args;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addRange(input, ranges, from, to) {</span><span class="s3">\n    </span><span class="s1">if (!ranges.every(([a, b]) =&gt; b &lt;= from || a &gt;= to))</span><span class="s3">\n        </span><span class="s1">input.raise(</span><span class="s3">\&quot;</span><span class="s1">Overlapping character range</span><span class="s3">\&quot;</span><span class="s1">, input.start);</span><span class="s3">\n    </span><span class="s1">ranges.push([from, to]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExprSuffix(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">let expr = parseExprInner(input);</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let kind = input.type;</span><span class="s3">\n        </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) || input.eat(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) || input.eat(</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">expr = new RepeatExpression(start, expr, kind);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return expr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function endOfSequence(input) {</span><span class="s3">\n    </span><span class="s1">return input.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">input.type == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">|| input.type == </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExprSequence(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start, exprs = [], markers = [none$2];</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">// Add markers at this position</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let localStart = input.start, markerType;</span><span class="s3">\n            </span><span class="s1">if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">markerType = </span><span class="s3">\&quot;</span><span class="s1">ambig</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">markerType = </span><span class="s3">\&quot;</span><span class="s1">prec</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">markers[markers.length - 1] =</span><span class="s3">\n                </span><span class="s1">markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (endOfSequence(input))</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">exprs.push(parseExprSuffix(input));</span><span class="s3">\n        </span><span class="s1">markers.push(none$2);</span><span class="s3">\n    </span><span class="s1">} while (!endOfSequence(input));</span><span class="s3">\n    </span><span class="s1">if (exprs.length == 1 &amp;&amp; markers.every(ms =&gt; ms.length == 0))</span><span class="s3">\n        </span><span class="s1">return exprs[0];</span><span class="s3">\n    </span><span class="s1">return new SequenceExpression(start, exprs, markers, !exprs.length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExprChoice(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start, left = parseExprSequence(input);</span><span class="s3">\n    </span><span class="s1">if (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">return left;</span><span class="s3">\n    </span><span class="s1">let exprs = [left];</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">exprs.push(parseExprSequence(input));</span><span class="s3">\n    </span><span class="s1">} while (input.eat(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">let empty = exprs.find(s =&gt; s instanceof SequenceExpression &amp;&amp; s.empty);</span><span class="s3">\n    </span><span class="s1">if (empty)</span><span class="s3">\n        </span><span class="s1">input.raise(</span><span class="s3">\&quot;</span><span class="s1">Empty expression in choice operator. If this is intentional, use () to make it explicit.</span><span class="s3">\&quot;</span><span class="s1">, empty.start);</span><span class="s3">\n    </span><span class="s1">return new ChoiceExpression(start, exprs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseIdent(input) {</span><span class="s3">\n    </span><span class="s1">if (input.type != </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">input.unexpected();</span><span class="s3">\n    </span><span class="s1">let start = input.start, name = input.value;</span><span class="s3">\n    </span><span class="s1">input.next();</span><span class="s3">\n    </span><span class="s1">return new Identifier(start, name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parsePrecedence(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">input.next();</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let items = [];</span><span class="s3">\n    </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (items.length)</span><span class="s3">\n            </span><span class="s1">input.eat(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">items.push({</span><span class="s3">\n            </span><span class="s1">id: parseIdent(input),</span><span class="s3">\n            </span><span class="s1">type: input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) ? </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot; </span><span class="s1">: input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">) ? </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot; </span><span class="s1">: input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cut</span><span class="s3">\&quot;</span><span class="s1">) ? </span><span class="s3">\&quot;</span><span class="s1">cut</span><span class="s3">\&quot; </span><span class="s1">: null</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new PrecDeclaration(start, items);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseTokens(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">input.next();</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let tokenRules = [];</span><span class="s3">\n    </span><span class="s1">let literals = [];</span><span class="s3">\n    </span><span class="s1">let precedences = [];</span><span class="s3">\n    </span><span class="s1">let conflicts = [];</span><span class="s3">\n    </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; input.value == </span><span class="s3">\&quot;</span><span class="s1">precedence</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">precedences.push(parseTokenPrecedence(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; input.value == </span><span class="s3">\&quot;</span><span class="s1">conflict</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">conflicts.push(parseTokenConflict(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">literals.push(new LiteralDeclaration(input.start, input.expect(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">), parseProps(input)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">tokenRules.push(parseRule(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseLocalTokens(input, start) {</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let tokenRules = [];</span><span class="s3">\n    </span><span class="s1">let precedences = [];</span><span class="s3">\n    </span><span class="s1">let fallback = null;</span><span class="s3">\n    </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (input.type == </span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; input.value == </span><span class="s3">\&quot;</span><span class="s1">precedence</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">precedences.push(parseTokenPrecedence(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.eat(</span><span class="s3">\&quot;</span><span class="s1">at</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !fallback) {</span><span class="s3">\n            </span><span class="s1">fallback = { id: parseIdent(input), props: parseProps(input) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">tokenRules.push(parseRule(input));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new LocalTokenDeclaration(start, precedences, tokenRules, fallback);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseTokenPrecedence(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">input.next();</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let tokens = [];</span><span class="s3">\n    </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (tokens.length)</span><span class="s3">\n            </span><span class="s1">input.eat(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let expr = parseExprInner(input);</span><span class="s3">\n        </span><span class="s1">if (expr instanceof LiteralExpression || expr instanceof NameExpression)</span><span class="s3">\n            </span><span class="s1">tokens.push(expr);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">input.raise(`Invalid expression in token precedences`, expr.start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new TokenPrecDeclaration(start, tokens);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseTokenConflict(input) {</span><span class="s3">\n    </span><span class="s1">let start = input.start;</span><span class="s3">\n    </span><span class="s1">input.next();</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let a = parseExprInner(input);</span><span class="s3">\n    </span><span class="s1">if (!(a instanceof LiteralExpression || a instanceof NameExpression))</span><span class="s3">\n        </span><span class="s1">input.raise(`Invalid expression in token conflict`, a.start);</span><span class="s3">\n    </span><span class="s1">input.eat(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let b = parseExprInner(input);</span><span class="s3">\n    </span><span class="s1">if (!(b instanceof LiteralExpression || b instanceof NameExpression))</span><span class="s3">\n        </span><span class="s1">input.raise(`Invalid expression in token conflict`, b.start);</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return new TokenConflictDeclaration(start, a, b);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExternalTokenSet(input) {</span><span class="s3">\n    </span><span class="s1">let tokens = [];</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">while (!input.eat(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (tokens.length)</span><span class="s3">\n            </span><span class="s1">input.eat(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let id = parseIdent(input);</span><span class="s3">\n        </span><span class="s1">let props = parseProps(input);</span><span class="s3">\n        </span><span class="s1">tokens.push({ id, props });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tokens;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExternalTokens(input, start) {</span><span class="s3">\n    </span><span class="s1">let id = parseIdent(input);</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let from = input.expect(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExternalSpecialize(input, type, start) {</span><span class="s3">\n    </span><span class="s1">let token = parseBracedExpr(input);</span><span class="s3">\n    </span><span class="s1">let id = parseIdent(input);</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let from = input.expect(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExternalPropSource(input, start) {</span><span class="s3">\n    </span><span class="s1">let id = parseIdent(input);</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return new ExternalPropSourceDeclaration(start, id, input.expect(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseExternalProp(input, start) {</span><span class="s3">\n    </span><span class="s1">let externalID = parseIdent(input);</span><span class="s3">\n    </span><span class="s1">let id = input.eat(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">as</span><span class="s3">\&quot;</span><span class="s1">) ? parseIdent(input) : externalID;</span><span class="s3">\n    </span><span class="s1">input.expect(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let from = input.expect(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return new ExternalPropDeclaration(start, id, externalID, from);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readString(string) {</span><span class="s3">\n    </span><span class="s1">let point = /</span><span class="s3">\\\\</span><span class="s1">(?:u</span><span class="s3">\\</span><span class="s1">{([</span><span class="s3">\\</span><span class="s1">da-f]+)</span><span class="s3">\\</span><span class="s1">}|u([</span><span class="s3">\\</span><span class="s1">da-f]{4})|x([</span><span class="s3">\\</span><span class="s1">da-f]{2})|([ntbrf0])|(.))|[^]/yig;</span><span class="s3">\n    </span><span class="s1">let out = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, m;</span><span class="s3">\n    </span><span class="s1">while (m = point.exec(string)) {</span><span class="s3">\n        </span><span class="s1">let [all, u1, u2, u3, single, unknown] = m;</span><span class="s3">\n        </span><span class="s1">if (u1 || u2 || u3)</span><span class="s3">\n            </span><span class="s1">out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16));</span><span class="s3">\n        </span><span class="s1">else if (single)</span><span class="s3">\n            </span><span class="s1">out += single == </span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">: single == </span><span class="s3">\&quot;</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">: single == </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">: single == </span><span class="s3">\&quot;</span><span class="s1">r</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot; </span><span class="s1">: single == </span><span class="s3">\&quot;</span><span class="s1">f</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">f</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\\</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">else if (unknown)</span><span class="s3">\n            </span><span class="s1">out += unknown;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">out += all;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return out;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hash(a, b) { return (a &lt;&lt; 5) + a + b; }</span><span class="s3">\n</span><span class="s1">function hashString(h, s) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; s.length; i++)</span><span class="s3">\n        </span><span class="s1">h = hash(h, s.charCodeAt(i));</span><span class="s3">\n    </span><span class="s1">return h;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const verbose = (typeof process != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; process.env.LOG) || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const timing = /</span><span class="s3">\\</span><span class="s1">btime</span><span class="s3">\\</span><span class="s1">b/.test(verbose);</span><span class="s3">\n</span><span class="s1">const time = timing ? (label, f) =&gt; {</span><span class="s3">\n    </span><span class="s1">let t0 = Date.now();</span><span class="s3">\n    </span><span class="s1">let result = f();</span><span class="s3">\n    </span><span class="s1">console.log(`${label} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">} : (_label, f) =&gt; f();</span><span class="s3">\n\n</span><span class="s1">class Pos {</span><span class="s3">\n    </span><span class="s1">constructor(rule, pos, </span><span class="s3">\n    </span><span class="s1">// NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called</span><span class="s3">\n    </span><span class="s1">ahead, ambigAhead, skipAhead, via) {</span><span class="s3">\n        </span><span class="s1">this.rule = rule;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.ahead = ahead;</span><span class="s3">\n        </span><span class="s1">this.ambigAhead = ambigAhead;</span><span class="s3">\n        </span><span class="s1">this.skipAhead = skipAhead;</span><span class="s3">\n        </span><span class="s1">this.via = via;</span><span class="s3">\n        </span><span class="s1">this.hash = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash);</span><span class="s3">\n        </span><span class="s1">for (let a of this.ahead)</span><span class="s3">\n            </span><span class="s1">h = hash(h, a.hash);</span><span class="s3">\n        </span><span class="s1">for (let group of this.ambigAhead)</span><span class="s3">\n            </span><span class="s1">h = hashString(h, group);</span><span class="s3">\n        </span><span class="s1">this.hash = h;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get next() {</span><span class="s3">\n        </span><span class="s1">return this.pos &lt; this.rule.parts.length ? this.rule.parts[this.pos] : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">advance() {</span><span class="s3">\n        </span><span class="s1">return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get skip() {</span><span class="s3">\n        </span><span class="s1">return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cmp(pos) {</span><span class="s3">\n        </span><span class="s1">return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||</span><span class="s3">\n            </span><span class="s1">cmpSet(this.ahead, pos.ahead, (a, b) =&gt; a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eqSimple(pos) {</span><span class="s3">\n        </span><span class="s1">return pos.rule == this.rule &amp;&amp; pos.pos == this.pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let parts = this.rule.parts.map(t =&gt; t.name);</span><span class="s3">\n        </span><span class="s1">parts.splice(this.pos, 0, </span><span class="s3">\&quot;</span><span class="s1">·</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return `${this.rule.name} -&gt; ${parts.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return this == other ||</span><span class="s3">\n            </span><span class="s1">this.hash == other.hash &amp;&amp; this.rule == other.rule &amp;&amp; this.pos == other.pos &amp;&amp; this.skipAhead == other.skipAhead &amp;&amp;</span><span class="s3">\n                </span><span class="s1">sameSet(this.ahead, other.ahead) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">sameSet(this.ambigAhead, other.ambigAhead);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">trail(maxLen = 60) {</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let pos = this; pos; pos = pos.via) {</span><span class="s3">\n            </span><span class="s1">for (let i = pos.pos - 1; i &gt;= 0; i--)</span><span class="s3">\n                </span><span class="s1">result.push(pos.rule.parts[i]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let value = result.reverse().join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (value.length &gt; maxLen)</span><span class="s3">\n            </span><span class="s1">value = value.slice(value.length - maxLen).replace(/.*? /, </span><span class="s3">\&quot;</span><span class="s1">… </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">conflicts(pos = this.pos) {</span><span class="s3">\n        </span><span class="s1">let result = this.rule.conflicts[pos];</span><span class="s3">\n        </span><span class="s1">if (pos == this.rule.parts.length &amp;&amp; this.ambigAhead.length)</span><span class="s3">\n            </span><span class="s1">result = result.join(new Conflicts(0, this.ambigAhead));</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static addOrigins(group, context) {</span><span class="s3">\n        </span><span class="s1">let result = group.slice();</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; result.length; i++) {</span><span class="s3">\n            </span><span class="s1">let next = result[i];</span><span class="s3">\n            </span><span class="s1">if (next.pos == 0)</span><span class="s3">\n                </span><span class="s1">for (let pos of context) {</span><span class="s3">\n                    </span><span class="s1">if (pos.next == next.rule.name &amp;&amp; !result.includes(pos))</span><span class="s3">\n                        </span><span class="s1">result.push(pos);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function conflictsAt(group) {</span><span class="s3">\n    </span><span class="s1">let result = Conflicts.none;</span><span class="s3">\n    </span><span class="s1">for (let pos of group)</span><span class="s3">\n        </span><span class="s1">result = result.join(pos.conflicts());</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Applies automatic action precedence based on repeat productions.</span><span class="s3">\n</span><span class="s1">// These are left-associative, so reducing the `R -&gt; R R` rule has</span><span class="s3">\n</span><span class="s1">// higher precedence.</span><span class="s3">\n</span><span class="s1">function compareRepeatPrec(a, b) {</span><span class="s3">\n    </span><span class="s1">for (let pos of a)</span><span class="s3">\n        </span><span class="s1">if (pos.rule.name.repeated) {</span><span class="s3">\n            </span><span class="s1">for (let posB of b)</span><span class="s3">\n                </span><span class="s1">if (posB.rule.name == pos.rule.name) {</span><span class="s3">\n                    </span><span class="s1">if (pos.rule.isRepeatWrap &amp;&amp; pos.pos == 2)</span><span class="s3">\n                        </span><span class="s1">return 1;</span><span class="s3">\n                    </span><span class="s1">if (posB.rule.isRepeatWrap &amp;&amp; posB.pos == 2)</span><span class="s3">\n                        </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cmpStr(a, b) {</span><span class="s3">\n    </span><span class="s1">return a &lt; b ? -1 : a &gt; b ? 1 : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function termsAhead(rule, pos, after, first) {</span><span class="s3">\n    </span><span class="s1">let found = [];</span><span class="s3">\n    </span><span class="s1">for (let i = pos + 1; i &lt; rule.parts.length; i++) {</span><span class="s3">\n        </span><span class="s1">let next = rule.parts[i], cont = false;</span><span class="s3">\n        </span><span class="s1">if (next.terminal) {</span><span class="s3">\n            </span><span class="s1">addTo(next, found);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">for (let term of first[next.name]) {</span><span class="s3">\n                </span><span class="s1">if (term == null)</span><span class="s3">\n                    </span><span class="s1">cont = true;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">addTo(term, found);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!cont)</span><span class="s3">\n            </span><span class="s1">return found;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let a of after)</span><span class="s3">\n        </span><span class="s1">addTo(a, found);</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function eqSet(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (!a[i].eq(b[i]))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameSet(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (a[i] != b[i])</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Shift {</span><span class="s3">\n    </span><span class="s1">constructor(term, target) {</span><span class="s3">\n        </span><span class="s1">this.term = term;</span><span class="s3">\n        </span><span class="s1">this.target = target;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return other instanceof Shift &amp;&amp; this.term == other.term &amp;&amp; other.target.id == this.target.id; }</span><span class="s3">\n    </span><span class="s1">cmp(other) { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id; }</span><span class="s3">\n    </span><span class="s1">matches(other, mapping) {</span><span class="s3">\n        </span><span class="s1">return other instanceof Shift &amp;&amp; mapping[other.target.id] == mapping[this.target.id];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return </span><span class="s3">\&quot;</span><span class="s1">s</span><span class="s3">\&quot; </span><span class="s1">+ this.target.id; }</span><span class="s3">\n    </span><span class="s1">map(mapping, states) {</span><span class="s3">\n        </span><span class="s1">let mapped = states[mapping[this.target.id]];</span><span class="s3">\n        </span><span class="s1">return mapped == this.target ? this : new Shift(this.term, mapped);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Reduce {</span><span class="s3">\n    </span><span class="s1">constructor(term, rule) {</span><span class="s3">\n        </span><span class="s1">this.term = term;</span><span class="s3">\n        </span><span class="s1">this.rule = rule;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return other instanceof Reduce &amp;&amp; this.term == other.term &amp;&amp; other.rule.sameReduce(this.rule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cmp(other) {</span><span class="s3">\n        </span><span class="s1">return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||</span><span class="s3">\n            </span><span class="s1">this.rule.parts.length - other.rule.parts.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matches(other, mapping) {</span><span class="s3">\n        </span><span class="s1">return other instanceof Reduce &amp;&amp; other.rule.sameReduce(this.rule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return `${this.rule.name.name}(${this.rule.parts.length})`; }</span><span class="s3">\n    </span><span class="s1">map() { return this; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hashPositions(set) {</span><span class="s3">\n    </span><span class="s1">let h = 5381;</span><span class="s3">\n    </span><span class="s1">for (let pos of set)</span><span class="s3">\n        </span><span class="s1">h = hash(h, pos.hash);</span><span class="s3">\n    </span><span class="s1">return h;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ConflictContext {</span><span class="s3">\n    </span><span class="s1">constructor(first) {</span><span class="s3">\n        </span><span class="s1">this.first = first;</span><span class="s3">\n        </span><span class="s1">this.conflicts = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class State {</span><span class="s3">\n    </span><span class="s1">constructor(id, set, flags = 0, skip, hash = hashPositions(set), startRule = null) {</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.set = set;</span><span class="s3">\n        </span><span class="s1">this.flags = flags;</span><span class="s3">\n        </span><span class="s1">this.skip = skip;</span><span class="s3">\n        </span><span class="s1">this.hash = hash;</span><span class="s3">\n        </span><span class="s1">this.startRule = startRule;</span><span class="s3">\n        </span><span class="s1">this.actions = [];</span><span class="s3">\n        </span><span class="s1">this.actionPositions = [];</span><span class="s3">\n        </span><span class="s1">this.goto = [];</span><span class="s3">\n        </span><span class="s1">this.tokenGroup = -1;</span><span class="s3">\n        </span><span class="s1">this.defaultReduce = null;</span><span class="s3">\n        </span><span class="s1">this._actionsByTerm = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let actions = this.actions.map(t =&gt; t.term + </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">+ t).join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) +</span><span class="s3">\n            </span><span class="s1">(this.goto.length ? </span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot; </span><span class="s1">+ this.goto.map(g =&gt; g.term + </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">+ g).join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return this.id + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ this.set.filter(p =&gt; p.pos &gt; 0).join() +</span><span class="s3">\n            </span><span class="s1">(this.defaultReduce ? `</span><span class="s3">\\</span><span class="s1">n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`</span><span class="s3">\n                </span><span class="s1">: actions.length ? </span><span class="s3">\&quot;\\</span><span class="s1">n  </span><span class="s3">\&quot; </span><span class="s1">+ actions : </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addActionInner(value, positions) {</span><span class="s3">\n        </span><span class="s1">check: for (let i = 0; i &lt; this.actions.length; i++) {</span><span class="s3">\n            </span><span class="s1">let action = this.actions[i];</span><span class="s3">\n            </span><span class="s1">if (action.term == value.term) {</span><span class="s3">\n                </span><span class="s1">if (action.eq(value))</span><span class="s3">\n                    </span><span class="s1">return null;</span><span class="s3">\n                </span><span class="s1">let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set);</span><span class="s3">\n                </span><span class="s1">let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos);</span><span class="s3">\n                </span><span class="s1">let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence;</span><span class="s3">\n                </span><span class="s1">if (diff &gt; 0) { // Drop the existing action</span><span class="s3">\n                    </span><span class="s1">this.actions.splice(i, 1);</span><span class="s3">\n                    </span><span class="s1">this.actionPositions.splice(i, 1);</span><span class="s3">\n                    </span><span class="s1">i--;</span><span class="s3">\n                    </span><span class="s1">continue check;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (diff &lt; 0) { // Drop this one</span><span class="s3">\n                    </span><span class="s1">return null;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (conflicts.ambigGroups.some(g =&gt; actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity</span><span class="s3">\n                    </span><span class="s1">continue check;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else { // Not resolved</span><span class="s3">\n                    </span><span class="s1">return action;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.actions.push(value);</span><span class="s3">\n        </span><span class="s1">this.actionPositions.push(positions);</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addAction(value, positions, context) {</span><span class="s3">\n        </span><span class="s1">let conflict = this.addActionInner(value, positions);</span><span class="s3">\n        </span><span class="s1">if (conflict) {</span><span class="s3">\n            </span><span class="s1">let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0];</span><span class="s3">\n            </span><span class="s1">let rules = [positions[0].rule.name, conflictPos.rule.name];</span><span class="s3">\n            </span><span class="s1">if (context.conflicts.some(c =&gt; c.rules.some(r =&gt; rules.includes(r))))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let error;</span><span class="s3">\n            </span><span class="s1">if (conflict instanceof Shift)</span><span class="s3">\n                </span><span class="s1">error = `shift/reduce conflict between</span><span class="s3">\\</span><span class="s1">n  ${conflictPos}</span><span class="s3">\\</span><span class="s1">nand</span><span class="s3">\\</span><span class="s1">n  ${positions[0].rule}`;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">error = `reduce/reduce conflict between</span><span class="s3">\\</span><span class="s1">n  ${conflictPos.rule}</span><span class="s3">\\</span><span class="s1">nand</span><span class="s3">\\</span><span class="s1">n  ${positions[0].rule}`;</span><span class="s3">\n            </span><span class="s1">error += `</span><span class="s3">\\</span><span class="s1">nWith input:</span><span class="s3">\\</span><span class="s1">n  ${positions[0].trail(70)} · ${value.term} …`;</span><span class="s3">\n            </span><span class="s1">if (conflict instanceof Shift)</span><span class="s3">\n                </span><span class="s1">error += findConflictShiftSource(positions[0], conflict.term, context.first);</span><span class="s3">\n            </span><span class="s1">error += findConflictOrigin(conflictPos, positions[0]);</span><span class="s3">\n            </span><span class="s1">context.conflicts.push(new Conflict(error, rules));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getGoto(term) {</span><span class="s3">\n        </span><span class="s1">return this.goto.find(a =&gt; a.term == term);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasSet(set) {</span><span class="s3">\n        </span><span class="s1">return eqSet(this.set, set);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">actionsByTerm() {</span><span class="s3">\n        </span><span class="s1">let result = this._actionsByTerm;</span><span class="s3">\n        </span><span class="s1">if (!result) {</span><span class="s3">\n            </span><span class="s1">this._actionsByTerm = result = Object.create(null);</span><span class="s3">\n            </span><span class="s1">for (let action of this.actions)</span><span class="s3">\n                </span><span class="s1">(result[action.term.id] || (result[action.term.id] = [])).push(action);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">if (this.actions.length) {</span><span class="s3">\n            </span><span class="s1">let first = this.actions[0];</span><span class="s3">\n            </span><span class="s1">if (first instanceof Reduce) {</span><span class="s3">\n                </span><span class="s1">let { rule } = first;</span><span class="s3">\n                </span><span class="s1">if (this.actions.every(a =&gt; a instanceof Reduce &amp;&amp; a.rule.sameReduce(rule)))</span><span class="s3">\n                    </span><span class="s1">this.defaultReduce = rule;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.actions.sort((a, b) =&gt; a.cmp(b));</span><span class="s3">\n        </span><span class="s1">this.goto.sort((a, b) =&gt; a.cmp(b));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">let dThis = this.defaultReduce, dOther = other.defaultReduce;</span><span class="s3">\n        </span><span class="s1">if (dThis || dOther)</span><span class="s3">\n            </span><span class="s1">return dThis &amp;&amp; dOther ? dThis.sameReduce(dOther) : false;</span><span class="s3">\n        </span><span class="s1">return this.skip == other.skip &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.tokenGroup == other.tokenGroup &amp;&amp;</span><span class="s3">\n            </span><span class="s1">eqSet(this.actions, other.actions) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">eqSet(this.goto, other.goto);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function closure(set, first) {</span><span class="s3">\n    </span><span class="s1">let added = [], redo = [];</span><span class="s3">\n    </span><span class="s1">function addFor(name, ahead, ambigAhead, skipAhead, via) {</span><span class="s3">\n        </span><span class="s1">for (let rule of name.rules) {</span><span class="s3">\n            </span><span class="s1">let add = added.find(a =&gt; a.rule == rule);</span><span class="s3">\n            </span><span class="s1">if (!add) {</span><span class="s3">\n                </span><span class="s1">let existing = set.find(p =&gt; p.pos == 0 &amp;&amp; p.rule == rule);</span><span class="s3">\n                </span><span class="s1">add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)</span><span class="s3">\n                    </span><span class="s1">: new Pos(rule, 0, [], none$1, skipAhead, via);</span><span class="s3">\n                </span><span class="s1">added.push(add);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (add.skipAhead != skipAhead)</span><span class="s3">\n                </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">Inconsistent skip sets after </span><span class="s3">\&quot; </span><span class="s1">+ via.trail());</span><span class="s3">\n            </span><span class="s1">add.ambigAhead = union(add.ambigAhead, ambigAhead);</span><span class="s3">\n            </span><span class="s1">for (let term of ahead)</span><span class="s3">\n                </span><span class="s1">if (!add.ahead.includes(term)) {</span><span class="s3">\n                    </span><span class="s1">add.ahead.push(term);</span><span class="s3">\n                    </span><span class="s1">if (add.rule.parts.length &amp;&amp; !add.rule.parts[0].terminal)</span><span class="s3">\n                        </span><span class="s1">addTo(add, redo);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let pos of set) {</span><span class="s3">\n        </span><span class="s1">let next = pos.next;</span><span class="s3">\n        </span><span class="s1">if (next &amp;&amp; !next.terminal)</span><span class="s3">\n            </span><span class="s1">addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first), pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip, pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (redo.length) {</span><span class="s3">\n        </span><span class="s1">let add = redo.pop();</span><span class="s3">\n        </span><span class="s1">addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first), union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none$1), add.rule.parts.length == 1 ? add.skipAhead : add.rule.skip, add);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let result = set.slice();</span><span class="s3">\n    </span><span class="s1">for (let add of added) {</span><span class="s3">\n        </span><span class="s1">add.ahead.sort((a, b) =&gt; a.hash - b.hash);</span><span class="s3">\n        </span><span class="s1">add.finish();</span><span class="s3">\n        </span><span class="s1">let origIndex = set.findIndex(p =&gt; p.pos == 0 &amp;&amp; p.rule == add.rule);</span><span class="s3">\n        </span><span class="s1">if (origIndex &gt; -1)</span><span class="s3">\n            </span><span class="s1">result[origIndex] = add;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">result.push(add);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result.sort((a, b) =&gt; a.cmp(b));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addTo(value, array) {</span><span class="s3">\n    </span><span class="s1">if (!array.includes(value))</span><span class="s3">\n        </span><span class="s1">array.push(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeFirstSets(terms) {</span><span class="s3">\n    </span><span class="s1">let table = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let t of terms.terms)</span><span class="s3">\n        </span><span class="s1">if (!t.terminal)</span><span class="s3">\n            </span><span class="s1">table[t.name] = [];</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let change = false;</span><span class="s3">\n        </span><span class="s1">for (let nt of terms.terms)</span><span class="s3">\n            </span><span class="s1">if (!nt.terminal)</span><span class="s3">\n                </span><span class="s1">for (let rule of nt.rules) {</span><span class="s3">\n                    </span><span class="s1">let set = table[nt.name];</span><span class="s3">\n                    </span><span class="s1">let found = false, startLen = set.length;</span><span class="s3">\n                    </span><span class="s1">for (let part of rule.parts) {</span><span class="s3">\n                        </span><span class="s1">found = true;</span><span class="s3">\n                        </span><span class="s1">if (part.terminal) {</span><span class="s3">\n                            </span><span class="s1">addTo(part, set);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">for (let t of table[part.name]) {</span><span class="s3">\n                                </span><span class="s1">if (t == null)</span><span class="s3">\n                                    </span><span class="s1">found = false;</span><span class="s3">\n                                </span><span class="s1">else</span><span class="s3">\n                                    </span><span class="s1">addTo(t, set);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (found)</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (!found)</span><span class="s3">\n                        </span><span class="s1">addTo(null, set);</span><span class="s3">\n                    </span><span class="s1">if (set.length &gt; startLen)</span><span class="s3">\n                        </span><span class="s1">change = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!change)</span><span class="s3">\n            </span><span class="s1">return table;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Core {</span><span class="s3">\n    </span><span class="s1">constructor(set, state) {</span><span class="s3">\n        </span><span class="s1">this.set = set;</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Conflict {</span><span class="s3">\n    </span><span class="s1">constructor(error, rules) {</span><span class="s3">\n        </span><span class="s1">this.error = error;</span><span class="s3">\n        </span><span class="s1">this.rules = rules;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findConflictOrigin(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.eqSimple(b))</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">function via(root, start) {</span><span class="s3">\n        </span><span class="s1">let hist = [];</span><span class="s3">\n        </span><span class="s1">for (let p = start.via; !p.eqSimple(root); p = p.via)</span><span class="s3">\n            </span><span class="s1">hist.push(p);</span><span class="s3">\n        </span><span class="s1">if (!hist.length)</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">hist.unshift(start);</span><span class="s3">\n        </span><span class="s1">return hist.reverse().map((p, i) =&gt; </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;  \&quot;</span><span class="s1">.repeat(i + 1) + (p == start ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">via </span><span class="s3">\&quot;</span><span class="s1">) + p).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let p = a; p; p = p.via)</span><span class="s3">\n        </span><span class="s1">for (let p2 = b; p2; p2 = p2.via) {</span><span class="s3">\n            </span><span class="s1">if (p.eqSimple(p2))</span><span class="s3">\n                </span><span class="s1">return </span><span class="s3">\&quot;\\</span><span class="s1">nShared origin: </span><span class="s3">\&quot; </span><span class="s1">+ p + via(p, a) + via(p, b);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Search for the reason that a given 'after' token exists at the</span><span class="s3">\n</span><span class="s1">// given pos, by scanning up the trail of positions. Because the `via`</span><span class="s3">\n</span><span class="s1">// link is only one source of a pos, of potentially many, this</span><span class="s3">\n</span><span class="s1">// requires a re-simulation of the whole path up to the pos.</span><span class="s3">\n</span><span class="s1">function findConflictShiftSource(conflictPos, termAfter, first) {</span><span class="s3">\n    </span><span class="s1">let pos = conflictPos, path = [];</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">for (let i = pos.pos - 1; i &gt;= 0; i--)</span><span class="s3">\n            </span><span class="s1">path.push(pos.rule.parts[i]);</span><span class="s3">\n        </span><span class="s1">if (!pos.via)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">pos = pos.via;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">path.reverse();</span><span class="s3">\n    </span><span class="s1">let seen = new Set();</span><span class="s3">\n    </span><span class="s1">function explore(pos, i, hasMatch) {</span><span class="s3">\n        </span><span class="s1">if (i == path.length &amp;&amp; hasMatch &amp;&amp; !pos.next)</span><span class="s3">\n            </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">nThe reduction of ${conflictPos.rule.name} is allowed before ${termAfter} because of this rule:</span><span class="s3">\\</span><span class="s1">n  ${hasMatch}`;</span><span class="s3">\n        </span><span class="s1">for (let next; next = pos.next;) {</span><span class="s3">\n            </span><span class="s1">if (i &lt; path.length &amp;&amp; next == path[i]) {</span><span class="s3">\n                </span><span class="s1">let inner = explore(pos.advance(), i + 1, hasMatch);</span><span class="s3">\n                </span><span class="s1">if (inner)</span><span class="s3">\n                    </span><span class="s1">return inner;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let after = pos.rule.parts[pos.pos + 1], match = pos.pos + 1 == pos.rule.parts.length ? hasMatch : null;</span><span class="s3">\n            </span><span class="s1">if (after &amp;&amp; (after.terminal ? after == termAfter : first[after.name].includes(termAfter)))</span><span class="s3">\n                </span><span class="s1">match = pos.advance();</span><span class="s3">\n            </span><span class="s1">for (let rule of next.rules) {</span><span class="s3">\n                </span><span class="s1">let hash = (rule.id &lt;&lt; 5) + i + (match ? 555 : 0);</span><span class="s3">\n                </span><span class="s1">if (!seen.has(hash)) {</span><span class="s3">\n                    </span><span class="s1">seen.add(hash);</span><span class="s3">\n                    </span><span class="s1">let inner = explore(new Pos(rule, 0, [], [], next, pos), i, match);</span><span class="s3">\n                    </span><span class="s1">if (inner)</span><span class="s3">\n                        </span><span class="s1">return inner;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!next.terminal &amp;&amp; first[next.name].includes(null))</span><span class="s3">\n                </span><span class="s1">pos = pos.advance();</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return explore(pos, 0, null);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Builds a full LR(1) automaton</span><span class="s3">\n</span><span class="s1">function buildFullAutomaton(terms, startTerms, first) {</span><span class="s3">\n    </span><span class="s1">let states = [], statesBySetHash = {};</span><span class="s3">\n    </span><span class="s1">let cores = {};</span><span class="s3">\n    </span><span class="s1">let t0 = Date.now();</span><span class="s3">\n    </span><span class="s1">function getState(core, top) {</span><span class="s3">\n        </span><span class="s1">if (core.length == 0)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let coreHash = hashPositions(core), byHash = cores[coreHash];</span><span class="s3">\n        </span><span class="s1">let skip;</span><span class="s3">\n        </span><span class="s1">for (let pos of core) {</span><span class="s3">\n            </span><span class="s1">if (!skip)</span><span class="s3">\n                </span><span class="s1">skip = pos.skip;</span><span class="s3">\n            </span><span class="s1">else if (skip != pos.skip)</span><span class="s3">\n                </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">Inconsistent skip sets after </span><span class="s3">\&quot; </span><span class="s1">+ pos.trail());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (byHash)</span><span class="s3">\n            </span><span class="s1">for (let known of byHash)</span><span class="s3">\n                </span><span class="s1">if (eqSet(core, known.set)) {</span><span class="s3">\n                    </span><span class="s1">if (known.state.skip != skip)</span><span class="s3">\n                        </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">Inconsistent skip sets after </span><span class="s3">\&quot; </span><span class="s1">+ known.set[0].trail());</span><span class="s3">\n                    </span><span class="s1">return known.state;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let set = closure(core, first);</span><span class="s3">\n        </span><span class="s1">let hash = hashPositions(set), forHash = statesBySetHash[hash] || (statesBySetHash[hash] = []);</span><span class="s3">\n        </span><span class="s1">let found;</span><span class="s3">\n        </span><span class="s1">if (!top)</span><span class="s3">\n            </span><span class="s1">for (let state of forHash)</span><span class="s3">\n                </span><span class="s1">if (state.hasSet(set))</span><span class="s3">\n                    </span><span class="s1">found = state;</span><span class="s3">\n        </span><span class="s1">if (!found) {</span><span class="s3">\n            </span><span class="s1">found = new State(states.length, set, 0, skip, hash, top);</span><span class="s3">\n            </span><span class="s1">forHash.push(found);</span><span class="s3">\n            </span><span class="s1">states.push(found);</span><span class="s3">\n            </span><span class="s1">if (timing &amp;&amp; states.length % 500 == 0)</span><span class="s3">\n                </span><span class="s1">console.log(`${states.length} states after ${((Date.now() - t0) / 1000).toFixed(2)}s`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">(cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found));</span><span class="s3">\n        </span><span class="s1">return found;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const startTerm of startTerms) {</span><span class="s3">\n        </span><span class="s1">const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names[</span><span class="s3">\&quot;</span><span class="s1">%noskip</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">getState(startTerm.rules.map(rule =&gt; new Pos(rule, 0, [terms.eof], none$1, startSkip, null).finish()), startTerm);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let conflicts = new ConflictContext(first);</span><span class="s3">\n    </span><span class="s1">for (let filled = 0; filled &lt; states.length; filled++) {</span><span class="s3">\n        </span><span class="s1">let state = states[filled];</span><span class="s3">\n        </span><span class="s1">let byTerm = [], byTermPos = [], atEnd = [];</span><span class="s3">\n        </span><span class="s1">for (let pos of state.set) {</span><span class="s3">\n            </span><span class="s1">if (pos.pos == pos.rule.parts.length) {</span><span class="s3">\n                </span><span class="s1">if (!pos.rule.name.top)</span><span class="s3">\n                    </span><span class="s1">atEnd.push(pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let next = pos.rule.parts[pos.pos];</span><span class="s3">\n                </span><span class="s1">let index = byTerm.indexOf(next);</span><span class="s3">\n                </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">byTerm.push(next);</span><span class="s3">\n                    </span><span class="s1">byTermPos.push([pos]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">byTermPos[index].push(pos);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; byTerm.length; i++) {</span><span class="s3">\n            </span><span class="s1">let term = byTerm[i], positions = byTermPos[i].map(p =&gt; p.advance());</span><span class="s3">\n            </span><span class="s1">if (term.terminal) {</span><span class="s3">\n                </span><span class="s1">let set = applyCut(positions);</span><span class="s3">\n                </span><span class="s1">let next = getState(set);</span><span class="s3">\n                </span><span class="s1">if (next)</span><span class="s3">\n                    </span><span class="s1">state.addAction(new Shift(term, next), byTermPos[i], conflicts);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let goto = getState(positions);</span><span class="s3">\n                </span><span class="s1">if (goto)</span><span class="s3">\n                    </span><span class="s1">state.goto.push(new Shift(term, goto));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let replaced = false;</span><span class="s3">\n        </span><span class="s1">for (let pos of atEnd)</span><span class="s3">\n            </span><span class="s1">for (let ahead of pos.ahead) {</span><span class="s3">\n                </span><span class="s1">let count = state.actions.length;</span><span class="s3">\n                </span><span class="s1">state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts);</span><span class="s3">\n                </span><span class="s1">if (state.actions.length == count)</span><span class="s3">\n                    </span><span class="s1">replaced = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If some actions were replaced by others, double-check whether</span><span class="s3">\n        </span><span class="s1">// goto entries are now superfluous (for example, in an operator</span><span class="s3">\n        </span><span class="s1">// precedence-related state that has a shift for `*` but only a</span><span class="s3">\n        </span><span class="s1">// reduce for `+`, we don't need a goto entry for rules that start</span><span class="s3">\n        </span><span class="s1">// with `+`)</span><span class="s3">\n        </span><span class="s1">if (replaced)</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; state.goto.length; i++) {</span><span class="s3">\n                </span><span class="s1">let start = first[state.goto[i].term.name];</span><span class="s3">\n                </span><span class="s1">if (!start.some(term =&gt; state.actions.some(a =&gt; a.term == term &amp;&amp; (a instanceof Shift))))</span><span class="s3">\n                    </span><span class="s1">state.goto.splice(i--, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (conflicts.conflicts.length)</span><span class="s3">\n        </span><span class="s1">throw new GenError(conflicts.conflicts.map(c =&gt; c.error).join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">// Resolve alwaysReduce and sort actions</span><span class="s3">\n    </span><span class="s1">for (let state of states)</span><span class="s3">\n        </span><span class="s1">state.finish();</span><span class="s3">\n    </span><span class="s1">if (timing)</span><span class="s3">\n        </span><span class="s1">console.log(`${states.length} states total.`);</span><span class="s3">\n    </span><span class="s1">return states;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function applyCut(set) {</span><span class="s3">\n    </span><span class="s1">let found = null, cut = 1;</span><span class="s3">\n    </span><span class="s1">for (let pos of set) {</span><span class="s3">\n        </span><span class="s1">let value = pos.rule.conflicts[pos.pos - 1].cut;</span><span class="s3">\n        </span><span class="s1">if (value &lt; cut)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">if (!found || value &gt; cut) {</span><span class="s3">\n            </span><span class="s1">cut = value;</span><span class="s3">\n            </span><span class="s1">found = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">found.push(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return found || set;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Verify that there are no conflicting actions or goto entries in the</span><span class="s3">\n</span><span class="s1">// two given states (using the state ID remapping provided in mapping)</span><span class="s3">\n</span><span class="s1">function canMerge(a, b, mapping) {</span><span class="s3">\n    </span><span class="s1">// If a goto for the same term differs, that makes the states</span><span class="s3">\n    </span><span class="s1">// incompatible</span><span class="s3">\n    </span><span class="s1">for (let goto of a.goto)</span><span class="s3">\n        </span><span class="s1">for (let other of b.goto) {</span><span class="s3">\n            </span><span class="s1">if (goto.term == other.term &amp;&amp; mapping[goto.target.id] != mapping[other.target.id])</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If there is an action where a conflicting action exists in the</span><span class="s3">\n    </span><span class="s1">// other state, the merge is only allowed when both states have the</span><span class="s3">\n    </span><span class="s1">// exact same set of actions for this term.</span><span class="s3">\n    </span><span class="s1">let byTerm = b.actionsByTerm();</span><span class="s3">\n    </span><span class="s1">for (let action of a.actions) {</span><span class="s3">\n        </span><span class="s1">let setB = byTerm[action.term.id];</span><span class="s3">\n        </span><span class="s1">if (setB &amp;&amp; setB.some(other =&gt; !other.matches(action, mapping))) {</span><span class="s3">\n            </span><span class="s1">if (setB.length == 1)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">let setA = a.actionsByTerm()[action.term.id];</span><span class="s3">\n            </span><span class="s1">if (setA.length != setB.length || setA.some(a1 =&gt; !setB.some(a2 =&gt; a1.matches(a2, mapping))))</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeStates(states, mapping) {</span><span class="s3">\n    </span><span class="s1">let newStates = [];</span><span class="s3">\n    </span><span class="s1">for (let state of states) {</span><span class="s3">\n        </span><span class="s1">let newID = mapping[state.id];</span><span class="s3">\n        </span><span class="s1">if (!newStates[newID]) {</span><span class="s3">\n            </span><span class="s1">newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule);</span><span class="s3">\n            </span><span class="s1">newStates[newID].tokenGroup = state.tokenGroup;</span><span class="s3">\n            </span><span class="s1">newStates[newID].defaultReduce = state.defaultReduce;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let state of states) {</span><span class="s3">\n        </span><span class="s1">let newID = mapping[state.id], target = newStates[newID];</span><span class="s3">\n        </span><span class="s1">target.flags |= state.flags;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; state.actions.length; i++) {</span><span class="s3">\n            </span><span class="s1">let action = state.actions[i].map(mapping, newStates);</span><span class="s3">\n            </span><span class="s1">if (!target.actions.some(a =&gt; a.eq(action))) {</span><span class="s3">\n                </span><span class="s1">target.actions.push(action);</span><span class="s3">\n                </span><span class="s1">target.actionPositions.push(state.actionPositions[i]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let goto of state.goto) {</span><span class="s3">\n            </span><span class="s1">let mapped = goto.map(mapping, newStates);</span><span class="s3">\n            </span><span class="s1">if (!target.goto.some(g =&gt; g.eq(mapped)))</span><span class="s3">\n                </span><span class="s1">target.goto.push(mapped);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return newStates;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Group {</span><span class="s3">\n    </span><span class="s1">constructor(origin, member) {</span><span class="s3">\n        </span><span class="s1">this.origin = origin;</span><span class="s3">\n        </span><span class="s1">this.members = [member];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function samePosSet(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (!a[i].eqSimple(b[i]))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Collapse an LR(1) automaton to an LALR-like automaton</span><span class="s3">\n</span><span class="s1">function collapseAutomaton(states) {</span><span class="s3">\n    </span><span class="s1">let mapping = [], groups = [];</span><span class="s3">\n    </span><span class="s1">assignGroups: for (let i = 0; i &lt; states.length; i++) {</span><span class="s3">\n        </span><span class="s1">let state = states[i];</span><span class="s3">\n        </span><span class="s1">if (!state.startRule)</span><span class="s3">\n            </span><span class="s1">for (let j = 0; j &lt; groups.length; j++) {</span><span class="s3">\n                </span><span class="s1">let group = groups[j], other = states[group.members[0]];</span><span class="s3">\n                </span><span class="s1">if (state.tokenGroup == other.tokenGroup &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">state.skip == other.skip &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">!other.startRule &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">samePosSet(state.set, other.set)) {</span><span class="s3">\n                    </span><span class="s1">group.members.push(i);</span><span class="s3">\n                    </span><span class="s1">mapping.push(j);</span><span class="s3">\n                    </span><span class="s1">continue assignGroups;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">mapping.push(groups.length);</span><span class="s3">\n        </span><span class="s1">groups.push(new Group(groups.length, i));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function spill(groupIndex, index) {</span><span class="s3">\n        </span><span class="s1">let group = groups[groupIndex], state = states[group.members[index]];</span><span class="s3">\n        </span><span class="s1">let pop = group.members.pop();</span><span class="s3">\n        </span><span class="s1">if (index != group.members.length)</span><span class="s3">\n            </span><span class="s1">group.members[index] = pop;</span><span class="s3">\n        </span><span class="s1">for (let i = groupIndex + 1; i &lt; groups.length; i++) {</span><span class="s3">\n            </span><span class="s1">mapping[state.id] = i;</span><span class="s3">\n            </span><span class="s1">if (groups[i].origin == group.origin &amp;&amp;</span><span class="s3">\n                </span><span class="s1">groups[i].members.every(id =&gt; canMerge(state, states[id], mapping))) {</span><span class="s3">\n                </span><span class="s1">groups[i].members.push(state.id);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">mapping[state.id] = groups.length;</span><span class="s3">\n        </span><span class="s1">groups.push(new Group(group.origin, state.id));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let pass = 1;; pass++) {</span><span class="s3">\n        </span><span class="s1">let conflicts = false, t0 = Date.now();</span><span class="s3">\n        </span><span class="s1">for (let g = 0, startLen = groups.length; g &lt; startLen; g++) {</span><span class="s3">\n            </span><span class="s1">let group = groups[g];</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; group.members.length - 1; i++) {</span><span class="s3">\n                </span><span class="s1">for (let j = i + 1; j &lt; group.members.length; j++) {</span><span class="s3">\n                    </span><span class="s1">let idA = group.members[i], idB = group.members[j];</span><span class="s3">\n                    </span><span class="s1">if (!canMerge(states[idA], states[idB], mapping)) {</span><span class="s3">\n                        </span><span class="s1">conflicts = true;</span><span class="s3">\n                        </span><span class="s1">spill(g, j--);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (timing)</span><span class="s3">\n            </span><span class="s1">console.log(`Collapse pass ${pass}${conflicts ? `` : `, done`} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);</span><span class="s3">\n        </span><span class="s1">if (!conflicts)</span><span class="s3">\n            </span><span class="s1">return mergeStates(states, mapping);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeIdentical(states) {</span><span class="s3">\n    </span><span class="s1">for (let pass = 1;; pass++) {</span><span class="s3">\n        </span><span class="s1">let mapping = [], didMerge = false, t0 = Date.now();</span><span class="s3">\n        </span><span class="s1">let newStates = [];</span><span class="s3">\n        </span><span class="s1">// Find states that either have the same alwaysReduce or the same</span><span class="s3">\n        </span><span class="s1">// actions, and merge them.</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; states.length; i++) {</span><span class="s3">\n            </span><span class="s1">let state = states[i];</span><span class="s3">\n            </span><span class="s1">let match = newStates.findIndex(s =&gt; state.eq(s));</span><span class="s3">\n            </span><span class="s1">if (match &lt; 0) {</span><span class="s3">\n                </span><span class="s1">mapping[i] = newStates.length;</span><span class="s3">\n                </span><span class="s1">newStates.push(state);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">mapping[i] = match;</span><span class="s3">\n                </span><span class="s1">didMerge = true;</span><span class="s3">\n                </span><span class="s1">let other = newStates[match], add = null;</span><span class="s3">\n                </span><span class="s1">for (let pos of state.set)</span><span class="s3">\n                    </span><span class="s1">if (!other.set.some(p =&gt; p.eqSimple(pos)))</span><span class="s3">\n                        </span><span class="s1">(add || (add = [])).push(pos);</span><span class="s3">\n                </span><span class="s1">if (add)</span><span class="s3">\n                    </span><span class="s1">other.set = add.concat(other.set).sort((a, b) =&gt; a.cmp(b));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (timing)</span><span class="s3">\n            </span><span class="s1">console.log(`Merge identical pass ${pass}${didMerge ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">, done</span><span class="s3">\&quot;</span><span class="s1">} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);</span><span class="s3">\n        </span><span class="s1">if (!didMerge)</span><span class="s3">\n            </span><span class="s1">return states;</span><span class="s3">\n        </span><span class="s1">// Make sure actions point at merged state objects</span><span class="s3">\n        </span><span class="s1">for (let state of newStates)</span><span class="s3">\n            </span><span class="s1">if (!state.defaultReduce) {</span><span class="s3">\n                </span><span class="s1">state.actions = state.actions.map(a =&gt; a.map(mapping, newStates));</span><span class="s3">\n                </span><span class="s1">state.goto = state.goto.map(a =&gt; a.map(mapping, newStates));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Renumber ids</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; newStates.length; i++)</span><span class="s3">\n            </span><span class="s1">newStates[i].id = i;</span><span class="s3">\n        </span><span class="s1">states = newStates;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const none$1 = [];</span><span class="s3">\n</span><span class="s1">function finishAutomaton(full) {</span><span class="s3">\n    </span><span class="s1">return mergeIdentical(collapseAutomaton(full));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Encode numbers as groups of printable ascii characters</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - 0xffff, which is often used as placeholder, is encoded as </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - The characters from </span><span class="s3">\&quot; \&quot; </span><span class="s1">(32) to </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">(125), excluding '</span><span class="s3">\&quot;</span><span class="s1">' and</span><span class="s3">\n</span><span class="s1">//   </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">, indicate values from 0 to 92</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - The first bit in a 'digit' is used to indicate whether this is</span><span class="s3">\n</span><span class="s1">//   the end of a number.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - That leaves 46 other values, which are actually significant.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - The digits in a number are ordered from high to low significance.</span><span class="s3">\n</span><span class="s1">function digitToChar(digit) {</span><span class="s3">\n    </span><span class="s1">let ch = digit + 32 /* Encode.Start */;</span><span class="s3">\n    </span><span class="s1">if (ch &gt;= 34 /* Encode.Gap1 */)</span><span class="s3">\n        </span><span class="s1">ch++;</span><span class="s3">\n    </span><span class="s1">if (ch &gt;= 92 /* Encode.Gap2 */)</span><span class="s3">\n        </span><span class="s1">ch++;</span><span class="s3">\n    </span><span class="s1">return String.fromCharCode(ch);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function encode(value, max = 0xffff) {</span><span class="s3">\n    </span><span class="s1">if (value &gt; max)</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Trying to encode a number that's too big: </span><span class="s3">\&quot; </span><span class="s1">+ value);</span><span class="s3">\n    </span><span class="s1">if (value == 65535 /* Encode.BigVal */)</span><span class="s3">\n        </span><span class="s1">return String.fromCharCode(126 /* Encode.BigValCode */);</span><span class="s3">\n    </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let first = 46 /* Encode.Base */;; first = 0) {</span><span class="s3">\n        </span><span class="s1">let low = value % 46 /* Encode.Base */, rest = value - low;</span><span class="s3">\n        </span><span class="s1">result = digitToChar(low + first) + result;</span><span class="s3">\n        </span><span class="s1">if (rest == 0)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">value = rest / 46 /* Encode.Base */;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function encodeArray(values, max = 0xffff) {</span><span class="s3">\n    </span><span class="s1">let result = '</span><span class="s3">\&quot;</span><span class="s1">' + encode(values.length, 0xffffffff);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; values.length; i++)</span><span class="s3">\n        </span><span class="s1">result += encode(values[i], max);</span><span class="s3">\n    </span><span class="s1">result += '</span><span class="s3">\&quot;</span><span class="s1">';</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const none = [];</span><span class="s3">\n</span><span class="s1">class Parts {</span><span class="s3">\n    </span><span class="s1">constructor(terms, conflicts) {</span><span class="s3">\n        </span><span class="s1">this.terms = terms;</span><span class="s3">\n        </span><span class="s1">this.conflicts = conflicts;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">concat(other) {</span><span class="s3">\n        </span><span class="s1">if (this == Parts.none)</span><span class="s3">\n            </span><span class="s1">return other;</span><span class="s3">\n        </span><span class="s1">if (other == Parts.none)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let conflicts = null;</span><span class="s3">\n        </span><span class="s1">if (this.conflicts || other.conflicts) {</span><span class="s3">\n            </span><span class="s1">conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();</span><span class="s3">\n            </span><span class="s1">let otherConflicts = other.ensureConflicts();</span><span class="s3">\n            </span><span class="s1">conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0]);</span><span class="s3">\n            </span><span class="s1">for (let i = 1; i &lt; otherConflicts.length; i++)</span><span class="s3">\n                </span><span class="s1">conflicts.push(otherConflicts[i]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new Parts(this.terms.concat(other.terms), conflicts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">withConflicts(pos, conflicts) {</span><span class="s3">\n        </span><span class="s1">if (conflicts == Conflicts.none)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();</span><span class="s3">\n        </span><span class="s1">array[pos] = array[pos].join(conflicts);</span><span class="s3">\n        </span><span class="s1">return new Parts(this.terms, array);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ensureConflicts() {</span><span class="s3">\n        </span><span class="s1">if (this.conflicts)</span><span class="s3">\n            </span><span class="s1">return this.conflicts;</span><span class="s3">\n        </span><span class="s1">let empty = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt;= this.terms.length; i++)</span><span class="s3">\n            </span><span class="s1">empty.push(Conflicts.none);</span><span class="s3">\n        </span><span class="s1">return empty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Parts.none = new Parts(none, null);</span><span class="s3">\n</span><span class="s1">function p(...terms) { return new Parts(terms, null); }</span><span class="s3">\n</span><span class="s1">class BuiltRule {</span><span class="s3">\n    </span><span class="s1">constructor(id, args, term) {</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.args = args;</span><span class="s3">\n        </span><span class="s1">this.term = term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matches(expr) {</span><span class="s3">\n        </span><span class="s1">return this.id == expr.id.name &amp;&amp; exprsEq(expr.args, this.args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matchesRepeat(expr) {</span><span class="s3">\n        </span><span class="s1">return this.id == </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; exprEq(expr.expr, this.args[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Builder {</span><span class="s3">\n    </span><span class="s1">constructor(text, options) {</span><span class="s3">\n        </span><span class="s1">this.options = options;</span><span class="s3">\n        </span><span class="s1">this.terms = new TermSet;</span><span class="s3">\n        </span><span class="s1">this.specialized = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.tokenOrigins = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.rules = [];</span><span class="s3">\n        </span><span class="s1">this.built = [];</span><span class="s3">\n        </span><span class="s1">this.ruleNames = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.namespaces = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.namedTerms = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.termTable = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.knownProps = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.dynamicRulePrecedences = [];</span><span class="s3">\n        </span><span class="s1">this.definedGroups = [];</span><span class="s3">\n        </span><span class="s1">this.astRules = [];</span><span class="s3">\n        </span><span class="s1">this.currentSkip = [];</span><span class="s3">\n        </span><span class="s1">time(</span><span class="s3">\&quot;</span><span class="s1">Parse</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">this.input = new Input(text, options.fileName);</span><span class="s3">\n            </span><span class="s1">this.ast = this.input.parse();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let NP = NodeProp;</span><span class="s3">\n        </span><span class="s1">for (let prop in NP) {</span><span class="s3">\n            </span><span class="s1">if (NP[prop] instanceof NodeProp &amp;&amp; !NP[prop].perNode)</span><span class="s3">\n                </span><span class="s1">this.knownProps[prop] = { prop: NP[prop], source: { name: prop, from: null } };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let prop of this.ast.externalProps) {</span><span class="s3">\n            </span><span class="s1">this.knownProps[prop.id.name] = {</span><span class="s3">\n                </span><span class="s1">prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : new NodeProp(),</span><span class="s3">\n                </span><span class="s1">source: { name: prop.externalID.name, from: prop.source }</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.dialects = this.ast.dialects.map(d =&gt; d.name);</span><span class="s3">\n        </span><span class="s1">this.tokens = new MainTokenSet(this, this.ast.tokens);</span><span class="s3">\n        </span><span class="s1">this.localTokens = this.ast.localTokens.map(g =&gt; new LocalTokenSet(this, g));</span><span class="s3">\n        </span><span class="s1">this.externalTokens = this.ast.externalTokens.map(ext =&gt; new ExternalTokenSet(this, ext));</span><span class="s3">\n        </span><span class="s1">this.externalSpecializers = this.ast.externalSpecializers.map(decl =&gt; new ExternalSpecializer(this, decl));</span><span class="s3">\n        </span><span class="s1">time(</span><span class="s3">\&quot;</span><span class="s1">Build rules</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">let noSkip = this.newName(</span><span class="s3">\&quot;</span><span class="s1">%noskip</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n            </span><span class="s1">this.defineRule(noSkip, []);</span><span class="s3">\n            </span><span class="s1">let mainSkip = this.ast.mainSkip ? this.newName(</span><span class="s3">\&quot;</span><span class="s1">%mainskip</span><span class="s3">\&quot;</span><span class="s1">, true) : noSkip;</span><span class="s3">\n            </span><span class="s1">let scopedSkip = [], topRules = [];</span><span class="s3">\n            </span><span class="s1">for (let rule of this.ast.rules)</span><span class="s3">\n                </span><span class="s1">this.astRules.push({ skip: mainSkip, rule });</span><span class="s3">\n            </span><span class="s1">for (let rule of this.ast.topRules)</span><span class="s3">\n                </span><span class="s1">topRules.push({ skip: mainSkip, rule });</span><span class="s3">\n            </span><span class="s1">for (let scoped of this.ast.scopedSkip) {</span><span class="s3">\n                </span><span class="s1">let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) =&gt; i &lt; scopedSkip.length &amp;&amp; exprEq(sc.expr, scoped.expr));</span><span class="s3">\n                </span><span class="s1">if (found &gt; -1)</span><span class="s3">\n                    </span><span class="s1">skip = scopedSkip[found];</span><span class="s3">\n                </span><span class="s1">else if (this.ast.mainSkip &amp;&amp; exprEq(scoped.expr, this.ast.mainSkip))</span><span class="s3">\n                    </span><span class="s1">skip = mainSkip;</span><span class="s3">\n                </span><span class="s1">else if (!isEmpty(scoped.expr))</span><span class="s3">\n                    </span><span class="s1">skip = this.newName(</span><span class="s3">\&quot;</span><span class="s1">%skip</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n                </span><span class="s1">scopedSkip.push(skip);</span><span class="s3">\n                </span><span class="s1">for (let rule of scoped.rules)</span><span class="s3">\n                    </span><span class="s1">this.astRules.push({ skip, rule });</span><span class="s3">\n                </span><span class="s1">for (let rule of scoped.topRules)</span><span class="s3">\n                    </span><span class="s1">topRules.push({ skip, rule });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let { rule } of this.astRules) {</span><span class="s3">\n                </span><span class="s1">this.unique(rule.id);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.currentSkip.push(noSkip);</span><span class="s3">\n            </span><span class="s1">this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip];</span><span class="s3">\n            </span><span class="s1">if (mainSkip != noSkip)</span><span class="s3">\n                </span><span class="s1">this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip));</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.ast.scopedSkip.length; i++) {</span><span class="s3">\n                </span><span class="s1">let skip = scopedSkip[i];</span><span class="s3">\n                </span><span class="s1">if (!this.skipRules.includes(skip)) {</span><span class="s3">\n                    </span><span class="s1">this.skipRules.push(skip);</span><span class="s3">\n                    </span><span class="s1">if (skip != noSkip)</span><span class="s3">\n                        </span><span class="s1">this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.currentSkip.pop();</span><span class="s3">\n            </span><span class="s1">for (let { rule, skip } of topRules.sort((a, b) =&gt; a.rule.start - b.rule.start)) {</span><span class="s3">\n                </span><span class="s1">this.unique(rule.id);</span><span class="s3">\n                </span><span class="s1">this.used(rule.id.name);</span><span class="s3">\n                </span><span class="s1">this.currentSkip.push(skip);</span><span class="s3">\n                </span><span class="s1">let { name, props } = this.nodeInfo(rule.props, </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">, rule.id.name, none, none, rule.expr);</span><span class="s3">\n                </span><span class="s1">let term = this.terms.makeTop(name, props);</span><span class="s3">\n                </span><span class="s1">this.namedTerms[name] = term;</span><span class="s3">\n                </span><span class="s1">this.defineRule(term, this.normalizeExpr(rule.expr));</span><span class="s3">\n                </span><span class="s1">this.currentSkip.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let ext of this.externalSpecializers)</span><span class="s3">\n                </span><span class="s1">ext.finish();</span><span class="s3">\n            </span><span class="s1">for (let { skip, rule } of this.astRules) {</span><span class="s3">\n                </span><span class="s1">if (this.ruleNames[rule.id.name] &amp;&amp; isExported(rule) &amp;&amp; !rule.params.length) {</span><span class="s3">\n                    </span><span class="s1">this.buildRule(rule, [], skip, false);</span><span class="s3">\n                    </span><span class="s1">if (rule.expr instanceof SequenceExpression &amp;&amp; rule.expr.exprs.length == 0)</span><span class="s3">\n                        </span><span class="s1">this.used(rule.id.name);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">for (let name in this.ruleNames) {</span><span class="s3">\n            </span><span class="s1">let value = this.ruleNames[name];</span><span class="s3">\n            </span><span class="s1">if (value)</span><span class="s3">\n                </span><span class="s1">this.warn(`Unused rule '${value.name}'`, value.start);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.tokens.takePrecedences();</span><span class="s3">\n        </span><span class="s1">this.tokens.takeConflicts();</span><span class="s3">\n        </span><span class="s1">for (let lt of this.localTokens)</span><span class="s3">\n            </span><span class="s1">lt.takePrecedences();</span><span class="s3">\n        </span><span class="s1">for (let { name, group, rule } of this.definedGroups)</span><span class="s3">\n            </span><span class="s1">this.defineGroup(name, group, rule);</span><span class="s3">\n        </span><span class="s1">this.checkGroups();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unique(id) {</span><span class="s3">\n        </span><span class="s1">if (id.name in this.ruleNames)</span><span class="s3">\n            </span><span class="s1">this.raise(`Duplicate definition of rule '${id.name}'`, id.start);</span><span class="s3">\n        </span><span class="s1">this.ruleNames[id.name] = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">used(name) {</span><span class="s3">\n        </span><span class="s1">this.ruleNames[name] = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">newName(base, nodeName = null, props = {}) {</span><span class="s3">\n        </span><span class="s1">for (let i = nodeName ? 0 : 1;; i++) {</span><span class="s3">\n            </span><span class="s1">let name = i ? `${base}-${i}` : base;</span><span class="s3">\n            </span><span class="s1">if (!this.terms.names[name])</span><span class="s3">\n                </span><span class="s1">return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">prepareParser() {</span><span class="s3">\n        </span><span class="s1">let rules = time(</span><span class="s3">\&quot;</span><span class="s1">Simplify rules</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; simplifyRules(this.rules, [</span><span class="s3">\n            </span><span class="s1">...this.skipRules,</span><span class="s3">\n            </span><span class="s1">...this.terms.tops</span><span class="s3">\n        </span><span class="s1">]));</span><span class="s3">\n        </span><span class="s1">let { nodeTypes, names: termNames, minRepeatTerm, maxTerm } = this.terms.finish(rules);</span><span class="s3">\n        </span><span class="s1">for (let prop in this.namedTerms)</span><span class="s3">\n            </span><span class="s1">this.termTable[prop] = this.namedTerms[prop].id;</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">bgrammar</span><span class="s3">\\</span><span class="s1">b/.test(verbose))</span><span class="s3">\n            </span><span class="s1">console.log(rules.join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">let startTerms = this.terms.tops.slice();</span><span class="s3">\n        </span><span class="s1">let first = computeFirstSets(this.terms);</span><span class="s3">\n        </span><span class="s1">let skipInfo = this.skipRules.map((name, id) =&gt; {</span><span class="s3">\n            </span><span class="s1">let skip = [], startTokens = [], rules = [];</span><span class="s3">\n            </span><span class="s1">for (let rule of name.rules) {</span><span class="s3">\n                </span><span class="s1">if (!rule.parts.length)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">let start = rule.parts[0];</span><span class="s3">\n                </span><span class="s1">for (let t of start.terminal ? [start] : first[start.name] || [])</span><span class="s3">\n                    </span><span class="s1">if (t &amp;&amp; !startTokens.includes(t))</span><span class="s3">\n                        </span><span class="s1">startTokens.push(t);</span><span class="s3">\n                </span><span class="s1">if (start.terminal &amp;&amp; rule.parts.length == 1 &amp;&amp; !rules.some(r =&gt; r != rule &amp;&amp; r.parts[0] == start))</span><span class="s3">\n                    </span><span class="s1">skip.push(start);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">rules.push(rule);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">name.rules = rules;</span><span class="s3">\n            </span><span class="s1">if (rules.length)</span><span class="s3">\n                </span><span class="s1">startTerms.push(name);</span><span class="s3">\n            </span><span class="s1">return { skip, rule: rules.length ? name : null, startTokens, id };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let fullTable = time(</span><span class="s3">\&quot;</span><span class="s1">Build full automaton</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; buildFullAutomaton(this.terms, startTerms, first));</span><span class="s3">\n        </span><span class="s1">let localTokens = this.localTokens</span><span class="s3">\n            </span><span class="s1">.map((grp, i) =&gt; grp.buildLocalGroup(fullTable, skipInfo, i));</span><span class="s3">\n        </span><span class="s1">let { tokenGroups, tokenPrec, tokenData } = time(</span><span class="s3">\&quot;</span><span class="s1">Build token groups</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; this.tokens.buildTokenGroups(fullTable, skipInfo, localTokens.length));</span><span class="s3">\n        </span><span class="s1">let table = time(</span><span class="s3">\&quot;</span><span class="s1">Finish automaton</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; finishAutomaton(fullTable));</span><span class="s3">\n        </span><span class="s1">let skipState = findSkipStates(table, this.terms.tops);</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">blr</span><span class="s3">\\</span><span class="s1">b/.test(verbose))</span><span class="s3">\n            </span><span class="s1">console.log(table.join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">let specialized = [];</span><span class="s3">\n        </span><span class="s1">for (let ext of this.externalSpecializers)</span><span class="s3">\n            </span><span class="s1">specialized.push(ext);</span><span class="s3">\n        </span><span class="s1">for (let name in this.specialized)</span><span class="s3">\n            </span><span class="s1">specialized.push({ token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name]) });</span><span class="s3">\n        </span><span class="s1">let tokStart = (tokenizer) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (tokenizer instanceof ExternalTokenSet)</span><span class="s3">\n                </span><span class="s1">return tokenizer.ast.start;</span><span class="s3">\n            </span><span class="s1">return this.tokens.ast ? this.tokens.ast.start : -1;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let tokenizers = tokenGroups</span><span class="s3">\n            </span><span class="s1">.concat(this.externalTokens)</span><span class="s3">\n            </span><span class="s1">.sort((a, b) =&gt; tokStart(a) - tokStart(b))</span><span class="s3">\n            </span><span class="s1">.concat(localTokens);</span><span class="s3">\n        </span><span class="s1">let data = new DataBuilder;</span><span class="s3">\n        </span><span class="s1">let skipData = skipInfo.map(info =&gt; {</span><span class="s3">\n            </span><span class="s1">let actions = [];</span><span class="s3">\n            </span><span class="s1">for (let term of info.skip)</span><span class="s3">\n                </span><span class="s1">actions.push(term.id, 0, 262144 /* Action.StayFlag */ &gt;&gt; 16);</span><span class="s3">\n            </span><span class="s1">if (info.rule) {</span><span class="s3">\n                </span><span class="s1">let state = table.find(s =&gt; s.startRule == info.rule);</span><span class="s3">\n                </span><span class="s1">for (let action of state.actions)</span><span class="s3">\n                    </span><span class="s1">actions.push(action.term.id, state.id, 131072 /* Action.GotoFlag */ &gt;&gt; 16);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">actions.push(65535 /* Seq.End */, 0 /* Seq.Done */);</span><span class="s3">\n            </span><span class="s1">return data.storeArray(actions);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let states = time(</span><span class="s3">\&quot;</span><span class="s1">Finish states</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">let states = new Uint32Array(table.length * 6 /* ParseState.Size */);</span><span class="s3">\n            </span><span class="s1">let forceReductions = this.computeForceReductions(table, skipInfo);</span><span class="s3">\n            </span><span class="s1">let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this);</span><span class="s3">\n            </span><span class="s1">for (let s of table)</span><span class="s3">\n                </span><span class="s1">finishCx.finish(s, skipState(s.id), forceReductions[s.id]);</span><span class="s3">\n            </span><span class="s1">return states;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let dialects = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.dialects.length; i++)</span><span class="s3">\n            </span><span class="s1">dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t =&gt; t.id).concat(65535 /* Seq.End */));</span><span class="s3">\n        </span><span class="s1">let dynamicPrecedences = null;</span><span class="s3">\n        </span><span class="s1">if (this.dynamicRulePrecedences.length) {</span><span class="s3">\n            </span><span class="s1">dynamicPrecedences = Object.create(null);</span><span class="s3">\n            </span><span class="s1">for (let { rule, prec } of this.dynamicRulePrecedences)</span><span class="s3">\n                </span><span class="s1">dynamicPrecedences[rule.id] = prec;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let topRules = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let term of this.terms.tops)</span><span class="s3">\n            </span><span class="s1">topRules[term.nodeName] = [table.find(state =&gt; state.startRule == term).id, term.id];</span><span class="s3">\n        </span><span class="s1">let precTable = data.storeArray(tokenPrec.concat(65535 /* Seq.End */));</span><span class="s3">\n        </span><span class="s1">let { nodeProps, skippedTypes } = this.gatherNodeProps(nodeTypes);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">states,</span><span class="s3">\n            </span><span class="s1">stateData: data.finish(),</span><span class="s3">\n            </span><span class="s1">goto: computeGotoTable(table),</span><span class="s3">\n            </span><span class="s1">nodeNames: nodeTypes.filter(t =&gt; t.id &lt; minRepeatTerm).map(t =&gt; t.nodeName).join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">nodeProps,</span><span class="s3">\n            </span><span class="s1">skippedTypes,</span><span class="s3">\n            </span><span class="s1">maxTerm,</span><span class="s3">\n            </span><span class="s1">repeatNodeCount: nodeTypes.length - minRepeatTerm,</span><span class="s3">\n            </span><span class="s1">tokenizers,</span><span class="s3">\n            </span><span class="s1">tokenData,</span><span class="s3">\n            </span><span class="s1">topRules,</span><span class="s3">\n            </span><span class="s1">dialects,</span><span class="s3">\n            </span><span class="s1">dynamicPrecedences,</span><span class="s3">\n            </span><span class="s1">specialized,</span><span class="s3">\n            </span><span class="s1">tokenPrec: precTable,</span><span class="s3">\n            </span><span class="s1">termNames</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getParser() {</span><span class="s3">\n        </span><span class="s1">let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers, tokenData, topRules, dialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();</span><span class="s3">\n        </span><span class="s1">let specialized = rawSpecialized.map(v =&gt; {</span><span class="s3">\n            </span><span class="s1">if (v instanceof ExternalSpecializer) {</span><span class="s3">\n                </span><span class="s1">let ext = this.options.externalSpecializer(v.ast.id.name, this.termTable);</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">term: v.term.id,</span><span class="s3">\n                    </span><span class="s1">get: (value, stack) =&gt; (ext(value, stack) &lt;&lt; 1) |</span><span class="s3">\n                        </span><span class="s1">(v.ast.type == </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot; </span><span class="s1">? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */),</span><span class="s3">\n                    </span><span class="s1">external: ext,</span><span class="s3">\n                    </span><span class="s1">extend: v.ast.type == </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot;\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return { term: v.token.id, get: (value) =&gt; v.table[value] || -1 };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return LRParser.deserialize({</span><span class="s3">\n            </span><span class="s1">version: 14 /* File.Version */,</span><span class="s3">\n            </span><span class="s1">states,</span><span class="s3">\n            </span><span class="s1">stateData,</span><span class="s3">\n            </span><span class="s1">goto,</span><span class="s3">\n            </span><span class="s1">nodeNames,</span><span class="s3">\n            </span><span class="s1">maxTerm,</span><span class="s3">\n            </span><span class="s1">repeatNodeCount,</span><span class="s3">\n            </span><span class="s1">nodeProps: rawNodeProps.map(({ prop, terms }) =&gt; [this.knownProps[prop].prop, ...terms]),</span><span class="s3">\n            </span><span class="s1">propSources: !this.options.externalPropSource ? undefined</span><span class="s3">\n                </span><span class="s1">: this.ast.externalPropSources.map(s =&gt; this.options.externalPropSource(s.id.name)),</span><span class="s3">\n            </span><span class="s1">skippedNodes: skippedTypes,</span><span class="s3">\n            </span><span class="s1">tokenData,</span><span class="s3">\n            </span><span class="s1">tokenizers: tokenizers.map(tok =&gt; tok.create()),</span><span class="s3">\n            </span><span class="s1">context: !this.ast.context ? undefined</span><span class="s3">\n                </span><span class="s1">: typeof this.options.contextTracker == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? this.options.contextTracker(this.termTable)</span><span class="s3">\n                    </span><span class="s1">: this.options.contextTracker,</span><span class="s3">\n            </span><span class="s1">topRules,</span><span class="s3">\n            </span><span class="s1">dialects,</span><span class="s3">\n            </span><span class="s1">dynamicPrecedences,</span><span class="s3">\n            </span><span class="s1">specialized,</span><span class="s3">\n            </span><span class="s1">tokenPrec,</span><span class="s3">\n            </span><span class="s1">termNames</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getParserFile() {</span><span class="s3">\n        </span><span class="s1">let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers: rawTokenizers, tokenData, topRules, dialects: rawDialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();</span><span class="s3">\n        </span><span class="s1">let mod = this.options.moduleStyle || </span><span class="s3">\&quot;</span><span class="s1">es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let gen = </span><span class="s3">\&quot;</span><span class="s1">// This file was generated by lezer-generator. You probably shouldn't edit it.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, head = gen;</span><span class="s3">\n        </span><span class="s1">let imports = {}, imported = Object.create(null);</span><span class="s3">\n        </span><span class="s1">let defined = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let word of KEYWORDS)</span><span class="s3">\n            </span><span class="s1">defined[word] = true;</span><span class="s3">\n        </span><span class="s1">let exportName = this.options.exportName || </span><span class="s3">\&quot;</span><span class="s1">parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">defined[exportName] = true;</span><span class="s3">\n        </span><span class="s1">let getName = (prefix) =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n                </span><span class="s1">let id = prefix + (i ? </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot; </span><span class="s1">+ i : </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (!defined[id])</span><span class="s3">\n                    </span><span class="s1">return id;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let importName = (name, source, prefix = name) =&gt; {</span><span class="s3">\n            </span><span class="s1">let spec = name + </span><span class="s3">\&quot; </span><span class="s1">from </span><span class="s3">\&quot; </span><span class="s1">+ source;</span><span class="s3">\n            </span><span class="s1">if (imported[spec])</span><span class="s3">\n                </span><span class="s1">return imported[spec];</span><span class="s3">\n            </span><span class="s1">let src = JSON.stringify(source), varName = name;</span><span class="s3">\n            </span><span class="s1">if (name in defined) {</span><span class="s3">\n                </span><span class="s1">varName = getName(prefix);</span><span class="s3">\n                </span><span class="s1">name += `${mod == </span><span class="s3">\&quot;</span><span class="s1">cjs</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">as</span><span class="s3">\&quot;</span><span class="s1">} ${varName}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">defined[varName] = true;</span><span class="s3">\n            </span><span class="s1">(imports[src] || (imports[src] = [])).push(name);</span><span class="s3">\n            </span><span class="s1">return imported[spec] = varName;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let lrParser = importName(</span><span class="s3">\&quot;</span><span class="s1">LRParser</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">@lezer/lr</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let tokenizers = rawTokenizers.map(tok =&gt; tok.createSource(importName));</span><span class="s3">\n        </span><span class="s1">let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source) : null;</span><span class="s3">\n        </span><span class="s1">let nodeProps = rawNodeProps.map(({ prop, terms }) =&gt; {</span><span class="s3">\n            </span><span class="s1">let { source } = this.knownProps[prop];</span><span class="s3">\n            </span><span class="s1">let propID = source.from ? importName(source.name, source.from) : JSON.stringify(source.name);</span><span class="s3">\n            </span><span class="s1">return `[${propID}, ${terms.map(serializePropValue).join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}]`;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">function specializationTableString(table) {</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">{__proto__:null,</span><span class="s3">\&quot; </span><span class="s1">+ Object.keys(table).map(key =&gt; `${/^(</span><span class="s3">\\</span><span class="s1">d+|[a-zA-Z_]</span><span class="s3">\\</span><span class="s1">w*)$/.test(key) ? key : JSON.stringify(key)}:${table[key]}`)</span><span class="s3">\n                </span><span class="s1">.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let specHead = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let specialized = rawSpecialized.map(v =&gt; {</span><span class="s3">\n            </span><span class="s1">if (v instanceof ExternalSpecializer) {</span><span class="s3">\n                </span><span class="s1">let name = importName(v.ast.id.name, v.ast.source);</span><span class="s3">\n                </span><span class="s1">let ts = this.options.typeScript ? </span><span class="s3">\&quot;</span><span class="s1">: any</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">return `{term: ${v.term.id}, get: (value${ts}, stack${ts}) =&gt; (${name}(value, stack) &lt;&lt; 1)${v.ast.type == </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot; </span><span class="s1">? ` | ${1 /* Specialize.Extend */}` : ''}, external: ${name}${v.ast.type == </span><span class="s3">\&quot;</span><span class="s1">extend</span><span class="s3">\&quot; </span><span class="s1">? ', extend: true' : ''}}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let tableName = getName(</span><span class="s3">\&quot;</span><span class="s1">spec_</span><span class="s3">\&quot; </span><span class="s1">+ v.token.name.replace(/</span><span class="s3">\\</span><span class="s1">W/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n                </span><span class="s1">defined[tableName] = true;</span><span class="s3">\n                </span><span class="s1">specHead += `const ${tableName} = ${specializationTableString(v.table)}</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n                </span><span class="s1">let ts = this.options.typeScript ? `: keyof typeof ${tableName}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">return `{term: ${v.token.id}, get: (value${ts}) =&gt; ${tableName}[value] || -1}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let propSources = this.ast.externalPropSources.map(s =&gt; importName(s.id.name, s.source));</span><span class="s3">\n        </span><span class="s1">for (let source in imports) {</span><span class="s3">\n            </span><span class="s1">if (mod == </span><span class="s3">\&quot;</span><span class="s1">cjs</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">head += `const {${imports[source].join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}} = require(${source})</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">head += `import {${imports[source].join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}} from ${source}</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">head += specHead;</span><span class="s3">\n        </span><span class="s1">function serializePropValue(value) {</span><span class="s3">\n            </span><span class="s1">return typeof value != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| /^(true|false|</span><span class="s3">\\</span><span class="s1">d+(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)$/.test(value) ? value : JSON.stringify(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let dialects = Object.keys(rawDialects).map(d =&gt; `${d}: ${rawDialects[d]}`);</span><span class="s3">\n        </span><span class="s1">let parserStr = `${lrParser}.deserialize({</span><span class="s3">\n  </span><span class="s1">version: ${14 /* File.Version */},</span><span class="s3">\n  </span><span class="s1">states: ${encodeArray(states, 0xffffffff)},</span><span class="s3">\n  </span><span class="s1">stateData: ${encodeArray(stateData)},</span><span class="s3">\n  </span><span class="s1">goto: ${encodeArray(goto)},</span><span class="s3">\n  </span><span class="s1">nodeNames: ${JSON.stringify(nodeNames)},</span><span class="s3">\n  </span><span class="s1">maxTerm: ${maxTerm}${context ? `,</span><span class="s3">\n  </span><span class="s1">context: ${context}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${nodeProps.length ? `,</span><span class="s3">\n  </span><span class="s1">nodeProps: [</span><span class="s3">\n    </span><span class="s1">${nodeProps.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\\</span><span class="s1">n    </span><span class="s3">\&quot;</span><span class="s1">)}</span><span class="s3">\n  </span><span class="s1">]` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${propSources.length ? `,</span><span class="s3">\n  </span><span class="s1">propSources: [${propSources.join()}]` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${skippedTypes.length ? `,</span><span class="s3">\n  </span><span class="s1">skippedNodes: ${JSON.stringify(skippedTypes)}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">repeatNodeCount: ${repeatNodeCount},</span><span class="s3">\n  </span><span class="s1">tokenData: ${encodeArray(tokenData)},</span><span class="s3">\n  </span><span class="s1">tokenizers: [${tokenizers.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}],</span><span class="s3">\n  </span><span class="s1">topRules: ${JSON.stringify(topRules)}${dialects.length ? `,</span><span class="s3">\n  </span><span class="s1">dialects: {${dialects.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${dynamicPrecedences ? `,</span><span class="s3">\n  </span><span class="s1">dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${specialized.length ? `,</span><span class="s3">\n  </span><span class="s1">specialized: [${specialized.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}]` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">tokenPrec: ${tokenPrec}${this.options.includeNames ? `,</span><span class="s3">\n  </span><span class="s1">termNames: ${JSON.stringify(termNames)}` : ''}</span><span class="s3">\n</span><span class="s1">})`;</span><span class="s3">\n        </span><span class="s1">let terms = [];</span><span class="s3">\n        </span><span class="s1">for (let name in this.termTable) {</span><span class="s3">\n            </span><span class="s1">let id = name;</span><span class="s3">\n            </span><span class="s1">if (KEYWORDS.includes(id))</span><span class="s3">\n                </span><span class="s1">for (let i = 1;; i++) {</span><span class="s3">\n                    </span><span class="s1">id = </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">.repeat(i) + name;</span><span class="s3">\n                    </span><span class="s1">if (!(id in this.termTable))</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!/^[</span><span class="s3">\\</span><span class="s1">w$]+$/.test(name)) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">terms.push(`${id}${mod == </span><span class="s3">\&quot;</span><span class="s1">cjs</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">} ${this.termTable[name]}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let id = 0; id &lt; this.dialects.length; id++)</span><span class="s3">\n            </span><span class="s1">terms.push(`Dialect_${this.dialects[id]}${mod == </span><span class="s3">\&quot;</span><span class="s1">cjs</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">} ${id}`);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">parser: head + (mod == </span><span class="s3">\&quot;</span><span class="s1">cjs</span><span class="s3">\&quot; </span><span class="s1">? `exports.${exportName} = ${parserStr}</span><span class="s3">\\</span><span class="s1">n` : `export const ${exportName} = ${parserStr}</span><span class="s3">\\</span><span class="s1">n`),</span><span class="s3">\n            </span><span class="s1">terms: mod == </span><span class="s3">\&quot;</span><span class="s1">cjs</span><span class="s3">\&quot; </span><span class="s1">? `${gen}module.exports = {</span><span class="s3">\\</span><span class="s1">n  ${terms.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\\</span><span class="s1">n  </span><span class="s3">\&quot;</span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">n}`</span><span class="s3">\n                </span><span class="s1">: `${gen}export const</span><span class="s3">\\</span><span class="s1">n  ${terms.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\\</span><span class="s1">n  </span><span class="s3">\&quot;</span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gatherNonSkippedNodes() {</span><span class="s3">\n        </span><span class="s1">let seen = Object.create(null);</span><span class="s3">\n        </span><span class="s1">let work = [];</span><span class="s3">\n        </span><span class="s1">let add = (term) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!seen[term.id]) {</span><span class="s3">\n                </span><span class="s1">seen[term.id] = true;</span><span class="s3">\n                </span><span class="s1">work.push(term);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.terms.tops.forEach(add);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; work.length; i++) {</span><span class="s3">\n            </span><span class="s1">for (let rule of work[i].rules)</span><span class="s3">\n                </span><span class="s1">for (let part of rule.parts)</span><span class="s3">\n                    </span><span class="s1">add(part);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return seen;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gatherNodeProps(nodeTypes) {</span><span class="s3">\n        </span><span class="s1">let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = [];</span><span class="s3">\n        </span><span class="s1">let nodeProps = [];</span><span class="s3">\n        </span><span class="s1">for (let type of nodeTypes) {</span><span class="s3">\n            </span><span class="s1">if (!notSkipped[type.id] &amp;&amp; !type.error)</span><span class="s3">\n                </span><span class="s1">skippedTypes.push(type.id);</span><span class="s3">\n            </span><span class="s1">for (let prop in type.props) {</span><span class="s3">\n                </span><span class="s1">let known = this.knownProps[prop];</span><span class="s3">\n                </span><span class="s1">if (!known)</span><span class="s3">\n                    </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">No known prop type for </span><span class="s3">\&quot; </span><span class="s1">+ prop);</span><span class="s3">\n                </span><span class="s1">if (known.source.from == null &amp;&amp; (known.source.name == </span><span class="s3">\&quot;</span><span class="s1">repeated</span><span class="s3">\&quot; </span><span class="s1">|| known.source.name == </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">let rec = nodeProps.find(r =&gt; r.prop == prop);</span><span class="s3">\n                </span><span class="s1">if (!rec)</span><span class="s3">\n                    </span><span class="s1">nodeProps.push(rec = { prop, values: {} });</span><span class="s3">\n                </span><span class="s1">(rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">nodeProps: nodeProps.map(({ prop, values }) =&gt; {</span><span class="s3">\n                </span><span class="s1">let terms = [];</span><span class="s3">\n                </span><span class="s1">for (let val in values) {</span><span class="s3">\n                    </span><span class="s1">let ids = values[val];</span><span class="s3">\n                    </span><span class="s1">if (ids.length == 1) {</span><span class="s3">\n                        </span><span class="s1">terms.push(ids[0], val);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">terms.push(-ids.length);</span><span class="s3">\n                        </span><span class="s1">for (let id of ids)</span><span class="s3">\n                            </span><span class="s1">terms.push(id);</span><span class="s3">\n                        </span><span class="s1">terms.push(val);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return { prop, terms };</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">skippedTypes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">makeTerminal(name, tag, props) {</span><span class="s3">\n        </span><span class="s1">return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeForceReductions(states, skipInfo) {</span><span class="s3">\n        </span><span class="s1">// This finds a forced reduction for every state, trying to guard</span><span class="s3">\n        </span><span class="s1">// against cyclic forced reductions, where a given parse stack can</span><span class="s3">\n        </span><span class="s1">// endlessly continue running forced reductions without making any</span><span class="s3">\n        </span><span class="s1">// progress.</span><span class="s3">\n        </span><span class="s1">//</span><span class="s3">\n        </span><span class="s1">// This occurs with length-1 reductions. We never generate</span><span class="s3">\n        </span><span class="s1">// length-0 reductions, and length-2+ reductions always shrink the</span><span class="s3">\n        </span><span class="s1">// stack, so they are guaranteed to make progress.</span><span class="s3">\n        </span><span class="s1">//</span><span class="s3">\n        </span><span class="s1">// If there are states S1 and S2 whose forced reductions reduce</span><span class="s3">\n        </span><span class="s1">// terms T1 and T2 respectively, both with a length of 1, _and_</span><span class="s3">\n        </span><span class="s1">// there is a state S3, which has goto entries T1 -&gt; S2, T2 -&gt; S1,</span><span class="s3">\n        </span><span class="s1">// you can get cyclic reductions. Of course, the cycle may also</span><span class="s3">\n        </span><span class="s1">// contain more than two steps.</span><span class="s3">\n        </span><span class="s1">let reductions = [];</span><span class="s3">\n        </span><span class="s1">let candidates = [];</span><span class="s3">\n        </span><span class="s1">// A map from terms to states that they are mapped to in goto</span><span class="s3">\n        </span><span class="s1">// entries.</span><span class="s3">\n        </span><span class="s1">let gotoEdges = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let state of states) {</span><span class="s3">\n            </span><span class="s1">reductions.push(0);</span><span class="s3">\n            </span><span class="s1">for (let edge of state.goto) {</span><span class="s3">\n                </span><span class="s1">let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = []);</span><span class="s3">\n                </span><span class="s1">let found = array.find(o =&gt; o.target == edge.target.id);</span><span class="s3">\n                </span><span class="s1">if (found)</span><span class="s3">\n                    </span><span class="s1">found.parents.push(state.id);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">array.push({ parents: [state.id], target: edge.target.id });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">candidates[state.id] = state.set.filter(pos =&gt; pos.pos &gt; 0 &amp;&amp; !pos.rule.name.top)</span><span class="s3">\n                </span><span class="s1">.sort((a, b) =&gt; b.pos - a.pos || a.rule.parts.length - b.rule.parts.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Mapping from state ids to terms that that state has a length-1</span><span class="s3">\n        </span><span class="s1">// forced reduction for.</span><span class="s3">\n        </span><span class="s1">let length1Reductions = Object.create(null);</span><span class="s3">\n        </span><span class="s1">function createsCycle(term, startState, parents = null) {</span><span class="s3">\n            </span><span class="s1">let edges = gotoEdges[term];</span><span class="s3">\n            </span><span class="s1">if (!edges)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">return edges.some(val =&gt; {</span><span class="s3">\n                </span><span class="s1">let parentIntersection = parents ? parents.filter(id =&gt; val.parents.includes(id)) : val.parents;</span><span class="s3">\n                </span><span class="s1">if (parentIntersection.length == 0)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">if (val.target == startState)</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">let found = length1Reductions[val.target];</span><span class="s3">\n                </span><span class="s1">return found != null &amp;&amp; createsCycle(found, startState, parentIntersection);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let state of states) {</span><span class="s3">\n            </span><span class="s1">if (state.defaultReduce &amp;&amp; state.defaultReduce.parts.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">reductions[state.id] = reduceAction(state.defaultReduce, skipInfo);</span><span class="s3">\n                </span><span class="s1">if (state.defaultReduce.parts.length == 1)</span><span class="s3">\n                    </span><span class="s1">length1Reductions[state.id] = state.defaultReduce.name.id;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// To avoid painting states that only have one potential forced</span><span class="s3">\n        </span><span class="s1">// reduction into a corner, reduction assignment is done by</span><span class="s3">\n        </span><span class="s1">// candidate size, starting with the states with fewer candidates.</span><span class="s3">\n        </span><span class="s1">for (let setSize = 1;; setSize++) {</span><span class="s3">\n            </span><span class="s1">let done = true;</span><span class="s3">\n            </span><span class="s1">for (let state of states) {</span><span class="s3">\n                </span><span class="s1">if (state.defaultReduce)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">let set = candidates[state.id];</span><span class="s3">\n                </span><span class="s1">if (set.length != setSize) {</span><span class="s3">\n                    </span><span class="s1">if (set.length &gt; setSize)</span><span class="s3">\n                        </span><span class="s1">done = false;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">for (let pos of set) {</span><span class="s3">\n                    </span><span class="s1">if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {</span><span class="s3">\n                        </span><span class="s1">reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos);</span><span class="s3">\n                        </span><span class="s1">if (pos.pos == 1)</span><span class="s3">\n                            </span><span class="s1">length1Reductions[state.id] = pos.rule.name.id;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (done)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return reductions;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">substituteArgs(expr, args, params) {</span><span class="s3">\n        </span><span class="s1">if (args.length == 0)</span><span class="s3">\n            </span><span class="s1">return expr;</span><span class="s3">\n        </span><span class="s1">return expr.walk(expr =&gt; {</span><span class="s3">\n            </span><span class="s1">let found;</span><span class="s3">\n            </span><span class="s1">if (expr instanceof NameExpression &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(found = params.findIndex(p =&gt; p.name == expr.id.name)) &gt; -1) {</span><span class="s3">\n                </span><span class="s1">let arg = args[found];</span><span class="s3">\n                </span><span class="s1">if (expr.args.length) {</span><span class="s3">\n                    </span><span class="s1">if (arg instanceof NameExpression &amp;&amp; !arg.args.length)</span><span class="s3">\n                        </span><span class="s1">return new NameExpression(expr.start, arg.id, expr.args);</span><span class="s3">\n                    </span><span class="s1">this.raise(`Passing arguments to a parameter that already has arguments`, expr.start);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return arg;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (expr instanceof InlineRuleExpression) {</span><span class="s3">\n                </span><span class="s1">let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params);</span><span class="s3">\n                </span><span class="s1">return props == r.props ? expr :</span><span class="s3">\n                    </span><span class="s1">new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (expr instanceof SpecializeExpression) {</span><span class="s3">\n                </span><span class="s1">let props = this.substituteArgsInProps(expr.props, args, params);</span><span class="s3">\n                </span><span class="s1">return props == expr.props ? expr :</span><span class="s3">\n                    </span><span class="s1">new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return expr;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">substituteArgsInProps(props, args, params) {</span><span class="s3">\n        </span><span class="s1">let substituteInValue = (value) =&gt; {</span><span class="s3">\n            </span><span class="s1">let result = value;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; value.length; i++) {</span><span class="s3">\n                </span><span class="s1">let part = value[i];</span><span class="s3">\n                </span><span class="s1">if (!part.name)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">let found = params.findIndex(p =&gt; p.name == part.name);</span><span class="s3">\n                </span><span class="s1">if (found &lt; 0)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">if (result == value)</span><span class="s3">\n                    </span><span class="s1">result = value.slice();</span><span class="s3">\n                </span><span class="s1">let expr = args[found];</span><span class="s3">\n                </span><span class="s1">if (expr instanceof NameExpression &amp;&amp; !expr.args.length)</span><span class="s3">\n                    </span><span class="s1">result[i] = new PropPart(part.start, expr.id.name, null);</span><span class="s3">\n                </span><span class="s1">else if (expr instanceof LiteralExpression)</span><span class="s3">\n                    </span><span class="s1">result[i] = new PropPart(part.start, expr.value, null);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let result = props;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; props.length; i++) {</span><span class="s3">\n            </span><span class="s1">let prop = props[i], value = substituteInValue(prop.value);</span><span class="s3">\n            </span><span class="s1">if (value != prop.value) {</span><span class="s3">\n                </span><span class="s1">if (result == props)</span><span class="s3">\n                    </span><span class="s1">result = props.slice();</span><span class="s3">\n                </span><span class="s1">result[i] = new Prop(prop.start, prop.at, prop.name, value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">conflictsFor(markers) {</span><span class="s3">\n        </span><span class="s1">let here = Conflicts.none, atEnd = Conflicts.none;</span><span class="s3">\n        </span><span class="s1">for (let marker of markers) {</span><span class="s3">\n            </span><span class="s1">if (marker.type == </span><span class="s3">\&quot;</span><span class="s1">ambig</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">here = here.join(new Conflicts(0, [marker.id.name]));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let precs = this.ast.precedences;</span><span class="s3">\n                </span><span class="s1">let index = precs ? precs.items.findIndex(item =&gt; item.id.name == marker.id.name) : -1;</span><span class="s3">\n                </span><span class="s1">if (index &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start);</span><span class="s3">\n                </span><span class="s1">let prec = precs.items[index], value = precs.items.length - index;</span><span class="s3">\n                </span><span class="s1">if (prec.type == </span><span class="s3">\&quot;</span><span class="s1">cut</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">here = here.join(new Conflicts(0, none, value));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">here = here.join(new Conflicts(value &lt;&lt; 2));</span><span class="s3">\n                    </span><span class="s1">atEnd = atEnd.join(new Conflicts((value &lt;&lt; 2) + (prec.type == </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot; </span><span class="s1">? 1 : prec.type == </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot; </span><span class="s1">? -1 : 0)));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { here, atEnd };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">raise(message, pos = 1) {</span><span class="s3">\n        </span><span class="s1">return this.input.raise(message, pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">warn(message, pos = -1) {</span><span class="s3">\n        </span><span class="s1">let msg = this.input.message(message, pos);</span><span class="s3">\n        </span><span class="s1">if (this.options.warn)</span><span class="s3">\n            </span><span class="s1">this.options.warn(msg);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">console.warn(msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">defineRule(name, choices) {</span><span class="s3">\n        </span><span class="s1">let skip = this.currentSkip[this.currentSkip.length - 1];</span><span class="s3">\n        </span><span class="s1">for (let choice of choices)</span><span class="s3">\n            </span><span class="s1">this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolve(expr) {</span><span class="s3">\n        </span><span class="s1">for (let built of this.built)</span><span class="s3">\n            </span><span class="s1">if (built.matches(expr))</span><span class="s3">\n                </span><span class="s1">return [p(built.term)];</span><span class="s3">\n        </span><span class="s1">let found = this.tokens.getToken(expr);</span><span class="s3">\n        </span><span class="s1">if (found)</span><span class="s3">\n            </span><span class="s1">return [p(found)];</span><span class="s3">\n        </span><span class="s1">for (let grp of this.localTokens) {</span><span class="s3">\n            </span><span class="s1">let found = grp.getToken(expr);</span><span class="s3">\n            </span><span class="s1">if (found)</span><span class="s3">\n                </span><span class="s1">return [p(found)];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let ext of this.externalTokens) {</span><span class="s3">\n            </span><span class="s1">let found = ext.getToken(expr);</span><span class="s3">\n            </span><span class="s1">if (found)</span><span class="s3">\n                </span><span class="s1">return [p(found)];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let ext of this.externalSpecializers) {</span><span class="s3">\n            </span><span class="s1">let found = ext.getToken(expr);</span><span class="s3">\n            </span><span class="s1">if (found)</span><span class="s3">\n                </span><span class="s1">return [p(found)];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let known = this.astRules.find(r =&gt; r.rule.id.name == expr.id.name);</span><span class="s3">\n        </span><span class="s1">if (!known)</span><span class="s3">\n            </span><span class="s1">return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start);</span><span class="s3">\n        </span><span class="s1">if (known.rule.params.length != expr.args.length)</span><span class="s3">\n            </span><span class="s1">this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start);</span><span class="s3">\n        </span><span class="s1">this.used(known.rule.id.name);</span><span class="s3">\n        </span><span class="s1">return [p(this.buildRule(known.rule, expr.args, known.skip))];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// For tree-balancing reasons, repeat expressions X+ have to be</span><span class="s3">\n    </span><span class="s1">// normalized to something like</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">//     R -&gt; X | R R</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Returns the `R` term.</span><span class="s3">\n    </span><span class="s1">normalizeRepeat(expr) {</span><span class="s3">\n        </span><span class="s1">let known = this.built.find(b =&gt; b.matchesRepeat(expr));</span><span class="s3">\n        </span><span class="s1">if (known)</span><span class="s3">\n            </span><span class="s1">return p(known.term);</span><span class="s3">\n        </span><span class="s1">let name = expr.expr.prec &lt; expr.prec ? `(${expr.expr})+` : `${expr.expr}+`;</span><span class="s3">\n        </span><span class="s1">let term = this.terms.makeRepeat(this.terms.uniqueName(name));</span><span class="s3">\n        </span><span class="s1">this.built.push(new BuiltRule(</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">, [expr.expr], term));</span><span class="s3">\n        </span><span class="s1">this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)));</span><span class="s3">\n        </span><span class="s1">return p(term);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">normalizeSequence(expr) {</span><span class="s3">\n        </span><span class="s1">let result = expr.exprs.map(e =&gt; this.normalizeExpr(e));</span><span class="s3">\n        </span><span class="s1">let builder = this;</span><span class="s3">\n        </span><span class="s1">function complete(start, from, endConflicts) {</span><span class="s3">\n            </span><span class="s1">let { here, atEnd } = builder.conflictsFor(expr.markers[from]);</span><span class="s3">\n            </span><span class="s1">if (from == result.length)</span><span class="s3">\n                </span><span class="s1">return [start.withConflicts(start.terms.length, here.join(endConflicts))];</span><span class="s3">\n            </span><span class="s1">let choices = [];</span><span class="s3">\n            </span><span class="s1">for (let choice of result[from]) {</span><span class="s3">\n                </span><span class="s1">for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here), from + 1, endConflicts.join(atEnd)))</span><span class="s3">\n                    </span><span class="s1">choices.push(full);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return choices;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return complete(Parts.none, 0, Conflicts.none);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">normalizeExpr(expr) {</span><span class="s3">\n        </span><span class="s1">if (expr instanceof RepeatExpression &amp;&amp; expr.kind == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return [Parts.none, ...this.normalizeExpr(expr.expr)];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof RepeatExpression) {</span><span class="s3">\n            </span><span class="s1">let repeated = this.normalizeRepeat(expr);</span><span class="s3">\n            </span><span class="s1">return expr.kind == </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">? [repeated] : [Parts.none, repeated];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof ChoiceExpression) {</span><span class="s3">\n            </span><span class="s1">return expr.exprs.reduce((o, e) =&gt; o.concat(this.normalizeExpr(e)), []);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof SequenceExpression) {</span><span class="s3">\n            </span><span class="s1">return this.normalizeSequence(expr);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof LiteralExpression) {</span><span class="s3">\n            </span><span class="s1">return [p(this.tokens.getLiteral(expr))];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof NameExpression) {</span><span class="s3">\n            </span><span class="s1">return this.resolve(expr);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof SpecializeExpression) {</span><span class="s3">\n            </span><span class="s1">return [p(this.resolveSpecialization(expr))];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof InlineRuleExpression) {</span><span class="s3">\n            </span><span class="s1">return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildRule(rule, args, skip, inline = false) {</span><span class="s3">\n        </span><span class="s1">let expr = this.substituteArgs(rule.expr, args, rule.params);</span><span class="s3">\n        </span><span class="s1">let { name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported } = this.nodeInfo(rule.props || none, inline ? </span><span class="s3">\&quot;</span><span class="s1">pg</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">pgi</span><span class="s3">\&quot;</span><span class="s1">, rule.id.name, args, rule.params, rule.expr);</span><span class="s3">\n        </span><span class="s1">if (exported &amp;&amp; rule.params.length)</span><span class="s3">\n            </span><span class="s1">this.warn(`Can't export parameterized rules`, rule.start);</span><span class="s3">\n        </span><span class="s1">if (exported &amp;&amp; inline)</span><span class="s3">\n            </span><span class="s1">this.warn(`Can't export inline rule`, rule.start);</span><span class="s3">\n        </span><span class="s1">let name = this.newName(rule.id.name + (args.length ? </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot; </span><span class="s1">+ args.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">), nodeName || true, props);</span><span class="s3">\n        </span><span class="s1">if (explicitInline)</span><span class="s3">\n            </span><span class="s1">name.inline = true;</span><span class="s3">\n        </span><span class="s1">if (dynamicPrec)</span><span class="s3">\n            </span><span class="s1">this.registerDynamicPrec(name, dynamicPrec);</span><span class="s3">\n        </span><span class="s1">if ((name.nodeType || exported) &amp;&amp; rule.params.length == 0) {</span><span class="s3">\n            </span><span class="s1">if (!nodeName)</span><span class="s3">\n                </span><span class="s1">name.preserve = true;</span><span class="s3">\n            </span><span class="s1">if (!inline)</span><span class="s3">\n                </span><span class="s1">this.namedTerms[exported || rule.id.name] = name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!inline)</span><span class="s3">\n            </span><span class="s1">this.built.push(new BuiltRule(rule.id.name, args, name));</span><span class="s3">\n        </span><span class="s1">this.currentSkip.push(skip);</span><span class="s3">\n        </span><span class="s1">let parts = this.normalizeExpr(expr);</span><span class="s3">\n        </span><span class="s1">if (parts.length &gt; 100 * (expr instanceof ChoiceExpression ? expr.exprs.length : 1))</span><span class="s3">\n            </span><span class="s1">this.warn(`Rule ${rule.id.name} is generating a lot (${parts.length}) of choices.</span><span class="s3">\\</span><span class="s1">n  Consider splitting it up or reducing the amount of ? or | operator uses.`, rule.start);</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">brulesize</span><span class="s3">\\</span><span class="s1">b/.test(verbose) &amp;&amp; parts.length &gt; 10)</span><span class="s3">\n            </span><span class="s1">console.log(`Rule ${rule.id.name}: ${parts.length} variants`);</span><span class="s3">\n        </span><span class="s1">this.defineRule(name, parts);</span><span class="s3">\n        </span><span class="s1">this.currentSkip.pop();</span><span class="s3">\n        </span><span class="s1">if (group)</span><span class="s3">\n            </span><span class="s1">this.definedGroups.push({ name, group, rule });</span><span class="s3">\n        </span><span class="s1">return name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nodeInfo(props, </span><span class="s3">\n    </span><span class="s1">// p for dynamic precedence, d for dialect, i for inline, g for group, a for disabling the ignore test for default name</span><span class="s3">\n    </span><span class="s1">allow, defaultName = null, args = none, params = none, expr, defaultProps) {</span><span class="s3">\n        </span><span class="s1">let result = {};</span><span class="s3">\n        </span><span class="s1">let name = defaultName &amp;&amp; (allow.indexOf(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">) &gt; -1 || !ignored(defaultName)) &amp;&amp; !/ /.test(defaultName) ? defaultName : null;</span><span class="s3">\n        </span><span class="s1">let dialect = null, dynamicPrec = 0, inline = false, group = null, exported = null;</span><span class="s3">\n        </span><span class="s1">for (let prop of props) {</span><span class="s3">\n            </span><span class="s1">if (!prop.at) {</span><span class="s3">\n                </span><span class="s1">if (!this.knownProps[prop.name]) {</span><span class="s3">\n                    </span><span class="s1">let builtin = [</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dialect</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dynamicPrecedence</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">isGroup</span><span class="s3">\&quot;</span><span class="s1">].includes(prop.name)</span><span class="s3">\n                        </span><span class="s1">? ` (did you mean '@${prop.name}'?)` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                    </span><span class="s1">this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">result[prop.name] = this.finishProp(prop, args, params);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prop.name == </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">name = this.finishProp(prop, args, params);</span><span class="s3">\n                </span><span class="s1">if (/ /.test(name))</span><span class="s3">\n                    </span><span class="s1">this.raise(`Node names cannot have spaces ('${name}')`, prop.start);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prop.name == </span><span class="s3">\&quot;</span><span class="s1">dialect</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (allow.indexOf(</span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">) &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">Can't specify a dialect on non-token rules</span><span class="s3">\&quot;</span><span class="s1">, props[0].start);</span><span class="s3">\n                </span><span class="s1">if (prop.value.length != 1 &amp;&amp; !prop.value[0].value)</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">The '@dialect' rule prop must hold a plain string value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">let dialectID = this.dialects.indexOf(prop.value[0].value);</span><span class="s3">\n                </span><span class="s1">if (dialectID &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start);</span><span class="s3">\n                </span><span class="s1">dialect = dialectID;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prop.name == </span><span class="s3">\&quot;</span><span class="s1">dynamicPrecedence</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (allow.indexOf(</span><span class="s3">\&quot;</span><span class="s1">p</span><span class="s3">\&quot;</span><span class="s1">) &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">Dynamic precedence can only be specified on nonterminals</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (prop.value.length != 1 || !/^-?(?:10|</span><span class="s3">\\</span><span class="s1">d)$/.test(prop.value[0].value))</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">dynamicPrec = +prop.value[0].value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prop.name == </span><span class="s3">\&quot;</span><span class="s1">inline</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (prop.value.length)</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">'@inline' doesn't take a value</span><span class="s3">\&quot;</span><span class="s1">, prop.value[0].start);</span><span class="s3">\n                </span><span class="s1">if (allow.indexOf(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">) &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">Inline can only be specified on nonterminals</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">inline = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prop.name == </span><span class="s3">\&quot;</span><span class="s1">isGroup</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (allow.indexOf(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">) &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.raise(</span><span class="s3">\&quot;</span><span class="s1">'@isGroup' can only be specified on nonterminals</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">group = prop.value.length ? this.finishProp(prop, args, params) : defaultName;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prop.name == </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (prop.value.length)</span><span class="s3">\n                    </span><span class="s1">exported = this.finishProp(prop, args, params);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">exported = defaultName;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (expr &amp;&amp; this.ast.autoDelim &amp;&amp; (name || hasProps(result))) {</span><span class="s3">\n            </span><span class="s1">let delim = this.findDelimiters(expr);</span><span class="s3">\n            </span><span class="s1">if (delim) {</span><span class="s3">\n                </span><span class="s1">addToProp(delim[0], </span><span class="s3">\&quot;</span><span class="s1">closedBy</span><span class="s3">\&quot;</span><span class="s1">, delim[1].nodeName);</span><span class="s3">\n                </span><span class="s1">addToProp(delim[1], </span><span class="s3">\&quot;</span><span class="s1">openedBy</span><span class="s3">\&quot;</span><span class="s1">, delim[0].nodeName);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (defaultProps &amp;&amp; hasProps(defaultProps)) {</span><span class="s3">\n            </span><span class="s1">for (let prop in defaultProps)</span><span class="s3">\n                </span><span class="s1">if (!(prop in result))</span><span class="s3">\n                    </span><span class="s1">result[prop] = defaultProps[prop];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (hasProps(result) &amp;&amp; !name)</span><span class="s3">\n            </span><span class="s1">this.raise(`Node has properties but no name`, props.length ? props[0].start : expr.start);</span><span class="s3">\n        </span><span class="s1">if (inline &amp;&amp; (hasProps(result) || dialect || dynamicPrec))</span><span class="s3">\n            </span><span class="s1">this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start);</span><span class="s3">\n        </span><span class="s1">if (inline &amp;&amp; name)</span><span class="s3">\n            </span><span class="s1">name = null;</span><span class="s3">\n        </span><span class="s1">return { name, props: result, dialect, dynamicPrec, inline, group, exported };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finishProp(prop, args, params) {</span><span class="s3">\n        </span><span class="s1">return prop.value.map(part =&gt; {</span><span class="s3">\n            </span><span class="s1">if (part.value)</span><span class="s3">\n                </span><span class="s1">return part.value;</span><span class="s3">\n            </span><span class="s1">let pos = params.findIndex(param =&gt; param.name == part.name);</span><span class="s3">\n            </span><span class="s1">if (pos &lt; 0)</span><span class="s3">\n                </span><span class="s1">this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start);</span><span class="s3">\n            </span><span class="s1">let expr = args[pos];</span><span class="s3">\n            </span><span class="s1">if (expr instanceof NameExpression &amp;&amp; !expr.args.length)</span><span class="s3">\n                </span><span class="s1">return expr.id.name;</span><span class="s3">\n            </span><span class="s1">if (expr instanceof LiteralExpression)</span><span class="s3">\n                </span><span class="s1">return expr.value;</span><span class="s3">\n            </span><span class="s1">return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start);</span><span class="s3">\n        </span><span class="s1">}).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolveSpecialization(expr) {</span><span class="s3">\n        </span><span class="s1">let type = expr.type;</span><span class="s3">\n        </span><span class="s1">let { name, props, dialect, exported } = this.nodeInfo(expr.props, </span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let terminal = this.normalizeExpr(expr.token);</span><span class="s3">\n        </span><span class="s1">if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)</span><span class="s3">\n            </span><span class="s1">this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start);</span><span class="s3">\n        </span><span class="s1">let values;</span><span class="s3">\n        </span><span class="s1">if (expr.content instanceof LiteralExpression)</span><span class="s3">\n            </span><span class="s1">values = [expr.content.value];</span><span class="s3">\n        </span><span class="s1">else if ((expr.content instanceof ChoiceExpression) &amp;&amp; expr.content.exprs.every(e =&gt; e instanceof LiteralExpression))</span><span class="s3">\n            </span><span class="s1">values = expr.content.exprs.map(expr =&gt; expr.value);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start);</span><span class="s3">\n        </span><span class="s1">let term = terminal[0].terms[0], token = null;</span><span class="s3">\n        </span><span class="s1">let table = this.specialized[term.name] || (this.specialized[term.name] = []);</span><span class="s3">\n        </span><span class="s1">for (let value of values) {</span><span class="s3">\n            </span><span class="s1">let known = table.find(sp =&gt; sp.value == value);</span><span class="s3">\n            </span><span class="s1">if (known == null) {</span><span class="s3">\n                </span><span class="s1">if (!token) {</span><span class="s3">\n                    </span><span class="s1">token = this.makeTerminal(term.name + </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(value), name, props);</span><span class="s3">\n                    </span><span class="s1">if (dialect != null)</span><span class="s3">\n                        </span><span class="s1">(this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">table.push({ value, term: token, type, dialect, name });</span><span class="s3">\n                </span><span class="s1">this.tokenOrigins[token.name] = { spec: term };</span><span class="s3">\n                </span><span class="s1">if (name || exported) {</span><span class="s3">\n                    </span><span class="s1">if (!name)</span><span class="s3">\n                        </span><span class="s1">token.preserve = true;</span><span class="s3">\n                    </span><span class="s1">this.namedTerms[exported || name] = token;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (known.type != type)</span><span class="s3">\n                    </span><span class="s1">this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`, expr.start);</span><span class="s3">\n                </span><span class="s1">if (known.dialect != dialect)</span><span class="s3">\n                    </span><span class="s1">this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);</span><span class="s3">\n                </span><span class="s1">if (known.name != name)</span><span class="s3">\n                    </span><span class="s1">this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);</span><span class="s3">\n                </span><span class="s1">if (token &amp;&amp; known.term != token)</span><span class="s3">\n                    </span><span class="s1">this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start);</span><span class="s3">\n                </span><span class="s1">token = known.term;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return token;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findDelimiters(expr) {</span><span class="s3">\n        </span><span class="s1">if (!(expr instanceof SequenceExpression) || expr.exprs.length &lt; 2)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let findToken = (expr) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (expr instanceof LiteralExpression)</span><span class="s3">\n                </span><span class="s1">return { term: this.tokens.getLiteral(expr), str: expr.value };</span><span class="s3">\n            </span><span class="s1">if (expr instanceof NameExpression &amp;&amp; expr.args.length == 0) {</span><span class="s3">\n                </span><span class="s1">let rule = this.ast.rules.find(r =&gt; r.id.name == expr.id.name);</span><span class="s3">\n                </span><span class="s1">if (rule)</span><span class="s3">\n                    </span><span class="s1">return findToken(rule.expr);</span><span class="s3">\n                </span><span class="s1">let token = this.tokens.rules.find(r =&gt; r.id.name == expr.id.name);</span><span class="s3">\n                </span><span class="s1">if (token &amp;&amp; token.expr instanceof LiteralExpression)</span><span class="s3">\n                    </span><span class="s1">return { term: this.tokens.getToken(expr), str: token.expr.value };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let lastToken = findToken(expr.exprs[expr.exprs.length - 1]);</span><span class="s3">\n        </span><span class="s1">if (!lastToken || !lastToken.term.nodeName)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">const brackets = [</span><span class="s3">\&quot;</span><span class="s1">()</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{}</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">let bracket = brackets.find(b =&gt; lastToken.str.indexOf(b[1]) &gt; -1 &amp;&amp; lastToken.str.indexOf(b[0]) &lt; 0);</span><span class="s3">\n        </span><span class="s1">if (!bracket)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let firstToken = findToken(expr.exprs[0]);</span><span class="s3">\n        </span><span class="s1">if (!firstToken || !firstToken.term.nodeName ||</span><span class="s3">\n            </span><span class="s1">firstToken.str.indexOf(bracket[0]) &lt; 0 || firstToken.str.indexOf(bracket[1]) &gt; -1)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">return [firstToken.term, lastToken.term];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">registerDynamicPrec(term, prec) {</span><span class="s3">\n        </span><span class="s1">this.dynamicRulePrecedences.push({ rule: term, prec });</span><span class="s3">\n        </span><span class="s1">term.preserve = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">defineGroup(rule, group, ast) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let recur = [];</span><span class="s3">\n        </span><span class="s1">let getNamed = (rule) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (rule.nodeName)</span><span class="s3">\n                </span><span class="s1">return [rule];</span><span class="s3">\n            </span><span class="s1">if (recur.includes(rule))</span><span class="s3">\n                </span><span class="s1">this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`, ast.start);</span><span class="s3">\n            </span><span class="s1">let result = [];</span><span class="s3">\n            </span><span class="s1">recur.push(rule);</span><span class="s3">\n            </span><span class="s1">for (let r of this.rules)</span><span class="s3">\n                </span><span class="s1">if (r.name == rule) {</span><span class="s3">\n                    </span><span class="s1">let names = r.parts.map(getNamed).filter(x =&gt; x.length);</span><span class="s3">\n                    </span><span class="s1">if (names.length &gt; 1)</span><span class="s3">\n                        </span><span class="s1">this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start);</span><span class="s3">\n                    </span><span class="s1">if (names.length == 1)</span><span class="s3">\n                        </span><span class="s1">for (let n of names[0])</span><span class="s3">\n                            </span><span class="s1">result.push(n);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">recur.pop();</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (let name of getNamed(rule))</span><span class="s3">\n            </span><span class="s1">name.props[</span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">] = (((_a = name.props[</span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">]) === null || _a === void 0 ? void 0 : _a.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)) || []).concat(group).sort().join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkGroups() {</span><span class="s3">\n        </span><span class="s1">let groups = Object.create(null), nodeNames = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let term of this.terms.terms)</span><span class="s3">\n            </span><span class="s1">if (term.nodeName) {</span><span class="s3">\n                </span><span class="s1">nodeNames[term.nodeName] = true;</span><span class="s3">\n                </span><span class="s1">if (term.props[</span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">])</span><span class="s3">\n                    </span><span class="s1">for (let group of term.props[</span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">].split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)) {</span><span class="s3">\n                        </span><span class="s1">(groups[group] || (groups[group] = [])).push(term);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let names = Object.keys(groups);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; names.length; i++) {</span><span class="s3">\n            </span><span class="s1">let name = names[i], terms = groups[name];</span><span class="s3">\n            </span><span class="s1">if (nodeNames[name])</span><span class="s3">\n                </span><span class="s1">this.warn(`Group name '${name}' conflicts with a node of the same name`);</span><span class="s3">\n            </span><span class="s1">for (let j = i + 1; j &lt; names.length; j++) {</span><span class="s3">\n                </span><span class="s1">let other = groups[names[j]];</span><span class="s3">\n                </span><span class="s1">if (terms.some(t =&gt; other.includes(t)) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(terms.length &gt; other.length ? other.some(t =&gt; !terms.includes(t)) : terms.some(t =&gt; !other.includes(t))))</span><span class="s3">\n                    </span><span class="s1">this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const MinSharedActions = 5;</span><span class="s3">\n</span><span class="s1">class FinishStateContext {</span><span class="s3">\n    </span><span class="s1">constructor(tokenizers, data, stateArray, skipData, skipInfo, states, builder) {</span><span class="s3">\n        </span><span class="s1">this.tokenizers = tokenizers;</span><span class="s3">\n        </span><span class="s1">this.data = data;</span><span class="s3">\n        </span><span class="s1">this.stateArray = stateArray;</span><span class="s3">\n        </span><span class="s1">this.skipData = skipData;</span><span class="s3">\n        </span><span class="s1">this.skipInfo = skipInfo;</span><span class="s3">\n        </span><span class="s1">this.states = states;</span><span class="s3">\n        </span><span class="s1">this.builder = builder;</span><span class="s3">\n        </span><span class="s1">this.sharedActions = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findSharedActions(state) {</span><span class="s3">\n        </span><span class="s1">if (state.actions.length &lt; MinSharedActions)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let found = null;</span><span class="s3">\n        </span><span class="s1">for (let shared of this.sharedActions) {</span><span class="s3">\n            </span><span class="s1">if ((!found || shared.actions.length &gt; found.actions.length) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">shared.actions.every(a =&gt; state.actions.some(b =&gt; b.eq(a))))</span><span class="s3">\n                </span><span class="s1">found = shared;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (found)</span><span class="s3">\n            </span><span class="s1">return found;</span><span class="s3">\n        </span><span class="s1">let max = null, scratch = [];</span><span class="s3">\n        </span><span class="s1">for (let i = state.id + 1; i &lt; this.states.length; i++) {</span><span class="s3">\n            </span><span class="s1">let other = this.states[i], fill = 0;</span><span class="s3">\n            </span><span class="s1">if (other.defaultReduce || other.actions.length &lt; MinSharedActions)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">for (let a of state.actions)</span><span class="s3">\n                </span><span class="s1">for (let b of other.actions)</span><span class="s3">\n                    </span><span class="s1">if (a.eq(b))</span><span class="s3">\n                        </span><span class="s1">scratch[fill++] = a;</span><span class="s3">\n            </span><span class="s1">if (fill &gt;= MinSharedActions &amp;&amp; (!max || max.length &lt; fill)) {</span><span class="s3">\n                </span><span class="s1">max = scratch;</span><span class="s3">\n                </span><span class="s1">scratch = [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!max)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let result = { actions: max, addr: this.storeActions(max, -1, null) };</span><span class="s3">\n        </span><span class="s1">this.sharedActions.push(result);</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">storeActions(actions, skipReduce, shared) {</span><span class="s3">\n        </span><span class="s1">if (skipReduce &lt; 0 &amp;&amp; shared &amp;&amp; shared.actions.length == actions.length)</span><span class="s3">\n            </span><span class="s1">return shared.addr;</span><span class="s3">\n        </span><span class="s1">let data = [];</span><span class="s3">\n        </span><span class="s1">for (let action of actions) {</span><span class="s3">\n            </span><span class="s1">if (shared &amp;&amp; shared.actions.some(a =&gt; a.eq(action)))</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (action instanceof Shift) {</span><span class="s3">\n                </span><span class="s1">data.push(action.term.id, action.target.id, 0);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let code = reduceAction(action.rule, this.skipInfo);</span><span class="s3">\n                </span><span class="s1">if (code != skipReduce)</span><span class="s3">\n                    </span><span class="s1">data.push(action.term.id, code &amp; 65535 /* Action.ValueMask */, code &gt;&gt; 16);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">data.push(65535 /* Seq.End */);</span><span class="s3">\n        </span><span class="s1">if (skipReduce &gt; -1)</span><span class="s3">\n            </span><span class="s1">data.push(2 /* Seq.Other */, skipReduce &amp; 65535 /* Action.ValueMask */, skipReduce &gt;&gt; 16);</span><span class="s3">\n        </span><span class="s1">else if (shared)</span><span class="s3">\n            </span><span class="s1">data.push(1 /* Seq.Next */, shared.addr &amp; 0xffff, shared.addr &gt;&gt; 16);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">data.push(0 /* Seq.Done */);</span><span class="s3">\n        </span><span class="s1">return this.data.storeArray(data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(state, isSkip, forcedReduce) {</span><span class="s3">\n        </span><span class="s1">let b = this.builder;</span><span class="s3">\n        </span><span class="s1">let skipID = b.skipRules.indexOf(state.skip);</span><span class="s3">\n        </span><span class="s1">let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens;</span><span class="s3">\n        </span><span class="s1">let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0;</span><span class="s3">\n        </span><span class="s1">let flags = isSkip ? 1 /* StateFlag.Skipped */ : 0;</span><span class="s3">\n        </span><span class="s1">let skipReduce = -1, shared = null;</span><span class="s3">\n        </span><span class="s1">if (defaultReduce == 0) {</span><span class="s3">\n            </span><span class="s1">if (isSkip)</span><span class="s3">\n                </span><span class="s1">for (const action of state.actions)</span><span class="s3">\n                    </span><span class="s1">if (action instanceof Reduce &amp;&amp; action.term.eof)</span><span class="s3">\n                        </span><span class="s1">skipReduce = reduceAction(action.rule, this.skipInfo);</span><span class="s3">\n            </span><span class="s1">if (skipReduce &lt; 0)</span><span class="s3">\n                </span><span class="s1">shared = this.findSharedActions(state);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (state.set.some(p =&gt; p.rule.name.top &amp;&amp; p.pos == p.rule.parts.length))</span><span class="s3">\n            </span><span class="s1">flags |= 2 /* StateFlag.Accepting */;</span><span class="s3">\n        </span><span class="s1">let external = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; state.actions.length + skipTerms.length; i++) {</span><span class="s3">\n            </span><span class="s1">let term = i &lt; state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length];</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">let orig = b.tokenOrigins[term.name];</span><span class="s3">\n                </span><span class="s1">if (orig &amp;&amp; orig.spec) {</span><span class="s3">\n                    </span><span class="s1">term = orig.spec;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (orig &amp;&amp; (orig.external instanceof ExternalTokenSet))</span><span class="s3">\n                    </span><span class="s1">addToSet(external, orig.external);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let tokenizerMask = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.tokenizers.length; i++) {</span><span class="s3">\n            </span><span class="s1">let tok = this.tokenizers[i];</span><span class="s3">\n            </span><span class="s1">if (external.includes(tok) || tok.groupID == state.tokenGroup)</span><span class="s3">\n                </span><span class="s1">tokenizerMask |= (1 &lt;&lt; i);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let base = state.id * 6 /* ParseState.Size */;</span><span class="s3">\n        </span><span class="s1">this.stateArray[base + 0 /* ParseState.Flags */] = flags;</span><span class="s3">\n        </span><span class="s1">this.stateArray[base + 1 /* ParseState.Actions */] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared);</span><span class="s3">\n        </span><span class="s1">this.stateArray[base + 2 /* ParseState.Skip */] = skipTable;</span><span class="s3">\n        </span><span class="s1">this.stateArray[base + 3 /* ParseState.TokenizerMask */] = tokenizerMask;</span><span class="s3">\n        </span><span class="s1">this.stateArray[base + 4 /* ParseState.DefaultReduce */] = defaultReduce;</span><span class="s3">\n        </span><span class="s1">this.stateArray[base + 5 /* ParseState.ForcedReduce */] = forcedReduce;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addToProp(term, prop, value) {</span><span class="s3">\n    </span><span class="s1">let cur = term.props[prop];</span><span class="s3">\n    </span><span class="s1">if (!cur || cur.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">).indexOf(value) &lt; 0)</span><span class="s3">\n        </span><span class="s1">term.props[prop] = cur ? cur + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ value : value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildSpecializeTable(spec) {</span><span class="s3">\n    </span><span class="s1">let table = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let { value, term, type } of spec) {</span><span class="s3">\n        </span><span class="s1">let code = type == </span><span class="s3">\&quot;</span><span class="s1">specialize</span><span class="s3">\&quot; </span><span class="s1">? 0 /* Specialize.Specialize */ : 1 /* Specialize.Extend */;</span><span class="s3">\n        </span><span class="s1">table[value] = (term.id &lt;&lt; 1) | code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return table;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function reduceAction(rule, skipInfo, depth = rule.parts.length) {</span><span class="s3">\n    </span><span class="s1">return rule.name.id | 65536 /* Action.ReduceFlag */ |</span><span class="s3">\n        </span><span class="s1">(rule.isRepeatWrap &amp;&amp; depth == rule.parts.length ? 131072 /* Action.RepeatFlag */ : 0) |</span><span class="s3">\n        </span><span class="s1">(skipInfo.some(i =&gt; i.rule == rule.name) ? 262144 /* Action.StayFlag */ : 0) |</span><span class="s3">\n        </span><span class="s1">(depth &lt;&lt; 19 /* Action.ReduceDepthShift */);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findArray(data, value) {</span><span class="s3">\n    </span><span class="s1">search: for (let i = 0;;) {</span><span class="s3">\n        </span><span class="s1">let next = data.indexOf(value[0], i);</span><span class="s3">\n        </span><span class="s1">if (next == -1 || next + value.length &gt; data.length)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">for (let j = 1; j &lt; value.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (value[j] != data[next + j]) {</span><span class="s3">\n                </span><span class="s1">i = next + 1;</span><span class="s3">\n                </span><span class="s1">continue search;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findSkipStates(table, startRules) {</span><span class="s3">\n    </span><span class="s1">let nonSkip = Object.create(null);</span><span class="s3">\n    </span><span class="s1">let work = [];</span><span class="s3">\n    </span><span class="s1">let add = (state) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!nonSkip[state.id]) {</span><span class="s3">\n            </span><span class="s1">nonSkip[state.id] = true;</span><span class="s3">\n            </span><span class="s1">work.push(state);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (let state of table)</span><span class="s3">\n        </span><span class="s1">if (state.startRule &amp;&amp; startRules.includes(state.startRule))</span><span class="s3">\n            </span><span class="s1">add(state);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; work.length; i++) {</span><span class="s3">\n        </span><span class="s1">for (let a of work[i].actions)</span><span class="s3">\n            </span><span class="s1">if (a instanceof Shift)</span><span class="s3">\n                </span><span class="s1">add(a.target);</span><span class="s3">\n        </span><span class="s1">for (let a of work[i].goto)</span><span class="s3">\n            </span><span class="s1">add(a.target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (id) =&gt; !nonSkip[id];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class DataBuilder {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.data = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">storeArray(data) {</span><span class="s3">\n        </span><span class="s1">let found = findArray(this.data, data);</span><span class="s3">\n        </span><span class="s1">if (found &gt; -1)</span><span class="s3">\n            </span><span class="s1">return found;</span><span class="s3">\n        </span><span class="s1">let pos = this.data.length;</span><span class="s3">\n        </span><span class="s1">for (let num of data)</span><span class="s3">\n            </span><span class="s1">this.data.push(num);</span><span class="s3">\n        </span><span class="s1">return pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">return Uint16Array.from(this.data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// The goto table maps a start state + a term to a new state, and is</span><span class="s3">\n</span><span class="s1">// used to determine the new state when reducing. Because this allows</span><span class="s3">\n</span><span class="s1">// more more efficient representation and access, unlike the action</span><span class="s3">\n</span><span class="s1">// tables, the goto table is organized by term, with groups of start</span><span class="s3">\n</span><span class="s1">// states that map to a given end state enumerated for each term.</span><span class="s3">\n</span><span class="s1">// Since many terms only have a single valid goto target, this makes</span><span class="s3">\n</span><span class="s1">// it cheaper to look those up.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// (Unfortunately, though the standard LR parsing mechanism never</span><span class="s3">\n</span><span class="s1">// looks up invalid goto states, the incremental parsing mechanism</span><span class="s3">\n</span><span class="s1">// needs accurate goto information for a state/term pair, so we do</span><span class="s3">\n</span><span class="s1">// need to store state ids even for terms that have only one target.)</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - First comes the amount of terms in the table</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - Then, for each term, the offset of the term's data</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// - At these offsets, there's a record for each target state</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//   - Such a record starts with the amount of start states that go to</span><span class="s3">\n</span><span class="s1">//     this target state, shifted one to the left, with the first bit</span><span class="s3">\n</span><span class="s1">//     only set if this is the last record for this term.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//   - Then follows the target state id</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//   - And then the start state ids</span><span class="s3">\n</span><span class="s1">function computeGotoTable(states) {</span><span class="s3">\n    </span><span class="s1">let goto = {};</span><span class="s3">\n    </span><span class="s1">let maxTerm = 0;</span><span class="s3">\n    </span><span class="s1">for (let state of states) {</span><span class="s3">\n        </span><span class="s1">for (let entry of state.goto) {</span><span class="s3">\n            </span><span class="s1">maxTerm = Math.max(entry.term.id, maxTerm);</span><span class="s3">\n            </span><span class="s1">let set = goto[entry.term.id] || (goto[entry.term.id] = {});</span><span class="s3">\n            </span><span class="s1">(set[entry.target.id] || (set[entry.target.id] = [])).push(state.id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let data = new DataBuilder;</span><span class="s3">\n    </span><span class="s1">let index = [];</span><span class="s3">\n    </span><span class="s1">let offset = maxTerm + 2; // Offset of the data, taking index size into account</span><span class="s3">\n    </span><span class="s1">for (let term = 0; term &lt;= maxTerm; term++) {</span><span class="s3">\n        </span><span class="s1">let entries = goto[term];</span><span class="s3">\n        </span><span class="s1">if (!entries) {</span><span class="s3">\n            </span><span class="s1">index.push(1);</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let termTable = [];</span><span class="s3">\n        </span><span class="s1">let keys = Object.keys(entries);</span><span class="s3">\n        </span><span class="s1">for (let target of keys) {</span><span class="s3">\n            </span><span class="s1">let list = entries[target];</span><span class="s3">\n            </span><span class="s1">termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length &lt;&lt; 1));</span><span class="s3">\n            </span><span class="s1">termTable.push(+target);</span><span class="s3">\n            </span><span class="s1">for (let source of list)</span><span class="s3">\n                </span><span class="s1">termTable.push(source);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">index.push(data.storeArray(termTable) + offset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (index.some(n =&gt; n &gt; 0xffff))</span><span class="s3">\n        </span><span class="s1">throw new GenError(</span><span class="s3">\&quot;</span><span class="s1">Goto table too large</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return Uint16Array.from([maxTerm + 1, ...index, ...data.data]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenGroup {</span><span class="s3">\n    </span><span class="s1">constructor(tokens, groupID) {</span><span class="s3">\n        </span><span class="s1">this.tokens = tokens;</span><span class="s3">\n        </span><span class="s1">this.groupID = groupID;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">create() { return this.groupID; }</span><span class="s3">\n    </span><span class="s1">createSource() { return String(this.groupID); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addToSet(set, value) {</span><span class="s3">\n    </span><span class="s1">if (!set.includes(value))</span><span class="s3">\n        </span><span class="s1">set.push(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildTokenMasks(groups) {</span><span class="s3">\n    </span><span class="s1">let masks = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let group of groups) {</span><span class="s3">\n        </span><span class="s1">let groupMask = 1 &lt;&lt; group.groupID;</span><span class="s3">\n        </span><span class="s1">for (let term of group.tokens) {</span><span class="s3">\n            </span><span class="s1">masks[term.id] = (masks[term.id] || 0) | groupMask;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return masks;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenArg {</span><span class="s3">\n    </span><span class="s1">constructor(name, expr, scope) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.expr = expr;</span><span class="s3">\n        </span><span class="s1">this.scope = scope;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BuildingRule {</span><span class="s3">\n    </span><span class="s1">constructor(name, start, to, args) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.args = args;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenSet {</span><span class="s3">\n    </span><span class="s1">constructor(b, ast) {</span><span class="s3">\n        </span><span class="s1">this.b = b;</span><span class="s3">\n        </span><span class="s1">this.ast = ast;</span><span class="s3">\n        </span><span class="s1">this.startState = new State$1;</span><span class="s3">\n        </span><span class="s1">this.built = [];</span><span class="s3">\n        </span><span class="s1">this.building = []; // Used for recursion check</span><span class="s3">\n        </span><span class="s1">this.byDialect = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.precedenceRelations = [];</span><span class="s3">\n        </span><span class="s1">this.rules = ast ? ast.rules : none;</span><span class="s3">\n        </span><span class="s1">for (let rule of this.rules)</span><span class="s3">\n            </span><span class="s1">b.unique(rule.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getToken(expr) {</span><span class="s3">\n        </span><span class="s1">for (let built of this.built)</span><span class="s3">\n            </span><span class="s1">if (built.matches(expr))</span><span class="s3">\n                </span><span class="s1">return built.term;</span><span class="s3">\n        </span><span class="s1">let name = expr.id.name;</span><span class="s3">\n        </span><span class="s1">let rule = this.rules.find(r =&gt; r.id.name == name);</span><span class="s3">\n        </span><span class="s1">if (!rule)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let { name: nodeName, props, dialect, exported } = this.b.nodeInfo(rule.props, </span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">, name, expr.args, rule.params.length != expr.args.length ? none : rule.params);</span><span class="s3">\n        </span><span class="s1">let term = this.b.makeTerminal(expr.toString(), nodeName, props);</span><span class="s3">\n        </span><span class="s1">if (dialect != null)</span><span class="s3">\n            </span><span class="s1">(this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);</span><span class="s3">\n        </span><span class="s1">if ((term.nodeType || exported) &amp;&amp; rule.params.length == 0) {</span><span class="s3">\n            </span><span class="s1">if (!term.nodeType)</span><span class="s3">\n                </span><span class="s1">term.preserve = true;</span><span class="s3">\n            </span><span class="s1">this.b.namedTerms[exported || name] = term;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.buildRule(rule, expr, this.startState, new State$1([term]));</span><span class="s3">\n        </span><span class="s1">this.built.push(new BuiltRule(name, expr.args, term));</span><span class="s3">\n        </span><span class="s1">return term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildRule(rule, expr, from, to, args = none) {</span><span class="s3">\n        </span><span class="s1">let name = expr.id.name;</span><span class="s3">\n        </span><span class="s1">if (rule.params.length != expr.args.length)</span><span class="s3">\n            </span><span class="s1">this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start);</span><span class="s3">\n        </span><span class="s1">let building = this.building.find(b =&gt; b.name == name &amp;&amp; exprsEq(expr.args, b.args));</span><span class="s3">\n        </span><span class="s1">if (building) {</span><span class="s3">\n            </span><span class="s1">if (building.to == to) {</span><span class="s3">\n                </span><span class="s1">from.nullEdge(building.start);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let lastIndex = this.building.length - 1;</span><span class="s3">\n            </span><span class="s1">while (this.building[lastIndex].name != name)</span><span class="s3">\n                </span><span class="s1">lastIndex--;</span><span class="s3">\n            </span><span class="s1">this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(lastIndex).map(b =&gt; b.name).join(</span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot;</span><span class="s1">)}`, expr.start);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.b.used(rule.id.name);</span><span class="s3">\n        </span><span class="s1">let start = new State$1;</span><span class="s3">\n        </span><span class="s1">from.nullEdge(start);</span><span class="s3">\n        </span><span class="s1">this.building.push(new BuildingRule(name, start, to, expr.args));</span><span class="s3">\n        </span><span class="s1">this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to, expr.args.map((e, i) =&gt; new TokenArg(rule.params[i].name, e, args)));</span><span class="s3">\n        </span><span class="s1">this.building.pop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">build(expr, from, to, args) {</span><span class="s3">\n        </span><span class="s1">if (expr instanceof NameExpression) {</span><span class="s3">\n            </span><span class="s1">let name = expr.id.name, arg = args.find(a =&gt; a.name == name);</span><span class="s3">\n            </span><span class="s1">if (arg)</span><span class="s3">\n                </span><span class="s1">return this.build(arg.expr, from, to, arg.scope);</span><span class="s3">\n            </span><span class="s1">let rule;</span><span class="s3">\n            </span><span class="s1">for (let i = 0, lt = this.b.localTokens; i &lt;= lt.length; i++) {</span><span class="s3">\n                </span><span class="s1">let set = i == lt.length ? this.b.tokens : lt[i];</span><span class="s3">\n                </span><span class="s1">rule = set.rules.find(r =&gt; r.id.name == name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!rule)</span><span class="s3">\n                </span><span class="s1">return this.b.raise(`Reference to token rule '${expr.id.name}', which isn't found`, expr.start);</span><span class="s3">\n            </span><span class="s1">this.buildRule(rule, expr, from, to, args);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof CharClass) {</span><span class="s3">\n            </span><span class="s1">for (let [a, b] of CharClasses[expr.type])</span><span class="s3">\n                </span><span class="s1">from.edge(a, b, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof ChoiceExpression) {</span><span class="s3">\n            </span><span class="s1">for (let choice of expr.exprs)</span><span class="s3">\n                </span><span class="s1">this.build(choice, from, to, args);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isEmpty(expr)) {</span><span class="s3">\n            </span><span class="s1">from.nullEdge(to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof SequenceExpression) {</span><span class="s3">\n            </span><span class="s1">let conflict = expr.markers.find(c =&gt; c.length &gt; 0);</span><span class="s3">\n            </span><span class="s1">if (conflict)</span><span class="s3">\n                </span><span class="s1">this.b.raise(</span><span class="s3">\&quot;</span><span class="s1">Conflict marker in token expression</span><span class="s3">\&quot;</span><span class="s1">, conflict[0].start);</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; expr.exprs.length; i++) {</span><span class="s3">\n                </span><span class="s1">let next = i == expr.exprs.length - 1 ? to : new State$1;</span><span class="s3">\n                </span><span class="s1">this.build(expr.exprs[i], from, next, args);</span><span class="s3">\n                </span><span class="s1">from = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof RepeatExpression) {</span><span class="s3">\n            </span><span class="s1">if (expr.kind == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">let loop = new State$1;</span><span class="s3">\n                </span><span class="s1">from.nullEdge(loop);</span><span class="s3">\n                </span><span class="s1">this.build(expr.expr, loop, loop, args);</span><span class="s3">\n                </span><span class="s1">loop.nullEdge(to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (expr.kind == </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">let loop = new State$1;</span><span class="s3">\n                </span><span class="s1">this.build(expr.expr, from, loop, args);</span><span class="s3">\n                </span><span class="s1">this.build(expr.expr, loop, loop, args);</span><span class="s3">\n                </span><span class="s1">loop.nullEdge(to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else { // expr.kind == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;\n                </span><span class="s1">from.nullEdge(to);</span><span class="s3">\n                </span><span class="s1">this.build(expr.expr, from, to, args);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof SetExpression) {</span><span class="s3">\n            </span><span class="s1">for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)</span><span class="s3">\n                </span><span class="s1">rangeEdges(from, to, a, b);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof LiteralExpression) {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; expr.value.length; i++) {</span><span class="s3">\n                </span><span class="s1">let ch = expr.value.charCodeAt(i);</span><span class="s3">\n                </span><span class="s1">let next = i == expr.value.length - 1 ? to : new State$1;</span><span class="s3">\n                </span><span class="s1">from.edge(ch, ch + 1, next);</span><span class="s3">\n                </span><span class="s1">from = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (expr instanceof AnyExpression) {</span><span class="s3">\n            </span><span class="s1">let mid = new State$1;</span><span class="s3">\n            </span><span class="s1">from.edge(0, 0xDC00, to);</span><span class="s3">\n            </span><span class="s1">from.edge(0xDC00, MAX_CHAR + 1, to);</span><span class="s3">\n            </span><span class="s1">from.edge(0xD800, 0xDC00, mid);</span><span class="s3">\n            </span><span class="s1">mid.edge(0xDC00, 0xE000, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.b.raise(`Unrecognized expression type in token`, expr.start);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">takePrecedences() {</span><span class="s3">\n        </span><span class="s1">let rel = this.precedenceRelations = [];</span><span class="s3">\n        </span><span class="s1">if (this.ast)</span><span class="s3">\n            </span><span class="s1">for (let group of this.ast.precedences) {</span><span class="s3">\n                </span><span class="s1">let prev = [];</span><span class="s3">\n                </span><span class="s1">for (let item of group.items) {</span><span class="s3">\n                    </span><span class="s1">let level = [];</span><span class="s3">\n                    </span><span class="s1">if (item instanceof NameExpression) {</span><span class="s3">\n                        </span><span class="s1">for (let built of this.built)</span><span class="s3">\n                            </span><span class="s1">if (item.args.length ? built.matches(item) : built.id == item.id.name)</span><span class="s3">\n                                </span><span class="s1">level.push(built.term);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">let id = JSON.stringify(item.value), found = this.built.find(b =&gt; b.id == id);</span><span class="s3">\n                        </span><span class="s1">if (found)</span><span class="s3">\n                            </span><span class="s1">level.push(found.term);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (!level.length)</span><span class="s3">\n                        </span><span class="s1">this.b.warn(`Precedence specified for unknown token ${item}`, item.start);</span><span class="s3">\n                    </span><span class="s1">for (let term of level)</span><span class="s3">\n                        </span><span class="s1">addRel(rel, term, prev);</span><span class="s3">\n                    </span><span class="s1">prev = prev.concat(level);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">precededBy(a, b) {</span><span class="s3">\n        </span><span class="s1">let found = this.precedenceRelations.find(r =&gt; r.term == a);</span><span class="s3">\n        </span><span class="s1">return found &amp;&amp; found.after.includes(b);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildPrecTable(softConflicts) {</span><span class="s3">\n        </span><span class="s1">let precTable = [], rel = this.precedenceRelations.slice();</span><span class="s3">\n        </span><span class="s1">// Add entries for soft-conflicting tokens that are in the</span><span class="s3">\n        </span><span class="s1">// precedence table, to make sure they'll appear in the right</span><span class="s3">\n        </span><span class="s1">// order and don't mess up the longer-wins default rule.</span><span class="s3">\n        </span><span class="s1">for (let { a, b, soft } of softConflicts)</span><span class="s3">\n            </span><span class="s1">if (soft) {</span><span class="s3">\n                </span><span class="s1">if (!rel.some(r =&gt; r.term == a) || !rel.some(r =&gt; r.term == b))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">if (soft &lt; 0)</span><span class="s3">\n                    </span><span class="s1">[a, b] = [b, a]; // Now a is longer than b (and should thus take precedence)</span><span class="s3">\n                </span><span class="s1">addRel(rel, b, [a]);</span><span class="s3">\n                </span><span class="s1">addRel(rel, a, []);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">add: while (rel.length) {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; rel.length; i++) {</span><span class="s3">\n                </span><span class="s1">let record = rel[i];</span><span class="s3">\n                </span><span class="s1">if (record.after.every(t =&gt; precTable.includes(t.id))) {</span><span class="s3">\n                    </span><span class="s1">precTable.push(record.term.id);</span><span class="s3">\n                    </span><span class="s1">if (rel.length == 1)</span><span class="s3">\n                        </span><span class="s1">break add;</span><span class="s3">\n                    </span><span class="s1">rel[i] = rel.pop();</span><span class="s3">\n                    </span><span class="s1">continue add;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.b.raise(`Cyclic token precedence relation between ${rel.map(r =&gt; r.term).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return precTable;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class MainTokenSet extends TokenSet {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.explicitConflicts = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLiteral(expr) {</span><span class="s3">\n        </span><span class="s1">let id = JSON.stringify(expr.value);</span><span class="s3">\n        </span><span class="s1">for (let built of this.built)</span><span class="s3">\n            </span><span class="s1">if (built.id == id)</span><span class="s3">\n                </span><span class="s1">return built.term;</span><span class="s3">\n        </span><span class="s1">let name = null, props = {}, dialect = null, exported = null;</span><span class="s3">\n        </span><span class="s1">let decl = this.ast ? this.ast.literals.find(l =&gt; l.literal == expr.value) : null;</span><span class="s3">\n        </span><span class="s1">if (decl)</span><span class="s3">\n            </span><span class="s1">({ name, props, dialect, exported } = this.b.nodeInfo(decl.props, </span><span class="s3">\&quot;</span><span class="s1">da</span><span class="s3">\&quot;</span><span class="s1">, expr.value));</span><span class="s3">\n        </span><span class="s1">let term = this.b.makeTerminal(id, name, props);</span><span class="s3">\n        </span><span class="s1">if (dialect != null)</span><span class="s3">\n            </span><span class="s1">(this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);</span><span class="s3">\n        </span><span class="s1">if (exported)</span><span class="s3">\n            </span><span class="s1">this.b.namedTerms[exported] = term;</span><span class="s3">\n        </span><span class="s1">this.build(expr, this.startState, new State$1([term]), none);</span><span class="s3">\n        </span><span class="s1">this.built.push(new BuiltRule(id, none, term));</span><span class="s3">\n        </span><span class="s1">return term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">takeConflicts() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let resolve = (expr) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (expr instanceof NameExpression) {</span><span class="s3">\n                </span><span class="s1">for (let built of this.built)</span><span class="s3">\n                    </span><span class="s1">if (built.matches(expr))</span><span class="s3">\n                        </span><span class="s1">return built.term;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let id = JSON.stringify(expr.value), found = this.built.find(b =&gt; b.id == id);</span><span class="s3">\n                </span><span class="s1">if (found)</span><span class="s3">\n                    </span><span class="s1">return found.term;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start);</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (let c of ((_a = this.ast) === null || _a === void 0 ? void 0 : _a.conflicts) || []) {</span><span class="s3">\n            </span><span class="s1">let a = resolve(c.a), b = resolve(c.b);</span><span class="s3">\n            </span><span class="s1">if (a &amp;&amp; b) {</span><span class="s3">\n                </span><span class="s1">if (a.id &lt; b.id)</span><span class="s3">\n                    </span><span class="s1">[a, b] = [b, a];</span><span class="s3">\n                </span><span class="s1">this.explicitConflicts.push({ a, b });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Token groups are a mechanism for allowing conflicting (matching</span><span class="s3">\n    </span><span class="s1">// overlapping input, without an explicit precedence being given)</span><span class="s3">\n    </span><span class="s1">// tokens to exist in a grammar _if_ they don't occur in the same</span><span class="s3">\n    </span><span class="s1">// place (aren't used in the same states).</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// States that use tokens that conflict will raise an error when any</span><span class="s3">\n    </span><span class="s1">// of the conflicting pairs of tokens both occur in that state.</span><span class="s3">\n    </span><span class="s1">// Otherwise, they are assigned a token group, which includes all</span><span class="s3">\n    </span><span class="s1">// the potentially-conflicting tokens they use. If there's already a</span><span class="s3">\n    </span><span class="s1">// group that doesn't have any conflicts with those tokens, that is</span><span class="s3">\n    </span><span class="s1">// reused, otherwise a new group is created.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// So each state has zero or one token groups, and each conflicting</span><span class="s3">\n    </span><span class="s1">// token may belong to one or more groups. Tokens get assigned a</span><span class="s3">\n    </span><span class="s1">// 16-bit bitmask with the groups they belong to set to 1 (all-1s</span><span class="s3">\n    </span><span class="s1">// for non-conflicting tokens). When tokenizing, that mask is</span><span class="s3">\n    </span><span class="s1">// compared to the current state's group (again using all-1s for</span><span class="s3">\n    </span><span class="s1">// group-less states) to determine whether a token is applicable for</span><span class="s3">\n    </span><span class="s1">// this state.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Extended/specialized tokens are treated as their parent token for</span><span class="s3">\n    </span><span class="s1">// this purpose.</span><span class="s3">\n    </span><span class="s1">buildTokenGroups(states, skipInfo, startID) {</span><span class="s3">\n        </span><span class="s1">let tokens = this.startState.compile();</span><span class="s3">\n        </span><span class="s1">if (tokens.accepting.length)</span><span class="s3">\n            </span><span class="s1">this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r =&gt; r.id.name == tokens.accepting[0].name).start);</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">btokens</span><span class="s3">\\</span><span class="s1">b/.test(verbose))</span><span class="s3">\n            </span><span class="s1">console.log(tokens.toString());</span><span class="s3">\n        </span><span class="s1">// If there is a precedence specified for the pair, the conflict is resolved</span><span class="s3">\n        </span><span class="s1">let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))</span><span class="s3">\n            </span><span class="s1">.filter(({ a, b }) =&gt; !this.precededBy(a, b) &amp;&amp; !this.precededBy(b, a));</span><span class="s3">\n        </span><span class="s1">for (let { a, b } of this.explicitConflicts) {</span><span class="s3">\n            </span><span class="s1">if (!allConflicts.some(c =&gt; c.a == a &amp;&amp; c.b == b))</span><span class="s3">\n                </span><span class="s1">allConflicts.push(new Conflict$1(a, b, 0, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let softConflicts = allConflicts.filter(c =&gt; c.soft), conflicts = allConflicts.filter(c =&gt; !c.soft);</span><span class="s3">\n        </span><span class="s1">let errors = [];</span><span class="s3">\n        </span><span class="s1">let groups = [];</span><span class="s3">\n        </span><span class="s1">for (let state of states) {</span><span class="s3">\n            </span><span class="s1">if (state.defaultReduce || state.tokenGroup &gt; -1)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">// Find potentially-conflicting terms (in terms) and the things</span><span class="s3">\n            </span><span class="s1">// they conflict with (in conflicts), and raise an error if</span><span class="s3">\n            </span><span class="s1">// there's a token conflict directly in this state.</span><span class="s3">\n            </span><span class="s1">let terms = [], incompatible = [];</span><span class="s3">\n            </span><span class="s1">let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;</span><span class="s3">\n            </span><span class="s1">for (let term of skip)</span><span class="s3">\n                </span><span class="s1">if (state.actions.some(a =&gt; a.term == term))</span><span class="s3">\n                    </span><span class="s1">this.b.raise(`Use of token ${term.name} conflicts with skip rule`);</span><span class="s3">\n            </span><span class="s1">let stateTerms = [];</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; state.actions.length + (skip ? skip.length : 0); i++) {</span><span class="s3">\n                </span><span class="s1">let term = i &lt; state.actions.length ? state.actions[i].term : skip[i - state.actions.length];</span><span class="s3">\n                </span><span class="s1">let orig = this.b.tokenOrigins[term.name];</span><span class="s3">\n                </span><span class="s1">if (orig &amp;&amp; orig.spec)</span><span class="s3">\n                    </span><span class="s1">term = orig.spec;</span><span class="s3">\n                </span><span class="s1">else if (orig &amp;&amp; orig.external)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">addToSet(stateTerms, term);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (stateTerms.length == 0)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">for (let term of stateTerms) {</span><span class="s3">\n                </span><span class="s1">for (let conflict of conflicts) {</span><span class="s3">\n                    </span><span class="s1">let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null;</span><span class="s3">\n                    </span><span class="s1">if (!conflicting)</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                    </span><span class="s1">if (stateTerms.includes(conflicting) &amp;&amp; !errors.some(e =&gt; e.conflict == conflict)) {</span><span class="s3">\n                        </span><span class="s1">let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">})` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                        </span><span class="s1">errors.push({</span><span class="s3">\n                            </span><span class="s1">error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                                </span><span class="s1">`After: ${state.set[0].trail()}`,</span><span class="s3">\n                            </span><span class="s1">conflict</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">addToSet(terms, term);</span><span class="s3">\n                    </span><span class="s1">addToSet(incompatible, conflicting);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let tokenGroup = null;</span><span class="s3">\n            </span><span class="s1">for (let group of groups) {</span><span class="s3">\n                </span><span class="s1">if (incompatible.some(term =&gt; group.tokens.includes(term)))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">for (let term of terms)</span><span class="s3">\n                    </span><span class="s1">addToSet(group.tokens, term);</span><span class="s3">\n                </span><span class="s1">tokenGroup = group;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!tokenGroup) {</span><span class="s3">\n                </span><span class="s1">tokenGroup = new TokenGroup(terms, groups.length + startID);</span><span class="s3">\n                </span><span class="s1">groups.push(tokenGroup);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">state.tokenGroup = tokenGroup.groupID;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (errors.length)</span><span class="s3">\n            </span><span class="s1">this.b.raise(errors.map(e =&gt; e.error).join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">if (groups.length + startID &gt; 16)</span><span class="s3">\n            </span><span class="s1">this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);</span><span class="s3">\n        </span><span class="s1">let precTable = this.buildPrecTable(softConflicts);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">tokenGroups: groups,</span><span class="s3">\n            </span><span class="s1">tokenPrec: precTable,</span><span class="s3">\n            </span><span class="s1">tokenData: tokens.toArray(buildTokenMasks(groups), precTable)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LocalTokenSet extends TokenSet {</span><span class="s3">\n    </span><span class="s1">constructor(b, ast) {</span><span class="s3">\n        </span><span class="s1">super(b, ast);</span><span class="s3">\n        </span><span class="s1">this.fallback = null;</span><span class="s3">\n        </span><span class="s1">if (ast.fallback)</span><span class="s3">\n            </span><span class="s1">b.unique(ast.fallback.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getToken(expr) {</span><span class="s3">\n        </span><span class="s1">let term = null;</span><span class="s3">\n        </span><span class="s1">if (this.ast.fallback &amp;&amp; this.ast.fallback.id.name == expr.id.name) {</span><span class="s3">\n            </span><span class="s1">if (expr.args.length)</span><span class="s3">\n                </span><span class="s1">this.b.raise(`Incorrect number of arguments for ${expr.id.name}`, expr.start);</span><span class="s3">\n            </span><span class="s1">if (!this.fallback) {</span><span class="s3">\n                </span><span class="s1">let { name: nodeName, props, exported } = this.b.nodeInfo(this.ast.fallback.props, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, expr.id.name, none, none);</span><span class="s3">\n                </span><span class="s1">let term = this.fallback = this.b.makeTerminal(expr.id.name, nodeName, props);</span><span class="s3">\n                </span><span class="s1">if (term.nodeType || exported) {</span><span class="s3">\n                    </span><span class="s1">if (!term.nodeType)</span><span class="s3">\n                        </span><span class="s1">term.preserve = true;</span><span class="s3">\n                    </span><span class="s1">this.b.namedTerms[exported || expr.id.name] = term;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.b.used(expr.id.name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">term = this.fallback;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">term = super.getToken(expr);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (term &amp;&amp; !this.b.tokenOrigins[term.name])</span><span class="s3">\n            </span><span class="s1">this.b.tokenOrigins[term.name] = { group: this };</span><span class="s3">\n        </span><span class="s1">return term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildLocalGroup(states, skipInfo, id) {</span><span class="s3">\n        </span><span class="s1">let tokens = this.startState.compile();</span><span class="s3">\n        </span><span class="s1">if (tokens.accepting.length)</span><span class="s3">\n            </span><span class="s1">this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r =&gt; r.id.name == tokens.accepting[0].name).start);</span><span class="s3">\n        </span><span class="s1">for (let { a, b, exampleA } of tokens.findConflicts(() =&gt; true)) {</span><span class="s3">\n            </span><span class="s1">if (!this.precededBy(a, b) &amp;&amp; !this.precededBy(b, a))</span><span class="s3">\n                </span><span class="s1">this.b.raise(`Overlapping tokens ${a.name} and ${b.name} in local token group${exampleA ? ` (example: ${JSON.stringify(exampleA)})` : ''}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let state of states) {</span><span class="s3">\n            </span><span class="s1">if (state.defaultReduce)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">// See if this state uses any of the tokens in this group, and</span><span class="s3">\n            </span><span class="s1">// if so, make sure it *only* uses tokens from this group.</span><span class="s3">\n            </span><span class="s1">let usesThis = null;</span><span class="s3">\n            </span><span class="s1">let usesOther = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens[0];</span><span class="s3">\n            </span><span class="s1">for (let { term } of state.actions) {</span><span class="s3">\n                </span><span class="s1">let orig = this.b.tokenOrigins[term.name];</span><span class="s3">\n                </span><span class="s1">if ((orig === null || orig === void 0 ? void 0 : orig.group) == this)</span><span class="s3">\n                    </span><span class="s1">usesThis = term;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">usesOther = term;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (usesThis) {</span><span class="s3">\n                </span><span class="s1">if (usesOther)</span><span class="s3">\n                    </span><span class="s1">this.b.raise(`Tokens from a local token group used together with other tokens (${usesThis.name} with ${usesOther.name})`);</span><span class="s3">\n                </span><span class="s1">state.tokenGroup = id;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let precTable = this.buildPrecTable(none);</span><span class="s3">\n        </span><span class="s1">let tokenData = tokens.toArray({ [id]: 65535 /* Seq.End */ }, precTable);</span><span class="s3">\n        </span><span class="s1">let precOffset = tokenData.length;</span><span class="s3">\n        </span><span class="s1">let fullData = new Uint16Array(tokenData.length + precTable.length + 1);</span><span class="s3">\n        </span><span class="s1">fullData.set(tokenData, 0);</span><span class="s3">\n        </span><span class="s1">fullData.set(precTable, precOffset);</span><span class="s3">\n        </span><span class="s1">fullData[fullData.length - 1] = 65535 /* Seq.End */;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">groupID: id,</span><span class="s3">\n            </span><span class="s1">create: () =&gt; new LocalTokenGroup(fullData, precOffset, this.fallback ? this.fallback.id : undefined),</span><span class="s3">\n            </span><span class="s1">createSource: importName =&gt; `new ${importName(</span><span class="s3">\&quot;</span><span class="s1">LocalTokenGroup</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">@lezer/lr</span><span class="s3">\&quot;</span><span class="s1">)}(${encodeArray(fullData)}, ${precOffset}${this.fallback ? `, ${this.fallback.id}` : ''})`</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkTogether(states, b, skipInfo) {</span><span class="s3">\n    </span><span class="s1">let cache = Object.create(null);</span><span class="s3">\n    </span><span class="s1">function hasTerm(state, term) {</span><span class="s3">\n        </span><span class="s1">return state.actions.some(a =&gt; a.term == term) ||</span><span class="s3">\n            </span><span class="s1">skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (a, b) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (a.id &lt; b.id)</span><span class="s3">\n            </span><span class="s1">[a, b] = [b, a];</span><span class="s3">\n        </span><span class="s1">let key = a.id | (b.id &lt;&lt; 16), cached = cache[key];</span><span class="s3">\n        </span><span class="s1">if (cached != null)</span><span class="s3">\n            </span><span class="s1">return cached;</span><span class="s3">\n        </span><span class="s1">return cache[key] = states.some(state =&gt; hasTerm(state, a) &amp;&amp; hasTerm(state, b));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function invertRanges(ranges) {</span><span class="s3">\n    </span><span class="s1">let pos = 0, result = [];</span><span class="s3">\n    </span><span class="s1">for (let [a, b] of ranges) {</span><span class="s3">\n        </span><span class="s1">if (a &gt; pos)</span><span class="s3">\n            </span><span class="s1">result.push([pos, a]);</span><span class="s3">\n        </span><span class="s1">pos = b;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (pos &lt;= MAX_CODE)</span><span class="s3">\n        </span><span class="s1">result.push([pos, MAX_CODE + 1]);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff;</span><span class="s3">\n</span><span class="s1">const LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff;</span><span class="s3">\n</span><span class="s1">// Create intermediate states for astral characters in a range, if</span><span class="s3">\n</span><span class="s1">// necessary, since the tokenizer acts on UTF16 characters</span><span class="s3">\n</span><span class="s1">function rangeEdges(from, to, low, hi) {</span><span class="s3">\n    </span><span class="s1">if (low &lt; ASTRAL) {</span><span class="s3">\n        </span><span class="s1">if (low &lt; GAP_START)</span><span class="s3">\n            </span><span class="s1">from.edge(low, Math.min(hi, GAP_START), to);</span><span class="s3">\n        </span><span class="s1">if (hi &gt; GAP_END)</span><span class="s3">\n            </span><span class="s1">from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to);</span><span class="s3">\n        </span><span class="s1">low = ASTRAL;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (hi &lt;= ASTRAL)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1);</span><span class="s3">\n    </span><span class="s1">let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1);</span><span class="s3">\n    </span><span class="s1">let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1);</span><span class="s3">\n    </span><span class="s1">if (lowA == hiA) { // Share the first char code</span><span class="s3">\n        </span><span class="s1">let hop = new State$1;</span><span class="s3">\n        </span><span class="s1">from.edge(lowA, lowA + 1, hop);</span><span class="s3">\n        </span><span class="s1">hop.edge(lowB, hiB + 1, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let midStart = lowA, midEnd = hiA;</span><span class="s3">\n        </span><span class="s1">if (lowB &gt; LOW_SURR_B) {</span><span class="s3">\n            </span><span class="s1">midStart++;</span><span class="s3">\n            </span><span class="s1">let hop = new State$1;</span><span class="s3">\n            </span><span class="s1">from.edge(lowA, lowA + 1, hop);</span><span class="s3">\n            </span><span class="s1">hop.edge(lowB, HIGH_SURR_B + 1, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (hiB &lt; HIGH_SURR_B) {</span><span class="s3">\n            </span><span class="s1">midEnd--;</span><span class="s3">\n            </span><span class="s1">let hop = new State$1;</span><span class="s3">\n            </span><span class="s1">from.edge(hiA, hiA + 1, hop);</span><span class="s3">\n            </span><span class="s1">hop.edge(LOW_SURR_B, hiB + 1, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (midStart &lt;= midEnd) {</span><span class="s3">\n            </span><span class="s1">let hop = new State$1;</span><span class="s3">\n            </span><span class="s1">from.edge(midStart, midEnd + 1, hop);</span><span class="s3">\n            </span><span class="s1">hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isEmpty(expr) {</span><span class="s3">\n    </span><span class="s1">return expr instanceof SequenceExpression &amp;&amp; expr.exprs.length == 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function gatherExtTokens(b, tokens) {</span><span class="s3">\n    </span><span class="s1">let result = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let token of tokens) {</span><span class="s3">\n        </span><span class="s1">b.unique(token.id);</span><span class="s3">\n        </span><span class="s1">let { name, props, dialect } = b.nodeInfo(token.props, </span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">, token.id.name);</span><span class="s3">\n        </span><span class="s1">let term = b.makeTerminal(token.id.name, name, props);</span><span class="s3">\n        </span><span class="s1">if (dialect != null)</span><span class="s3">\n            </span><span class="s1">(b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term);</span><span class="s3">\n        </span><span class="s1">b.namedTerms[token.id.name] = result[token.id.name] = term;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findExtToken(b, tokens, expr) {</span><span class="s3">\n    </span><span class="s1">let found = tokens[expr.id.name];</span><span class="s3">\n    </span><span class="s1">if (!found)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">if (expr.args.length)</span><span class="s3">\n        </span><span class="s1">b.raise(</span><span class="s3">\&quot;</span><span class="s1">External tokens cannot take arguments</span><span class="s3">\&quot;</span><span class="s1">, expr.args[0].start);</span><span class="s3">\n    </span><span class="s1">b.used(expr.id.name);</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addRel(rel, term, after) {</span><span class="s3">\n    </span><span class="s1">let found = rel.findIndex(r =&gt; r.term == term);</span><span class="s3">\n    </span><span class="s1">if (found &lt; 0)</span><span class="s3">\n        </span><span class="s1">rel.push({ term, after });</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">rel[found] = { term, after: rel[found].after.concat(after) };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ExternalTokenSet {</span><span class="s3">\n    </span><span class="s1">constructor(b, ast) {</span><span class="s3">\n        </span><span class="s1">this.b = b;</span><span class="s3">\n        </span><span class="s1">this.ast = ast;</span><span class="s3">\n        </span><span class="s1">this.tokens = gatherExtTokens(b, ast.tokens);</span><span class="s3">\n        </span><span class="s1">for (let name in this.tokens)</span><span class="s3">\n            </span><span class="s1">this.b.tokenOrigins[this.tokens[name].name] = { external: this };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getToken(expr) { return findExtToken(this.b, this.tokens, expr); }</span><span class="s3">\n    </span><span class="s1">create() {</span><span class="s3">\n        </span><span class="s1">return this.b.options.externalTokenizer(this.ast.id.name, this.b.termTable);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createSource(importName) {</span><span class="s3">\n        </span><span class="s1">let { source, id: { name } } = this.ast;</span><span class="s3">\n        </span><span class="s1">return importName(name, source);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ExternalSpecializer {</span><span class="s3">\n    </span><span class="s1">constructor(b, ast) {</span><span class="s3">\n        </span><span class="s1">this.b = b;</span><span class="s3">\n        </span><span class="s1">this.ast = ast;</span><span class="s3">\n        </span><span class="s1">this.term = null;</span><span class="s3">\n        </span><span class="s1">this.tokens = gatherExtTokens(b, ast.tokens);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">let terms = this.b.normalizeExpr(this.ast.token);</span><span class="s3">\n        </span><span class="s1">if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)</span><span class="s3">\n            </span><span class="s1">this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start);</span><span class="s3">\n        </span><span class="s1">this.term = terms[0].terms[0];</span><span class="s3">\n        </span><span class="s1">for (let name in this.tokens)</span><span class="s3">\n            </span><span class="s1">this.b.tokenOrigins[this.tokens[name].name] = { spec: this.term, external: this };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getToken(expr) { return findExtToken(this.b, this.tokens, expr); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function inlineRules(rules, preserve) {</span><span class="s3">\n    </span><span class="s1">for (let pass = 0;; pass++) {</span><span class="s3">\n        </span><span class="s1">let inlinable = Object.create(null), found;</span><span class="s3">\n        </span><span class="s1">if (pass == 0)</span><span class="s3">\n            </span><span class="s1">for (let rule of rules) {</span><span class="s3">\n                </span><span class="s1">if (rule.name.inline &amp;&amp; !inlinable[rule.name.name]) {</span><span class="s3">\n                    </span><span class="s1">let group = rules.filter(r =&gt; r.name == rule.name);</span><span class="s3">\n                    </span><span class="s1">if (group.some(r =&gt; r.parts.includes(rule.name)))</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                    </span><span class="s1">found = inlinable[rule.name.name] = group;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; rules.length; i++) {</span><span class="s3">\n            </span><span class="s1">let rule = rules[i];</span><span class="s3">\n            </span><span class="s1">if (!rule.name.interesting &amp;&amp; !rule.parts.includes(rule.name) &amp;&amp; rule.parts.length &lt; 3 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!preserve.includes(rule.name) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(rule.parts.length == 1 || rules.every(other =&gt; other.skip == rule.skip || !other.parts.includes(rule.name))) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!rule.parts.some(p =&gt; !!inlinable[p.name]) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!rules.some((r, j) =&gt; j != i &amp;&amp; r.name == rule.name))</span><span class="s3">\n                </span><span class="s1">found = inlinable[rule.name.name] = [rule];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!found)</span><span class="s3">\n            </span><span class="s1">return rules;</span><span class="s3">\n        </span><span class="s1">let newRules = [];</span><span class="s3">\n        </span><span class="s1">for (let rule of rules) {</span><span class="s3">\n            </span><span class="s1">if (inlinable[rule.name.name])</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (!rule.parts.some(p =&gt; !!inlinable[p.name])) {</span><span class="s3">\n                </span><span class="s1">newRules.push(rule);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">function expand(at, conflicts, parts) {</span><span class="s3">\n                </span><span class="s1">if (at == rule.parts.length) {</span><span class="s3">\n                    </span><span class="s1">newRules.push(new Rule(rule.name, parts, conflicts, rule.skip));</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let next = rule.parts[at], replace = inlinable[next.name];</span><span class="s3">\n                </span><span class="s1">if (!replace) {</span><span class="s3">\n                    </span><span class="s1">expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next));</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">for (let r of replace)</span><span class="s3">\n                    </span><span class="s1">expand(at + 1, conflicts.slice(0, conflicts.length - 1)</span><span class="s3">\n                        </span><span class="s1">.concat(conflicts[at].join(r.conflicts[0]))</span><span class="s3">\n                        </span><span class="s1">.concat(r.conflicts.slice(1, r.conflicts.length - 1))</span><span class="s3">\n                        </span><span class="s1">.concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])), parts.concat(r.parts));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">expand(0, [rule.conflicts[0]], []);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">rules = newRules;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeRules(rules) {</span><span class="s3">\n    </span><span class="s1">let merged = Object.create(null), found;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; rules.length;) {</span><span class="s3">\n        </span><span class="s1">let groupStart = i;</span><span class="s3">\n        </span><span class="s1">let name = rules[i++].name;</span><span class="s3">\n        </span><span class="s1">while (i &lt; rules.length &amp;&amp; rules[i].name == name)</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">let size = i - groupStart;</span><span class="s3">\n        </span><span class="s1">if (name.interesting)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">for (let j = i; j &lt; rules.length;) {</span><span class="s3">\n            </span><span class="s1">let otherStart = j, otherName = rules[j++].name;</span><span class="s3">\n            </span><span class="s1">while (j &lt; rules.length &amp;&amp; rules[j].name == otherName)</span><span class="s3">\n                </span><span class="s1">j++;</span><span class="s3">\n            </span><span class="s1">if (j - otherStart != size || otherName.interesting)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let match = true;</span><span class="s3">\n            </span><span class="s1">for (let k = 0; k &lt; size &amp;&amp; match; k++) {</span><span class="s3">\n                </span><span class="s1">let a = rules[groupStart + k], b = rules[otherStart + k];</span><span class="s3">\n                </span><span class="s1">if (a.cmpNoName(b) != 0)</span><span class="s3">\n                    </span><span class="s1">match = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (match)</span><span class="s3">\n                </span><span class="s1">found = merged[name.name] = otherName;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!found)</span><span class="s3">\n        </span><span class="s1">return rules;</span><span class="s3">\n    </span><span class="s1">let newRules = [];</span><span class="s3">\n    </span><span class="s1">for (let rule of rules)</span><span class="s3">\n        </span><span class="s1">if (!merged[rule.name.name]) {</span><span class="s3">\n            </span><span class="s1">newRules.push(rule.parts.every(p =&gt; !merged[p.name]) ? rule :</span><span class="s3">\n                </span><span class="s1">new Rule(rule.name, rule.parts.map(p =&gt; merged[p.name] || p), rule.conflicts, rule.skip));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return newRules;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function simplifyRules(rules, preserve) {</span><span class="s3">\n    </span><span class="s1">return mergeRules(inlineRules(rules, preserve));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Build an in-memory parser instance for a given grammar. This is</span><span class="s3">\n</span><span class="s1">mostly useful for testing. If your grammar uses external</span><span class="s3">\n</span><span class="s1">tokenizers, you'll have to provide the `externalTokenizer` option</span><span class="s3">\n</span><span class="s1">for the returned parser to be able to parse anything.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildParser(text, options = {}) {</span><span class="s3">\n    </span><span class="s1">let builder = new Builder(text, options), parser = builder.getParser();</span><span class="s3">\n    </span><span class="s1">parser.termTable = builder.termTable;</span><span class="s3">\n    </span><span class="s1">return parser;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const KEYWORDS = [</span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">debugger</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">implements</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">package</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">private</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">protected</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">public</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">yield</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">require</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Build the code that represents the parser tables for a given</span><span class="s3">\n</span><span class="s1">grammar description. The `parser` property in the return value</span><span class="s3">\n</span><span class="s1">holds the main file that exports the `Parser` instance. The</span><span class="s3">\n</span><span class="s1">`terms` property holds a declaration file that defines constants</span><span class="s3">\n</span><span class="s1">for all of the named terms in grammar, holding their ids as value.</span><span class="s3">\n</span><span class="s1">This is useful when external code, such as a tokenizer, needs to</span><span class="s3">\n</span><span class="s1">be able to use these ids. It is recommended to run a tree-shaking</span><span class="s3">\n</span><span class="s1">bundler when importing this file, since you usually only need a</span><span class="s3">\n</span><span class="s1">handful of the many terms in your code.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildParserFile(text, options = {}) {</span><span class="s3">\n    </span><span class="s1">return new Builder(text, options).getParserFile();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ignored(name) {</span><span class="s3">\n    </span><span class="s1">let first = name[0];</span><span class="s3">\n    </span><span class="s1">return first == </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot; </span><span class="s1">|| first.toUpperCase() != first;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isExported(rule) {</span><span class="s3">\n    </span><span class="s1">return rule.props.some(p =&gt; p.at &amp;&amp; p.name == </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { GenError, buildParser, buildParserFile };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>