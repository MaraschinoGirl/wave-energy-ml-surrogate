<html>
<head>
<title>3230.25e2cf51e31209917c87.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
3230.25e2cf51e31209917c87.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;3230.25e2cf51e31209917c87.js?v=25e2cf51e31209917c87&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA,YAAY;AACZ,mBAAmB;AACnB,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,MAAM,kCAAkC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,OAAO;;AAE7C;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,OAAO;;AAE7C,+DAA+D;AAC/D;AACA,mCAAmC,OAAO,OAAO;;AAEjD,sEAAsE;AACtE;AACA;AACA,yCAAyC,OAAO,OAAO;;AAEvD;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,uBAAuB;;AAEjI;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,8DAA8D;;AAE1F;AACA,sBAAsB;AACtB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAA6C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,4CAA4C;;AAExE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+BAA+B;AAC/B,wCAAwC;AACxC,qCAAqC;AACrC,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,oBAAoB,QAAQ;AAC5B;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/xquery.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// The keywords object is set to the result of this self executing</span><span class="s3">\n</span><span class="s1">// function. Each keyword is a property of the keywords object whose</span><span class="s3">\n</span><span class="s1">// value is {type: atype, style: astyle}</span><span class="s3">\n</span><span class="s1">var keywords = function(){</span><span class="s3">\n  </span><span class="s1">// convenience functions used to build keywords object</span><span class="s3">\n  </span><span class="s1">function kw(type) {return {type: type, style: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">};}</span><span class="s3">\n  </span><span class="s1">var operator = kw(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">, atom = {type: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">, punctuation = {type: </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">, style: null}</span><span class="s3">\n  </span><span class="s1">, qualifier = {type: </span><span class="s3">\&quot;</span><span class="s1">axis_specifier</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">qualifier</span><span class="s3">\&quot;</span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// kwObj is what is return from this function at the end</span><span class="s3">\n  </span><span class="s1">var kwObj = {</span><span class="s3">\n    </span><span class="s1">',': punctuation</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// a list of 'basic' keywords. For each add a property to kwObj with the value of</span><span class="s3">\n  </span><span class="s1">// {type: basic[i], style: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">} e.g. 'after' --&gt; {type: </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',</span><span class="s3">\n               </span><span class="s1">'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',</span><span class="s3">\n               </span><span class="s1">'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',</span><span class="s3">\n               </span><span class="s1">'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',</span><span class="s3">\n               </span><span class="s1">'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',</span><span class="s3">\n               </span><span class="s1">'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',</span><span class="s3">\n               </span><span class="s1">'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',</span><span class="s3">\n               </span><span class="s1">'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',</span><span class="s3">\n               </span><span class="s1">'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',</span><span class="s3">\n               </span><span class="s1">'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',</span><span class="s3">\n               </span><span class="s1">'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',</span><span class="s3">\n               </span><span class="s1">'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',</span><span class="s3">\n               </span><span class="s1">'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',</span><span class="s3">\n               </span><span class="s1">'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',</span><span class="s3">\n               </span><span class="s1">'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',</span><span class="s3">\n               </span><span class="s1">'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',</span><span class="s3">\n               </span><span class="s1">'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',</span><span class="s3">\n               </span><span class="s1">'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',</span><span class="s3">\n               </span><span class="s1">'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',</span><span class="s3">\n               </span><span class="s1">'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];</span><span class="s3">\n  </span><span class="s1">for(var i=0, l=basic.length; i &lt; l; i++) { kwObj[basic[i]] = kw(basic[i]);};</span><span class="s3">\n\n  </span><span class="s1">// a list of types. For each add a property to kwObj with the value of</span><span class="s3">\n  </span><span class="s1">// {type: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',</span><span class="s3">\n               </span><span class="s1">'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',</span><span class="s3">\n               </span><span class="s1">'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',</span><span class="s3">\n               </span><span class="s1">'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',</span><span class="s3">\n               </span><span class="s1">'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',</span><span class="s3">\n               </span><span class="s1">'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',</span><span class="s3">\n               </span><span class="s1">'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',</span><span class="s3">\n               </span><span class="s1">'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',</span><span class="s3">\n               </span><span class="s1">'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',</span><span class="s3">\n               </span><span class="s1">'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];</span><span class="s3">\n  </span><span class="s1">for(var i=0, l=types.length; i &lt; l; i++) { kwObj[types[i]] = atom;};</span><span class="s3">\n\n  </span><span class="s1">// each operator will add a property to kwObj with value of {type: </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '&gt;', '&gt;=', '&lt;', '&lt;=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];</span><span class="s3">\n  </span><span class="s1">for(var i=0, l=operators.length; i &lt; l; i++) { kwObj[operators[i]] = operator;};</span><span class="s3">\n\n  </span><span class="s1">// each axis_specifiers will add a property to kwObj with value of {type: </span><span class="s3">\&quot;</span><span class="s1">axis_specifier</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">qualifier</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var axis_specifiers = [</span><span class="s3">\&quot;</span><span class="s1">self::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">attribute::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">child::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">descendant::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">descendant-or-self::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">parent::</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                         \&quot;</span><span class="s1">ancestor::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">ancestor-or-self::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">following::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">preceding::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">following-sibling::</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">preceding-sibling::</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">for(var i=0, l=axis_specifiers.length; i &lt; l; i++) { kwObj[axis_specifiers[i]] = qualifier; };</span><span class="s3">\n\n  </span><span class="s1">return kwObj;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">function chain(stream, state, f) {</span><span class="s3">\n  </span><span class="s1">state.tokenize = f;</span><span class="s3">\n  </span><span class="s1">return f(stream, state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// the primary mode tokenizer</span><span class="s3">\n</span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch = stream.next(),</span><span class="s3">\n      </span><span class="s1">mightBeFunction = false,</span><span class="s3">\n      </span><span class="s1">isEQName = isEQNameAhead(stream);</span><span class="s3">\n\n  </span><span class="s1">// an XML tag (if not in some sub, chained tokenizer)</span><span class="s3">\n  </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if(stream.match(</span><span class="s3">\&quot;</span><span class="s1">!--</span><span class="s3">\&quot;</span><span class="s1">, true))</span><span class="s3">\n      </span><span class="s1">return chain(stream, state, tokenXMLComment);</span><span class="s3">\n\n    </span><span class="s1">if(stream.match(</span><span class="s3">\&quot;</span><span class="s1">![CDATA</span><span class="s3">\&quot;</span><span class="s1">, false)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenCDATA;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if(stream.match(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">, false)) {</span><span class="s3">\n      </span><span class="s1">return chain(stream, state, tokenPreProcessing);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var isclose = stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">stream.eatSpace();</span><span class="s3">\n    </span><span class="s1">var tagName = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, c;</span><span class="s3">\n    </span><span class="s1">while ((c = stream.eat(/[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">u00a0=&lt;&gt;</span><span class="s3">\\\&quot;\\</span><span class="s1">'</span><span class="s3">\\</span><span class="s1">/?]/))) tagName += c;</span><span class="s3">\n\n    </span><span class="s1">return chain(stream, state, tokenTag(tagName, isclose));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// start code block</span><span class="s3">\n  </span><span class="s1">else if(ch == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">codeblock</span><span class="s3">\&quot;</span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// end code block</span><span class="s3">\n  </span><span class="s1">else if(ch == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">popStateStack(state);</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// if we're in an XML block</span><span class="s3">\n  </span><span class="s1">else if(isInXmlBlock(state)) {</span><span class="s3">\n    </span><span class="s1">if(ch == </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">else if(ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">popStateStack(state);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// if a number</span><span class="s3">\n  </span><span class="s1">else if (/</span><span class="s3">\\</span><span class="s1">d/.test(ch)) {</span><span class="s3">\n    </span><span class="s1">stream.match(/^</span><span class="s3">\\</span><span class="s1">d*(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*)?(?:E[+</span><span class="s3">\\</span><span class="s1">-]?</span><span class="s3">\\</span><span class="s1">d+)?/);</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// comment start</span><span class="s3">\n  </span><span class="s1">else if (ch === </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return chain(stream, state, tokenComment);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// quoted string</span><span class="s3">\n  </span><span class="s1">else if (!isEQName &amp;&amp; (ch === '</span><span class="s3">\&quot;</span><span class="s1">' || ch === </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n    </span><span class="s1">return chain(stream, state, tokenString(ch));</span><span class="s3">\n  </span><span class="s1">// variable</span><span class="s3">\n  </span><span class="s1">else if(ch === </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return chain(stream, state, tokenVariable);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// assignment</span><span class="s3">\n  </span><span class="s1">else if(ch ===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// open paren</span><span class="s3">\n  </span><span class="s1">else if(ch === </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">paren</span><span class="s3">\&quot;</span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// close paren</span><span class="s3">\n  </span><span class="s1">else if(ch === </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">popStateStack(state);</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// open paren</span><span class="s3">\n  </span><span class="s1">else if(ch === </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">bracket</span><span class="s3">\&quot;</span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// close paren</span><span class="s3">\n  </span><span class="s1">else if(ch === </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">popStateStack(state);</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">var known = keywords.propertyIsEnumerable(ch) &amp;&amp; keywords[ch];</span><span class="s3">\n\n    </span><span class="s1">// if there's a EQName ahead, consume the rest of the string portion, it's likely a function</span><span class="s3">\n    </span><span class="s1">if(isEQName &amp;&amp; ch === '</span><span class="s3">\\\&quot;</span><span class="s1">') while(stream.next() !== '</span><span class="s3">\&quot;</span><span class="s1">'){}</span><span class="s3">\n    </span><span class="s1">if(isEQName &amp;&amp; ch === '</span><span class="s3">\\</span><span class="s1">'') while(stream.next() !== '</span><span class="s3">\\</span><span class="s1">''){}</span><span class="s3">\n\n    </span><span class="s1">// gobble up a word if the character is not known</span><span class="s3">\n    </span><span class="s1">if(!known) stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_-]/);</span><span class="s3">\n\n    </span><span class="s1">// gobble a colon in the case that is a lib func type call fn:doc</span><span class="s3">\n    </span><span class="s1">var foundColon = stream.eat(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier</span><span class="s3">\n    </span><span class="s1">// which should get matched as a keyword</span><span class="s3">\n    </span><span class="s1">if(!stream.eat(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; foundColon) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_-]/);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)</span><span class="s3">\n    </span><span class="s1">if(stream.match(/^[ </span><span class="s3">\\</span><span class="s1">t]*</span><span class="s3">\\</span><span class="s1">(/, false)) {</span><span class="s3">\n      </span><span class="s1">mightBeFunction = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// is the word a keyword?</span><span class="s3">\n    </span><span class="s1">var word = stream.current();</span><span class="s3">\n    </span><span class="s1">known = keywords.propertyIsEnumerable(word) &amp;&amp; keywords[word];</span><span class="s3">\n\n    </span><span class="s1">// if we think it's a function call but not yet known,</span><span class="s3">\n    </span><span class="s1">// set style to variable for now for lack of something better</span><span class="s3">\n    </span><span class="s1">if(mightBeFunction &amp;&amp; !known) known = {type: </span><span class="s3">\&quot;</span><span class="s1">function_call</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// if the previous word was element, attribute, axis specifier, this word should be the name of that</span><span class="s3">\n    </span><span class="s1">if(isInXmlConstructor(state)) {</span><span class="s3">\n      </span><span class="s1">popStateStack(state);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// as previously checked, if the word is element,attribute, axis specifier, call it an </span><span class="s3">\&quot;</span><span class="s1">xmlconstructor</span><span class="s3">\&quot; </span><span class="s1">and</span><span class="s3">\n    </span><span class="s1">// push the stack so we know to look for it on the next word</span><span class="s3">\n    </span><span class="s1">if(word == </span><span class="s3">\&quot;</span><span class="s1">element</span><span class="s3">\&quot; </span><span class="s1">|| word == </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot; </span><span class="s1">|| known.type == </span><span class="s3">\&quot;</span><span class="s1">axis_specifier</span><span class="s3">\&quot;</span><span class="s1">) pushStateStack(state, {type: </span><span class="s3">\&quot;</span><span class="s1">xmlconstructor</span><span class="s3">\&quot;</span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// if the word is known, return the details of that else just call this a generic 'word'</span><span class="s3">\n    </span><span class="s1">return known ? known.style : </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// handle comments, including nested</span><span class="s3">\n</span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;</span><span class="s3">\n  </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n      </span><span class="s1">if(nestedCount &gt; 0)</span><span class="s3">\n        </span><span class="s1">nestedCount--;</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">popStateStack(state);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if(ch == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeNested) {</span><span class="s3">\n      </span><span class="s1">nestedCount++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">maybeNested = (ch == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// tokenizer for string literals</span><span class="s3">\n</span><span class="s1">// optionally pass a tokenizer function to set state.tokenize back to when finished</span><span class="s3">\n</span><span class="s1">function tokenString(quote, f) {</span><span class="s3">\n  </span><span class="s1">return function(stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch;</span><span class="s3">\n\n    </span><span class="s1">if(isInString(state) &amp;&amp; stream.current() == quote) {</span><span class="s3">\n      </span><span class="s1">popStateStack(state);</span><span class="s3">\n      </span><span class="s1">if(f) state.tokenize = f;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, name: quote, tokenize: tokenString(quote, f) });</span><span class="s3">\n\n    </span><span class="s1">// if we're in a string and in an XML block, allow an embedded code block</span><span class="s3">\n    </span><span class="s1">if(stream.match(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, false) &amp;&amp; isInXmlAttributeBlock(state)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n    </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n      </span><span class="s1">if (ch ==  quote) {</span><span class="s3">\n        </span><span class="s1">popStateStack(state);</span><span class="s3">\n        </span><span class="s1">if(f) state.tokenize = f;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// if we're in a string and in an XML block, allow an embedded code block in an attribute</span><span class="s3">\n        </span><span class="s1">if(stream.match(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, false) &amp;&amp; isInXmlAttributeBlock(state)) {</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n          </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// tokenizer for variables</span><span class="s3">\n</span><span class="s1">function tokenVariable(stream, state) {</span><span class="s3">\n  </span><span class="s1">var isVariableChar = /[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_-]/;</span><span class="s3">\n\n  </span><span class="s1">// a variable may start with a quoted EQName so if the next character is quote, consume to the next quote</span><span class="s3">\n  </span><span class="s1">if(stream.eat(</span><span class="s3">\&quot;\\\&quot;\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">while(stream.next() !== '</span><span class="s3">\\\&quot;</span><span class="s1">'){};</span><span class="s3">\n    </span><span class="s1">stream.eat(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(isVariableChar);</span><span class="s3">\n    </span><span class="s1">if(!stream.match(</span><span class="s3">\&quot;</span><span class="s1">:=</span><span class="s3">\&quot;</span><span class="s1">, false)) stream.eat(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stream.eatWhile(isVariableChar);</span><span class="s3">\n  </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// tokenizer for XML tags</span><span class="s3">\n</span><span class="s1">function tokenTag(name, isclose) {</span><span class="s3">\n  </span><span class="s1">return function(stream, state) {</span><span class="s3">\n    </span><span class="s1">stream.eatSpace();</span><span class="s3">\n    </span><span class="s1">if(isclose &amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">popStateStack(state);</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// self closing tag without attributes?</span><span class="s3">\n    </span><span class="s1">if(!stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n      </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">, name: name, tokenize: tokenBase});</span><span class="s3">\n    </span><span class="s1">if(!stream.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenAttribute;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// tokenizer for XML attributes</span><span class="s3">\n</span><span class="s1">function tokenAttribute(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch = stream.next();</span><span class="s3">\n\n  </span><span class="s1">if(ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">if(isInXmlAttributeBlock(state)) popStateStack(state);</span><span class="s3">\n    </span><span class="s1">if(isInXmlBlock(state)) popStateStack(state);</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if(ch == </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if(isInXmlAttributeBlock(state)) popStateStack(state);</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if(ch == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">// quoted string</span><span class="s3">\n  </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">' || ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return chain(stream, state, tokenString(ch, tokenAttribute));</span><span class="s3">\n\n  </span><span class="s1">if(!isInXmlAttributeBlock(state))</span><span class="s3">\n    </span><span class="s1">pushStateStack(state, { type: </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">, tokenize: tokenAttribute});</span><span class="s3">\n\n  </span><span class="s1">stream.eat(/[a-zA-Z_:]/);</span><span class="s3">\n  </span><span class="s1">stream.eatWhile(/[-a-zA-Z0-9_:.]/);</span><span class="s3">\n  </span><span class="s1">stream.eatSpace();</span><span class="s3">\n\n  </span><span class="s1">// the case where the attribute has not value and the tag was closed</span><span class="s3">\n  </span><span class="s1">if(stream.match(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, false) || stream.match(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, false)) {</span><span class="s3">\n    </span><span class="s1">popStateStack(state);</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// handle comments, including nested</span><span class="s3">\n</span><span class="s1">function tokenXMLComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(</span><span class="s3">\&quot;</span><span class="s1">-&gt;</span><span class="s3">\&quot;</span><span class="s1">, true)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">// handle CDATA</span><span class="s3">\n</span><span class="s1">function tokenCDATA(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">, true)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// handle preprocessing instructions</span><span class="s3">\n</span><span class="s1">function tokenPreProcessing(stream, state) {</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, true)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">processingInstruction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">// functions to test the current context of the state</span><span class="s3">\n</span><span class="s1">function isInXmlBlock(state) { return isIn(state, </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n</span><span class="s1">function isInXmlAttributeBlock(state) { return isIn(state, </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n</span><span class="s1">function isInXmlConstructor(state) { return isIn(state, </span><span class="s3">\&quot;</span><span class="s1">xmlconstructor</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n</span><span class="s1">function isInString(state) { return isIn(state, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n\n</span><span class="s1">function isEQNameAhead(stream) {</span><span class="s3">\n  </span><span class="s1">// assume we've already eaten a quote (</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if(stream.current() === '</span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\n    </span><span class="s1">return stream.match(/^[^</span><span class="s3">\\\&quot;</span><span class="s1">]+</span><span class="s3">\\\&quot;\\</span><span class="s1">:/, false);</span><span class="s3">\n  </span><span class="s1">else if(stream.current() === '</span><span class="s3">\\</span><span class="s1">'')</span><span class="s3">\n    </span><span class="s1">return stream.match(/^[^</span><span class="s3">\\\&quot;</span><span class="s1">]+</span><span class="s3">\\</span><span class="s1">'</span><span class="s3">\\</span><span class="s1">:/, false);</span><span class="s3">\n  </span><span class="s1">else</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isIn(state, type) {</span><span class="s3">\n  </span><span class="s1">return (state.stack.length &amp;&amp; state.stack[state.stack.length - 1].type == type);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function pushStateStack(state, newState) {</span><span class="s3">\n  </span><span class="s1">state.stack.push(newState);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function popStateStack(state) {</span><span class="s3">\n  </span><span class="s1">state.stack.pop();</span><span class="s3">\n  </span><span class="s1">var reinstateTokenize = state.stack.length &amp;&amp; state.stack[state.stack.length-1].tokenize;</span><span class="s3">\n  </span><span class="s1">state.tokenize = reinstateTokenize || tokenBase;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// the interface for the mode API</span><span class="s3">\n</span><span class="s1">export const xQuery = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">xquery</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">startState: function() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">tokenize: tokenBase,</span><span class="s3">\n      </span><span class="s1">cc: [],</span><span class="s3">\n      </span><span class="s1">stack: []</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n    </span><span class="s1">var style = state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">return style;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">commentTokens: {block: {open: </span><span class="s3">\&quot;</span><span class="s1">(:</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">:)</span><span class="s3">\&quot;</span><span class="s1">}}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>