<html>
<head>
<title>383.086fc5ebac8a08e85b7c.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
383.086fc5ebac8a08e85b7c.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;383.086fc5ebac8a08e85b7c.js?v=086fc5ebac8a08e85b7c&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAa;;AAEb;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;;AAEd;AACA,WAAW;AACX,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA,uCAAuC;AACvC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;;;;;;;;ACtQA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,8BAA8B;AACrE;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,YAAY;AACZ;AACA,sCAAsC;AACtC;AACA;AACA,UAAU;AACV;AACA;AACA,iDAAiD;AACjD;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA,MAAM;AACN,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AChhBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;ACvLhB;;AAEb;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;;;;;;;;ACrHA;;AAEb;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACrCa;;AAEb,eAAe,mBAAO,CAAC,KAAe;AACtC,SAAS,mBAAO,CAAC,KAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAM,8BAA8B,qBAAM;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD,IAAI;AACJ,sCAAsC;AACtC;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,yBAAyB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/minimist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/path-browserify/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/process/browser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/querystringify/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/requires-port/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/url-parse/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">function hasKey(obj, keys) {</span><span class="s3">\n\t</span><span class="s1">var o = obj;</span><span class="s3">\n\t</span><span class="s1">keys.slice(0, -1).forEach(function (key) {</span><span class="s3">\n\t\t</span><span class="s1">o = o[key] || {};</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\n\t</span><span class="s1">var key = keys[keys.length - 1];</span><span class="s3">\n\t</span><span class="s1">return key in o;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isNumber(x) {</span><span class="s3">\n\t</span><span class="s1">if (typeof x === 'number') { return true; }</span><span class="s3">\n\t</span><span class="s1">if ((/^0x[0-9a-f]+$/i).test(x)) { return true; }</span><span class="s3">\n\t</span><span class="s1">return (/^[-+]?(?:</span><span class="s3">\\</span><span class="s1">d+(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*)?|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)(e[-+]?</span><span class="s3">\\</span><span class="s1">d+)?$/).test(x);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isConstructorOrProto(obj, key) {</span><span class="s3">\n\t</span><span class="s1">return (key === 'constructor' &amp;&amp; typeof obj[key] === 'function') || key === '__proto__';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = function (args, opts) {</span><span class="s3">\n\t</span><span class="s1">if (!opts) { opts = {}; }</span><span class="s3">\n\n\t</span><span class="s1">var flags = {</span><span class="s3">\n\t\t</span><span class="s1">bools: {},</span><span class="s3">\n\t\t</span><span class="s1">strings: {},</span><span class="s3">\n\t\t</span><span class="s1">unknownFn: null,</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\n\t</span><span class="s1">if (typeof opts.unknown === 'function') {</span><span class="s3">\n\t\t</span><span class="s1">flags.unknownFn = opts.unknown;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (typeof opts.boolean === 'boolean' &amp;&amp; opts.boolean) {</span><span class="s3">\n\t\t</span><span class="s1">flags.allBools = true;</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">[].concat(opts.boolean).filter(Boolean).forEach(function (key) {</span><span class="s3">\n\t\t\t</span><span class="s1">flags.bools[key] = true;</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">var aliases = {};</span><span class="s3">\n\n\t</span><span class="s1">function aliasIsBoolean(key) {</span><span class="s3">\n\t\t</span><span class="s1">return aliases[key].some(function (x) {</span><span class="s3">\n\t\t\t</span><span class="s1">return flags.bools[x];</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">Object.keys(opts.alias || {}).forEach(function (key) {</span><span class="s3">\n\t\t</span><span class="s1">aliases[key] = [].concat(opts.alias[key]);</span><span class="s3">\n\t\t</span><span class="s1">aliases[key].forEach(function (x) {</span><span class="s3">\n\t\t\t</span><span class="s1">aliases[x] = [key].concat(aliases[key].filter(function (y) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return x !== y;</span><span class="s3">\n\t\t\t</span><span class="s1">}));</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\n\t</span><span class="s1">[].concat(opts.string).filter(Boolean).forEach(function (key) {</span><span class="s3">\n\t\t</span><span class="s1">flags.strings[key] = true;</span><span class="s3">\n\t\t</span><span class="s1">if (aliases[key]) {</span><span class="s3">\n\t\t\t</span><span class="s1">[].concat(aliases[key]).forEach(function (k) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">flags.strings[k] = true;</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\n\t</span><span class="s1">var defaults = opts.default || {};</span><span class="s3">\n\n\t</span><span class="s1">var argv = { _: [] };</span><span class="s3">\n\n\t</span><span class="s1">function argDefined(key, arg) {</span><span class="s3">\n\t\t</span><span class="s1">return (flags.allBools &amp;&amp; (/^--[^=]+$/).test(arg))</span><span class="s3">\n\t\t\t</span><span class="s1">|| flags.strings[key]</span><span class="s3">\n\t\t\t</span><span class="s1">|| flags.bools[key]</span><span class="s3">\n\t\t\t</span><span class="s1">|| aliases[key];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">function setKey(obj, keys, value) {</span><span class="s3">\n\t\t</span><span class="s1">var o = obj;</span><span class="s3">\n\t\t</span><span class="s1">for (var i = 0; i &lt; keys.length - 1; i++) {</span><span class="s3">\n\t\t\t</span><span class="s1">var key = keys[i];</span><span class="s3">\n\t\t\t</span><span class="s1">if (isConstructorOrProto(o, key)) { return; }</span><span class="s3">\n\t\t\t</span><span class="s1">if (o[key] === undefined) { o[key] = {}; }</span><span class="s3">\n\t\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t\t</span><span class="s1">o[key] === Object.prototype</span><span class="s3">\n\t\t\t\t</span><span class="s1">|| o[key] === Number.prototype</span><span class="s3">\n\t\t\t\t</span><span class="s1">|| o[key] === String.prototype</span><span class="s3">\n\t\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">o[key] = {};</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (o[key] === Array.prototype) { o[key] = []; }</span><span class="s3">\n\t\t\t</span><span class="s1">o = o[key];</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">var lastKey = keys[keys.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">if (isConstructorOrProto(o, lastKey)) { return; }</span><span class="s3">\n\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t</span><span class="s1">o === Object.prototype</span><span class="s3">\n\t\t\t</span><span class="s1">|| o === Number.prototype</span><span class="s3">\n\t\t\t</span><span class="s1">|| o === String.prototype</span><span class="s3">\n\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">o = {};</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (o === Array.prototype) { o = []; }</span><span class="s3">\n\t\t</span><span class="s1">if (o[lastKey] === undefined || flags.bools[lastKey] || typeof o[lastKey] === 'boolean') {</span><span class="s3">\n\t\t\t</span><span class="s1">o[lastKey] = value;</span><span class="s3">\n\t\t</span><span class="s1">} else if (Array.isArray(o[lastKey])) {</span><span class="s3">\n\t\t\t</span><span class="s1">o[lastKey].push(value);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">o[lastKey] = [o[lastKey], value];</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">function setArg(key, val, arg) {</span><span class="s3">\n\t\t</span><span class="s1">if (arg &amp;&amp; flags.unknownFn &amp;&amp; !argDefined(key, arg)) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (flags.unknownFn(arg) === false) { return; }</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">var value = !flags.strings[key] &amp;&amp; isNumber(val)</span><span class="s3">\n\t\t\t</span><span class="s1">? Number(val)</span><span class="s3">\n\t\t\t</span><span class="s1">: val;</span><span class="s3">\n\t\t</span><span class="s1">setKey(argv, key.split('.'), value);</span><span class="s3">\n\n\t\t</span><span class="s1">(aliases[key] || []).forEach(function (x) {</span><span class="s3">\n\t\t\t</span><span class="s1">setKey(argv, x.split('.'), value);</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">Object.keys(flags.bools).forEach(function (key) {</span><span class="s3">\n\t\t</span><span class="s1">setArg(key, defaults[key] === undefined ? false : defaults[key]);</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\n\t</span><span class="s1">var notFlags = [];</span><span class="s3">\n\n\t</span><span class="s1">if (args.indexOf('--') !== -1) {</span><span class="s3">\n\t\t</span><span class="s1">notFlags = args.slice(args.indexOf('--') + 1);</span><span class="s3">\n\t\t</span><span class="s1">args = args.slice(0, args.indexOf('--'));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">for (var i = 0; i &lt; args.length; i++) {</span><span class="s3">\n\t\t</span><span class="s1">var arg = args[i];</span><span class="s3">\n\t\t</span><span class="s1">var key;</span><span class="s3">\n\t\t</span><span class="s1">var next;</span><span class="s3">\n\n\t\t</span><span class="s1">if ((/^--.+=/).test(arg)) {</span><span class="s3">\n\t\t\t</span><span class="s1">// Using [</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S] instead of . because js doesn't support the</span><span class="s3">\n\t\t\t</span><span class="s1">// 'dotall' regex modifier. See:</span><span class="s3">\n\t\t\t</span><span class="s1">// http://stackoverflow.com/a/1068308/13216</span><span class="s3">\n\t\t\t</span><span class="s1">var m = arg.match(/^--([^=]+)=([</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*)$/);</span><span class="s3">\n\t\t\t</span><span class="s1">key = m[1];</span><span class="s3">\n\t\t\t</span><span class="s1">var value = m[2];</span><span class="s3">\n\t\t\t</span><span class="s1">if (flags.bools[key]) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">value = value !== 'false';</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">setArg(key, value, arg);</span><span class="s3">\n\t\t</span><span class="s1">} else if ((/^--no-.+/).test(arg)) {</span><span class="s3">\n\t\t\t</span><span class="s1">key = arg.match(/^--no-(.+)/)[1];</span><span class="s3">\n\t\t\t</span><span class="s1">setArg(key, false, arg);</span><span class="s3">\n\t\t</span><span class="s1">} else if ((/^--.+/).test(arg)) {</span><span class="s3">\n\t\t\t</span><span class="s1">key = arg.match(/^--(.+)/)[1];</span><span class="s3">\n\t\t\t</span><span class="s1">next = args[i + 1];</span><span class="s3">\n\t\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t\t</span><span class="s1">next !== undefined</span><span class="s3">\n\t\t\t\t</span><span class="s1">&amp;&amp; !(/^(-|--)[^-]/).test(next)</span><span class="s3">\n\t\t\t\t</span><span class="s1">&amp;&amp; !flags.bools[key]</span><span class="s3">\n\t\t\t\t</span><span class="s1">&amp;&amp; !flags.allBools</span><span class="s3">\n\t\t\t\t</span><span class="s1">&amp;&amp; (aliases[key] ? !aliasIsBoolean(key) : true)</span><span class="s3">\n\t\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">setArg(key, next, arg);</span><span class="s3">\n\t\t\t\t</span><span class="s1">i += 1;</span><span class="s3">\n\t\t\t</span><span class="s1">} else if ((/^(true|false)$/).test(next)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">setArg(key, next === 'true', arg);</span><span class="s3">\n\t\t\t\t</span><span class="s1">i += 1;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">setArg(key, flags.strings[key] ? '' : true, arg);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else if ((/^-[^-]+/).test(arg)) {</span><span class="s3">\n\t\t\t</span><span class="s1">var letters = arg.slice(1, -1).split('');</span><span class="s3">\n\n\t\t\t</span><span class="s1">var broken = false;</span><span class="s3">\n\t\t\t</span><span class="s1">for (var j = 0; j &lt; letters.length; j++) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">next = arg.slice(j + 2);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (next === '-') {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(letters[j], next, arg);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">continue;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if ((/[A-Za-z]/).test(letters[j]) &amp;&amp; next[0] === '=') {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(letters[j], next.slice(1), arg);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">broken = true;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">(/[A-Za-z]/).test(letters[j])</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">&amp;&amp; (/-?</span><span class="s3">\\</span><span class="s1">d+(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*)?(e-?</span><span class="s3">\\</span><span class="s1">d+)?$/).test(next)</span><span class="s3">\n\t\t\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(letters[j], next, arg);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">broken = true;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (letters[j + 1] &amp;&amp; letters[j + 1].match(/</span><span class="s3">\\</span><span class="s1">W/)) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(letters[j], arg.slice(j + 2), arg);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">broken = true;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">key = arg.slice(-1)[0];</span><span class="s3">\n\t\t\t</span><span class="s1">if (!broken &amp;&amp; key !== '-') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">args[i + 1]</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">&amp;&amp; !(/^(-|--)[^-]/).test(args[i + 1])</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">&amp;&amp; !flags.bools[key]</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">&amp;&amp; (aliases[key] ? !aliasIsBoolean(key) : true)</span><span class="s3">\n\t\t\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(key, args[i + 1], arg);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">i += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else if (args[i + 1] &amp;&amp; (/^(true|false)$/).test(args[i + 1])) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(key, args[i + 1] === 'true', arg);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">i += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">setArg(key, flags.strings[key] ? '' : true, arg);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!flags.unknownFn || flags.unknownFn(arg) !== false) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (opts.stopEarly) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">argv._.push.apply(argv._, args.slice(i + 1));</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">Object.keys(defaults).forEach(function (k) {</span><span class="s3">\n\t\t</span><span class="s1">if (!hasKey(argv, k.split('.'))) {</span><span class="s3">\n\t\t\t</span><span class="s1">setKey(argv, k.split('.'), defaults[k]);</span><span class="s3">\n\n\t\t\t</span><span class="s1">(aliases[k] || []).forEach(function (x) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">setKey(argv, x.split('.'), defaults[k]);</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\n\t</span><span class="s1">if (opts['--']) {</span><span class="s3">\n\t\t</span><span class="s1">argv['--'] = notFlags.slice();</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">notFlags.forEach(function (k) {</span><span class="s3">\n\t\t\t</span><span class="s1">argv._.push(k);</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return argv;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// 'path' module extracted from Node.js v8.11.1 (only the posix part)</span><span class="s3">\n</span><span class="s1">// transplited with Babel</span><span class="s3">\n\n</span><span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span><span class="s3">\n</span><span class="s1">// copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span><span class="s3">\n</span><span class="s1">// persons to whom the Software is furnished to do so, subject to the</span><span class="s3">\n</span><span class="s1">// following conditions:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The above copyright notice and this permission notice shall be included</span><span class="s3">\n</span><span class="s1">// in all copies or substantial portions of the Software.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span><span class="s3">\n</span><span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span><span class="s3">\n</span><span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span><span class="s3">\n</span><span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span><span class="s3">\n</span><span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span><span class="s3">\n</span><span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n\n</span><span class="s1">'use strict';</span><span class="s3">\n\n</span><span class="s1">function assertPath(path) {</span><span class="s3">\n  </span><span class="s1">if (typeof path !== 'string') {</span><span class="s3">\n    </span><span class="s1">throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Resolves . and .. elements in a path with directory names</span><span class="s3">\n</span><span class="s1">function normalizeStringPosix(path, allowAboveRoot) {</span><span class="s3">\n  </span><span class="s1">var res = '';</span><span class="s3">\n  </span><span class="s1">var lastSegmentLength = 0;</span><span class="s3">\n  </span><span class="s1">var lastSlash = -1;</span><span class="s3">\n  </span><span class="s1">var dots = 0;</span><span class="s3">\n  </span><span class="s1">var code;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt;= path.length; ++i) {</span><span class="s3">\n    </span><span class="s1">if (i &lt; path.length)</span><span class="s3">\n      </span><span class="s1">code = path.charCodeAt(i);</span><span class="s3">\n    </span><span class="s1">else if (code === 47 /*/*/)</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n      </span><span class="s1">code = 47 /*/*/;</span><span class="s3">\n    </span><span class="s1">if (code === 47 /*/*/) {</span><span class="s3">\n      </span><span class="s1">if (lastSlash === i - 1 || dots === 1) {</span><span class="s3">\n        </span><span class="s1">// NOOP</span><span class="s3">\n      </span><span class="s1">} else if (lastSlash !== i - 1 &amp;&amp; dots === 2) {</span><span class="s3">\n        </span><span class="s1">if (res.length &lt; 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {</span><span class="s3">\n          </span><span class="s1">if (res.length &gt; 2) {</span><span class="s3">\n            </span><span class="s1">var lastSlashIndex = res.lastIndexOf('/');</span><span class="s3">\n            </span><span class="s1">if (lastSlashIndex !== res.length - 1) {</span><span class="s3">\n              </span><span class="s1">if (lastSlashIndex === -1) {</span><span class="s3">\n                </span><span class="s1">res = '';</span><span class="s3">\n                </span><span class="s1">lastSegmentLength = 0;</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">res = res.slice(0, lastSlashIndex);</span><span class="s3">\n                </span><span class="s1">lastSegmentLength = res.length - 1 - res.lastIndexOf('/');</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">lastSlash = i;</span><span class="s3">\n              </span><span class="s1">dots = 0;</span><span class="s3">\n              </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (res.length === 2 || res.length === 1) {</span><span class="s3">\n            </span><span class="s1">res = '';</span><span class="s3">\n            </span><span class="s1">lastSegmentLength = 0;</span><span class="s3">\n            </span><span class="s1">lastSlash = i;</span><span class="s3">\n            </span><span class="s1">dots = 0;</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (allowAboveRoot) {</span><span class="s3">\n          </span><span class="s1">if (res.length &gt; 0)</span><span class="s3">\n            </span><span class="s1">res += '/..';</span><span class="s3">\n          </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">res = '..';</span><span class="s3">\n          </span><span class="s1">lastSegmentLength = 2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (res.length &gt; 0)</span><span class="s3">\n          </span><span class="s1">res += '/' + path.slice(lastSlash + 1, i);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n          </span><span class="s1">res = path.slice(lastSlash + 1, i);</span><span class="s3">\n        </span><span class="s1">lastSegmentLength = i - lastSlash - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">lastSlash = i;</span><span class="s3">\n      </span><span class="s1">dots = 0;</span><span class="s3">\n    </span><span class="s1">} else if (code === 46 /*.*/ &amp;&amp; dots !== -1) {</span><span class="s3">\n      </span><span class="s1">++dots;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">dots = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _format(sep, pathObject) {</span><span class="s3">\n  </span><span class="s1">var dir = pathObject.dir || pathObject.root;</span><span class="s3">\n  </span><span class="s1">var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');</span><span class="s3">\n  </span><span class="s1">if (!dir) {</span><span class="s3">\n    </span><span class="s1">return base;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (dir === pathObject.root) {</span><span class="s3">\n    </span><span class="s1">return dir + base;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return dir + sep + base;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var posix = {</span><span class="s3">\n  </span><span class="s1">// path.resolve([from ...], to)</span><span class="s3">\n  </span><span class="s1">resolve: function resolve() {</span><span class="s3">\n    </span><span class="s1">var resolvedPath = '';</span><span class="s3">\n    </span><span class="s1">var resolvedAbsolute = false;</span><span class="s3">\n    </span><span class="s1">var cwd;</span><span class="s3">\n\n    </span><span class="s1">for (var i = arguments.length - 1; i &gt;= -1 &amp;&amp; !resolvedAbsolute; i--) {</span><span class="s3">\n      </span><span class="s1">var path;</span><span class="s3">\n      </span><span class="s1">if (i &gt;= 0)</span><span class="s3">\n        </span><span class="s1">path = arguments[i];</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">if (cwd === undefined)</span><span class="s3">\n          </span><span class="s1">cwd = process.cwd();</span><span class="s3">\n        </span><span class="s1">path = cwd;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">assertPath(path);</span><span class="s3">\n\n      </span><span class="s1">// Skip empty entries</span><span class="s3">\n      </span><span class="s1">if (path.length === 0) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">resolvedPath = path + '/' + resolvedPath;</span><span class="s3">\n      </span><span class="s1">resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// At this point the path should be resolved to a full absolute path, but</span><span class="s3">\n    </span><span class="s1">// handle relative paths to be safe (might happen when process.cwd() fails)</span><span class="s3">\n\n    </span><span class="s1">// Normalize the path</span><span class="s3">\n    </span><span class="s1">resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);</span><span class="s3">\n\n    </span><span class="s1">if (resolvedAbsolute) {</span><span class="s3">\n      </span><span class="s1">if (resolvedPath.length &gt; 0)</span><span class="s3">\n        </span><span class="s1">return '/' + resolvedPath;</span><span class="s3">\n      </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return '/';</span><span class="s3">\n    </span><span class="s1">} else if (resolvedPath.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">return resolvedPath;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return '.';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">normalize: function normalize(path) {</span><span class="s3">\n    </span><span class="s1">assertPath(path);</span><span class="s3">\n\n    </span><span class="s1">if (path.length === 0) return '.';</span><span class="s3">\n\n    </span><span class="s1">var isAbsolute = path.charCodeAt(0) === 47 /*/*/;</span><span class="s3">\n    </span><span class="s1">var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;</span><span class="s3">\n\n    </span><span class="s1">// Normalize the path</span><span class="s3">\n    </span><span class="s1">path = normalizeStringPosix(path, !isAbsolute);</span><span class="s3">\n\n    </span><span class="s1">if (path.length === 0 &amp;&amp; !isAbsolute) path = '.';</span><span class="s3">\n    </span><span class="s1">if (path.length &gt; 0 &amp;&amp; trailingSeparator) path += '/';</span><span class="s3">\n\n    </span><span class="s1">if (isAbsolute) return '/' + path;</span><span class="s3">\n    </span><span class="s1">return path;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">isAbsolute: function isAbsolute(path) {</span><span class="s3">\n    </span><span class="s1">assertPath(path);</span><span class="s3">\n    </span><span class="s1">return path.length &gt; 0 &amp;&amp; path.charCodeAt(0) === 47 /*/*/;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">join: function join() {</span><span class="s3">\n    </span><span class="s1">if (arguments.length === 0)</span><span class="s3">\n      </span><span class="s1">return '.';</span><span class="s3">\n    </span><span class="s1">var joined;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; arguments.length; ++i) {</span><span class="s3">\n      </span><span class="s1">var arg = arguments[i];</span><span class="s3">\n      </span><span class="s1">assertPath(arg);</span><span class="s3">\n      </span><span class="s1">if (arg.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">if (joined === undefined)</span><span class="s3">\n          </span><span class="s1">joined = arg;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n          </span><span class="s1">joined += '/' + arg;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (joined === undefined)</span><span class="s3">\n      </span><span class="s1">return '.';</span><span class="s3">\n    </span><span class="s1">return posix.normalize(joined);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">relative: function relative(from, to) {</span><span class="s3">\n    </span><span class="s1">assertPath(from);</span><span class="s3">\n    </span><span class="s1">assertPath(to);</span><span class="s3">\n\n    </span><span class="s1">if (from === to) return '';</span><span class="s3">\n\n    </span><span class="s1">from = posix.resolve(from);</span><span class="s3">\n    </span><span class="s1">to = posix.resolve(to);</span><span class="s3">\n\n    </span><span class="s1">if (from === to) return '';</span><span class="s3">\n\n    </span><span class="s1">// Trim any leading backslashes</span><span class="s3">\n    </span><span class="s1">var fromStart = 1;</span><span class="s3">\n    </span><span class="s1">for (; fromStart &lt; from.length; ++fromStart) {</span><span class="s3">\n      </span><span class="s1">if (from.charCodeAt(fromStart) !== 47 /*/*/)</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var fromEnd = from.length;</span><span class="s3">\n    </span><span class="s1">var fromLen = fromEnd - fromStart;</span><span class="s3">\n\n    </span><span class="s1">// Trim any leading backslashes</span><span class="s3">\n    </span><span class="s1">var toStart = 1;</span><span class="s3">\n    </span><span class="s1">for (; toStart &lt; to.length; ++toStart) {</span><span class="s3">\n      </span><span class="s1">if (to.charCodeAt(toStart) !== 47 /*/*/)</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var toEnd = to.length;</span><span class="s3">\n    </span><span class="s1">var toLen = toEnd - toStart;</span><span class="s3">\n\n    </span><span class="s1">// Compare paths to find the longest common path from root</span><span class="s3">\n    </span><span class="s1">var length = fromLen &lt; toLen ? fromLen : toLen;</span><span class="s3">\n    </span><span class="s1">var lastCommonSep = -1;</span><span class="s3">\n    </span><span class="s1">var i = 0;</span><span class="s3">\n    </span><span class="s1">for (; i &lt;= length; ++i) {</span><span class="s3">\n      </span><span class="s1">if (i === length) {</span><span class="s3">\n        </span><span class="s1">if (toLen &gt; length) {</span><span class="s3">\n          </span><span class="s1">if (to.charCodeAt(toStart + i) === 47 /*/*/) {</span><span class="s3">\n            </span><span class="s1">// We get here if `from` is the exact base path for `to`.</span><span class="s3">\n            </span><span class="s1">// For example: from='/foo/bar'; to='/foo/bar/baz'</span><span class="s3">\n            </span><span class="s1">return to.slice(toStart + i + 1);</span><span class="s3">\n          </span><span class="s1">} else if (i === 0) {</span><span class="s3">\n            </span><span class="s1">// We get here if `from` is the root</span><span class="s3">\n            </span><span class="s1">// For example: from='/'; to='/foo'</span><span class="s3">\n            </span><span class="s1">return to.slice(toStart + i);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (fromLen &gt; length) {</span><span class="s3">\n          </span><span class="s1">if (from.charCodeAt(fromStart + i) === 47 /*/*/) {</span><span class="s3">\n            </span><span class="s1">// We get here if `to` is the exact base path for `from`.</span><span class="s3">\n            </span><span class="s1">// For example: from='/foo/bar/baz'; to='/foo/bar'</span><span class="s3">\n            </span><span class="s1">lastCommonSep = i;</span><span class="s3">\n          </span><span class="s1">} else if (i === 0) {</span><span class="s3">\n            </span><span class="s1">// We get here if `to` is the root.</span><span class="s3">\n            </span><span class="s1">// For example: from='/foo'; to='/'</span><span class="s3">\n            </span><span class="s1">lastCommonSep = 0;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var fromCode = from.charCodeAt(fromStart + i);</span><span class="s3">\n      </span><span class="s1">var toCode = to.charCodeAt(toStart + i);</span><span class="s3">\n      </span><span class="s1">if (fromCode !== toCode)</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">else if (fromCode === 47 /*/*/)</span><span class="s3">\n        </span><span class="s1">lastCommonSep = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var out = '';</span><span class="s3">\n    </span><span class="s1">// Generate the relative path based on the path difference between `to`</span><span class="s3">\n    </span><span class="s1">// and `from`</span><span class="s3">\n    </span><span class="s1">for (i = fromStart + lastCommonSep + 1; i &lt;= fromEnd; ++i) {</span><span class="s3">\n      </span><span class="s1">if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {</span><span class="s3">\n        </span><span class="s1">if (out.length === 0)</span><span class="s3">\n          </span><span class="s1">out += '..';</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n          </span><span class="s1">out += '/..';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Lastly, append the rest of the destination (`to`) path that comes after</span><span class="s3">\n    </span><span class="s1">// the common path parts</span><span class="s3">\n    </span><span class="s1">if (out.length &gt; 0)</span><span class="s3">\n      </span><span class="s1">return out + to.slice(toStart + lastCommonSep);</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">toStart += lastCommonSep;</span><span class="s3">\n      </span><span class="s1">if (to.charCodeAt(toStart) === 47 /*/*/)</span><span class="s3">\n        </span><span class="s1">++toStart;</span><span class="s3">\n      </span><span class="s1">return to.slice(toStart);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">_makeLong: function _makeLong(path) {</span><span class="s3">\n    </span><span class="s1">return path;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">dirname: function dirname(path) {</span><span class="s3">\n    </span><span class="s1">assertPath(path);</span><span class="s3">\n    </span><span class="s1">if (path.length === 0) return '.';</span><span class="s3">\n    </span><span class="s1">var code = path.charCodeAt(0);</span><span class="s3">\n    </span><span class="s1">var hasRoot = code === 47 /*/*/;</span><span class="s3">\n    </span><span class="s1">var end = -1;</span><span class="s3">\n    </span><span class="s1">var matchedSlash = true;</span><span class="s3">\n    </span><span class="s1">for (var i = path.length - 1; i &gt;= 1; --i) {</span><span class="s3">\n      </span><span class="s1">code = path.charCodeAt(i);</span><span class="s3">\n      </span><span class="s1">if (code === 47 /*/*/) {</span><span class="s3">\n          </span><span class="s1">if (!matchedSlash) {</span><span class="s3">\n            </span><span class="s1">end = i;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// We saw the first non-path separator</span><span class="s3">\n        </span><span class="s1">matchedSlash = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (end === -1) return hasRoot ? '/' : '.';</span><span class="s3">\n    </span><span class="s1">if (hasRoot &amp;&amp; end === 1) return '//';</span><span class="s3">\n    </span><span class="s1">return path.slice(0, end);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">basename: function basename(path, ext) {</span><span class="s3">\n    </span><span class="s1">if (ext !== undefined &amp;&amp; typeof ext !== 'string') throw new TypeError('</span><span class="s3">\&quot;</span><span class="s1">ext</span><span class="s3">\&quot; </span><span class="s1">argument must be a string');</span><span class="s3">\n    </span><span class="s1">assertPath(path);</span><span class="s3">\n\n    </span><span class="s1">var start = 0;</span><span class="s3">\n    </span><span class="s1">var end = -1;</span><span class="s3">\n    </span><span class="s1">var matchedSlash = true;</span><span class="s3">\n    </span><span class="s1">var i;</span><span class="s3">\n\n    </span><span class="s1">if (ext !== undefined &amp;&amp; ext.length &gt; 0 &amp;&amp; ext.length &lt;= path.length) {</span><span class="s3">\n      </span><span class="s1">if (ext.length === path.length &amp;&amp; ext === path) return '';</span><span class="s3">\n      </span><span class="s1">var extIdx = ext.length - 1;</span><span class="s3">\n      </span><span class="s1">var firstNonSlashEnd = -1;</span><span class="s3">\n      </span><span class="s1">for (i = path.length - 1; i &gt;= 0; --i) {</span><span class="s3">\n        </span><span class="s1">var code = path.charCodeAt(i);</span><span class="s3">\n        </span><span class="s1">if (code === 47 /*/*/) {</span><span class="s3">\n            </span><span class="s1">// If we reached a path separator that was not part of a set of path</span><span class="s3">\n            </span><span class="s1">// separators at the end of the string, stop now</span><span class="s3">\n            </span><span class="s1">if (!matchedSlash) {</span><span class="s3">\n              </span><span class="s1">start = i + 1;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (firstNonSlashEnd === -1) {</span><span class="s3">\n            </span><span class="s1">// We saw the first non-path separator, remember this index in case</span><span class="s3">\n            </span><span class="s1">// we need it if the extension ends up not matching</span><span class="s3">\n            </span><span class="s1">matchedSlash = false;</span><span class="s3">\n            </span><span class="s1">firstNonSlashEnd = i + 1;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (extIdx &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">// Try to match the explicit extension</span><span class="s3">\n            </span><span class="s1">if (code === ext.charCodeAt(extIdx)) {</span><span class="s3">\n              </span><span class="s1">if (--extIdx === -1) {</span><span class="s3">\n                </span><span class="s1">// We matched the extension, so mark this as the end of our path</span><span class="s3">\n                </span><span class="s1">// component</span><span class="s3">\n                </span><span class="s1">end = i;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Extension does not match, so our result is the entire path</span><span class="s3">\n              </span><span class="s1">// component</span><span class="s3">\n              </span><span class="s1">extIdx = -1;</span><span class="s3">\n              </span><span class="s1">end = firstNonSlashEnd;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;</span><span class="s3">\n      </span><span class="s1">return path.slice(start, end);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">for (i = path.length - 1; i &gt;= 0; --i) {</span><span class="s3">\n        </span><span class="s1">if (path.charCodeAt(i) === 47 /*/*/) {</span><span class="s3">\n            </span><span class="s1">// If we reached a path separator that was not part of a set of path</span><span class="s3">\n            </span><span class="s1">// separators at the end of the string, stop now</span><span class="s3">\n            </span><span class="s1">if (!matchedSlash) {</span><span class="s3">\n              </span><span class="s1">start = i + 1;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (end === -1) {</span><span class="s3">\n          </span><span class="s1">// We saw the first non-path separator, mark this as the end of our</span><span class="s3">\n          </span><span class="s1">// path component</span><span class="s3">\n          </span><span class="s1">matchedSlash = false;</span><span class="s3">\n          </span><span class="s1">end = i + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (end === -1) return '';</span><span class="s3">\n      </span><span class="s1">return path.slice(start, end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">extname: function extname(path) {</span><span class="s3">\n    </span><span class="s1">assertPath(path);</span><span class="s3">\n    </span><span class="s1">var startDot = -1;</span><span class="s3">\n    </span><span class="s1">var startPart = 0;</span><span class="s3">\n    </span><span class="s1">var end = -1;</span><span class="s3">\n    </span><span class="s1">var matchedSlash = true;</span><span class="s3">\n    </span><span class="s1">// Track the state of characters (if any) we see before our first dot and</span><span class="s3">\n    </span><span class="s1">// after any path separator we find</span><span class="s3">\n    </span><span class="s1">var preDotState = 0;</span><span class="s3">\n    </span><span class="s1">for (var i = path.length - 1; i &gt;= 0; --i) {</span><span class="s3">\n      </span><span class="s1">var code = path.charCodeAt(i);</span><span class="s3">\n      </span><span class="s1">if (code === 47 /*/*/) {</span><span class="s3">\n          </span><span class="s1">// If we reached a path separator that was not part of a set of path</span><span class="s3">\n          </span><span class="s1">// separators at the end of the string, stop now</span><span class="s3">\n          </span><span class="s1">if (!matchedSlash) {</span><span class="s3">\n            </span><span class="s1">startPart = i + 1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (end === -1) {</span><span class="s3">\n        </span><span class="s1">// We saw the first non-path separator, mark this as the end of our</span><span class="s3">\n        </span><span class="s1">// extension</span><span class="s3">\n        </span><span class="s1">matchedSlash = false;</span><span class="s3">\n        </span><span class="s1">end = i + 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (code === 46 /*.*/) {</span><span class="s3">\n          </span><span class="s1">// If this is our first dot, mark it as the start of our extension</span><span class="s3">\n          </span><span class="s1">if (startDot === -1)</span><span class="s3">\n            </span><span class="s1">startDot = i;</span><span class="s3">\n          </span><span class="s1">else if (preDotState !== 1)</span><span class="s3">\n            </span><span class="s1">preDotState = 1;</span><span class="s3">\n      </span><span class="s1">} else if (startDot !== -1) {</span><span class="s3">\n        </span><span class="s1">// We saw a non-dot and non-path separator before our dot, so we should</span><span class="s3">\n        </span><span class="s1">// have a good chance at having a non-empty extension</span><span class="s3">\n        </span><span class="s1">preDotState = -1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (startDot === -1 || end === -1 ||</span><span class="s3">\n        </span><span class="s1">// We saw a non-dot character immediately before the dot</span><span class="s3">\n        </span><span class="s1">preDotState === 0 ||</span><span class="s3">\n        </span><span class="s1">// The (right-most) trimmed path component is exactly '..'</span><span class="s3">\n        </span><span class="s1">preDotState === 1 &amp;&amp; startDot === end - 1 &amp;&amp; startDot === startPart + 1) {</span><span class="s3">\n      </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return path.slice(startDot, end);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">format: function format(pathObject) {</span><span class="s3">\n    </span><span class="s1">if (pathObject === null || typeof pathObject !== 'object') {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('The </span><span class="s3">\&quot;</span><span class="s1">pathObject</span><span class="s3">\&quot; </span><span class="s1">argument must be of type Object. Received type ' + typeof pathObject);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _format('/', pathObject);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">parse: function parse(path) {</span><span class="s3">\n    </span><span class="s1">assertPath(path);</span><span class="s3">\n\n    </span><span class="s1">var ret = { root: '', dir: '', base: '', ext: '', name: '' };</span><span class="s3">\n    </span><span class="s1">if (path.length === 0) return ret;</span><span class="s3">\n    </span><span class="s1">var code = path.charCodeAt(0);</span><span class="s3">\n    </span><span class="s1">var isAbsolute = code === 47 /*/*/;</span><span class="s3">\n    </span><span class="s1">var start;</span><span class="s3">\n    </span><span class="s1">if (isAbsolute) {</span><span class="s3">\n      </span><span class="s1">ret.root = '/';</span><span class="s3">\n      </span><span class="s1">start = 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">start = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var startDot = -1;</span><span class="s3">\n    </span><span class="s1">var startPart = 0;</span><span class="s3">\n    </span><span class="s1">var end = -1;</span><span class="s3">\n    </span><span class="s1">var matchedSlash = true;</span><span class="s3">\n    </span><span class="s1">var i = path.length - 1;</span><span class="s3">\n\n    </span><span class="s1">// Track the state of characters (if any) we see before our first dot and</span><span class="s3">\n    </span><span class="s1">// after any path separator we find</span><span class="s3">\n    </span><span class="s1">var preDotState = 0;</span><span class="s3">\n\n    </span><span class="s1">// Get non-dir info</span><span class="s3">\n    </span><span class="s1">for (; i &gt;= start; --i) {</span><span class="s3">\n      </span><span class="s1">code = path.charCodeAt(i);</span><span class="s3">\n      </span><span class="s1">if (code === 47 /*/*/) {</span><span class="s3">\n          </span><span class="s1">// If we reached a path separator that was not part of a set of path</span><span class="s3">\n          </span><span class="s1">// separators at the end of the string, stop now</span><span class="s3">\n          </span><span class="s1">if (!matchedSlash) {</span><span class="s3">\n            </span><span class="s1">startPart = i + 1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (end === -1) {</span><span class="s3">\n        </span><span class="s1">// We saw the first non-path separator, mark this as the end of our</span><span class="s3">\n        </span><span class="s1">// extension</span><span class="s3">\n        </span><span class="s1">matchedSlash = false;</span><span class="s3">\n        </span><span class="s1">end = i + 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (code === 46 /*.*/) {</span><span class="s3">\n          </span><span class="s1">// If this is our first dot, mark it as the start of our extension</span><span class="s3">\n          </span><span class="s1">if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;</span><span class="s3">\n        </span><span class="s1">} else if (startDot !== -1) {</span><span class="s3">\n        </span><span class="s1">// We saw a non-dot and non-path separator before our dot, so we should</span><span class="s3">\n        </span><span class="s1">// have a good chance at having a non-empty extension</span><span class="s3">\n        </span><span class="s1">preDotState = -1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (startDot === -1 || end === -1 ||</span><span class="s3">\n    </span><span class="s1">// We saw a non-dot character immediately before the dot</span><span class="s3">\n    </span><span class="s1">preDotState === 0 ||</span><span class="s3">\n    </span><span class="s1">// The (right-most) trimmed path component is exactly '..'</span><span class="s3">\n    </span><span class="s1">preDotState === 1 &amp;&amp; startDot === end - 1 &amp;&amp; startDot === startPart + 1) {</span><span class="s3">\n      </span><span class="s1">if (end !== -1) {</span><span class="s3">\n        </span><span class="s1">if (startPart === 0 &amp;&amp; isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (startPart === 0 &amp;&amp; isAbsolute) {</span><span class="s3">\n        </span><span class="s1">ret.name = path.slice(1, startDot);</span><span class="s3">\n        </span><span class="s1">ret.base = path.slice(1, end);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">ret.name = path.slice(startPart, startDot);</span><span class="s3">\n        </span><span class="s1">ret.base = path.slice(startPart, end);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ret.ext = path.slice(startDot, end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (startPart &gt; 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';</span><span class="s3">\n\n    </span><span class="s1">return ret;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">sep: '/',</span><span class="s3">\n  </span><span class="s1">delimiter: ':',</span><span class="s3">\n  </span><span class="s1">win32: null,</span><span class="s3">\n  </span><span class="s1">posix: null</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">posix.posix = posix;</span><span class="s3">\n\n</span><span class="s1">module.exports = posix;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// shim for using process in browser</span><span class="s3">\n</span><span class="s1">var process = module.exports = {};</span><span class="s3">\n\n</span><span class="s1">// cached from whatever global is present so that test runners that stub it</span><span class="s3">\n</span><span class="s1">// don't break things.  But we need to wrap it in a try catch in case it is</span><span class="s3">\n</span><span class="s1">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span><span class="s3">\n</span><span class="s1">// function because try/catches deoptimize in certain engines.</span><span class="s3">\n\n</span><span class="s1">var cachedSetTimeout;</span><span class="s3">\n</span><span class="s1">var cachedClearTimeout;</span><span class="s3">\n\n</span><span class="s1">function defaultSetTimout() {</span><span class="s3">\n    </span><span class="s1">throw new Error('setTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultClearTimeout () {</span><span class="s3">\n    </span><span class="s1">throw new Error('clearTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function () {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof setTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof clearTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} ())</span><span class="s3">\n</span><span class="s1">function runTimeout(fun) {</span><span class="s3">\n    </span><span class="s1">if (cachedSetTimeout === setTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if setTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedSetTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">} catch(e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(null, fun, 0);</span><span class="s3">\n        </span><span class="s1">} catch(e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(this, fun, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function runClearTimeout(marker) {</span><span class="s3">\n    </span><span class="s1">if (cachedClearTimeout === clearTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if clearTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedClearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">} catch (e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(null, marker);</span><span class="s3">\n        </span><span class="s1">} catch (e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span><span class="s3">\n            </span><span class="s1">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(this, marker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var queue = [];</span><span class="s3">\n</span><span class="s1">var draining = false;</span><span class="s3">\n</span><span class="s1">var currentQueue;</span><span class="s3">\n</span><span class="s1">var queueIndex = -1;</span><span class="s3">\n\n</span><span class="s1">function cleanUpNextTick() {</span><span class="s3">\n    </span><span class="s1">if (!draining || !currentQueue) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">if (currentQueue.length) {</span><span class="s3">\n        </span><span class="s1">queue = currentQueue.concat(queue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (queue.length) {</span><span class="s3">\n        </span><span class="s1">drainQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function drainQueue() {</span><span class="s3">\n    </span><span class="s1">if (draining) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var timeout = runTimeout(cleanUpNextTick);</span><span class="s3">\n    </span><span class="s1">draining = true;</span><span class="s3">\n\n    </span><span class="s1">var len = queue.length;</span><span class="s3">\n    </span><span class="s1">while(len) {</span><span class="s3">\n        </span><span class="s1">currentQueue = queue;</span><span class="s3">\n        </span><span class="s1">queue = [];</span><span class="s3">\n        </span><span class="s1">while (++queueIndex &lt; len) {</span><span class="s3">\n            </span><span class="s1">if (currentQueue) {</span><span class="s3">\n                </span><span class="s1">currentQueue[queueIndex].run();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n        </span><span class="s1">len = queue.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currentQueue = null;</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">runClearTimeout(timeout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">process.nextTick = function (fun) {</span><span class="s3">\n    </span><span class="s1">var args = new Array(arguments.length - 1);</span><span class="s3">\n    </span><span class="s1">if (arguments.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">for (var i = 1; i &lt; arguments.length; i++) {</span><span class="s3">\n            </span><span class="s1">args[i - 1] = arguments[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">queue.push(new Item(fun, args));</span><span class="s3">\n    </span><span class="s1">if (queue.length === 1 &amp;&amp; !draining) {</span><span class="s3">\n        </span><span class="s1">runTimeout(drainQueue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// v8 likes predictible objects</span><span class="s3">\n</span><span class="s1">function Item(fun, array) {</span><span class="s3">\n    </span><span class="s1">this.fun = fun;</span><span class="s3">\n    </span><span class="s1">this.array = array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Item.prototype.run = function () {</span><span class="s3">\n    </span><span class="s1">this.fun.apply(null, this.array);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.title = 'browser';</span><span class="s3">\n</span><span class="s1">process.browser = true;</span><span class="s3">\n</span><span class="s1">process.env = {};</span><span class="s3">\n</span><span class="s1">process.argv = [];</span><span class="s3">\n</span><span class="s1">process.version = ''; // empty string to avoid regexp issues</span><span class="s3">\n</span><span class="s1">process.versions = {};</span><span class="s3">\n\n</span><span class="s1">function noop() {}</span><span class="s3">\n\n</span><span class="s1">process.on = noop;</span><span class="s3">\n</span><span class="s1">process.addListener = noop;</span><span class="s3">\n</span><span class="s1">process.once = noop;</span><span class="s3">\n</span><span class="s1">process.off = noop;</span><span class="s3">\n</span><span class="s1">process.removeListener = noop;</span><span class="s3">\n</span><span class="s1">process.removeAllListeners = noop;</span><span class="s3">\n</span><span class="s1">process.emit = noop;</span><span class="s3">\n</span><span class="s1">process.prependListener = noop;</span><span class="s3">\n</span><span class="s1">process.prependOnceListener = noop;</span><span class="s3">\n\n</span><span class="s1">process.listeners = function (name) { return [] }</span><span class="s3">\n\n</span><span class="s1">process.binding = function (name) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.binding is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">process.cwd = function () { return '/' };</span><span class="s3">\n</span><span class="s1">process.chdir = function (dir) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.chdir is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.umask = function() { return 0; };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">var has = Object.prototype.hasOwnProperty</span><span class="s3">\n  </span><span class="s1">, undef;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Decode a URI encoded string.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} input The URI encoded string.</span><span class="s3">\n </span><span class="s1">* @returns {String|Null} The decoded string.</span><span class="s3">\n </span><span class="s1">* @api private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function decode(input) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return decodeURIComponent(input.replace(/</span><span class="s3">\\</span><span class="s1">+/g, ' '));</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Attempts to encode a given input.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} input The string that needs to be encoded.</span><span class="s3">\n </span><span class="s1">* @returns {String|Null} The encoded string.</span><span class="s3">\n </span><span class="s1">* @api private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function encode(input) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return encodeURIComponent(input);</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Simple query string parser.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} query The query string that needs to be parsed.</span><span class="s3">\n </span><span class="s1">* @returns {Object}</span><span class="s3">\n </span><span class="s1">* @api public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function querystring(query) {</span><span class="s3">\n  </span><span class="s1">var parser = /([^=?#&amp;]+)=?([^&amp;]*)/g</span><span class="s3">\n    </span><span class="s1">, result = {}</span><span class="s3">\n    </span><span class="s1">, part;</span><span class="s3">\n\n  </span><span class="s1">while (part = parser.exec(query)) {</span><span class="s3">\n    </span><span class="s1">var key = decode(part[1])</span><span class="s3">\n      </span><span class="s1">, value = decode(part[2]);</span><span class="s3">\n\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Prevent overriding of existing properties. This ensures that build-in</span><span class="s3">\n    </span><span class="s1">// methods like `toString` or __proto__ are not overriden by malicious</span><span class="s3">\n    </span><span class="s1">// querystrings.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// In the case if failed decoding, we want to omit the key/value pairs</span><span class="s3">\n    </span><span class="s1">// from the result.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">if (key === null || value === null || key in result) continue;</span><span class="s3">\n    </span><span class="s1">result[key] = value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform a query string to an object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Object} obj Object that should be transformed.</span><span class="s3">\n </span><span class="s1">* @param {String} prefix Optional prefix.</span><span class="s3">\n </span><span class="s1">* @returns {String}</span><span class="s3">\n </span><span class="s1">* @api public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function querystringify(obj, prefix) {</span><span class="s3">\n  </span><span class="s1">prefix = prefix || '';</span><span class="s3">\n\n  </span><span class="s1">var pairs = []</span><span class="s3">\n    </span><span class="s1">, value</span><span class="s3">\n    </span><span class="s1">, key;</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Optionally prefix with a '?' if needed</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if ('string' !== typeof prefix) prefix = '?';</span><span class="s3">\n\n  </span><span class="s1">for (key in obj) {</span><span class="s3">\n    </span><span class="s1">if (has.call(obj, key)) {</span><span class="s3">\n      </span><span class="s1">value = obj[key];</span><span class="s3">\n\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Edge cases where we actually want to encode the value to an empty</span><span class="s3">\n      </span><span class="s1">// string instead of the stringified value.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">if (!value &amp;&amp; (value === null || value === undef || isNaN(value))) {</span><span class="s3">\n        </span><span class="s1">value = '';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">key = encode(key);</span><span class="s3">\n      </span><span class="s1">value = encode(value);</span><span class="s3">\n\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// If we failed to encode the strings, we should bail out as we don't</span><span class="s3">\n      </span><span class="s1">// want to add invalid strings to the query.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">if (key === null || value === null) continue;</span><span class="s3">\n      </span><span class="s1">pairs.push(key +'='+ value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pairs.length ? prefix + pairs.join('&amp;') : '';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Expose the module.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">exports.stringify = querystringify;</span><span class="s3">\n</span><span class="s1">exports.parse = querystring;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if we're required to add a port number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see https://url.spec.whatwg.org/#default-port</span><span class="s3">\n </span><span class="s1">* @param {Number|String} port Port number we need to check</span><span class="s3">\n </span><span class="s1">* @param {String} protocol Protocol we need to check against.</span><span class="s3">\n </span><span class="s1">* @returns {Boolean} Is it a default port for the given protocol</span><span class="s3">\n </span><span class="s1">* @api private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">module.exports = function required(port, protocol) {</span><span class="s3">\n  </span><span class="s1">protocol = protocol.split(':')[0];</span><span class="s3">\n  </span><span class="s1">port = +port;</span><span class="s3">\n\n  </span><span class="s1">if (!port) return false;</span><span class="s3">\n\n  </span><span class="s1">switch (protocol) {</span><span class="s3">\n    </span><span class="s1">case 'http':</span><span class="s3">\n    </span><span class="s1">case 'ws':</span><span class="s3">\n    </span><span class="s1">return port !== 80;</span><span class="s3">\n\n    </span><span class="s1">case 'https':</span><span class="s3">\n    </span><span class="s1">case 'wss':</span><span class="s3">\n    </span><span class="s1">return port !== 443;</span><span class="s3">\n\n    </span><span class="s1">case 'ftp':</span><span class="s3">\n    </span><span class="s1">return port !== 21;</span><span class="s3">\n\n    </span><span class="s1">case 'gopher':</span><span class="s3">\n    </span><span class="s1">return port !== 70;</span><span class="s3">\n\n    </span><span class="s1">case 'file':</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return port !== 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">var required = require('requires-port')</span><span class="s3">\n  </span><span class="s1">, qs = require('querystringify')</span><span class="s3">\n  </span><span class="s1">, controlOrWhitespace = /^[</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x20</span><span class="s3">\\</span><span class="s1">u00a0</span><span class="s3">\\</span><span class="s1">u1680</span><span class="s3">\\</span><span class="s1">u2000-</span><span class="s3">\\</span><span class="s1">u200a</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029</span><span class="s3">\\</span><span class="s1">u202f</span><span class="s3">\\</span><span class="s1">u205f</span><span class="s3">\\</span><span class="s1">u3000</span><span class="s3">\\</span><span class="s1">ufeff]+/</span><span class="s3">\n  </span><span class="s1">, CRHTLF = /[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">t]/g</span><span class="s3">\n  </span><span class="s1">, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">, port = /:</span><span class="s3">\\</span><span class="s1">d+$/</span><span class="s3">\n  </span><span class="s1">, protocolre = /^([a-z][a-z0-9.+-]*:)?(</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)?([</span><span class="s3">\\\\</span><span class="s1">/]+)?([</span><span class="s3">\\</span><span class="s1">S</span><span class="s3">\\</span><span class="s1">s]*)/i</span><span class="s3">\n  </span><span class="s1">, windowsDriveLetter = /^[a-zA-Z]:/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove control characters and whitespace from the beginning of a string.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Object|String} str String to trim.</span><span class="s3">\n </span><span class="s1">* @returns {String} A new string representing `str` stripped of control</span><span class="s3">\n </span><span class="s1">*     characters and whitespace from its beginning.</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function trimLeft(str) {</span><span class="s3">\n  </span><span class="s1">return (str ? str : '').toString().replace(controlOrWhitespace, '');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* These are the parse rules for the URL parser, it informs the parser</span><span class="s3">\n </span><span class="s1">* about:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* 0. The char it Needs to parse, if it's a string it should be done using</span><span class="s3">\n </span><span class="s1">*    indexOf, RegExp using exec and NaN means set as current value.</span><span class="s3">\n </span><span class="s1">* 1. The property we should set when parsing this value.</span><span class="s3">\n </span><span class="s1">* 2. Indication if it's backwards or forward parsing, when set as number it's</span><span class="s3">\n </span><span class="s1">*    the value of extra chars that should be split off.</span><span class="s3">\n </span><span class="s1">* 3. Inherit from location if non existing in the parser.</span><span class="s3">\n </span><span class="s1">* 4. `toLowerCase` the resulting value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var rules = [</span><span class="s3">\n  </span><span class="s1">['#', 'hash'],                        // Extract from the back.</span><span class="s3">\n  </span><span class="s1">['?', 'query'],                       // Extract from the back.</span><span class="s3">\n  </span><span class="s1">function sanitize(address, url) {     // Sanitize what is left of the address</span><span class="s3">\n    </span><span class="s1">return isSpecial(url.protocol) ? address.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/') : address;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">['/', 'pathname'],                    // Extract from the back.</span><span class="s3">\n  </span><span class="s1">['@', 'auth', 1],                     // Extract from the front.</span><span class="s3">\n  </span><span class="s1">[NaN, 'host', undefined, 1, 1],       // Set left over value.</span><span class="s3">\n  </span><span class="s1">[/:(</span><span class="s3">\\</span><span class="s1">d*)$/, 'port', undefined, 1],    // RegExp the back.</span><span class="s3">\n  </span><span class="s1">[NaN, 'hostname', undefined, 1, 1]    // Set left over.</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* These properties should not be copied or inherited from. This is only needed</span><span class="s3">\n </span><span class="s1">* for all non blob URL's as a blob URL does not include a hash, only the</span><span class="s3">\n </span><span class="s1">* origin.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @type {Object}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var ignore = { hash: 1, query: 1 };</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The location object differs when your code is loaded through a normal page,</span><span class="s3">\n </span><span class="s1">* Worker or through a worker using a blob. And with the blobble begins the</span><span class="s3">\n </span><span class="s1">* trouble as the location object will contain the URL of the blob, not the</span><span class="s3">\n </span><span class="s1">* location of the page where our code is loaded in. The actual origin is</span><span class="s3">\n </span><span class="s1">* encoded in the `pathname` so we can thankfully generate a good </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;\n </span><span class="s1">* location from it so we can generate proper relative URL's again.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Object|String} loc Optional default location object.</span><span class="s3">\n </span><span class="s1">* @returns {Object} lolcation object.</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function lolcation(loc) {</span><span class="s3">\n  </span><span class="s1">var globalVar;</span><span class="s3">\n\n  </span><span class="s1">if (typeof window !== 'undefined') globalVar = window;</span><span class="s3">\n  </span><span class="s1">else if (typeof global !== 'undefined') globalVar = global;</span><span class="s3">\n  </span><span class="s1">else if (typeof self !== 'undefined') globalVar = self;</span><span class="s3">\n  </span><span class="s1">else globalVar = {};</span><span class="s3">\n\n  </span><span class="s1">var location = globalVar.location || {};</span><span class="s3">\n  </span><span class="s1">loc = loc || location;</span><span class="s3">\n\n  </span><span class="s1">var finaldestination = {}</span><span class="s3">\n    </span><span class="s1">, type = typeof loc</span><span class="s3">\n    </span><span class="s1">, key;</span><span class="s3">\n\n  </span><span class="s1">if ('blob:' === loc.protocol) {</span><span class="s3">\n    </span><span class="s1">finaldestination = new Url(unescape(loc.pathname), {});</span><span class="s3">\n  </span><span class="s1">} else if ('string' === type) {</span><span class="s3">\n    </span><span class="s1">finaldestination = new Url(loc, {});</span><span class="s3">\n    </span><span class="s1">for (key in ignore) delete finaldestination[key];</span><span class="s3">\n  </span><span class="s1">} else if ('object' === type) {</span><span class="s3">\n    </span><span class="s1">for (key in loc) {</span><span class="s3">\n      </span><span class="s1">if (key in ignore) continue;</span><span class="s3">\n      </span><span class="s1">finaldestination[key] = loc[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (finaldestination.slashes === undefined) {</span><span class="s3">\n      </span><span class="s1">finaldestination.slashes = slashes.test(loc.href);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return finaldestination;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a protocol scheme is special.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} The protocol scheme of the URL</span><span class="s3">\n </span><span class="s1">* @return {Boolean} `true` if the protocol scheme is special, else `false`</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isSpecial(scheme) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">scheme === 'file:' ||</span><span class="s3">\n    </span><span class="s1">scheme === 'ftp:' ||</span><span class="s3">\n    </span><span class="s1">scheme === 'http:' ||</span><span class="s3">\n    </span><span class="s1">scheme === 'https:' ||</span><span class="s3">\n    </span><span class="s1">scheme === 'ws:' ||</span><span class="s3">\n    </span><span class="s1">scheme === 'wss:'</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef ProtocolExtract</span><span class="s3">\n </span><span class="s1">* @type Object</span><span class="s3">\n </span><span class="s1">* @property {String} protocol Protocol matched in the URL, in lowercase.</span><span class="s3">\n </span><span class="s1">* @property {Boolean} slashes `true` if protocol is followed by </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">, else `false`.</span><span class="s3">\n </span><span class="s1">* @property {String} rest Rest of the URL that is not part of the protocol.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Extract protocol information from a URL with/without double slash (</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} address URL we want to extract from.</span><span class="s3">\n </span><span class="s1">* @param {Object} location</span><span class="s3">\n </span><span class="s1">* @return {ProtocolExtract} Extracted information.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function extractProtocol(address, location) {</span><span class="s3">\n  </span><span class="s1">address = trimLeft(address);</span><span class="s3">\n  </span><span class="s1">address = address.replace(CRHTLF, '');</span><span class="s3">\n  </span><span class="s1">location = location || {};</span><span class="s3">\n\n  </span><span class="s1">var match = protocolre.exec(address);</span><span class="s3">\n  </span><span class="s1">var protocol = match[1] ? match[1].toLowerCase() : '';</span><span class="s3">\n  </span><span class="s1">var forwardSlashes = !!match[2];</span><span class="s3">\n  </span><span class="s1">var otherSlashes = !!match[3];</span><span class="s3">\n  </span><span class="s1">var slashesCount = 0;</span><span class="s3">\n  </span><span class="s1">var rest;</span><span class="s3">\n\n  </span><span class="s1">if (forwardSlashes) {</span><span class="s3">\n    </span><span class="s1">if (otherSlashes) {</span><span class="s3">\n      </span><span class="s1">rest = match[2] + match[3] + match[4];</span><span class="s3">\n      </span><span class="s1">slashesCount = match[2].length + match[3].length;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">rest = match[2] + match[4];</span><span class="s3">\n      </span><span class="s1">slashesCount = match[2].length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (otherSlashes) {</span><span class="s3">\n      </span><span class="s1">rest = match[3] + match[4];</span><span class="s3">\n      </span><span class="s1">slashesCount = match[3].length;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">rest = match[4]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (protocol === 'file:') {</span><span class="s3">\n    </span><span class="s1">if (slashesCount &gt;= 2) {</span><span class="s3">\n      </span><span class="s1">rest = rest.slice(2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (isSpecial(protocol)) {</span><span class="s3">\n    </span><span class="s1">rest = match[4];</span><span class="s3">\n  </span><span class="s1">} else if (protocol) {</span><span class="s3">\n    </span><span class="s1">if (forwardSlashes) {</span><span class="s3">\n      </span><span class="s1">rest = rest.slice(2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (slashesCount &gt;= 2 &amp;&amp; isSpecial(location.protocol)) {</span><span class="s3">\n    </span><span class="s1">rest = match[4];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">protocol: protocol,</span><span class="s3">\n    </span><span class="s1">slashes: forwardSlashes || isSpecial(protocol),</span><span class="s3">\n    </span><span class="s1">slashesCount: slashesCount,</span><span class="s3">\n    </span><span class="s1">rest: rest</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Resolve a relative URL pathname against a base URL pathname.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} relative Pathname of the relative URL.</span><span class="s3">\n </span><span class="s1">* @param {String} base Pathname of the base URL.</span><span class="s3">\n </span><span class="s1">* @return {String} Resolved pathname.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolve(relative, base) {</span><span class="s3">\n  </span><span class="s1">if (relative === '') return base;</span><span class="s3">\n\n  </span><span class="s1">var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))</span><span class="s3">\n    </span><span class="s1">, i = path.length</span><span class="s3">\n    </span><span class="s1">, last = path[i - 1]</span><span class="s3">\n    </span><span class="s1">, unshift = false</span><span class="s3">\n    </span><span class="s1">, up = 0;</span><span class="s3">\n\n  </span><span class="s1">while (i--) {</span><span class="s3">\n    </span><span class="s1">if (path[i] === '.') {</span><span class="s3">\n      </span><span class="s1">path.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">} else if (path[i] === '..') {</span><span class="s3">\n      </span><span class="s1">path.splice(i, 1);</span><span class="s3">\n      </span><span class="s1">up++;</span><span class="s3">\n    </span><span class="s1">} else if (up) {</span><span class="s3">\n      </span><span class="s1">if (i === 0) unshift = true;</span><span class="s3">\n      </span><span class="s1">path.splice(i, 1);</span><span class="s3">\n      </span><span class="s1">up--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (unshift) path.unshift('');</span><span class="s3">\n  </span><span class="s1">if (last === '.' || last === '..') path.push('');</span><span class="s3">\n\n  </span><span class="s1">return path.join('/');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The actual URL instance. Instead of returning an object we've opted-in to</span><span class="s3">\n </span><span class="s1">* create an actual constructor as it's much more memory efficient and</span><span class="s3">\n </span><span class="s1">* faster and it pleases my OCD.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It is worth noting that we should not use `URL` as class name to prevent</span><span class="s3">\n </span><span class="s1">* clashes with the global URL instance that got introduced in browsers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {String} address URL we want to parse.</span><span class="s3">\n </span><span class="s1">* @param {Object|String} [location] Location defaults for relative paths.</span><span class="s3">\n </span><span class="s1">* @param {Boolean|Function} [parser] Parser for the query string.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Url(address, location, parser) {</span><span class="s3">\n  </span><span class="s1">address = trimLeft(address);</span><span class="s3">\n  </span><span class="s1">address = address.replace(CRHTLF, '');</span><span class="s3">\n\n  </span><span class="s1">if (!(this instanceof Url)) {</span><span class="s3">\n    </span><span class="s1">return new Url(address, location, parser);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var relative, extracted, parse, instruction, index, key</span><span class="s3">\n    </span><span class="s1">, instructions = rules.slice()</span><span class="s3">\n    </span><span class="s1">, type = typeof location</span><span class="s3">\n    </span><span class="s1">, url = this</span><span class="s3">\n    </span><span class="s1">, i = 0;</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The following if statements allows this module two have compatibility with</span><span class="s3">\n  </span><span class="s1">// 2 different API:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments</span><span class="s3">\n  </span><span class="s1">//    where the boolean indicates that the query string should also be parsed.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// 2. The `URL` interface of the browser which accepts a URL, object as</span><span class="s3">\n  </span><span class="s1">//    arguments. The supplied object will be used as default values / fall-back</span><span class="s3">\n  </span><span class="s1">//    for relative paths.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if ('object' !== type &amp;&amp; 'string' !== type) {</span><span class="s3">\n    </span><span class="s1">parser = location;</span><span class="s3">\n    </span><span class="s1">location = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (parser &amp;&amp; 'function' !== typeof parser) parser = qs.parse;</span><span class="s3">\n\n  </span><span class="s1">location = lolcation(location);</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Extract protocol information before running the instructions.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">extracted = extractProtocol(address || '', location);</span><span class="s3">\n  </span><span class="s1">relative = !extracted.protocol &amp;&amp; !extracted.slashes;</span><span class="s3">\n  </span><span class="s1">url.slashes = extracted.slashes || relative &amp;&amp; location.slashes;</span><span class="s3">\n  </span><span class="s1">url.protocol = extracted.protocol || location.protocol || '';</span><span class="s3">\n  </span><span class="s1">address = extracted.rest;</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// When the authority component is absent the URL starts with a path</span><span class="s3">\n  </span><span class="s1">// component.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">extracted.protocol === 'file:' &amp;&amp; (</span><span class="s3">\n      </span><span class="s1">extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||</span><span class="s3">\n    </span><span class="s1">(!extracted.slashes &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(extracted.protocol ||</span><span class="s3">\n        </span><span class="s1">extracted.slashesCount &lt; 2 ||</span><span class="s3">\n        </span><span class="s1">!isSpecial(url.protocol)))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">instructions[3] = [/(.*)/, 'pathname'];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (; i &lt; instructions.length; i++) {</span><span class="s3">\n    </span><span class="s1">instruction = instructions[i];</span><span class="s3">\n\n    </span><span class="s1">if (typeof instruction === 'function') {</span><span class="s3">\n      </span><span class="s1">address = instruction(address, url);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parse = instruction[0];</span><span class="s3">\n    </span><span class="s1">key = instruction[1];</span><span class="s3">\n\n    </span><span class="s1">if (parse !== parse) {</span><span class="s3">\n      </span><span class="s1">url[key] = address;</span><span class="s3">\n    </span><span class="s1">} else if ('string' === typeof parse) {</span><span class="s3">\n      </span><span class="s1">index = parse === '@'</span><span class="s3">\n        </span><span class="s1">? address.lastIndexOf(parse)</span><span class="s3">\n        </span><span class="s1">: address.indexOf(parse);</span><span class="s3">\n\n      </span><span class="s1">if (~index) {</span><span class="s3">\n        </span><span class="s1">if ('number' === typeof instruction[2]) {</span><span class="s3">\n          </span><span class="s1">url[key] = address.slice(0, index);</span><span class="s3">\n          </span><span class="s1">address = address.slice(index + instruction[2]);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">url[key] = address.slice(index);</span><span class="s3">\n          </span><span class="s1">address = address.slice(0, index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if ((index = parse.exec(address))) {</span><span class="s3">\n      </span><span class="s1">url[key] = index[1];</span><span class="s3">\n      </span><span class="s1">address = address.slice(0, index.index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">url[key] = url[key] || (</span><span class="s3">\n      </span><span class="s1">relative &amp;&amp; instruction[3] ? location[key] || '' : ''</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Hostname, host and protocol should be lowercased so they can be used to</span><span class="s3">\n    </span><span class="s1">// create a proper `origin`.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">if (instruction[4]) url[key] = url[key].toLowerCase();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Also parse the supplied query string in to an object. If we're supplied</span><span class="s3">\n  </span><span class="s1">// with a custom parser as function use that instead of the default build-in</span><span class="s3">\n  </span><span class="s1">// parser.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if (parser) url.query = parser(url.query);</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If the URL is relative, resolve the pathname against the base URL.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">relative</span><span class="s3">\n    </span><span class="s1">&amp;&amp; location.slashes</span><span class="s3">\n    </span><span class="s1">&amp;&amp; url.pathname.charAt(0) !== '/'</span><span class="s3">\n    </span><span class="s1">&amp;&amp; (url.pathname !== '' || location.pathname !== '')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">url.pathname = resolve(url.pathname, location.pathname);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Default to a / for pathname if none exists. This normalizes the URL</span><span class="s3">\n  </span><span class="s1">// to always have a /</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if (url.pathname.charAt(0) !== '/' &amp;&amp; isSpecial(url.protocol)) {</span><span class="s3">\n    </span><span class="s1">url.pathname = '/' + url.pathname;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// We should not add port numbers if they are already the default port number</span><span class="s3">\n  </span><span class="s1">// for a given protocol. As the host also contains the port number we're going</span><span class="s3">\n  </span><span class="s1">// override it with the hostname which contains no port number.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if (!required(url.port, url.protocol)) {</span><span class="s3">\n    </span><span class="s1">url.host = url.hostname;</span><span class="s3">\n    </span><span class="s1">url.port = '';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Parse down the `auth` for the username and password.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">url.username = url.password = '';</span><span class="s3">\n\n  </span><span class="s1">if (url.auth) {</span><span class="s3">\n    </span><span class="s1">index = url.auth.indexOf(':');</span><span class="s3">\n\n    </span><span class="s1">if (~index) {</span><span class="s3">\n      </span><span class="s1">url.username = url.auth.slice(0, index);</span><span class="s3">\n      </span><span class="s1">url.username = encodeURIComponent(decodeURIComponent(url.username));</span><span class="s3">\n\n      </span><span class="s1">url.password = url.auth.slice(index + 1);</span><span class="s3">\n      </span><span class="s1">url.password = encodeURIComponent(decodeURIComponent(url.password))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">url.username = encodeURIComponent(decodeURIComponent(url.auth));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">url.auth = url.password ? url.username +':'+ url.password : url.username;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">url.origin = url.protocol !== 'file:' &amp;&amp; isSpecial(url.protocol) &amp;&amp; url.host</span><span class="s3">\n    </span><span class="s1">? url.protocol +'//'+ url.host</span><span class="s3">\n    </span><span class="s1">: 'null';</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The href is just the compiled result.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">url.href = url.toString();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is convenience method for changing properties in the URL instance to</span><span class="s3">\n </span><span class="s1">* insure that they all propagate correctly.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {String} part          Property we need to adjust.</span><span class="s3">\n </span><span class="s1">* @param {Mixed} value          The newly assigned value.</span><span class="s3">\n </span><span class="s1">* @param {Boolean|Function} fn  When setting the query, it will be the function</span><span class="s3">\n </span><span class="s1">*                               used to parse the query.</span><span class="s3">\n </span><span class="s1">*                               When setting the protocol, double slash will be</span><span class="s3">\n </span><span class="s1">*                               removed from the final url if it is true.</span><span class="s3">\n </span><span class="s1">* @returns {URL} URL instance for chaining.</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function set(part, value, fn) {</span><span class="s3">\n  </span><span class="s1">var url = this;</span><span class="s3">\n\n  </span><span class="s1">switch (part) {</span><span class="s3">\n    </span><span class="s1">case 'query':</span><span class="s3">\n      </span><span class="s1">if ('string' === typeof value &amp;&amp; value.length) {</span><span class="s3">\n        </span><span class="s1">value = (fn || qs.parse)(value);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">url[part] = value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'port':</span><span class="s3">\n      </span><span class="s1">url[part] = value;</span><span class="s3">\n\n      </span><span class="s1">if (!required(value, url.protocol)) {</span><span class="s3">\n        </span><span class="s1">url.host = url.hostname;</span><span class="s3">\n        </span><span class="s1">url[part] = '';</span><span class="s3">\n      </span><span class="s1">} else if (value) {</span><span class="s3">\n        </span><span class="s1">url.host = url.hostname +':'+ value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'hostname':</span><span class="s3">\n      </span><span class="s1">url[part] = value;</span><span class="s3">\n\n      </span><span class="s1">if (url.port) value += ':'+ url.port;</span><span class="s3">\n      </span><span class="s1">url.host = value;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'host':</span><span class="s3">\n      </span><span class="s1">url[part] = value;</span><span class="s3">\n\n      </span><span class="s1">if (port.test(value)) {</span><span class="s3">\n        </span><span class="s1">value = value.split(':');</span><span class="s3">\n        </span><span class="s1">url.port = value.pop();</span><span class="s3">\n        </span><span class="s1">url.hostname = value.join(':');</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url.hostname = value;</span><span class="s3">\n        </span><span class="s1">url.port = '';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'protocol':</span><span class="s3">\n      </span><span class="s1">url.protocol = value.toLowerCase();</span><span class="s3">\n      </span><span class="s1">url.slashes = !fn;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'pathname':</span><span class="s3">\n    </span><span class="s1">case 'hash':</span><span class="s3">\n      </span><span class="s1">if (value) {</span><span class="s3">\n        </span><span class="s1">var char = part === 'pathname' ? '/' : '#';</span><span class="s3">\n        </span><span class="s1">url[part] = value.charAt(0) !== char ? char + value : value;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url[part] = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'username':</span><span class="s3">\n    </span><span class="s1">case 'password':</span><span class="s3">\n      </span><span class="s1">url[part] = encodeURIComponent(value);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n\n    </span><span class="s1">case 'auth':</span><span class="s3">\n      </span><span class="s1">var index = value.indexOf(':');</span><span class="s3">\n\n      </span><span class="s1">if (~index) {</span><span class="s3">\n        </span><span class="s1">url.username = value.slice(0, index);</span><span class="s3">\n        </span><span class="s1">url.username = encodeURIComponent(decodeURIComponent(url.username));</span><span class="s3">\n\n        </span><span class="s1">url.password = value.slice(index + 1);</span><span class="s3">\n        </span><span class="s1">url.password = encodeURIComponent(decodeURIComponent(url.password));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url.username = encodeURIComponent(decodeURIComponent(value));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; rules.length; i++) {</span><span class="s3">\n    </span><span class="s1">var ins = rules[i];</span><span class="s3">\n\n    </span><span class="s1">if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">url.auth = url.password ? url.username +':'+ url.password : url.username;</span><span class="s3">\n\n  </span><span class="s1">url.origin = url.protocol !== 'file:' &amp;&amp; isSpecial(url.protocol) &amp;&amp; url.host</span><span class="s3">\n    </span><span class="s1">? url.protocol +'//'+ url.host</span><span class="s3">\n    </span><span class="s1">: 'null';</span><span class="s3">\n\n  </span><span class="s1">url.href = url.toString();</span><span class="s3">\n\n  </span><span class="s1">return url;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform the properties back in to a valid and full URL string.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Function} stringify Optional query stringify function.</span><span class="s3">\n </span><span class="s1">* @returns {String} Compiled version of the URL.</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toString(stringify) {</span><span class="s3">\n  </span><span class="s1">if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;</span><span class="s3">\n\n  </span><span class="s1">var query</span><span class="s3">\n    </span><span class="s1">, url = this</span><span class="s3">\n    </span><span class="s1">, host = url.host</span><span class="s3">\n    </span><span class="s1">, protocol = url.protocol;</span><span class="s3">\n\n  </span><span class="s1">if (protocol &amp;&amp; protocol.charAt(protocol.length - 1) !== ':') protocol += ':';</span><span class="s3">\n\n  </span><span class="s1">var result =</span><span class="s3">\n    </span><span class="s1">protocol +</span><span class="s3">\n    </span><span class="s1">((url.protocol &amp;&amp; url.slashes) || isSpecial(url.protocol) ? '//' : '');</span><span class="s3">\n\n  </span><span class="s1">if (url.username) {</span><span class="s3">\n    </span><span class="s1">result += url.username;</span><span class="s3">\n    </span><span class="s1">if (url.password) result += ':'+ url.password;</span><span class="s3">\n    </span><span class="s1">result += '@';</span><span class="s3">\n  </span><span class="s1">} else if (url.password) {</span><span class="s3">\n    </span><span class="s1">result += ':'+ url.password;</span><span class="s3">\n    </span><span class="s1">result += '@';</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">url.protocol !== 'file:' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isSpecial(url.protocol) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!host &amp;&amp;</span><span class="s3">\n    </span><span class="s1">url.pathname !== '/'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Add back the empty userinfo, otherwise the original invalid URL</span><span class="s3">\n    </span><span class="s1">// might be transformed into a valid one with `url.pathname` as host.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">result += '@';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Trailing colon is removed from `url.host` when it is parsed. If it still</span><span class="s3">\n  </span><span class="s1">// ends with a colon, then add back the trailing colon that was removed. This</span><span class="s3">\n  </span><span class="s1">// prevents an invalid URL from being transformed into a valid one.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">if (host[host.length - 1] === ':' || (port.test(url.hostname) &amp;&amp; !url.port)) {</span><span class="s3">\n    </span><span class="s1">host += ':';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">result += host + url.pathname;</span><span class="s3">\n\n  </span><span class="s1">query = 'object' === typeof url.query ? stringify(url.query) : url.query;</span><span class="s3">\n  </span><span class="s1">if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;</span><span class="s3">\n\n  </span><span class="s1">if (url.hash) result += url.hash;</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Url.prototype = { set: set, toString: toString };</span><span class="s3">\n\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Expose the URL parser and some additional properties that might be useful for</span><span class="s3">\n</span><span class="s1">// others or testing.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">Url.extractProtocol = extractProtocol;</span><span class="s3">\n</span><span class="s1">Url.location = lolcation;</span><span class="s3">\n</span><span class="s1">Url.trimLeft = trimLeft;</span><span class="s3">\n</span><span class="s1">Url.qs = qs;</span><span class="s3">\n\n</span><span class="s1">module.exports = Url;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>