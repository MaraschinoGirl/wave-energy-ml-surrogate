<html>
<head>
<title>9425.46a85c9a33b839e23d9f.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
9425.46a85c9a33b839e23d9f.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;9425.46a85c9a33b839e23d9f.js?v=46a85c9a33b839e23d9f&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEO;AACP;AACA;AACA,4CAA4C;AAC5C,sCAAsC;AACtC,0CAA0C;AAC1C,sDAAsD;AACtD,kDAAkD;AAClD,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA,4BAA4B;AAC5B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,kDAAkD;AAClD;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,iEAAiE,EAAE,IAAI,cAAc;AACrF,sBAAsB,oBAAoB,yBAAyB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,uBAAuB;AAC3C;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE,gDAAgD,YAAY;AAC5D;AACA,mDAAmD;AACnD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gCAAgC;AAChC;AACA,2DAA2D,6BAA6B;AACxF;AACA,gCAAgC;AAChC;AACA,qCAAqC;AACrC;AACA;AACA,GAAG;AACH;AACA,oBAAoB,uBAAuB;AAC3C;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,uBAAuB;AAC3C;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,yCAAyC,IAAI;AAC7C,iCAAiC;AACjC;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,MAAM;AACN,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/clike.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function Context(indented, column, type, info, align, prev) {</span><span class="s3">\n  </span><span class="s1">this.indented = indented;</span><span class="s3">\n  </span><span class="s1">this.column = column;</span><span class="s3">\n  </span><span class="s1">this.type = type;</span><span class="s3">\n  </span><span class="s1">this.info = info;</span><span class="s3">\n  </span><span class="s1">this.align = align;</span><span class="s3">\n  </span><span class="s1">this.prev = prev;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function pushContext(state, col, type, info) {</span><span class="s3">\n  </span><span class="s1">var indent = state.indented;</span><span class="s3">\n  </span><span class="s1">if (state.context &amp;&amp; state.context.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; type != </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">indent = state.context.indented;</span><span class="s3">\n  </span><span class="s1">return state.context = new Context(indent, col, type, info, null, state.context);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function popContext(state) {</span><span class="s3">\n  </span><span class="s1">var t = state.context.type;</span><span class="s3">\n  </span><span class="s1">if (t == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">|| t == </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">|| t == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">state.indented = state.context.indented;</span><span class="s3">\n  </span><span class="s1">return state.context = state.context.prev;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function typeBefore(stream, state, pos) {</span><span class="s3">\n  </span><span class="s1">if (state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n  </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">S(?:[^- ]&gt;|[*</span><span class="s3">\\</span><span class="s1">]])</span><span class="s3">\\</span><span class="s1">s*$|</span><span class="s3">\\</span><span class="s1">*$/.test(stream.string.slice(0, pos))) return true;</span><span class="s3">\n  </span><span class="s1">if (state.typeAtEndOfLine &amp;&amp; stream.column() == stream.indentation()) return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isTopScope(context) {</span><span class="s3">\n  </span><span class="s1">for (;;) {</span><span class="s3">\n    </span><span class="s1">if (!context || context.type == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n    </span><span class="s1">if (context.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; context.prev.info != </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">) return false;</span><span class="s3">\n    </span><span class="s1">context = context.prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function clike(parserConfig) {</span><span class="s3">\n  </span><span class="s1">var statementIndentUnit = parserConfig.statementIndentUnit,</span><span class="s3">\n      </span><span class="s1">dontAlignCalls = parserConfig.dontAlignCalls,</span><span class="s3">\n      </span><span class="s1">keywords = parserConfig.keywords || {},</span><span class="s3">\n      </span><span class="s1">types = parserConfig.types || {},</span><span class="s3">\n      </span><span class="s1">builtin = parserConfig.builtin || {},</span><span class="s3">\n      </span><span class="s1">blockKeywords = parserConfig.blockKeywords || {},</span><span class="s3">\n      </span><span class="s1">defKeywords = parserConfig.defKeywords || {},</span><span class="s3">\n      </span><span class="s1">atoms = parserConfig.atoms || {},</span><span class="s3">\n      </span><span class="s1">hooks = parserConfig.hooks || {},</span><span class="s3">\n      </span><span class="s1">multiLineStrings = parserConfig.multiLineStrings,</span><span class="s3">\n      </span><span class="s1">indentStatements = parserConfig.indentStatements !== false,</span><span class="s3">\n      </span><span class="s1">indentSwitch = parserConfig.indentSwitch !== false,</span><span class="s3">\n      </span><span class="s1">namespaceSeparator = parserConfig.namespaceSeparator,</span><span class="s3">\n      </span><span class="s1">isPunctuationChar = parserConfig.isPunctuationChar || /[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{}</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">),;</span><span class="s3">\\</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">.]/,</span><span class="s3">\n      </span><span class="s1">numberStart = parserConfig.numberStart || /[</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">.]/,</span><span class="s3">\n      </span><span class="s1">number = parserConfig.number || /^(?:0x[a-f</span><span class="s3">\\</span><span class="s1">d]+|0b[01]+|(?:</span><span class="s3">\\</span><span class="s1">d+</span><span class="s3">\\</span><span class="s1">.?</span><span class="s3">\\</span><span class="s1">d*|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)(?:e[-+]?</span><span class="s3">\\</span><span class="s1">d+)?)(u|ll?|l|f)?/i,</span><span class="s3">\n      </span><span class="s1">isOperatorChar = parserConfig.isOperatorChar || /[+</span><span class="s3">\\</span><span class="s1">-*&amp;%=&lt;&gt;!?|</span><span class="s3">\\</span><span class="s1">/]/,</span><span class="s3">\n      </span><span class="s1">isIdentifierChar = parserConfig.isIdentifierChar || /[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/,</span><span class="s3">\n      </span><span class="s1">// An optional function that takes a {string} token and returns true if it</span><span class="s3">\n      </span><span class="s1">// should be treated as a builtin.</span><span class="s3">\n      </span><span class="s1">isReservedIdentifier = parserConfig.isReservedIdentifier || false;</span><span class="s3">\n\n  </span><span class="s1">var curPunc, isDefKeyword;</span><span class="s3">\n\n  </span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch = stream.next();</span><span class="s3">\n    </span><span class="s1">if (hooks[ch]) {</span><span class="s3">\n      </span><span class="s1">var result = hooks[ch](stream, state);</span><span class="s3">\n      </span><span class="s1">if (result !== false) return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">' || ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenString(ch);</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (numberStart.test(ch)) {</span><span class="s3">\n      </span><span class="s1">stream.backUp(1)</span><span class="s3">\n      </span><span class="s1">if (stream.match(number)) return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;\n      </span><span class="s1">stream.next()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isPunctuationChar.test(ch)) {</span><span class="s3">\n      </span><span class="s1">curPunc = ch;</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenComment;</span><span class="s3">\n        </span><span class="s1">return tokenComment(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isOperatorChar.test(ch)) {</span><span class="s3">\n      </span><span class="s1">while (!stream.match(/^</span><span class="s3">\\</span><span class="s1">/[</span><span class="s3">\\</span><span class="s1">/*]/, false) &amp;&amp; stream.eat(isOperatorChar)) {}</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(isIdentifierChar);</span><span class="s3">\n    </span><span class="s1">if (namespaceSeparator) while (stream.match(namespaceSeparator))</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(isIdentifierChar);</span><span class="s3">\n\n    </span><span class="s1">var cur = stream.current();</span><span class="s3">\n    </span><span class="s1">if (contains(keywords, cur)) {</span><span class="s3">\n      </span><span class="s1">if (contains(blockKeywords, cur)) curPunc = </span><span class="s3">\&quot;</span><span class="s1">newstatement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (contains(defKeywords, cur)) isDefKeyword = true;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (contains(types, cur)) return </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (contains(builtin, cur)</span><span class="s3">\n        </span><span class="s1">|| (isReservedIdentifier &amp;&amp; isReservedIdentifier(cur))) {</span><span class="s3">\n      </span><span class="s1">if (contains(blockKeywords, cur)) curPunc = </span><span class="s3">\&quot;</span><span class="s1">newstatement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">builtin</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (contains(atoms, cur)) return </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenString(quote) {</span><span class="s3">\n    </span><span class="s1">return function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var escaped = false, next, end = false;</span><span class="s3">\n      </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n        </span><span class="s1">if (next == quote &amp;&amp; !escaped) {end = true; break;}</span><span class="s3">\n        </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (end || !(escaped || multiLineStrings))</span><span class="s3">\n        </span><span class="s1">state.tokenize = null;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n    </span><span class="s1">var maybeEnd = false, ch;</span><span class="s3">\n    </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n      </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = null;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function maybeEOL(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (parserConfig.typeFirstDefinitions &amp;&amp; stream.eol() &amp;&amp; isTopScope(state.context))</span><span class="s3">\n      </span><span class="s1">state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Interface</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: parserConfig.name,</span><span class="s3">\n    </span><span class="s1">startState: function(indentUnit) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">tokenize: null,</span><span class="s3">\n        </span><span class="s1">context: new Context(-indentUnit, 0, </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">, null, false),</span><span class="s3">\n        </span><span class="s1">indented: 0,</span><span class="s3">\n        </span><span class="s1">startOfLine: true,</span><span class="s3">\n        </span><span class="s1">prevToken: null</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var ctx = state.context;</span><span class="s3">\n      </span><span class="s1">if (stream.sol()) {</span><span class="s3">\n        </span><span class="s1">if (ctx.align == null) ctx.align = false;</span><span class="s3">\n        </span><span class="s1">state.indented = stream.indentation();</span><span class="s3">\n        </span><span class="s1">state.startOfLine = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (stream.eatSpace()) { maybeEOL(stream, state); return null; }</span><span class="s3">\n      </span><span class="s1">curPunc = isDefKeyword = null;</span><span class="s3">\n      </span><span class="s1">var style = (state.tokenize || tokenBase)(stream, state);</span><span class="s3">\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">) return style;</span><span class="s3">\n      </span><span class="s1">if (ctx.align == null) ctx.align = true;</span><span class="s3">\n\n      </span><span class="s1">if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| curPunc == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">|| (curPunc == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^</span><span class="s3">\\</span><span class="s1">s*(?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/.*)?$/, false)))</span><span class="s3">\n        </span><span class="s1">while (state.context.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) popContext(state);</span><span class="s3">\n      </span><span class="s1">else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">while (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) ctx = popContext(state);</span><span class="s3">\n        </span><span class="s1">if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) ctx = popContext(state);</span><span class="s3">\n        </span><span class="s1">while (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) ctx = popContext(state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (curPunc == ctx.type) popContext(state);</span><span class="s3">\n      </span><span class="s1">else if (indentStatements &amp;&amp;</span><span class="s3">\n               </span><span class="s1">(((ctx.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">|| ctx.type == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; curPunc != </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n                </span><span class="s1">(ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; curPunc == </span><span class="s3">\&quot;</span><span class="s1">newstatement</span><span class="s3">\&quot;</span><span class="s1">))) {</span><span class="s3">\n        </span><span class="s1">pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">, stream.current());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">((state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">(parserConfig.typeFirstDefinitions &amp;&amp; typeBefore(stream, state, stream.start) &amp;&amp;</span><span class="s3">\n             </span><span class="s1">isTopScope(state.context) &amp;&amp; stream.match(/^</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">(/, false)))))</span><span class="s3">\n        </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">if (hooks.token) {</span><span class="s3">\n        </span><span class="s1">var result = hooks.token(stream, state, style);</span><span class="s3">\n        </span><span class="s1">if (result !== undefined) style = result;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parserConfig.styleDefs === false) style = </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">state.startOfLine = false;</span><span class="s3">\n      </span><span class="s1">state.prevToken = isDefKeyword ? </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot; </span><span class="s1">: style || curPunc;</span><span class="s3">\n      </span><span class="s1">maybeEOL(stream, state);</span><span class="s3">\n      </span><span class="s1">return style;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">indent: function(state, textAfter, context) {</span><span class="s3">\n      </span><span class="s1">if (state.tokenize != tokenBase &amp;&amp; state.tokenize != null || state.typeAtEndOfLine &amp;&amp; isTopScope(state.context))</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">var ctx = state.context, firstChar = textAfter &amp;&amp; textAfter.charAt(0);</span><span class="s3">\n      </span><span class="s1">var closing = firstChar == ctx.type;</span><span class="s3">\n      </span><span class="s1">if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) ctx = ctx.prev;</span><span class="s3">\n      </span><span class="s1">if (parserConfig.dontIndentStatements)</span><span class="s3">\n        </span><span class="s1">while (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parserConfig.dontIndentStatements.test(ctx.info))</span><span class="s3">\n          </span><span class="s1">ctx = ctx.prev</span><span class="s3">\n      </span><span class="s1">if (hooks.indent) {</span><span class="s3">\n        </span><span class="s1">var hook = hooks.indent(state, ctx, textAfter, context.unit);</span><span class="s3">\n        </span><span class="s1">if (typeof hook == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) return hook</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var switchBlock = ctx.prev &amp;&amp; ctx.prev.info == </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (parserConfig.allmanIndentation &amp;&amp; /[{(]/.test(firstChar)) {</span><span class="s3">\n        </span><span class="s1">while (ctx.type != </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ctx.type != </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) ctx = ctx.prev</span><span class="s3">\n        </span><span class="s1">return ctx.indented</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return ctx.indented + (firstChar == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">? 0 : statementIndentUnit || context.unit);</span><span class="s3">\n      </span><span class="s1">if (ctx.align &amp;&amp; (!dontAlignCalls || ctx.type != </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">return ctx.column + (closing ? 0 : 1);</span><span class="s3">\n      </span><span class="s1">if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !closing)</span><span class="s3">\n        </span><span class="s1">return ctx.indented + (statementIndentUnit || context.unit);</span><span class="s3">\n\n      </span><span class="s1">return ctx.indented + (closing ? 0 : context.unit) +</span><span class="s3">\n        </span><span class="s1">(!closing &amp;&amp; switchBlock &amp;&amp; !/^(?:case|default)</span><span class="s3">\\</span><span class="s1">b/.test(textAfter) ? context.unit : 0);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">languageData: {</span><span class="s3">\n      </span><span class="s1">indentOnInput: indentSwitch ? /^</span><span class="s3">\\</span><span class="s1">s*(?:case .*?:|default:|</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">}?|</span><span class="s3">\\</span><span class="s1">})$/ : /^</span><span class="s3">\\</span><span class="s1">s*[{}]$/,</span><span class="s3">\n      </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">, block: {open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot;</span><span class="s1">}},</span><span class="s3">\n      </span><span class="s1">autocomplete: Object.keys(keywords).concat(Object.keys(types)).concat(Object.keys(builtin)).concat(Object.keys(atoms)),</span><span class="s3">\n      </span><span class="s1">...parserConfig.languageData</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function words(str) {</span><span class="s3">\n  </span><span class="s1">var obj = {}, words = str.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;</span><span class="s3">\n  </span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function contains(words, word) {</span><span class="s3">\n  </span><span class="s1">if (typeof words === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return words(word);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return words.propertyIsEnumerable(word);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var cKeywords = </span><span class="s3">\&quot;</span><span class="s1">auto if break case register continue return default do sizeof </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">static else struct switch extern typedef union for goto while enum const </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">volatile inline restrict asm fortran</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.</span><span class="s3">\n</span><span class="s1">var cppKeywords = </span><span class="s3">\&quot;</span><span class="s1">alignas alignof and and_eq audit axiom bitand bitor catch </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">class compl concept constexpr const_cast decltype delete dynamic_cast </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">explicit export final friend import module mutable namespace new noexcept </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">not not_eq operator or or_eq override private protected public </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">reinterpret_cast requires static_assert static_cast template this </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">thread_local throw try typeid typename using virtual xor xor_eq</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">var objCKeywords = </span><span class="s3">\&quot;</span><span class="s1">bycopy byref in inout oneway out self super atomic nonatomic retain copy </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">@public @package @private @protected @required @optional @try @catch @finally @import </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">var objCBuiltins = </span><span class="s3">\&quot;</span><span class="s1">FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot; </span><span class="s1">NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT</span><span class="s3">\&quot;\n\n</span><span class="s1">// Do not use this. Use the cTypes function below. This is global just to avoid</span><span class="s3">\n</span><span class="s1">// excessive calls when cTypes is being called multiple times during a parse.</span><span class="s3">\n</span><span class="s1">var basicCTypes = words(</span><span class="s3">\&quot;</span><span class="s1">int long char short double float unsigned signed </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                        \&quot;</span><span class="s1">void bool</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// Do not use this. Use the objCTypes function below. This is global just to avoid</span><span class="s3">\n</span><span class="s1">// excessive calls when objCTypes is being called multiple times during a parse.</span><span class="s3">\n</span><span class="s1">var basicObjCTypes = words(</span><span class="s3">\&quot;</span><span class="s1">SEL instancetype id Class Protocol BOOL</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// Returns true if identifier is a </span><span class="s3">\&quot;</span><span class="s1">C</span><span class="s3">\&quot; </span><span class="s1">type.</span><span class="s3">\n</span><span class="s1">// C type is defined as those that are reserved by the compiler (basicTypes),</span><span class="s3">\n</span><span class="s1">// and those that end in _t (Reserved by POSIX for types)</span><span class="s3">\n</span><span class="s1">// http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html</span><span class="s3">\n</span><span class="s1">function cTypes(identifier) {</span><span class="s3">\n  </span><span class="s1">return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Returns true if identifier is a </span><span class="s3">\&quot;</span><span class="s1">Objective C</span><span class="s3">\&quot; </span><span class="s1">type.</span><span class="s3">\n</span><span class="s1">function objCTypes(identifier) {</span><span class="s3">\n  </span><span class="s1">return cTypes(identifier) || contains(basicObjCTypes, identifier);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var cBlockKeywords = </span><span class="s3">\&quot;</span><span class="s1">case do else for if switch while struct enum union</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var cDefKeywords = </span><span class="s3">\&quot;</span><span class="s1">struct enum union</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function cppHook(stream, state) {</span><span class="s3">\n  </span><span class="s1">if (!state.startOfLine) return false</span><span class="s3">\n  </span><span class="s1">for (var ch, next = null; ch = stream.peek();) {</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;\\\\\&quot; </span><span class="s1">&amp;&amp; stream.match(/^.$/)) {</span><span class="s3">\n      </span><span class="s1">next = cppHook</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^</span><span class="s3">\\</span><span class="s1">/[</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">*]/, false)) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stream.next()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.tokenize = next</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function pointerHook(_stream, state) {</span><span class="s3">\n  </span><span class="s1">if (state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) return </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// For C and C++ (and ObjC): identifiers starting with __</span><span class="s3">\n</span><span class="s1">// or _ followed by a capital letter are reserved for the compiler.</span><span class="s3">\n</span><span class="s1">function cIsReservedIdentifier(token) {</span><span class="s3">\n  </span><span class="s1">if (!token || token.length &lt; 2) return false;</span><span class="s3">\n  </span><span class="s1">if (token[0] != '_') return false;</span><span class="s3">\n  </span><span class="s1">return (token[1] == '_') || (token[1] !== token[1].toLowerCase());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function cpp14Literal(stream) {</span><span class="s3">\n  </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">.']/);</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function cpp11StringHook(stream, state) {</span><span class="s3">\n  </span><span class="s1">stream.backUp(1);</span><span class="s3">\n  </span><span class="s1">// Raw strings.</span><span class="s3">\n  </span><span class="s1">if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {</span><span class="s3">\n    </span><span class="s1">var match = stream.match(/^</span><span class="s3">\&quot;</span><span class="s1">([^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">()]{0,16})</span><span class="s3">\\</span><span class="s1">(/);</span><span class="s3">\n    </span><span class="s1">if (!match) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.cpp11RawStringDelim = match[1];</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenRawString;</span><span class="s3">\n    </span><span class="s1">return tokenRawString(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Unicode strings/chars.</span><span class="s3">\n  </span><span class="s1">if (stream.match(/^(?:u8|u|U|L)/)) {</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^[</span><span class="s3">\&quot;</span><span class="s1">']/, /* eat */ false)) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Ignore this hook.</span><span class="s3">\n  </span><span class="s1">stream.next();</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function cppLooksLikeConstructor(word) {</span><span class="s3">\n  </span><span class="s1">var lastTwo = /(</span><span class="s3">\\</span><span class="s1">w+)::~?(</span><span class="s3">\\</span><span class="s1">w+)$/.exec(word);</span><span class="s3">\n  </span><span class="s1">return lastTwo &amp;&amp; lastTwo[1] == lastTwo[2];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// C#-style strings where </span><span class="s3">\&quot;\&quot; </span><span class="s1">escapes a quote.</span><span class="s3">\n</span><span class="s1">function tokenAtString(stream, state) {</span><span class="s3">\n  </span><span class="s1">var next;</span><span class="s3">\n  </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n    </span><span class="s1">if (next == '</span><span class="s3">\&quot;</span><span class="s1">' &amp;&amp; !stream.eat('</span><span class="s3">\&quot;</span><span class="s1">')) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = null;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// C++11 raw string literal is &lt;prefix&gt;</span><span class="s3">\&quot;</span><span class="s1">&lt;delim&gt;( anything )&lt;delim&gt;</span><span class="s3">\&quot;</span><span class="s1">, where</span><span class="s3">\n</span><span class="s1">// &lt;delim&gt; can be a string up to 16 characters long.</span><span class="s3">\n</span><span class="s1">function tokenRawString(stream, state) {</span><span class="s3">\n  </span><span class="s1">// Escape characters that have special regex meanings.</span><span class="s3">\n  </span><span class="s1">var delim = state.cpp11RawStringDelim.replace(/[^</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">s]/g, '</span><span class="s3">\\\\</span><span class="s1">$&amp;');</span><span class="s3">\n  </span><span class="s1">var match = stream.match(new RegExp(</span><span class="s3">\&quot;</span><span class="s1">.*?</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ delim + '</span><span class="s3">\&quot;</span><span class="s1">'));</span><span class="s3">\n  </span><span class="s1">if (match)</span><span class="s3">\n    </span><span class="s1">state.tokenize = null;</span><span class="s3">\n  </span><span class="s1">else</span><span class="s3">\n    </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const c = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(cKeywords),</span><span class="s3">\n  </span><span class="s1">types: cTypes,</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(cBlockKeywords),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(cDefKeywords),</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">NULL true false</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">isReservedIdentifier: cIsReservedIdentifier,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook,</span><span class="s3">\n    \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">: pointerHook,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const cpp = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">cpp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(cKeywords + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ cppKeywords),</span><span class="s3">\n  </span><span class="s1">types: cTypes,</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(cBlockKeywords + </span><span class="s3">\&quot; </span><span class="s1">class try catch</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(cDefKeywords + </span><span class="s3">\&quot; </span><span class="s1">class namespace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false NULL nullptr</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">dontIndentStatements: /^template$/,</span><span class="s3">\n  </span><span class="s1">isIdentifierChar: /[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_~</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/,</span><span class="s3">\n  </span><span class="s1">isReservedIdentifier: cIsReservedIdentifier,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook,</span><span class="s3">\n    \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">: pointerHook,</span><span class="s3">\n    \&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">U</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">L</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">R</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">1</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">2</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">3</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">4</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">5</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">6</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">7</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">8</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">9</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    </span><span class="s1">token: function(stream, state, style) {</span><span class="s3">\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">(state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| state.prevToken == null ||</span><span class="s3">\n           </span><span class="s1">state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">cppLooksLikeConstructor(stream.current()))</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">namespaceSeparator: </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export const java = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">java</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\&quot;</span><span class="s1">abstract assert break case catch class const continue default </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">do else enum extends final finally for goto if implements import </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">instanceof interface native new package private protected public </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">return static strictfp super switch synchronized this throw throws transient </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">try volatile while @interface</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: words(</span><span class="s3">\&quot;</span><span class="s1">var byte short int long float double boolean char void Boolean Byte Character Double Float </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">Integer Long Number Object Short String StringBuffer StringBuilder Void</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">catch class do else finally for if switch try while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">class interface enum @interface</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">number: /^(?:0x[a-f</span><span class="s3">\\</span><span class="s1">d_]+|0b[01_]+|(?:[</span><span class="s3">\\</span><span class="s1">d_]+</span><span class="s3">\\</span><span class="s1">.?</span><span class="s3">\\</span><span class="s1">d*|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)(?:e[-+]?[</span><span class="s3">\\</span><span class="s1">d_]+)?)(u|ll?|l|f)?/i,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">// Don't match the @interface keyword.</span><span class="s3">\n      </span><span class="s1">if (stream.match('interface', false)) return false;</span><span class="s3">\n\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">': function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (!stream.match(/</span><span class="s3">\&quot;\&quot;</span><span class="s1">$/)) return false;</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenTripleString;</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const csharp = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">csharp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\&quot;</span><span class="s1">abstract as async await base break case catch checked class const continue</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">default delegate do else enum event explicit extern finally fixed for</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">foreach goto if implicit in init interface internal is lock namespace new</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">operator out override params private protected public readonly record ref required return sealed</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">sizeof stackalloc static struct switch this throw try typeof unchecked</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">unsafe using virtual void volatile while add alias ascending descending dynamic from get</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">global group into join let orderby partial remove select set value var yield</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: words(</span><span class="s3">\&quot;</span><span class="s1">Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot; </span><span class="s1">Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot; </span><span class="s1">UInt64 bool byte char decimal double short int long object</span><span class="s3">\&quot;  </span><span class="s1">+</span><span class="s3">\n               \&quot; </span><span class="s1">sbyte float string ushort uint ulong</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">catch class do else finally for foreach if struct switch try while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">class interface namespace record struct var</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (stream.eat('</span><span class="s3">\&quot;</span><span class="s1">')) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenAtString;</span><span class="s3">\n        </span><span class="s1">return tokenAtString(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">function tokenTripleString(stream, state) {</span><span class="s3">\n  </span><span class="s1">var escaped = false;</span><span class="s3">\n  </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n    </span><span class="s1">if (!escaped &amp;&amp; stream.match('</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">')) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = null;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">escaped = stream.next() == </span><span class="s3">\&quot;\\\\\&quot; </span><span class="s1">&amp;&amp; !escaped;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenNestedComment(depth) {</span><span class="s3">\n  </span><span class="s1">return function (stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch</span><span class="s3">\n    </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n      </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (depth == 1) {</span><span class="s3">\n          </span><span class="s1">state.tokenize = null</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">state.tokenize = tokenNestedComment(depth - 1)</span><span class="s3">\n          </span><span class="s1">return state.tokenize(stream, state)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenNestedComment(depth + 1)</span><span class="s3">\n        </span><span class="s1">return state.tokenize(stream, state)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const scala = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">scala</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\n    </span><span class="s1">/* scala */</span><span class="s3">\n    \&quot;</span><span class="s1">abstract case catch class def do else extends final finally for forSome if </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">implicit import lazy match new null object override package private protected return </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">sealed super this throw trait try type val var while with yield _ </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n\n    </span><span class="s1">/* package scala */</span><span class="s3">\n    \&quot;</span><span class="s1">assert assume require print println printf readLine readBoolean readByte readShort </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">readChar readInt readLong readFloat readDouble</span><span class="s3">\&quot;\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: words(</span><span class="s3">\n    \&quot;</span><span class="s1">AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n\n    </span><span class="s1">/* package java.lang */</span><span class="s3">\n    \&quot;</span><span class="s1">Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Compiler Double Exception Float Integer Long Math Number Object Package Pair Process </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Runtime Runnable SecurityManager Short StackTraceElement StrictMath String </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void</span><span class="s3">\&quot;\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">multiLineStrings: true,</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">catch class enum do else finally for forSome if match switch try while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">class enum def object package trait type val var</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">indentStatements: false,</span><span class="s3">\n  </span><span class="s1">indentSwitch: false,</span><span class="s3">\n  </span><span class="s1">isOperatorChar: /[+</span><span class="s3">\\</span><span class="s1">-*&amp;%=&lt;&gt;!?|</span><span class="s3">\\</span><span class="s1">/#:@]/,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">': function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (!stream.match('</span><span class="s3">\&quot;\&quot;</span><span class="s1">')) return false;</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenTripleString;</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^(</span><span class="s3">\\\\</span><span class="s1">[^'</span><span class="s3">\\</span><span class="s1">s]+|[^</span><span class="s3">\\\\</span><span class="s1">'])'/)) return </span><span class="s3">\&quot;</span><span class="s1">character</span><span class="s3">\&quot;\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var cx = state.context</span><span class="s3">\n      </span><span class="s1">if (cx.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; cx.align &amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (!stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) return false</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenNestedComment(1)</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">closeBrackets: {brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">', '</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">']}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">function tokenKotlinString(tripleString){</span><span class="s3">\n  </span><span class="s1">return function (stream, state) {</span><span class="s3">\n    </span><span class="s1">var escaped = false, next, end = false;</span><span class="s3">\n    </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n      </span><span class="s1">if (!tripleString &amp;&amp; !escaped &amp;&amp; stream.match('</span><span class="s3">\&quot;</span><span class="s1">') ) {end = true; break;}</span><span class="s3">\n      </span><span class="s1">if (tripleString &amp;&amp; stream.match('</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">')) {end = true; break;}</span><span class="s3">\n      </span><span class="s1">next = stream.next();</span><span class="s3">\n      </span><span class="s1">if(!escaped &amp;&amp; next == </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match('{'))</span><span class="s3">\n        </span><span class="s1">stream.skipTo(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot; </span><span class="s1">&amp;&amp; !tripleString;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end || !tripleString)</span><span class="s3">\n      </span><span class="s1">state.tokenize = null;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const kotlin = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">kotlin</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\n    </span><span class="s1">/*keywords*/</span><span class="s3">\n    \&quot;</span><span class="s1">package as typealias class interface this super val operator </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">var fun for is in This throw return annotation </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">break continue object if else while do try when !in !is as? </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n\n    </span><span class="s1">/*soft keywords*/</span><span class="s3">\n    \&quot;</span><span class="s1">file import where by get set abstract enum open inner override private public internal </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">protected catch finally out final vararg reified dynamic companion constructor init </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">sealed field property receiver param sparam lateinit data inline noinline tailrec </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">external annotation crossinline const operator infix suspend actual expect setparam</span><span class="s3">\&quot;\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: words(</span><span class="s3">\n    </span><span class="s1">/* package java.lang */</span><span class="s3">\n    \&quot;</span><span class="s1">Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Compiler Double Exception Float Integer Long Math Number Object Package Pair Process </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Runtime Runnable SecurityManager Short StackTraceElement StrictMath String </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">LazyThreadSafetyMode LongArray Nothing ShortArray Unit</span><span class="s3">\&quot;\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">intendSwitch: false,</span><span class="s3">\n  </span><span class="s1">indentStatements: false,</span><span class="s3">\n  </span><span class="s1">multiLineStrings: true,</span><span class="s3">\n  </span><span class="s1">number: /^(?:0x[a-f</span><span class="s3">\\</span><span class="s1">d_]+|0b[01_]+|(?:[</span><span class="s3">\\</span><span class="s1">d_]+(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)(?:e[-+]?[</span><span class="s3">\\</span><span class="s1">d_]+)?)(u|ll?|l|f)?/i,</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">catch class do else finally for if where try while enum</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">class val var object interface fun</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null this</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'*': function(_stream, state) {</span><span class="s3">\n      </span><span class="s1">return state.prevToken == '.' ? 'variable' : 'operator';</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">': function(stream, state) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenKotlinString(stream.match('</span><span class="s3">\&quot;\&quot;</span><span class="s1">'));</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (!stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) return false;</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenNestedComment(1);</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">indent: function(state, ctx, textAfter, indentUnit) {</span><span class="s3">\n      </span><span class="s1">var firstChar = textAfter &amp;&amp; textAfter.charAt(0);</span><span class="s3">\n      </span><span class="s1">if ((state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">|| state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; textAfter == </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return state.indented;</span><span class="s3">\n      </span><span class="s1">if ((state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; textAfter != </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; state.context.type != </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n          </span><span class="s1">state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">(state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">|| state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return indentUnit * 2 + ctx.indented;</span><span class="s3">\n      </span><span class="s1">if (ctx.align &amp;&amp; ctx.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return ctx.indented + (state.context.type == (textAfter || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).charAt(0) ? 0 : indentUnit);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">closeBrackets: {brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">', '</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">']}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export const shader = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">shader</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\&quot;</span><span class="s1">sampler1D sampler2D sampler3D samplerCube </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">sampler1DShadow sampler2DShadow </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">const attribute uniform varying </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">break continue discard return </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">for while do if else struct </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">in out inout</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: words(</span><span class="s3">\&quot;</span><span class="s1">float int bool void </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">mat2 mat3 mat4</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">for while do if else struct</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">builtin: words(</span><span class="s3">\&quot;</span><span class="s1">radians degrees sin cos tan asin acos atan </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">pow exp log exp2 sqrt inversesqrt </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">abs sign floor ceil fract mod min max clamp mix step smoothstep </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">length distance dot cross normalize ftransform faceforward </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">reflect refract matrixCompMult </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">lessThan lessThanEqual greaterThan greaterThanEqual </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">equal notEqual any all not </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">texture1D texture1DProj texture1DLod texture1DProjLod </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">texture2D texture2DProj texture2DLod texture2DProjLod </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">texture3D texture3DProj texture3DLod texture3DProjLod </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">textureCube textureCubeLod </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">shadow1D shadow2D shadow1DProj shadow2DProj </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">dFdx dFdy fwidth </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot;</span><span class="s1">noise1 noise2 noise3 noise4</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FogCoord gl_PointCoord </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_Position gl_PointSize gl_ClipVertex </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_TexCoord gl_FogFragCoord </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FragCoord gl_FrontFacing </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FragData gl_FragDepth </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_ProjectionMatrixInverseTranspose </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_ModelViewProjectionMatrixInverseTranspose </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_TextureMatrixInverseTranspose </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_NormalScale gl_DepthRange gl_ClipPlane </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FrontLightModelProduct gl_BackLightModelProduct </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_FogParameters </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n               \&quot;</span><span class="s1">gl_MaxDrawBuffers</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">indentSwitch: false,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const nesC = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">nesc</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(cKeywords + </span><span class="s3">\&quot; </span><span class="s1">as atomic async call command component components configuration event generic </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">implementation includes interface module new norace nx_struct nx_union post provides </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">signal task uses abstract extends</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: cTypes,</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(cBlockKeywords),</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">null true false</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const objectiveC = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">objectivec</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(cKeywords + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ objCKeywords),</span><span class="s3">\n  </span><span class="s1">types: objCTypes,</span><span class="s3">\n  </span><span class="s1">builtin: words(objCBuiltins),</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(cBlockKeywords + </span><span class="s3">\&quot; </span><span class="s1">@synthesize @try @catch @finally @autoreleasepool @synchronized</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(cDefKeywords + </span><span class="s3">\&quot; </span><span class="s1">@interface @implementation @protocol @class</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">dontIndentStatements: /^@.*$/,</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">YES NO NULL Nil nil true false nullptr</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">isReservedIdentifier: cIsReservedIdentifier,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook,</span><span class="s3">\n    \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">: pointerHook,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const objectiveCpp = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">objectivecpp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(cKeywords + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ objCKeywords + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ cppKeywords),</span><span class="s3">\n  </span><span class="s1">types: objCTypes,</span><span class="s3">\n  </span><span class="s1">builtin: words(objCBuiltins),</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(cBlockKeywords + </span><span class="s3">\&quot; </span><span class="s1">@synthesize @try @catch @finally @autoreleasepool @synchronized class try catch</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(cDefKeywords + </span><span class="s3">\&quot; </span><span class="s1">@interface @implementation @protocol @class class namespace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">dontIndentStatements: /^@.*$|^template$/,</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">YES NO NULL Nil nil true false nullptr</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">isReservedIdentifier: cIsReservedIdentifier,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook,</span><span class="s3">\n    \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">: pointerHook,</span><span class="s3">\n    \&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">U</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">L</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">R</span><span class="s3">\&quot;</span><span class="s1">: cpp11StringHook,</span><span class="s3">\n    \&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">1</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">2</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">3</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">4</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">5</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">6</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">7</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">8</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    \&quot;</span><span class="s1">9</span><span class="s3">\&quot;</span><span class="s1">: cpp14Literal,</span><span class="s3">\n    </span><span class="s1">token: function(stream, state, style) {</span><span class="s3">\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">(state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| state.prevToken == null ||</span><span class="s3">\n           </span><span class="s1">state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">cppLooksLikeConstructor(stream.current()))</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">namespaceSeparator: </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const squirrel = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">squirrel</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\&quot;</span><span class="s1">base break clone continue const default delete enum extends function in class</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">foreach local resume return this throw typeof yield constructor instanceof static</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: cTypes,</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">case catch class else for foreach if switch try while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">function local class</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: cppHook}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">// Ceylon Strings need to deal with interpolation</span><span class="s3">\n</span><span class="s1">var stringTokenizer = null;</span><span class="s3">\n</span><span class="s1">function tokenCeylonString(type) {</span><span class="s3">\n  </span><span class="s1">return function(stream, state) {</span><span class="s3">\n    </span><span class="s1">var escaped = false, next, end = false;</span><span class="s3">\n    </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n      </span><span class="s1">if (!escaped &amp;&amp; stream.match('</span><span class="s3">\&quot;</span><span class="s1">') &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(type == </span><span class="s3">\&quot;</span><span class="s1">single</span><span class="s3">\&quot; </span><span class="s1">|| stream.match('</span><span class="s3">\&quot;\&quot;</span><span class="s1">'))) {</span><span class="s3">\n        </span><span class="s1">end = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!escaped &amp;&amp; stream.match('``')) {</span><span class="s3">\n        </span><span class="s1">stringTokenizer = tokenCeylonString(type);</span><span class="s3">\n        </span><span class="s1">end = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">next = stream.next();</span><span class="s3">\n      </span><span class="s1">escaped = type == </span><span class="s3">\&quot;</span><span class="s1">single</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end)</span><span class="s3">\n      </span><span class="s1">state.tokenize = null;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const ceylon = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">ceylon</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\&quot;</span><span class="s1">abstracts alias assembly assert assign break case catch class continue dynamic else</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">exists extends finally for function given if import in interface is let module new</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">nonempty object of out outer package return satisfies super switch then this throw</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot; </span><span class="s1">try value void while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">types: function(word) {</span><span class="s3">\n    </span><span class="s1">// In Ceylon all identifiers that start with an uppercase are types</span><span class="s3">\n    </span><span class="s1">var first = word.charAt(0);</span><span class="s3">\n    </span><span class="s1">return (first === first.toUpperCase() &amp;&amp; first !== first.toLowerCase());</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">case catch class dynamic else finally for function if interface module new object switch try while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">defKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">class dynamic function interface module object package value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">builtin: words(</span><span class="s3">\&quot;</span><span class="s1">abstract actual aliased annotation by default deprecated doc final formal late license</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                 \&quot; </span><span class="s1">native optional sealed see serializable shared suppressWarnings tagged throws variable</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">isPunctuationChar: /[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{}</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">),;</span><span class="s3">\\</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">.`]/,</span><span class="s3">\n  </span><span class="s1">isOperatorChar: /[+</span><span class="s3">\\</span><span class="s1">-*&amp;%=&lt;&gt;!?|^~:</span><span class="s3">\\</span><span class="s1">/]/,</span><span class="s3">\n  </span><span class="s1">numberStart: /[</span><span class="s3">\\</span><span class="s1">d#$]/,</span><span class="s3">\n  </span><span class="s1">number: /^(?:#[</span><span class="s3">\\</span><span class="s1">da-fA-F_]+|</span><span class="s3">\\</span><span class="s1">$[01_]+|[</span><span class="s3">\\</span><span class="s1">d_]+[kMGTPmunpf]?|[</span><span class="s3">\\</span><span class="s1">d_]+</span><span class="s3">\\</span><span class="s1">.[</span><span class="s3">\\</span><span class="s1">d_]+(?:[eE][-+]?</span><span class="s3">\\</span><span class="s1">d+|[kMGTPmunpf]|)|)/i,</span><span class="s3">\n  </span><span class="s1">multiLineStrings: true,</span><span class="s3">\n  </span><span class="s1">typeFirstDefinitions: true,</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null larger smaller equal empty finished</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">indentSwitch: false,</span><span class="s3">\n  </span><span class="s1">styleDefs: false,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">': function(stream, state) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenCeylonString(stream.match('</span><span class="s3">\&quot;\&quot;</span><span class="s1">') ? </span><span class="s3">\&quot;</span><span class="s1">triple</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">single</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'`': function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (!stringTokenizer || !stream.match('`')) return false;</span><span class="s3">\n      </span><span class="s1">state.tokenize = stringTokenizer;</span><span class="s3">\n      </span><span class="s1">stringTokenizer = null;</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">if (stream.match(/^(</span><span class="s3">\\\\</span><span class="s1">[^'</span><span class="s3">\\</span><span class="s1">s]+|[^</span><span class="s3">\\\\</span><span class="s1">'])'/)) return </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">token: function(_stream, state, style) {</span><span class="s3">\n      </span><span class="s1">if ((style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">state.prevToken == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">closeBrackets: {brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">', '</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">']}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">function pushInterpolationStack(state) {</span><span class="s3">\n  </span><span class="s1">(state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function popInterpolationStack(state) {</span><span class="s3">\n  </span><span class="s1">return (state.interpolationStack || (state.interpolationStack = [])).pop();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sizeInterpolationStack(state) {</span><span class="s3">\n  </span><span class="s1">return state.interpolationStack ? state.interpolationStack.length : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenDartString(quote, stream, state, raw) {</span><span class="s3">\n  </span><span class="s1">var tripleQuoted = false;</span><span class="s3">\n  </span><span class="s1">if (stream.eat(quote)) {</span><span class="s3">\n    </span><span class="s1">if (stream.eat(quote)) tripleQuoted = true;</span><span class="s3">\n    </span><span class="s1">else return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">; //empty string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function tokenStringHelper(stream, state) {</span><span class="s3">\n    </span><span class="s1">var escaped = false;</span><span class="s3">\n    </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n      </span><span class="s1">if (!raw &amp;&amp; !escaped &amp;&amp; stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">pushInterpolationStack(state);</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenInterpolation;</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var next = stream.next();</span><span class="s3">\n      </span><span class="s1">if (next == quote &amp;&amp; !escaped &amp;&amp; (!tripleQuoted || stream.match(quote + quote))) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = null;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">escaped = !raw &amp;&amp; !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.tokenize = tokenStringHelper;</span><span class="s3">\n  </span><span class="s1">return tokenStringHelper(stream, state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenInterpolation(stream, state) {</span><span class="s3">\n  </span><span class="s1">stream.eat(</span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">// let clike handle the content of ${...},</span><span class="s3">\n    </span><span class="s1">// we take over again when </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">appears (see hooks).</span><span class="s3">\n    </span><span class="s1">state.tokenize = null;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenInterpolationIdentifier;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenInterpolationIdentifier(stream, state) {</span><span class="s3">\n  </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w_]/);</span><span class="s3">\n  </span><span class="s1">state.tokenize = popInterpolationStack(state);</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const dart = clike({</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">dart</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">keywords: words(</span><span class="s3">\&quot;</span><span class="s1">this super static final const abstract class extends external factory </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">implements mixin get native set typedef with enum throw rethrow assert break case </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">continue default in return new deferred async await covariant try catch finally </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">do else for if switch while import library export part of show hide is as extension </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                  \&quot;</span><span class="s1">on yield late required sealed base interface when inline</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">blockKeywords: words(</span><span class="s3">\&quot;</span><span class="s1">try catch finally do else for if switch while</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">builtin: words(</span><span class="s3">\&quot;</span><span class="s1">void bool num int double dynamic var String Null Never</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">atoms: words(</span><span class="s3">\&quot;</span><span class="s1">true false null</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">// clike numbers without the suffixes, and with '_' separators.</span><span class="s3">\n  </span><span class="s1">number: /^(?:0x[a-f</span><span class="s3">\\</span><span class="s1">d_]+|(?:[</span><span class="s3">\\</span><span class="s1">d_]+</span><span class="s3">\\</span><span class="s1">.?[</span><span class="s3">\\</span><span class="s1">d_]*|</span><span class="s3">\\</span><span class="s1">.[</span><span class="s3">\\</span><span class="s1">d_]+)(?:e[-+]?[</span><span class="s3">\\</span><span class="s1">d_]+)?)/i,</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: function(stream) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_</span><span class="s3">\\</span><span class="s1">.]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">// custom string handling to deal with triple-quoted strings and string interpolation</span><span class="s3">\n    \&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">return tokenDartString(</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, stream, state, false);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;\\\&quot;\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">return tokenDartString(</span><span class="s3">\&quot;\\\&quot;\&quot;</span><span class="s1">, stream, state, false);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var peek = stream.peek();</span><span class="s3">\n      </span><span class="s1">if (peek == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">|| peek == </span><span class="s3">\&quot;\\\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return tokenDartString(stream.next(), stream, state, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    \&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">: function(_stream, state) {</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">is end of interpolation, if interpolation stack is non-empty</span><span class="s3">\n      </span><span class="s1">if (sizeInterpolationStack(state) &gt; 0) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = popInterpolationStack(state);</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (!stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) return false</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenNestedComment(1)</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">token: function(stream, _, style) {</span><span class="s3">\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// Assume uppercase symbols are classes</span><span class="s3">\n        </span><span class="s1">var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$','g');</span><span class="s3">\n        </span><span class="s1">if (isUpper.test(stream.current())) {</span><span class="s3">\n          </span><span class="s1">return 'type';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>