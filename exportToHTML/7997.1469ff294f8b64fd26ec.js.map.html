<html>
<head>
<title>7997.1469ff294f8b64fd26ec.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7997.1469ff294f8b64fd26ec.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7997.1469ff294f8b64fd26ec.js?v=1469ff294f8b64fd26ec&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,kCAAkC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAkB;AAClB,gBAAgB;AAChB,iBAAiB;AACjB,gBAAgB;AAChB,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,eAAe;AACf;AACA,gCAAgC;AAChC,uBAAuB,sBAAsB,oDAAoD,QAAQ;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8EAA8E,MAAM;AACpF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,eAAe,UAAU,yBAAyB;AAClD;AACA,2FAA2F,QAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO;AAC7E,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,iBAAiB,QAAQ;AAChD,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4GAA4G;AACtH;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,kBAAkB,uBAAuB;AACzC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB,uBAAuB;AACvB,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgK&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/common/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n</span><span class="s1">The default maximum length of a `TreeBuffer` node.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const DefaultBufferLength = 1024;</span><span class="s3">\n</span><span class="s1">let nextPropID = 0;</span><span class="s3">\n</span><span class="s1">class Range {</span><span class="s3">\n    </span><span class="s1">constructor(from, to) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Each [node type](#common.NodeType) or [individual tree](#common.Tree)</span><span class="s3">\n</span><span class="s1">can have metadata associated with it in props. Instances of this</span><span class="s3">\n</span><span class="s1">class represent prop names.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class NodeProp {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a new node prop type.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(config = {}) {</span><span class="s3">\n        </span><span class="s1">this.id = nextPropID++;</span><span class="s3">\n        </span><span class="s1">this.perNode = !!config.perNode;</span><span class="s3">\n        </span><span class="s1">this.deserialize = config.deserialize || (() =&gt; {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">This node type doesn't define a deserialize function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This is meant to be used with</span><span class="s3">\n    </span><span class="s1">[`NodeSet.extend`](#common.NodeSet.extend) or</span><span class="s3">\n    </span><span class="s1">[`LRParser.configure`](#lr.ParserConfig.props) to compute</span><span class="s3">\n    </span><span class="s1">prop values for each node type in the set. Takes a [match</span><span class="s3">\n    </span><span class="s1">object](#common.NodeType^match) or function that returns undefined</span><span class="s3">\n    </span><span class="s1">if the node type doesn't get this prop, and the prop's value if</span><span class="s3">\n    </span><span class="s1">it does.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">add(match) {</span><span class="s3">\n        </span><span class="s1">if (this.perNode)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Can't add per-node props to node types</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (typeof match != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">match = NodeType.match(match);</span><span class="s3">\n        </span><span class="s1">return (type) =&gt; {</span><span class="s3">\n            </span><span class="s1">let result = match(type);</span><span class="s3">\n            </span><span class="s1">return result === undefined ? null : [this, result];</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Prop that is used to describe matching delimiters. For opening</span><span class="s3">\n</span><span class="s1">delimiters, this holds an array of node names (written as a</span><span class="s3">\n</span><span class="s1">space-separated string when declaring this prop in a grammar)</span><span class="s3">\n</span><span class="s1">for the node types of closing delimiters that match it.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.closedBy = new NodeProp({ deserialize: str =&gt; str.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The inverse of [`closedBy`](#common.NodeProp^closedBy). This is</span><span class="s3">\n</span><span class="s1">attached to closing delimiters, holding an array of node names</span><span class="s3">\n</span><span class="s1">of types of matching opening delimiters.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.openedBy = new NodeProp({ deserialize: str =&gt; str.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Used to assign node types to groups (for example, all node</span><span class="s3">\n</span><span class="s1">types that represent an expression could be tagged with an</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">` group).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.group = new NodeProp({ deserialize: str =&gt; str.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Attached to nodes to indicate these should be</span><span class="s3">\n</span><span class="s1">[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)</span><span class="s3">\n</span><span class="s1">in a bidirectional text isolate, so that direction-neutral</span><span class="s3">\n</span><span class="s1">characters on their sides don't incorrectly get associated with</span><span class="s3">\n</span><span class="s1">surrounding text. You'll generally want to set this for nodes</span><span class="s3">\n</span><span class="s1">that contain arbitrary text, like strings and comments, and for</span><span class="s3">\n</span><span class="s1">nodes that appear _inside_ arbitrary text, like HTML tags. When</span><span class="s3">\n</span><span class="s1">not given a value, in a grammar declaration, defaults to</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">`.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.isolate = new NodeProp({ deserialize: value =&gt; {</span><span class="s3">\n        </span><span class="s1">if (value &amp;&amp; value != </span><span class="s3">\&quot;</span><span class="s1">rtl</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; value != </span><span class="s3">\&quot;</span><span class="s1">ltr</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; value != </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid value for isolate: </span><span class="s3">\&quot; </span><span class="s1">+ value);</span><span class="s3">\n        </span><span class="s1">return value || </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The hash of the [context](#lr.ContextTracker.constructor)</span><span class="s3">\n</span><span class="s1">that the node was parsed in, if any. Used to limit reuse of</span><span class="s3">\n</span><span class="s1">contextual nodes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.contextHash = new NodeProp({ perNode: true });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The distance beyond the end of the node that the tokenizer</span><span class="s3">\n</span><span class="s1">looked ahead for any of the tokens inside the node. (The LR</span><span class="s3">\n</span><span class="s1">parser only stores this when it is larger than 25, for</span><span class="s3">\n</span><span class="s1">efficiency reasons.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.lookAhead = new NodeProp({ perNode: true });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This per-node prop is used to replace a given node, or part of a</span><span class="s3">\n</span><span class="s1">node, with another tree. This is useful to include trees from</span><span class="s3">\n</span><span class="s1">different languages in mixed-language parsers.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeProp.mounted = new NodeProp({ perNode: true });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A mounted tree, which can be [stored](#common.NodeProp^mounted) on</span><span class="s3">\n</span><span class="s1">a tree node to indicate that parts of its content are</span><span class="s3">\n</span><span class="s1">represented by another tree.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class MountedTree {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The inner tree.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">tree, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">If this is null, this tree replaces the entire node (it will</span><span class="s3">\n    </span><span class="s1">be included in the regular iteration instead of its host</span><span class="s3">\n    </span><span class="s1">node). If not, only the given ranges are considered to be</span><span class="s3">\n    </span><span class="s1">covered by this tree. This is used for trees that are mixed in</span><span class="s3">\n    </span><span class="s1">a way that isn't strictly hierarchical. Such mounted trees are</span><span class="s3">\n    </span><span class="s1">only entered by [`resolveInner`](#common.Tree.resolveInner)</span><span class="s3">\n    </span><span class="s1">and [`enter`](#common.SyntaxNode.enter).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlay, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The parser used to create this subtree.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parser) {</span><span class="s3">\n        </span><span class="s1">this.tree = tree;</span><span class="s3">\n        </span><span class="s1">this.overlay = overlay;</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static get(tree) {</span><span class="s3">\n        </span><span class="s1">return tree &amp;&amp; tree.props &amp;&amp; tree.props[NodeProp.mounted.id];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const noProps = Object.create(null);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Each node in a syntax tree has a node type associated with it.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class NodeType {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The name of the node type. Not necessarily unique, but if the</span><span class="s3">\n    </span><span class="s1">grammar was written properly, different node types with the</span><span class="s3">\n    </span><span class="s1">same name within a node set should play the same semantic</span><span class="s3">\n    </span><span class="s1">role.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">name, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">props, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The id of this node in its set. Corresponds to the term ids</span><span class="s3">\n    </span><span class="s1">used in the parser.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">id, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">flags = 0) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.flags = flags;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a node type.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(spec) {</span><span class="s3">\n        </span><span class="s1">let props = spec.props &amp;&amp; spec.props.length ? Object.create(null) : noProps;</span><span class="s3">\n        </span><span class="s1">let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |</span><span class="s3">\n            </span><span class="s1">(spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);</span><span class="s3">\n        </span><span class="s1">let type = new NodeType(spec.name || </span><span class="s3">\&quot;\&quot;</span><span class="s1">, props, spec.id, flags);</span><span class="s3">\n        </span><span class="s1">if (spec.props)</span><span class="s3">\n            </span><span class="s1">for (let src of spec.props) {</span><span class="s3">\n                </span><span class="s1">if (!Array.isArray(src))</span><span class="s3">\n                    </span><span class="s1">src = src(type);</span><span class="s3">\n                </span><span class="s1">if (src) {</span><span class="s3">\n                    </span><span class="s1">if (src[0].perNode)</span><span class="s3">\n                        </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Can't store a per-node prop on a node type</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">props[src[0].id] = src[1];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return type;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Retrieves a node prop for this type. Will return `undefined` if</span><span class="s3">\n    </span><span class="s1">the prop isn't present on this node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">prop(prop) { return this.props[prop.id]; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">True when this is the top node of a grammar.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isTop() { return (this.flags &amp; 1 /* NodeFlag.Top */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">True when this node is produced by a skip rule.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isSkipped() { return (this.flags &amp; 2 /* NodeFlag.Skipped */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether this is an error node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isError() { return (this.flags &amp; 4 /* NodeFlag.Error */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">When true, this node type doesn't correspond to a user-declared</span><span class="s3">\n    </span><span class="s1">named node, for example because it is used to cache repetition.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isAnonymous() { return (this.flags &amp; 8 /* NodeFlag.Anonymous */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns true when this node's name or one of its</span><span class="s3">\n    </span><span class="s1">[groups](#common.NodeProp^group) matches the given string.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">is(name) {</span><span class="s3">\n        </span><span class="s1">if (typeof name == 'string') {</span><span class="s3">\n            </span><span class="s1">if (this.name == name)</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">let group = this.prop(NodeProp.group);</span><span class="s3">\n            </span><span class="s1">return group ? group.indexOf(name) &gt; -1 : false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.id == name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a function from node types to arbitrary values by</span><span class="s3">\n    </span><span class="s1">specifying an object whose property names are node or</span><span class="s3">\n    </span><span class="s1">[group](#common.NodeProp^group) names. Often useful with</span><span class="s3">\n    </span><span class="s1">[`NodeProp.add`](#common.NodeProp.add). You can put multiple</span><span class="s3">\n    </span><span class="s1">names, separated by spaces, in a single property name to map</span><span class="s3">\n    </span><span class="s1">multiple node names to a single value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static match(map) {</span><span class="s3">\n        </span><span class="s1">let direct = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let prop in map)</span><span class="s3">\n            </span><span class="s1">for (let name of prop.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">direct[name] = map[prop];</span><span class="s3">\n        </span><span class="s1">return (node) =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let groups = node.prop(NodeProp.group), i = -1; i &lt; (groups ? groups.length : 0); i++) {</span><span class="s3">\n                </span><span class="s1">let found = direct[i &lt; 0 ? node.name : groups[i]];</span><span class="s3">\n                </span><span class="s1">if (found)</span><span class="s3">\n                    </span><span class="s1">return found;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An empty dummy node type to use when no actual type is available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">NodeType.none = new NodeType(</span><span class="s3">\&quot;\&quot;</span><span class="s1">, Object.create(null), 0, 8 /* NodeFlag.Anonymous */);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A node set holds a collection of node types. It is used to</span><span class="s3">\n</span><span class="s1">compactly represent trees by storing their type ids, rather than a</span><span class="s3">\n</span><span class="s1">full pointer to the type object, in a numeric array. Each parser</span><span class="s3">\n</span><span class="s1">[has](#lr.LRParser.nodeSet) a node set, and [tree</span><span class="s3">\n</span><span class="s1">buffers](#common.TreeBuffer) can only store collections of nodes</span><span class="s3">\n</span><span class="s1">from the same set. A set can have a maximum of 2**16 (65536) node</span><span class="s3">\n</span><span class="s1">types in it, so that the ids fit into 16-bit typed array slots.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class NodeSet {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a set with the given types. The `id` property of each</span><span class="s3">\n    </span><span class="s1">type should correspond to its position within the array.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The node types in this set, by id.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">types) {</span><span class="s3">\n        </span><span class="s1">this.types = types;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; types.length; i++)</span><span class="s3">\n            </span><span class="s1">if (types[i].id != i)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Node type ids should correspond to array positions when creating a node set</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a copy of this set with some node properties added. The</span><span class="s3">\n    </span><span class="s1">arguments to this method can be created with</span><span class="s3">\n    </span><span class="s1">[`NodeProp.add`](#common.NodeProp.add).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">extend(...props) {</span><span class="s3">\n        </span><span class="s1">let newTypes = [];</span><span class="s3">\n        </span><span class="s1">for (let type of this.types) {</span><span class="s3">\n            </span><span class="s1">let newProps = null;</span><span class="s3">\n            </span><span class="s1">for (let source of props) {</span><span class="s3">\n                </span><span class="s1">let add = source(type);</span><span class="s3">\n                </span><span class="s1">if (add) {</span><span class="s3">\n                    </span><span class="s1">if (!newProps)</span><span class="s3">\n                        </span><span class="s1">newProps = Object.assign({}, type.props);</span><span class="s3">\n                    </span><span class="s1">newProps[add[0].id] = add[1];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new NodeSet(newTypes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Options that control iteration. Can be combined with the `|`</span><span class="s3">\n</span><span class="s1">operator to enable multiple ones.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var IterMode;</span><span class="s3">\n</span><span class="s1">(function (IterMode) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">When enabled, iteration will only visit [`Tree`](#common.Tree)</span><span class="s3">\n    </span><span class="s1">objects, not nodes packed into</span><span class="s3">\n    </span><span class="s1">[`TreeBuffer`](#common.TreeBuffer)s.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">IterMode[IterMode[</span><span class="s3">\&quot;</span><span class="s1">ExcludeBuffers</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">ExcludeBuffers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Enable this to make iteration include anonymous nodes (such as</span><span class="s3">\n    </span><span class="s1">the nodes that wrap repeated grammar constructs into a balanced</span><span class="s3">\n    </span><span class="s1">tree).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">IterMode[IterMode[</span><span class="s3">\&quot;</span><span class="s1">IncludeAnonymous</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">IncludeAnonymous</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">By default, regular [mounted](#common.NodeProp^mounted) nodes</span><span class="s3">\n    </span><span class="s1">replace their base node in iteration. Enable this to ignore them</span><span class="s3">\n    </span><span class="s1">instead.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">IterMode[IterMode[</span><span class="s3">\&quot;</span><span class="s1">IgnoreMounts</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">IgnoreMounts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This option only applies in</span><span class="s3">\n    </span><span class="s1">[`enter`](#common.SyntaxNode.enter)-style methods. It tells the</span><span class="s3">\n    </span><span class="s1">library to not enter mounted overlays if one covers the given</span><span class="s3">\n    </span><span class="s1">position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">IterMode[IterMode[</span><span class="s3">\&quot;</span><span class="s1">IgnoreOverlays</span><span class="s3">\&quot;</span><span class="s1">] = 8] = </span><span class="s3">\&quot;</span><span class="s1">IgnoreOverlays</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(IterMode || (IterMode = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A piece of syntax tree. There are two ways to approach these</span><span class="s3">\n</span><span class="s1">trees: the way they are actually stored in memory, and the</span><span class="s3">\n</span><span class="s1">convenient way.</span><span class="s3">\n\n</span><span class="s1">Syntax trees are stored as a tree of `Tree` and `TreeBuffer`</span><span class="s3">\n</span><span class="s1">objects. By packing detail information into `TreeBuffer` leaf</span><span class="s3">\n</span><span class="s1">nodes, the representation is made a lot more memory-efficient.</span><span class="s3">\n\n</span><span class="s1">However, when you want to actually work with tree nodes, this</span><span class="s3">\n</span><span class="s1">representation is very awkward, so most client code will want to</span><span class="s3">\n</span><span class="s1">use the [`TreeCursor`](#common.TreeCursor) or</span><span class="s3">\n</span><span class="s1">[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides</span><span class="s3">\n</span><span class="s1">a view on some part of this data structure, and can be used to</span><span class="s3">\n</span><span class="s1">move around to adjacent nodes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Tree {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Construct a new tree. See also [`Tree.build`](#common.Tree^build).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The type of the top node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">type, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This node's child nodes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">children, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The positions (offsets relative to the start of this tree) of</span><span class="s3">\n    </span><span class="s1">the children.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">positions, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The total length of this tree</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">length, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Per-node [node props](#common.NodeProp) to associate with this node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">props) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.children = children;</span><span class="s3">\n        </span><span class="s1">this.positions = positions;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.props = null;</span><span class="s3">\n        </span><span class="s1">if (props &amp;&amp; props.length) {</span><span class="s3">\n            </span><span class="s1">this.props = Object.create(null);</span><span class="s3">\n            </span><span class="s1">for (let [prop, value] of props)</span><span class="s3">\n                </span><span class="s1">this.props[typeof prop == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? prop : prop.id] = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let mounted = MountedTree.get(this);</span><span class="s3">\n        </span><span class="s1">if (mounted &amp;&amp; !mounted.overlay)</span><span class="s3">\n            </span><span class="s1">return mounted.tree.toString();</span><span class="s3">\n        </span><span class="s1">let children = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let ch of this.children) {</span><span class="s3">\n            </span><span class="s1">let str = ch.toString();</span><span class="s3">\n            </span><span class="s1">if (str) {</span><span class="s3">\n                </span><span class="s1">if (children)</span><span class="s3">\n                    </span><span class="s1">children += </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">children += str;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return !this.type.name ? children :</span><span class="s3">\n            </span><span class="s1">(/</span><span class="s3">\\</span><span class="s1">W/.test(this.type.name) &amp;&amp; !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +</span><span class="s3">\n                </span><span class="s1">(children.length ? </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ children + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a [tree cursor](#common.TreeCursor) positioned at the top of</span><span class="s3">\n    </span><span class="s1">the tree. Mode can be used to [control](#common.IterMode) which</span><span class="s3">\n    </span><span class="s1">nodes the cursor visits.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cursor(mode = 0) {</span><span class="s3">\n        </span><span class="s1">return new TreeCursor(this.topNode, mode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a [tree cursor](#common.TreeCursor) pointing into this tree</span><span class="s3">\n    </span><span class="s1">at the given position and side (see</span><span class="s3">\n    </span><span class="s1">[`moveTo`](#common.TreeCursor.moveTo).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cursorAt(pos, side = 0, mode = 0) {</span><span class="s3">\n        </span><span class="s1">let scope = CachedNode.get(this) || this.topNode;</span><span class="s3">\n        </span><span class="s1">let cursor = new TreeCursor(scope);</span><span class="s3">\n        </span><span class="s1">cursor.moveTo(pos, side);</span><span class="s3">\n        </span><span class="s1">CachedNode.set(this, cursor._tree);</span><span class="s3">\n        </span><span class="s1">return cursor;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a [syntax node](#common.SyntaxNode) object for the top of the</span><span class="s3">\n    </span><span class="s1">tree.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get topNode() {</span><span class="s3">\n        </span><span class="s1">return new TreeNode(this, 0, 0, null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the [syntax node](#common.SyntaxNode) at the given position.</span><span class="s3">\n    </span><span class="s1">If `side` is -1, this will move into nodes that end at the</span><span class="s3">\n    </span><span class="s1">position. If 1, it'll move into nodes that start at the</span><span class="s3">\n    </span><span class="s1">position. With 0, it'll only enter nodes that cover the position</span><span class="s3">\n    </span><span class="s1">from both sides.</span><span class="s3">\n    \n    </span><span class="s1">Note that this will not enter</span><span class="s3">\n    </span><span class="s1">[overlays](#common.MountedTree.overlay), and you often want</span><span class="s3">\n    </span><span class="s1">[`resolveInner`](#common.Tree.resolveInner) instead.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resolve(pos, side = 0) {</span><span class="s3">\n        </span><span class="s1">let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);</span><span class="s3">\n        </span><span class="s1">CachedNode.set(this, node);</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Like [`resolve`](#common.Tree.resolve), but will enter</span><span class="s3">\n    </span><span class="s1">[overlaid](#common.MountedTree.overlay) nodes, producing a syntax node</span><span class="s3">\n    </span><span class="s1">pointing into the innermost overlaid tree at the given position</span><span class="s3">\n    </span><span class="s1">(with parent links going through all parent structure, including</span><span class="s3">\n    </span><span class="s1">the host trees).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resolveInner(pos, side = 0) {</span><span class="s3">\n        </span><span class="s1">let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);</span><span class="s3">\n        </span><span class="s1">CachedInnerNode.set(this, node);</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">In some situations, it can be useful to iterate through all</span><span class="s3">\n    </span><span class="s1">nodes around a position, including those in overlays that don't</span><span class="s3">\n    </span><span class="s1">directly cover the position. This method gives you an iterator</span><span class="s3">\n    </span><span class="s1">that will produce all nodes, from small to big, around the given</span><span class="s3">\n    </span><span class="s1">position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resolveStack(pos, side = 0) {</span><span class="s3">\n        </span><span class="s1">return stackIterator(this, pos, side);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the tree and its children, calling `enter` for any</span><span class="s3">\n    </span><span class="s1">node that touches the `from`/`to` region (if given) before</span><span class="s3">\n    </span><span class="s1">running over such a node's children, and `leave` (if given) when</span><span class="s3">\n    </span><span class="s1">leaving the node. When `enter` returns `false`, that node will</span><span class="s3">\n    </span><span class="s1">not have its children iterated over (or `leave` called).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterate(spec) {</span><span class="s3">\n        </span><span class="s1">let { enter, leave, from = 0, to = this.length } = spec;</span><span class="s3">\n        </span><span class="s1">let mode = spec.mode || 0, anon = (mode &amp; IterMode.IncludeAnonymous) &gt; 0;</span><span class="s3">\n        </span><span class="s1">for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {</span><span class="s3">\n            </span><span class="s1">let entered = false;</span><span class="s3">\n            </span><span class="s1">if (c.from &lt;= to &amp;&amp; c.to &gt;= from &amp;&amp; (!anon &amp;&amp; c.type.isAnonymous || enter(c) !== false)) {</span><span class="s3">\n                </span><span class="s1">if (c.firstChild())</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">entered = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">if (entered &amp;&amp; leave &amp;&amp; (anon || !c.type.isAnonymous))</span><span class="s3">\n                    </span><span class="s1">leave(c);</span><span class="s3">\n                </span><span class="s1">if (c.nextSibling())</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (!c.parent())</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">entered = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the value of the given [node prop](#common.NodeProp) for this</span><span class="s3">\n    </span><span class="s1">node. Works with both per-node and per-type props.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">prop(prop) {</span><span class="s3">\n        </span><span class="s1">return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns the node's [per-node props](#common.NodeProp.perNode) in a</span><span class="s3">\n    </span><span class="s1">format that can be passed to the [`Tree`](#common.Tree)</span><span class="s3">\n    </span><span class="s1">constructor.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get propValues() {</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">if (this.props)</span><span class="s3">\n            </span><span class="s1">for (let id in this.props)</span><span class="s3">\n                </span><span class="s1">result.push([+id, this.props[id]]);</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Balance the direct children of this tree, producing a copy of</span><span class="s3">\n    </span><span class="s1">which may have children grouped into subtrees with type</span><span class="s3">\n    </span><span class="s1">[`NodeType.none`](#common.NodeType^none).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">balance(config = {}) {</span><span class="s3">\n        </span><span class="s1">return this.children.length &lt;= 8 /* Balance.BranchFactor */ ? this :</span><span class="s3">\n            </span><span class="s1">balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) =&gt; new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) =&gt; new Tree(NodeType.none, children, positions, length)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Build a tree from a postfix-ordered buffer of node information,</span><span class="s3">\n    </span><span class="s1">or a cursor over such a buffer.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static build(data) { return buildTree(data); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The empty tree</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Tree.empty = new Tree(NodeType.none, [], [], 0);</span><span class="s3">\n</span><span class="s1">class FlatBufferCursor {</span><span class="s3">\n    </span><span class="s1">constructor(buffer, index) {</span><span class="s3">\n        </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get id() { return this.buffer[this.index - 4]; }</span><span class="s3">\n    </span><span class="s1">get start() { return this.buffer[this.index - 3]; }</span><span class="s3">\n    </span><span class="s1">get end() { return this.buffer[this.index - 2]; }</span><span class="s3">\n    </span><span class="s1">get size() { return this.buffer[this.index - 1]; }</span><span class="s3">\n    </span><span class="s1">get pos() { return this.index; }</span><span class="s3">\n    </span><span class="s1">next() { this.index -= 4; }</span><span class="s3">\n    </span><span class="s1">fork() { return new FlatBufferCursor(this.buffer, this.index); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Tree buffers contain (type, start, end, endIndex) quads for each</span><span class="s3">\n</span><span class="s1">node. In such a buffer, nodes are stored in prefix order (parents</span><span class="s3">\n</span><span class="s1">before children, with the endIndex of the parent indicating which</span><span class="s3">\n</span><span class="s1">children belong to it).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TreeBuffer {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a tree buffer.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The buffer's content.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">buffer, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The total length of the group of nodes in the buffer.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">length, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The node set used in this buffer.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set) {</span><span class="s3">\n        </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">this.set = set;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get type() { return NodeType.none; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let index = 0; index &lt; this.buffer.length;) {</span><span class="s3">\n            </span><span class="s1">result.push(this.childString(index));</span><span class="s3">\n            </span><span class="s1">index = this.buffer[index + 3];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">childString(index) {</span><span class="s3">\n        </span><span class="s1">let id = this.buffer[index], endIndex = this.buffer[index + 3];</span><span class="s3">\n        </span><span class="s1">let type = this.set.types[id], result = type.name;</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">W/.test(result) &amp;&amp; !type.isError)</span><span class="s3">\n            </span><span class="s1">result = JSON.stringify(result);</span><span class="s3">\n        </span><span class="s1">index += 4;</span><span class="s3">\n        </span><span class="s1">if (endIndex == index)</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">let children = [];</span><span class="s3">\n        </span><span class="s1">while (index &lt; endIndex) {</span><span class="s3">\n            </span><span class="s1">children.push(this.childString(index));</span><span class="s3">\n            </span><span class="s1">index = this.buffer[index + 3];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result + </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ children.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">findChild(startIndex, endIndex, dir, pos, side) {</span><span class="s3">\n        </span><span class="s1">let { buffer } = this, pick = -1;</span><span class="s3">\n        </span><span class="s1">for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {</span><span class="s3">\n            </span><span class="s1">if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {</span><span class="s3">\n                </span><span class="s1">pick = i;</span><span class="s3">\n                </span><span class="s1">if (dir &gt; 0)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return pick;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">slice(startI, endI, from) {</span><span class="s3">\n        </span><span class="s1">let b = this.buffer;</span><span class="s3">\n        </span><span class="s1">let copy = new Uint16Array(endI - startI), len = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = startI, j = 0; i &lt; endI;) {</span><span class="s3">\n            </span><span class="s1">copy[j++] = b[i++];</span><span class="s3">\n            </span><span class="s1">copy[j++] = b[i++] - from;</span><span class="s3">\n            </span><span class="s1">let to = copy[j++] = b[i++] - from;</span><span class="s3">\n            </span><span class="s1">copy[j++] = b[i++] - startI;</span><span class="s3">\n            </span><span class="s1">len = Math.max(len, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new TreeBuffer(copy, len, this.set);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkSide(side, pos, from, to) {</span><span class="s3">\n    </span><span class="s1">switch (side) {</span><span class="s3">\n        </span><span class="s1">case -2 /* Side.Before */: return from &lt; pos;</span><span class="s3">\n        </span><span class="s1">case -1 /* Side.AtOrBefore */: return to &gt;= pos &amp;&amp; from &lt; pos;</span><span class="s3">\n        </span><span class="s1">case 0 /* Side.Around */: return from &lt; pos &amp;&amp; to &gt; pos;</span><span class="s3">\n        </span><span class="s1">case 1 /* Side.AtOrAfter */: return from &lt;= pos &amp;&amp; to &gt; pos;</span><span class="s3">\n        </span><span class="s1">case 2 /* Side.After */: return to &gt; pos;</span><span class="s3">\n        </span><span class="s1">case 4 /* Side.DontCare */: return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveNode(node, pos, side, overlays) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">// Move up to a node that actually holds the position, if possible</span><span class="s3">\n    </span><span class="s1">while (node.from == node.to ||</span><span class="s3">\n        </span><span class="s1">(side &lt; 1 ? node.from &gt;= pos : node.from &gt; pos) ||</span><span class="s3">\n        </span><span class="s1">(side &gt; -1 ? node.to &lt;= pos : node.to &lt; pos)) {</span><span class="s3">\n        </span><span class="s1">let parent = !overlays &amp;&amp; node instanceof TreeNode &amp;&amp; node.index &lt; 0 ? null : node.parent;</span><span class="s3">\n        </span><span class="s1">if (!parent)</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">node = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let mode = overlays ? 0 : IterMode.IgnoreOverlays;</span><span class="s3">\n    </span><span class="s1">// Must go up out of overlays when those do not overlap with pos</span><span class="s3">\n    </span><span class="s1">if (overlays)</span><span class="s3">\n        </span><span class="s1">for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {</span><span class="s3">\n            </span><span class="s1">if (scan instanceof TreeNode &amp;&amp; scan.index &lt; 0 &amp;&amp; ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)</span><span class="s3">\n                </span><span class="s1">node = parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let inner = node.enter(pos, side, mode);</span><span class="s3">\n        </span><span class="s1">if (!inner)</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">node = inner;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BaseNode {</span><span class="s3">\n    </span><span class="s1">cursor(mode = 0) { return new TreeCursor(this, mode); }</span><span class="s3">\n    </span><span class="s1">getChild(type, before = null, after = null) {</span><span class="s3">\n        </span><span class="s1">let r = getChildren(this, type, before, after);</span><span class="s3">\n        </span><span class="s1">return r.length ? r[0] : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getChildren(type, before = null, after = null) {</span><span class="s3">\n        </span><span class="s1">return getChildren(this, type, before, after);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolve(pos, side = 0) {</span><span class="s3">\n        </span><span class="s1">return resolveNode(this, pos, side, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolveInner(pos, side = 0) {</span><span class="s3">\n        </span><span class="s1">return resolveNode(this, pos, side, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matchContext(context) {</span><span class="s3">\n        </span><span class="s1">return matchNodeContext(this, context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">enterUnfinishedNodesBefore(pos) {</span><span class="s3">\n        </span><span class="s1">let scan = this.childBefore(pos), node = this;</span><span class="s3">\n        </span><span class="s1">while (scan) {</span><span class="s3">\n            </span><span class="s1">let last = scan.lastChild;</span><span class="s3">\n            </span><span class="s1">if (!last || last.to != scan.to)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (last.type.isError &amp;&amp; last.from == last.to) {</span><span class="s3">\n                </span><span class="s1">node = scan;</span><span class="s3">\n                </span><span class="s1">scan = last.prevSibling;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">scan = last;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get node() { return this; }</span><span class="s3">\n    </span><span class="s1">get next() { return this.parent; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TreeNode extends BaseNode {</span><span class="s3">\n    </span><span class="s1">constructor(_tree, from, </span><span class="s3">\n    </span><span class="s1">// Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)</span><span class="s3">\n    </span><span class="s1">index, _parent) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._tree = _tree;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n        </span><span class="s1">this._parent = _parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get type() { return this._tree.type; }</span><span class="s3">\n    </span><span class="s1">get name() { return this._tree.type.name; }</span><span class="s3">\n    </span><span class="s1">get to() { return this.from + this._tree.length; }</span><span class="s3">\n    </span><span class="s1">nextChild(i, dir, pos, side, mode = 0) {</span><span class="s3">\n        </span><span class="s1">for (let parent = this;;) {</span><span class="s3">\n            </span><span class="s1">for (let { children, positions } = parent._tree, e = dir &gt; 0 ? children.length : -1; i != e; i += dir) {</span><span class="s3">\n                </span><span class="s1">let next = children[i], start = positions[i] + parent.from;</span><span class="s3">\n                </span><span class="s1">if (!checkSide(side, pos, start, start + next.length))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">if (next instanceof TreeBuffer) {</span><span class="s3">\n                    </span><span class="s1">if (mode &amp; IterMode.ExcludeBuffers)</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                    </span><span class="s1">let index = next.findChild(0, next.buffer.length, dir, pos - start, side);</span><span class="s3">\n                    </span><span class="s1">if (index &gt; -1)</span><span class="s3">\n                        </span><span class="s1">return new BufferNode(new BufferContext(parent, next, i, start), null, index);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if ((mode &amp; IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {</span><span class="s3">\n                    </span><span class="s1">let mounted;</span><span class="s3">\n                    </span><span class="s1">if (!(mode &amp; IterMode.IgnoreMounts) &amp;&amp; (mounted = MountedTree.get(next)) &amp;&amp; !mounted.overlay)</span><span class="s3">\n                        </span><span class="s1">return new TreeNode(mounted.tree, start, i, parent);</span><span class="s3">\n                    </span><span class="s1">let inner = new TreeNode(next, start, i, parent);</span><span class="s3">\n                    </span><span class="s1">return (mode &amp; IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner</span><span class="s3">\n                        </span><span class="s1">: inner.nextChild(dir &lt; 0 ? next.children.length - 1 : 0, dir, pos, side);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if ((mode &amp; IterMode.IncludeAnonymous) || !parent.type.isAnonymous)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">if (parent.index &gt;= 0)</span><span class="s3">\n                </span><span class="s1">i = parent.index + dir;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">i = dir &lt; 0 ? -1 : parent._parent._tree.children.length;</span><span class="s3">\n            </span><span class="s1">parent = parent._parent;</span><span class="s3">\n            </span><span class="s1">if (!parent)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }</span><span class="s3">\n    </span><span class="s1">get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }</span><span class="s3">\n    </span><span class="s1">childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }</span><span class="s3">\n    </span><span class="s1">childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }</span><span class="s3">\n    </span><span class="s1">enter(pos, side, mode = 0) {</span><span class="s3">\n        </span><span class="s1">let mounted;</span><span class="s3">\n        </span><span class="s1">if (!(mode &amp; IterMode.IgnoreOverlays) &amp;&amp; (mounted = MountedTree.get(this._tree)) &amp;&amp; mounted.overlay) {</span><span class="s3">\n            </span><span class="s1">let rPos = pos - this.from;</span><span class="s3">\n            </span><span class="s1">for (let { from, to } of mounted.overlay) {</span><span class="s3">\n                </span><span class="s1">if ((side &gt; 0 ? from &lt;= rPos : from &lt; rPos) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(side &lt; 0 ? to &gt;= rPos : to &gt; rPos))</span><span class="s3">\n                    </span><span class="s1">return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.nextChild(0, 1, pos, side, mode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextSignificantParent() {</span><span class="s3">\n        </span><span class="s1">let val = this;</span><span class="s3">\n        </span><span class="s1">while (val.type.isAnonymous &amp;&amp; val._parent)</span><span class="s3">\n            </span><span class="s1">val = val._parent;</span><span class="s3">\n        </span><span class="s1">return val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parent() {</span><span class="s3">\n        </span><span class="s1">return this._parent ? this._parent.nextSignificantParent() : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get nextSibling() {</span><span class="s3">\n        </span><span class="s1">return this._parent &amp;&amp; this.index &gt;= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get prevSibling() {</span><span class="s3">\n        </span><span class="s1">return this._parent &amp;&amp; this.index &gt;= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get tree() { return this._tree; }</span><span class="s3">\n    </span><span class="s1">toTree() { return this._tree; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() { return this._tree.toString(); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getChildren(node, type, before, after) {</span><span class="s3">\n    </span><span class="s1">let cur = node.cursor(), result = [];</span><span class="s3">\n    </span><span class="s1">if (!cur.firstChild())</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">if (before != null)</span><span class="s3">\n        </span><span class="s1">for (let found = false; !found;) {</span><span class="s3">\n            </span><span class="s1">found = cur.type.is(before);</span><span class="s3">\n            </span><span class="s1">if (!cur.nextSibling())</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (after != null &amp;&amp; cur.type.is(after))</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">if (cur.type.is(type))</span><span class="s3">\n            </span><span class="s1">result.push(cur.node);</span><span class="s3">\n        </span><span class="s1">if (!cur.nextSibling())</span><span class="s3">\n            </span><span class="s1">return after == null ? result : [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function matchNodeContext(node, context, i = context.length - 1) {</span><span class="s3">\n    </span><span class="s1">for (let p = node.parent; i &gt;= 0; p = p.parent) {</span><span class="s3">\n        </span><span class="s1">if (!p)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (!p.type.isAnonymous) {</span><span class="s3">\n            </span><span class="s1">if (context[i] &amp;&amp; context[i] != p.name)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">i--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BufferContext {</span><span class="s3">\n    </span><span class="s1">constructor(parent, buffer, index, start) {</span><span class="s3">\n        </span><span class="s1">this.parent = parent;</span><span class="s3">\n        </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BufferNode extends BaseNode {</span><span class="s3">\n    </span><span class="s1">get name() { return this.type.name; }</span><span class="s3">\n    </span><span class="s1">get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }</span><span class="s3">\n    </span><span class="s1">get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }</span><span class="s3">\n    </span><span class="s1">constructor(context, _parent, index) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n        </span><span class="s1">this._parent = _parent;</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n        </span><span class="s1">this.type = context.buffer.set.types[context.buffer.buffer[index]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">child(dir, pos, side) {</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.context;</span><span class="s3">\n        </span><span class="s1">let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);</span><span class="s3">\n        </span><span class="s1">return index &lt; 0 ? null : new BufferNode(this.context, this, index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }</span><span class="s3">\n    </span><span class="s1">get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }</span><span class="s3">\n    </span><span class="s1">childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }</span><span class="s3">\n    </span><span class="s1">childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }</span><span class="s3">\n    </span><span class="s1">enter(pos, side, mode = 0) {</span><span class="s3">\n        </span><span class="s1">if (mode &amp; IterMode.ExcludeBuffers)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.context;</span><span class="s3">\n        </span><span class="s1">let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side &gt; 0 ? 1 : -1, pos - this.context.start, side);</span><span class="s3">\n        </span><span class="s1">return index &lt; 0 ? null : new BufferNode(this.context, this, index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parent() {</span><span class="s3">\n        </span><span class="s1">return this._parent || this.context.parent.nextSignificantParent();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">externalSibling(dir) {</span><span class="s3">\n        </span><span class="s1">return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get nextSibling() {</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.context;</span><span class="s3">\n        </span><span class="s1">let after = buffer.buffer[this.index + 3];</span><span class="s3">\n        </span><span class="s1">if (after &lt; (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))</span><span class="s3">\n            </span><span class="s1">return new BufferNode(this.context, this._parent, after);</span><span class="s3">\n        </span><span class="s1">return this.externalSibling(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get prevSibling() {</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.context;</span><span class="s3">\n        </span><span class="s1">let parentStart = this._parent ? this._parent.index + 4 : 0;</span><span class="s3">\n        </span><span class="s1">if (this.index == parentStart)</span><span class="s3">\n            </span><span class="s1">return this.externalSibling(-1);</span><span class="s3">\n        </span><span class="s1">return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get tree() { return null; }</span><span class="s3">\n    </span><span class="s1">toTree() {</span><span class="s3">\n        </span><span class="s1">let children = [], positions = [];</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.context;</span><span class="s3">\n        </span><span class="s1">let startI = this.index + 4, endI = buffer.buffer[this.index + 3];</span><span class="s3">\n        </span><span class="s1">if (endI &gt; startI) {</span><span class="s3">\n            </span><span class="s1">let from = buffer.buffer[this.index + 1];</span><span class="s3">\n            </span><span class="s1">children.push(buffer.slice(startI, endI, from));</span><span class="s3">\n            </span><span class="s1">positions.push(0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new Tree(this.type, children, positions, this.to - this.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() { return this.context.buffer.childString(this.index); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function iterStack(heads) {</span><span class="s3">\n    </span><span class="s1">if (!heads.length)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let pick = 0, picked = heads[0];</span><span class="s3">\n    </span><span class="s1">for (let i = 1; i &lt; heads.length; i++) {</span><span class="s3">\n        </span><span class="s1">let node = heads[i];</span><span class="s3">\n        </span><span class="s1">if (node.from &gt; picked.from || node.to &lt; picked.to) {</span><span class="s3">\n            </span><span class="s1">picked = node;</span><span class="s3">\n            </span><span class="s1">pick = i;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let next = picked instanceof TreeNode &amp;&amp; picked.index &lt; 0 ? null : picked.parent;</span><span class="s3">\n    </span><span class="s1">let newHeads = heads.slice();</span><span class="s3">\n    </span><span class="s1">if (next)</span><span class="s3">\n        </span><span class="s1">newHeads[pick] = next;</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">newHeads.splice(pick, 1);</span><span class="s3">\n    </span><span class="s1">return new StackIterator(newHeads, picked);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class StackIterator {</span><span class="s3">\n    </span><span class="s1">constructor(heads, node) {</span><span class="s3">\n        </span><span class="s1">this.heads = heads;</span><span class="s3">\n        </span><span class="s1">this.node = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get next() { return iterStack(this.heads); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function stackIterator(tree, pos, side) {</span><span class="s3">\n    </span><span class="s1">let inner = tree.resolveInner(pos, side), layers = null;</span><span class="s3">\n    </span><span class="s1">for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {</span><span class="s3">\n        </span><span class="s1">if (scan.index &lt; 0) { // This is an overlay root</span><span class="s3">\n            </span><span class="s1">let parent = scan.parent;</span><span class="s3">\n            </span><span class="s1">(layers || (layers = [inner])).push(parent.resolve(pos, side));</span><span class="s3">\n            </span><span class="s1">scan = parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let mount = MountedTree.get(scan.tree);</span><span class="s3">\n            </span><span class="s1">// Relevant overlay branching off</span><span class="s3">\n            </span><span class="s1">if (mount &amp;&amp; mount.overlay &amp;&amp; mount.overlay[0].from &lt;= pos &amp;&amp; mount.overlay[mount.overlay.length - 1].to &gt;= pos) {</span><span class="s3">\n                </span><span class="s1">let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);</span><span class="s3">\n                </span><span class="s1">(layers || (layers = [inner])).push(resolveNode(root, pos, side, false));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return layers ? iterStack(layers) : inner;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A tree cursor object focuses on a given node in a syntax tree, and</span><span class="s3">\n</span><span class="s1">allows you to move to adjacent nodes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TreeCursor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Shorthand for `.type.name`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get name() { return this.type.name; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(node, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mode = 0) {</span><span class="s3">\n        </span><span class="s1">this.mode = mode;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.buffer = null;</span><span class="s3">\n        </span><span class="s1">this.stack = [];</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.index = 0;</span><span class="s3">\n        </span><span class="s1">this.bufferNode = null;</span><span class="s3">\n        </span><span class="s1">if (node instanceof TreeNode) {</span><span class="s3">\n            </span><span class="s1">this.yieldNode(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._tree = node.context.parent;</span><span class="s3">\n            </span><span class="s1">this.buffer = node.context;</span><span class="s3">\n            </span><span class="s1">for (let n = node._parent; n; n = n._parent)</span><span class="s3">\n                </span><span class="s1">this.stack.unshift(n.index);</span><span class="s3">\n            </span><span class="s1">this.bufferNode = node;</span><span class="s3">\n            </span><span class="s1">this.yieldBuf(node.index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">yieldNode(node) {</span><span class="s3">\n        </span><span class="s1">if (!node)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this._tree = node;</span><span class="s3">\n        </span><span class="s1">this.type = node.type;</span><span class="s3">\n        </span><span class="s1">this.from = node.from;</span><span class="s3">\n        </span><span class="s1">this.to = node.to;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">yieldBuf(index, type) {</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n        </span><span class="s1">let { start, buffer } = this.buffer;</span><span class="s3">\n        </span><span class="s1">this.type = type || buffer.set.types[buffer.buffer[index]];</span><span class="s3">\n        </span><span class="s1">this.from = start + buffer.buffer[index + 1];</span><span class="s3">\n        </span><span class="s1">this.to = start + buffer.buffer[index + 2];</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">yield(node) {</span><span class="s3">\n        </span><span class="s1">if (!node)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (node instanceof TreeNode) {</span><span class="s3">\n            </span><span class="s1">this.buffer = null;</span><span class="s3">\n            </span><span class="s1">return this.yieldNode(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.buffer = node.context;</span><span class="s3">\n        </span><span class="s1">return this.yieldBuf(node.index, node.type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">enterChild(dir, pos, side) {</span><span class="s3">\n        </span><span class="s1">if (!this.buffer)</span><span class="s3">\n            </span><span class="s1">return this.yield(this._tree.nextChild(dir &lt; 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.buffer;</span><span class="s3">\n        </span><span class="s1">let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.stack.push(this.index);</span><span class="s3">\n        </span><span class="s1">return this.yieldBuf(index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move the cursor to this node's first child. When this returns</span><span class="s3">\n    </span><span class="s1">false, the node has no child, and the cursor has not been moved.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move the cursor to this node's last child.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move the cursor to the first child that ends after `pos`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the last child that starts before `pos`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move the cursor to the child around `pos`. If side is -1 the</span><span class="s3">\n    </span><span class="s1">child may end at that position, when 1 it may start there. This</span><span class="s3">\n    </span><span class="s1">will also enter [overlaid](#common.MountedTree.overlay)</span><span class="s3">\n    </span><span class="s1">[mounted](#common.NodeProp^mounted) trees unless `overlays` is</span><span class="s3">\n    </span><span class="s1">set to false.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">enter(pos, side, mode = this.mode) {</span><span class="s3">\n        </span><span class="s1">if (!this.buffer)</span><span class="s3">\n            </span><span class="s1">return this.yield(this._tree.enter(pos, side, mode));</span><span class="s3">\n        </span><span class="s1">return mode &amp; IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the node's parent node, if this isn't the top node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parent() {</span><span class="s3">\n        </span><span class="s1">if (!this.buffer)</span><span class="s3">\n            </span><span class="s1">return this.yieldNode((this.mode &amp; IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);</span><span class="s3">\n        </span><span class="s1">if (this.stack.length)</span><span class="s3">\n            </span><span class="s1">return this.yieldBuf(this.stack.pop());</span><span class="s3">\n        </span><span class="s1">let parent = (this.mode &amp; IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();</span><span class="s3">\n        </span><span class="s1">this.buffer = null;</span><span class="s3">\n        </span><span class="s1">return this.yieldNode(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sibling(dir) {</span><span class="s3">\n        </span><span class="s1">if (!this.buffer)</span><span class="s3">\n            </span><span class="s1">return !this._tree._parent ? false</span><span class="s3">\n                </span><span class="s1">: this.yield(this._tree.index &lt; 0 ? null</span><span class="s3">\n                    </span><span class="s1">: this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.buffer, d = this.stack.length - 1;</span><span class="s3">\n        </span><span class="s1">if (dir &lt; 0) {</span><span class="s3">\n            </span><span class="s1">let parentStart = d &lt; 0 ? 0 : this.stack[d] + 4;</span><span class="s3">\n            </span><span class="s1">if (this.index != parentStart)</span><span class="s3">\n                </span><span class="s1">return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let after = buffer.buffer[this.index + 3];</span><span class="s3">\n            </span><span class="s1">if (after &lt; (d &lt; 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))</span><span class="s3">\n                </span><span class="s1">return this.yieldBuf(after);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return d &lt; 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to this node's next sibling, if any.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">nextSibling() { return this.sibling(1); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to this node's previous sibling, if any.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">prevSibling() { return this.sibling(-1); }</span><span class="s3">\n    </span><span class="s1">atLastNode(dir) {</span><span class="s3">\n        </span><span class="s1">let index, parent, { buffer } = this;</span><span class="s3">\n        </span><span class="s1">if (buffer) {</span><span class="s3">\n            </span><span class="s1">if (dir &gt; 0) {</span><span class="s3">\n                </span><span class="s1">if (this.index &lt; buffer.buffer.buffer.length)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; this.index; i++)</span><span class="s3">\n                    </span><span class="s1">if (buffer.buffer.buffer[i + 3] &lt; this.index)</span><span class="s3">\n                        </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">({ index, parent } = buffer);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">({ index, _parent: parent } = this._tree);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (; parent; { index, _parent: parent } = parent) {</span><span class="s3">\n            </span><span class="s1">if (index &gt; -1)</span><span class="s3">\n                </span><span class="s1">for (let i = index + dir, e = dir &lt; 0 ? -1 : parent._tree.children.length; i != e; i += dir) {</span><span class="s3">\n                    </span><span class="s1">let child = parent._tree.children[i];</span><span class="s3">\n                    </span><span class="s1">if ((this.mode &amp; IterMode.IncludeAnonymous) ||</span><span class="s3">\n                        </span><span class="s1">child instanceof TreeBuffer ||</span><span class="s3">\n                        </span><span class="s1">!child.type.isAnonymous ||</span><span class="s3">\n                        </span><span class="s1">hasChild(child))</span><span class="s3">\n                        </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">move(dir, enter) {</span><span class="s3">\n        </span><span class="s1">if (enter &amp;&amp; this.enterChild(dir, 0, 4 /* Side.DontCare */))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (this.sibling(dir))</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">if (this.atLastNode(dir) || !this.parent())</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the next node in a</span><span class="s3">\n    </span><span class="s1">[pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)</span><span class="s3">\n    </span><span class="s1">traversal, going from a node to its first child or, if the</span><span class="s3">\n    </span><span class="s1">current node is empty or `enter` is false, its next sibling or</span><span class="s3">\n    </span><span class="s1">the next sibling of the first parent node that has one.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">next(enter = true) { return this.move(1, enter); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the next node in a last-to-first pre-order traveral. A</span><span class="s3">\n    </span><span class="s1">node is followed by its last child or, if it has none, its</span><span class="s3">\n    </span><span class="s1">previous sibling or the previous sibling of the first parent</span><span class="s3">\n    </span><span class="s1">node that has one.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">prev(enter = true) { return this.move(-1, enter); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move the cursor to the innermost node that covers `pos`. If</span><span class="s3">\n    </span><span class="s1">`side` is -1, it will enter nodes that end at `pos`. If it is 1,</span><span class="s3">\n    </span><span class="s1">it will enter nodes that start at `pos`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveTo(pos, side = 0) {</span><span class="s3">\n        </span><span class="s1">// Move up to a node that actually holds the position, if possible</span><span class="s3">\n        </span><span class="s1">while (this.from == this.to ||</span><span class="s3">\n            </span><span class="s1">(side &lt; 1 ? this.from &gt;= pos : this.from &gt; pos) ||</span><span class="s3">\n            </span><span class="s1">(side &gt; -1 ? this.to &lt;= pos : this.to &lt; pos))</span><span class="s3">\n            </span><span class="s1">if (!this.parent())</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">// Then scan down into child nodes as far as possible</span><span class="s3">\n        </span><span class="s1">while (this.enterChild(1, pos, side)) { }</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a [syntax node](#common.SyntaxNode) at the cursor's current</span><span class="s3">\n    </span><span class="s1">position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get node() {</span><span class="s3">\n        </span><span class="s1">if (!this.buffer)</span><span class="s3">\n            </span><span class="s1">return this._tree;</span><span class="s3">\n        </span><span class="s1">let cache = this.bufferNode, result = null, depth = 0;</span><span class="s3">\n        </span><span class="s1">if (cache &amp;&amp; cache.context == this.buffer) {</span><span class="s3">\n            </span><span class="s1">scan: for (let index = this.index, d = this.stack.length; d &gt;= 0;) {</span><span class="s3">\n                </span><span class="s1">for (let c = cache; c; c = c._parent)</span><span class="s3">\n                    </span><span class="s1">if (c.index == index) {</span><span class="s3">\n                        </span><span class="s1">if (index == this.index)</span><span class="s3">\n                            </span><span class="s1">return c;</span><span class="s3">\n                        </span><span class="s1">result = c;</span><span class="s3">\n                        </span><span class="s1">depth = d + 1;</span><span class="s3">\n                        </span><span class="s1">break scan;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">index = this.stack[--d];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = depth; i &lt; this.stack.length; i++)</span><span class="s3">\n            </span><span class="s1">result = new BufferNode(this.buffer, result, this.stack[i]);</span><span class="s3">\n        </span><span class="s1">return this.bufferNode = new BufferNode(this.buffer, result, this.index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the [tree](#common.Tree) that represents the current node, if</span><span class="s3">\n    </span><span class="s1">any. Will return null when the node is in a [tree</span><span class="s3">\n    </span><span class="s1">buffer](#common.TreeBuffer).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get tree() {</span><span class="s3">\n        </span><span class="s1">return this.buffer ? null : this._tree._tree;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the current node and all its descendants, calling</span><span class="s3">\n    </span><span class="s1">`enter` when entering a node and `leave`, if given, when leaving</span><span class="s3">\n    </span><span class="s1">one. When `enter` returns `false`, any children of that node are</span><span class="s3">\n    </span><span class="s1">skipped, and `leave` isn't called for it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterate(enter, leave) {</span><span class="s3">\n        </span><span class="s1">for (let depth = 0;;) {</span><span class="s3">\n            </span><span class="s1">let mustLeave = false;</span><span class="s3">\n            </span><span class="s1">if (this.type.isAnonymous || enter(this) !== false) {</span><span class="s3">\n                </span><span class="s1">if (this.firstChild()) {</span><span class="s3">\n                    </span><span class="s1">depth++;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!this.type.isAnonymous)</span><span class="s3">\n                    </span><span class="s1">mustLeave = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">if (mustLeave &amp;&amp; leave)</span><span class="s3">\n                    </span><span class="s1">leave(this);</span><span class="s3">\n                </span><span class="s1">mustLeave = this.type.isAnonymous;</span><span class="s3">\n                </span><span class="s1">if (this.nextSibling())</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (!depth)</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">this.parent();</span><span class="s3">\n                </span><span class="s1">depth--;</span><span class="s3">\n                </span><span class="s1">mustLeave = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Test whether the current node matches a given contexta sequence</span><span class="s3">\n    </span><span class="s1">of direct parent node names. Empty strings in the context array</span><span class="s3">\n    </span><span class="s1">are treated as wildcards.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">matchContext(context) {</span><span class="s3">\n        </span><span class="s1">if (!this.buffer)</span><span class="s3">\n            </span><span class="s1">return matchNodeContext(this.node, context);</span><span class="s3">\n        </span><span class="s1">let { buffer } = this.buffer, { types } = buffer.set;</span><span class="s3">\n        </span><span class="s1">for (let i = context.length - 1, d = this.stack.length - 1; i &gt;= 0; d--) {</span><span class="s3">\n            </span><span class="s1">if (d &lt; 0)</span><span class="s3">\n                </span><span class="s1">return matchNodeContext(this.node, context, i);</span><span class="s3">\n            </span><span class="s1">let type = types[buffer.buffer[this.stack[d]]];</span><span class="s3">\n            </span><span class="s1">if (!type.isAnonymous) {</span><span class="s3">\n                </span><span class="s1">if (context[i] &amp;&amp; context[i] != type.name)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">i--;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasChild(tree) {</span><span class="s3">\n    </span><span class="s1">return tree.children.some(ch =&gt; ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildTree(data) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;</span><span class="s3">\n    </span><span class="s1">let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;</span><span class="s3">\n    </span><span class="s1">let types = nodeSet.types;</span><span class="s3">\n    </span><span class="s1">let contextHash = 0, lookAhead = 0;</span><span class="s3">\n    </span><span class="s1">function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {</span><span class="s3">\n        </span><span class="s1">let { id, start, end, size } = cursor;</span><span class="s3">\n        </span><span class="s1">let lookAheadAtStart = lookAhead;</span><span class="s3">\n        </span><span class="s1">while (size &lt; 0) {</span><span class="s3">\n            </span><span class="s1">cursor.next();</span><span class="s3">\n            </span><span class="s1">if (size == -1 /* SpecialRecord.Reuse */) {</span><span class="s3">\n                </span><span class="s1">let node = reused[id];</span><span class="s3">\n                </span><span class="s1">children.push(node);</span><span class="s3">\n                </span><span class="s1">positions.push(start - parentStart);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change</span><span class="s3">\n                </span><span class="s1">contextHash = id;</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (size == -4 /* SpecialRecord.LookAhead */) {</span><span class="s3">\n                </span><span class="s1">lookAhead = id;</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw new RangeError(`Unrecognized record size: ${size}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let type = types[id], node, buffer;</span><span class="s3">\n        </span><span class="s1">let startPos = start - parentStart;</span><span class="s3">\n        </span><span class="s1">if (end - start &lt;= maxBufferLength &amp;&amp; (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {</span><span class="s3">\n            </span><span class="s1">// Small enough for a buffer, and no reused nodes inside</span><span class="s3">\n            </span><span class="s1">let data = new Uint16Array(buffer.size - buffer.skip);</span><span class="s3">\n            </span><span class="s1">let endPos = cursor.pos - buffer.size, index = data.length;</span><span class="s3">\n            </span><span class="s1">while (cursor.pos &gt; endPos)</span><span class="s3">\n                </span><span class="s1">index = copyToBuffer(buffer.start, data, index);</span><span class="s3">\n            </span><span class="s1">node = new TreeBuffer(data, end - buffer.start, nodeSet);</span><span class="s3">\n            </span><span class="s1">startPos = buffer.start - parentStart;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else { // Make it a node</span><span class="s3">\n            </span><span class="s1">let endPos = cursor.pos - size;</span><span class="s3">\n            </span><span class="s1">cursor.next();</span><span class="s3">\n            </span><span class="s1">let localChildren = [], localPositions = [];</span><span class="s3">\n            </span><span class="s1">let localInRepeat = id &gt;= minRepeatType ? id : -1;</span><span class="s3">\n            </span><span class="s1">let lastGroup = 0, lastEnd = end;</span><span class="s3">\n            </span><span class="s1">while (cursor.pos &gt; endPos) {</span><span class="s3">\n                </span><span class="s1">if (localInRepeat &gt;= 0 &amp;&amp; cursor.id == localInRepeat &amp;&amp; cursor.size &gt;= 0) {</span><span class="s3">\n                    </span><span class="s1">if (cursor.end &lt;= lastEnd - maxBufferLength) {</span><span class="s3">\n                        </span><span class="s1">makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);</span><span class="s3">\n                        </span><span class="s1">lastGroup = localChildren.length;</span><span class="s3">\n                        </span><span class="s1">lastEnd = cursor.end;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">cursor.next();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (depth &gt; 2500 /* CutOff.Depth */) {</span><span class="s3">\n                    </span><span class="s1">takeFlatNode(start, endPos, localChildren, localPositions);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (localInRepeat &gt;= 0 &amp;&amp; lastGroup &gt; 0 &amp;&amp; lastGroup &lt; localChildren.length)</span><span class="s3">\n                </span><span class="s1">makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);</span><span class="s3">\n            </span><span class="s1">localChildren.reverse();</span><span class="s3">\n            </span><span class="s1">localPositions.reverse();</span><span class="s3">\n            </span><span class="s1">if (localInRepeat &gt; -1 &amp;&amp; lastGroup &gt; 0) {</span><span class="s3">\n                </span><span class="s1">let make = makeBalanced(type);</span><span class="s3">\n                </span><span class="s1">node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">children.push(node);</span><span class="s3">\n        </span><span class="s1">positions.push(startPos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function takeFlatNode(parentStart, minPos, children, positions) {</span><span class="s3">\n        </span><span class="s1">let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions</span><span class="s3">\n        </span><span class="s1">let nodeCount = 0, stopAt = -1;</span><span class="s3">\n        </span><span class="s1">while (cursor.pos &gt; minPos) {</span><span class="s3">\n            </span><span class="s1">let { id, start, end, size } = cursor;</span><span class="s3">\n            </span><span class="s1">if (size &gt; 4) { // Not a leaf</span><span class="s3">\n                </span><span class="s1">cursor.next();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (stopAt &gt; -1 &amp;&amp; start &lt; stopAt) {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (stopAt &lt; 0)</span><span class="s3">\n                    </span><span class="s1">stopAt = end - maxBufferLength;</span><span class="s3">\n                </span><span class="s1">nodes.push(id, start, end);</span><span class="s3">\n                </span><span class="s1">nodeCount++;</span><span class="s3">\n                </span><span class="s1">cursor.next();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (nodeCount) {</span><span class="s3">\n            </span><span class="s1">let buffer = new Uint16Array(nodeCount * 4);</span><span class="s3">\n            </span><span class="s1">let start = nodes[nodes.length - 2];</span><span class="s3">\n            </span><span class="s1">for (let i = nodes.length - 3, j = 0; i &gt;= 0; i -= 3) {</span><span class="s3">\n                </span><span class="s1">buffer[j++] = nodes[i];</span><span class="s3">\n                </span><span class="s1">buffer[j++] = nodes[i + 1] - start;</span><span class="s3">\n                </span><span class="s1">buffer[j++] = nodes[i + 2] - start;</span><span class="s3">\n                </span><span class="s1">buffer[j++] = j;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));</span><span class="s3">\n            </span><span class="s1">positions.push(start - parentStart);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function makeBalanced(type) {</span><span class="s3">\n        </span><span class="s1">return (children, positions, length) =&gt; {</span><span class="s3">\n            </span><span class="s1">let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;</span><span class="s3">\n            </span><span class="s1">if (lastI &gt;= 0 &amp;&amp; (last = children[lastI]) instanceof Tree) {</span><span class="s3">\n                </span><span class="s1">if (!lastI &amp;&amp; last.type == type &amp;&amp; last.length == length)</span><span class="s3">\n                    </span><span class="s1">return last;</span><span class="s3">\n                </span><span class="s1">if (lookAheadProp = last.prop(NodeProp.lookAhead))</span><span class="s3">\n                    </span><span class="s1">lookAhead = positions[lastI] + last.length + lookAheadProp;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return makeTree(type, children, positions, length, lookAhead);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {</span><span class="s3">\n        </span><span class="s1">let localChildren = [], localPositions = [];</span><span class="s3">\n        </span><span class="s1">while (children.length &gt; i) {</span><span class="s3">\n            </span><span class="s1">localChildren.push(children.pop());</span><span class="s3">\n            </span><span class="s1">localPositions.push(positions.pop() + base - from);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));</span><span class="s3">\n        </span><span class="s1">positions.push(from - base);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function makeTree(type, children, positions, length, lookAhead = 0, props) {</span><span class="s3">\n        </span><span class="s1">if (contextHash) {</span><span class="s3">\n            </span><span class="s1">let pair = [NodeProp.contextHash, contextHash];</span><span class="s3">\n            </span><span class="s1">props = props ? [pair].concat(props) : [pair];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (lookAhead &gt; 25) {</span><span class="s3">\n            </span><span class="s1">let pair = [NodeProp.lookAhead, lookAhead];</span><span class="s3">\n            </span><span class="s1">props = props ? [pair].concat(props) : [pair];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new Tree(type, children, positions, length, props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function findBufferSize(maxSize, inRepeat) {</span><span class="s3">\n        </span><span class="s1">// Scan through the buffer to find previous siblings that fit</span><span class="s3">\n        </span><span class="s1">// together in a TreeBuffer, and don't contain any reused nodes</span><span class="s3">\n        </span><span class="s1">// (which can't be stored in a buffer).</span><span class="s3">\n        </span><span class="s1">// If `inRepeat` is &gt; -1, ignore node boundaries of that type for</span><span class="s3">\n        </span><span class="s1">// nesting, but make sure the end falls either at the start</span><span class="s3">\n        </span><span class="s1">// (`maxSize`) or before such a node.</span><span class="s3">\n        </span><span class="s1">let fork = cursor.fork();</span><span class="s3">\n        </span><span class="s1">let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;</span><span class="s3">\n        </span><span class="s1">let result = { size: 0, start: 0, skip: 0 };</span><span class="s3">\n        </span><span class="s1">scan: for (let minPos = fork.pos - maxSize; fork.pos &gt; minPos;) {</span><span class="s3">\n            </span><span class="s1">let nodeSize = fork.size;</span><span class="s3">\n            </span><span class="s1">// Pretend nested repeat nodes of the same type don't exist</span><span class="s3">\n            </span><span class="s1">if (fork.id == inRepeat &amp;&amp; nodeSize &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">// Except that we store the current state as a valid return</span><span class="s3">\n                </span><span class="s1">// value.</span><span class="s3">\n                </span><span class="s1">result.size = size;</span><span class="s3">\n                </span><span class="s1">result.start = start;</span><span class="s3">\n                </span><span class="s1">result.skip = skip;</span><span class="s3">\n                </span><span class="s1">skip += 4;</span><span class="s3">\n                </span><span class="s1">size += 4;</span><span class="s3">\n                </span><span class="s1">fork.next();</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let startPos = fork.pos - nodeSize;</span><span class="s3">\n            </span><span class="s1">if (nodeSize &lt; 0 || startPos &lt; minPos || fork.start &lt; minStart)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">let localSkipped = fork.id &gt;= minRepeatType ? 4 : 0;</span><span class="s3">\n            </span><span class="s1">let nodeStart = fork.start;</span><span class="s3">\n            </span><span class="s1">fork.next();</span><span class="s3">\n            </span><span class="s1">while (fork.pos &gt; startPos) {</span><span class="s3">\n                </span><span class="s1">if (fork.size &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">if (fork.size == -3 /* SpecialRecord.ContextChange */)</span><span class="s3">\n                        </span><span class="s1">localSkipped += 4;</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">break scan;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (fork.id &gt;= minRepeatType) {</span><span class="s3">\n                    </span><span class="s1">localSkipped += 4;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">fork.next();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">start = nodeStart;</span><span class="s3">\n            </span><span class="s1">size += nodeSize;</span><span class="s3">\n            </span><span class="s1">skip += localSkipped;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (inRepeat &lt; 0 || size == maxSize) {</span><span class="s3">\n            </span><span class="s1">result.size = size;</span><span class="s3">\n            </span><span class="s1">result.start = start;</span><span class="s3">\n            </span><span class="s1">result.skip = skip;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result.size &gt; 4 ? result : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function copyToBuffer(bufferStart, buffer, index) {</span><span class="s3">\n        </span><span class="s1">let { id, start, end, size } = cursor;</span><span class="s3">\n        </span><span class="s1">cursor.next();</span><span class="s3">\n        </span><span class="s1">if (size &gt;= 0 &amp;&amp; id &lt; minRepeatType) {</span><span class="s3">\n            </span><span class="s1">let startIndex = index;</span><span class="s3">\n            </span><span class="s1">if (size &gt; 4) {</span><span class="s3">\n                </span><span class="s1">let endPos = cursor.pos - (size - 4);</span><span class="s3">\n                </span><span class="s1">while (cursor.pos &gt; endPos)</span><span class="s3">\n                    </span><span class="s1">index = copyToBuffer(bufferStart, buffer, index);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">buffer[--index] = startIndex;</span><span class="s3">\n            </span><span class="s1">buffer[--index] = end - bufferStart;</span><span class="s3">\n            </span><span class="s1">buffer[--index] = start - bufferStart;</span><span class="s3">\n            </span><span class="s1">buffer[--index] = id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (size == -3 /* SpecialRecord.ContextChange */) {</span><span class="s3">\n            </span><span class="s1">contextHash = id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (size == -4 /* SpecialRecord.LookAhead */) {</span><span class="s3">\n            </span><span class="s1">lookAhead = id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let children = [], positions = [];</span><span class="s3">\n    </span><span class="s1">while (cursor.pos &gt; 0)</span><span class="s3">\n        </span><span class="s1">takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);</span><span class="s3">\n    </span><span class="s1">let length = (_a = data.length) !== null &amp;&amp; _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);</span><span class="s3">\n    </span><span class="s1">return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const nodeSizeCache = new WeakMap;</span><span class="s3">\n</span><span class="s1">function nodeSize(balanceType, node) {</span><span class="s3">\n    </span><span class="s1">if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">let size = nodeSizeCache.get(node);</span><span class="s3">\n    </span><span class="s1">if (size == null) {</span><span class="s3">\n        </span><span class="s1">size = 1;</span><span class="s3">\n        </span><span class="s1">for (let child of node.children) {</span><span class="s3">\n            </span><span class="s1">if (child.type != balanceType || !(child instanceof Tree)) {</span><span class="s3">\n                </span><span class="s1">size = 1;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">size += nodeSize(balanceType, child);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">nodeSizeCache.set(node, size);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return size;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function balanceRange(</span><span class="s3">\n</span><span class="s1">// The type the balanced tree's inner nodes.</span><span class="s3">\n</span><span class="s1">balanceType, </span><span class="s3">\n</span><span class="s1">// The direct children and their positions</span><span class="s3">\n</span><span class="s1">children, positions, </span><span class="s3">\n</span><span class="s1">// The index range in children/positions to use</span><span class="s3">\n</span><span class="s1">from, to, </span><span class="s3">\n</span><span class="s1">// The start position of the nodes, relative to their parent.</span><span class="s3">\n</span><span class="s1">start, </span><span class="s3">\n</span><span class="s1">// Length of the outer node</span><span class="s3">\n</span><span class="s1">length, </span><span class="s3">\n</span><span class="s1">// Function to build the top node of the balanced tree</span><span class="s3">\n</span><span class="s1">mkTop, </span><span class="s3">\n</span><span class="s1">// Function to build internal nodes for the balanced tree</span><span class="s3">\n</span><span class="s1">mkTree) {</span><span class="s3">\n    </span><span class="s1">let total = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = from; i &lt; to; i++)</span><span class="s3">\n        </span><span class="s1">total += nodeSize(balanceType, children[i]);</span><span class="s3">\n    </span><span class="s1">let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);</span><span class="s3">\n    </span><span class="s1">let localChildren = [], localPositions = [];</span><span class="s3">\n    </span><span class="s1">function divide(children, positions, from, to, offset) {</span><span class="s3">\n        </span><span class="s1">for (let i = from; i &lt; to;) {</span><span class="s3">\n            </span><span class="s1">let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n            </span><span class="s1">for (; i &lt; to; i++) {</span><span class="s3">\n                </span><span class="s1">let nextSize = nodeSize(balanceType, children[i]);</span><span class="s3">\n                </span><span class="s1">if (groupSize + nextSize &gt;= maxChild)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">groupSize += nextSize;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (i == groupFrom + 1) {</span><span class="s3">\n                </span><span class="s1">if (groupSize &gt; maxChild) {</span><span class="s3">\n                    </span><span class="s1">let only = children[groupFrom]; // Only trees can have a size &gt; 1</span><span class="s3">\n                    </span><span class="s1">divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">localChildren.push(children[groupFrom]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let length = positions[i - 1] + children[i - 1].length - groupStart;</span><span class="s3">\n                </span><span class="s1">localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">localPositions.push(groupStart + offset - start);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">divide(children, positions, from, to, 0);</span><span class="s3">\n    </span><span class="s1">return (mkTop || mkTree)(localChildren, localPositions, length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Provides a way to associate values with pieces of trees. As long</span><span class="s3">\n</span><span class="s1">as that part of the tree is reused, the associated values can be</span><span class="s3">\n</span><span class="s1">retrieved from an updated tree.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class NodeWeakMap {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.map = new WeakMap();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setBuffer(buffer, index, value) {</span><span class="s3">\n        </span><span class="s1">let inner = this.map.get(buffer);</span><span class="s3">\n        </span><span class="s1">if (!inner)</span><span class="s3">\n            </span><span class="s1">this.map.set(buffer, inner = new Map);</span><span class="s3">\n        </span><span class="s1">inner.set(index, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getBuffer(buffer, index) {</span><span class="s3">\n        </span><span class="s1">let inner = this.map.get(buffer);</span><span class="s3">\n        </span><span class="s1">return inner &amp;&amp; inner.get(index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Set the value for this syntax node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set(node, value) {</span><span class="s3">\n        </span><span class="s1">if (node instanceof BufferNode)</span><span class="s3">\n            </span><span class="s1">this.setBuffer(node.context.buffer, node.index, value);</span><span class="s3">\n        </span><span class="s1">else if (node instanceof TreeNode)</span><span class="s3">\n            </span><span class="s1">this.map.set(node.tree, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Retrieve value for this syntax node, if it exists in the map.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get(node) {</span><span class="s3">\n        </span><span class="s1">return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)</span><span class="s3">\n            </span><span class="s1">: node instanceof TreeNode ? this.map.get(node.tree) : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Set the value for the node that a cursor currently points to.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cursorSet(cursor, value) {</span><span class="s3">\n        </span><span class="s1">if (cursor.buffer)</span><span class="s3">\n            </span><span class="s1">this.setBuffer(cursor.buffer.buffer, cursor.index, value);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.map.set(cursor.tree, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Retrieve the value for the node that a cursor currently points</span><span class="s3">\n    </span><span class="s1">to.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cursorGet(cursor) {</span><span class="s3">\n        </span><span class="s1">return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Tree fragments are used during [incremental</span><span class="s3">\n</span><span class="s1">parsing](#common.Parser.startParse) to track parts of old trees</span><span class="s3">\n</span><span class="s1">that can be reused in a new parse. An array of fragments is used</span><span class="s3">\n</span><span class="s1">to track regions of an old tree whose nodes might be reused in new</span><span class="s3">\n</span><span class="s1">parses. Use the static</span><span class="s3">\n</span><span class="s1">[`applyChanges`](#common.TreeFragment^applyChanges) method to</span><span class="s3">\n</span><span class="s1">update fragments for document changes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TreeFragment {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Construct a tree fragment. You'll usually want to use</span><span class="s3">\n    </span><span class="s1">[`addTree`](#common.TreeFragment^addTree) and</span><span class="s3">\n    </span><span class="s1">[`applyChanges`](#common.TreeFragment^applyChanges) instead of</span><span class="s3">\n    </span><span class="s1">calling this directly.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The start of the unchanged range pointed to by this fragment.</span><span class="s3">\n    </span><span class="s1">This refers to an offset in the _updated_ document (as opposed</span><span class="s3">\n    </span><span class="s1">to the original tree).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The end of the unchanged range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">to, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The tree that this fragment is based on.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">tree, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The offset between the fragment's tree and the document that</span><span class="s3">\n    </span><span class="s1">this fragment can be used against. Add this when going from</span><span class="s3">\n    </span><span class="s1">document to tree positions, subtract it to go from tree to</span><span class="s3">\n    </span><span class="s1">document positions.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">offset, openStart = false, openEnd = false) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.tree = tree;</span><span class="s3">\n        </span><span class="s1">this.offset = offset;</span><span class="s3">\n        </span><span class="s1">this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whether the start of the fragment represents the start of a</span><span class="s3">\n    </span><span class="s1">parse, or the end of a change. (In the second case, it may not</span><span class="s3">\n    </span><span class="s1">be safe to reuse some nodes at the start, depending on the</span><span class="s3">\n    </span><span class="s1">parsing algorithm.)</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get openStart() { return (this.open &amp; 1 /* Open.Start */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whether the end of the fragment represents the end of a</span><span class="s3">\n    </span><span class="s1">full-document parse, or the start of a change.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get openEnd() { return (this.open &amp; 2 /* Open.End */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a set of fragments from a freshly parsed tree, or update</span><span class="s3">\n    </span><span class="s1">an existing set of fragments by replacing the ones that overlap</span><span class="s3">\n    </span><span class="s1">with a tree with content from the new tree. When `partial` is</span><span class="s3">\n    </span><span class="s1">true, the parse is treated as incomplete, and the resulting</span><span class="s3">\n    </span><span class="s1">fragment has [`openEnd`](#common.TreeFragment.openEnd) set to</span><span class="s3">\n    </span><span class="s1">true.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static addTree(tree, fragments = [], partial = false) {</span><span class="s3">\n        </span><span class="s1">let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];</span><span class="s3">\n        </span><span class="s1">for (let f of fragments)</span><span class="s3">\n            </span><span class="s1">if (f.to &gt; tree.length)</span><span class="s3">\n                </span><span class="s1">result.push(f);</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Apply a set of edits to an array of fragments, removing or</span><span class="s3">\n    </span><span class="s1">splitting fragments as necessary to remove edited ranges, and</span><span class="s3">\n    </span><span class="s1">adjusting offsets for fragments that moved.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static applyChanges(fragments, changes, minGap = 128) {</span><span class="s3">\n        </span><span class="s1">if (!changes.length)</span><span class="s3">\n            </span><span class="s1">return fragments;</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">let fI = 1, nextF = fragments.length ? fragments[0] : null;</span><span class="s3">\n        </span><span class="s1">for (let cI = 0, pos = 0, off = 0;; cI++) {</span><span class="s3">\n            </span><span class="s1">let nextC = cI &lt; changes.length ? changes[cI] : null;</span><span class="s3">\n            </span><span class="s1">let nextPos = nextC ? nextC.fromA : 1e9;</span><span class="s3">\n            </span><span class="s1">if (nextPos - pos &gt;= minGap)</span><span class="s3">\n                </span><span class="s1">while (nextF &amp;&amp; nextF.from &lt; nextPos) {</span><span class="s3">\n                    </span><span class="s1">let cut = nextF;</span><span class="s3">\n                    </span><span class="s1">if (pos &gt;= cut.from || nextPos &lt;= cut.to || off) {</span><span class="s3">\n                        </span><span class="s1">let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;</span><span class="s3">\n                        </span><span class="s1">cut = fFrom &gt;= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI &gt; 0, !!nextC);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (cut)</span><span class="s3">\n                        </span><span class="s1">result.push(cut);</span><span class="s3">\n                    </span><span class="s1">if (nextF.to &gt; nextPos)</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">nextF = fI &lt; fragments.length ? fragments[fI++] : null;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!nextC)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">pos = nextC.toA;</span><span class="s3">\n            </span><span class="s1">off = nextC.toA - nextC.toB;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A superclass that parsers should extend.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Parser {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Start a parse, returning a [partial parse](#common.PartialParse)</span><span class="s3">\n    </span><span class="s1">object. [`fragments`](#common.TreeFragment) can be passed in to</span><span class="s3">\n    </span><span class="s1">make the parse incremental.</span><span class="s3">\n    \n    </span><span class="s1">By default, the entire input is parsed. You can pass `ranges`,</span><span class="s3">\n    </span><span class="s1">which should be a sorted array of non-empty, non-overlapping</span><span class="s3">\n    </span><span class="s1">ranges, to parse only those ranges. The tree returned in that</span><span class="s3">\n    </span><span class="s1">case will start at `ranges[0].from`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startParse(input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">if (typeof input == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">input = new StringInput(input);</span><span class="s3">\n        </span><span class="s1">ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r =&gt; new Range(r.from, r.to)) : [new Range(0, 0)];</span><span class="s3">\n        </span><span class="s1">return this.createParse(input, fragments || [], ranges);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Run a full parse, returning the resulting tree.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parse(input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">let parse = this.startParse(input, fragments, ranges);</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let done = parse.advance();</span><span class="s3">\n            </span><span class="s1">if (done)</span><span class="s3">\n                </span><span class="s1">return done;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class StringInput {</span><span class="s3">\n    </span><span class="s1">constructor(string) {</span><span class="s3">\n        </span><span class="s1">this.string = string;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() { return this.string.length; }</span><span class="s3">\n    </span><span class="s1">chunk(from) { return this.string.slice(from); }</span><span class="s3">\n    </span><span class="s1">get lineChunks() { return false; }</span><span class="s3">\n    </span><span class="s1">read(from, to) { return this.string.slice(from, to); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a parse wrapper that, after the inner parse completes,</span><span class="s3">\n</span><span class="s1">scans its tree for mixed language regions with the `nest`</span><span class="s3">\n</span><span class="s1">function, runs the resulting [inner parses](#common.NestedParse),</span><span class="s3">\n</span><span class="s1">and then [mounts](#common.NodeProp^mounted) their results onto the</span><span class="s3">\n</span><span class="s1">tree.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function parseMixed(nest) {</span><span class="s3">\n    </span><span class="s1">return (parse, input, fragments, ranges) =&gt; new MixedParse(parse, nest, input, fragments, ranges);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class InnerParse {</span><span class="s3">\n    </span><span class="s1">constructor(parser, parse, overlay, target, from) {</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.parse = parse;</span><span class="s3">\n        </span><span class="s1">this.overlay = overlay;</span><span class="s3">\n        </span><span class="s1">this.target = target;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkRanges(ranges) {</span><span class="s3">\n    </span><span class="s1">if (!ranges.length || ranges.some(r =&gt; r.from &gt;= r.to))</span><span class="s3">\n        </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid inner parse ranges given: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(ranges));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ActiveOverlay {</span><span class="s3">\n    </span><span class="s1">constructor(parser, predicate, mounts, index, start, target, prev) {</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.predicate = predicate;</span><span class="s3">\n        </span><span class="s1">this.mounts = mounts;</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n        </span><span class="s1">this.target = target;</span><span class="s3">\n        </span><span class="s1">this.prev = prev;</span><span class="s3">\n        </span><span class="s1">this.depth = 0;</span><span class="s3">\n        </span><span class="s1">this.ranges = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const stoppedInner = new NodeProp({ perNode: true });</span><span class="s3">\n</span><span class="s1">class MixedParse {</span><span class="s3">\n    </span><span class="s1">constructor(base, nest, input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">this.nest = nest;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments;</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.inner = [];</span><span class="s3">\n        </span><span class="s1">this.innerDone = 0;</span><span class="s3">\n        </span><span class="s1">this.baseTree = null;</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = null;</span><span class="s3">\n        </span><span class="s1">this.baseParse = base;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">advance() {</span><span class="s3">\n        </span><span class="s1">if (this.baseParse) {</span><span class="s3">\n            </span><span class="s1">let done = this.baseParse.advance();</span><span class="s3">\n            </span><span class="s1">if (!done)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">this.baseParse = null;</span><span class="s3">\n            </span><span class="s1">this.baseTree = done;</span><span class="s3">\n            </span><span class="s1">this.startInner();</span><span class="s3">\n            </span><span class="s1">if (this.stoppedAt != null)</span><span class="s3">\n                </span><span class="s1">for (let inner of this.inner)</span><span class="s3">\n                    </span><span class="s1">inner.parse.stopAt(this.stoppedAt);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.innerDone == this.inner.length) {</span><span class="s3">\n            </span><span class="s1">let result = this.baseTree;</span><span class="s3">\n            </span><span class="s1">if (this.stoppedAt != null)</span><span class="s3">\n                </span><span class="s1">result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let inner = this.inner[this.innerDone], done = inner.parse.advance();</span><span class="s3">\n        </span><span class="s1">if (done) {</span><span class="s3">\n            </span><span class="s1">this.innerDone++;</span><span class="s3">\n            </span><span class="s1">// This is a somewhat dodgy but super helpful hack where we</span><span class="s3">\n            </span><span class="s1">// patch up nodes created by the inner parse (and thus</span><span class="s3">\n            </span><span class="s1">// presumably not aliased anywhere else) to hold the information</span><span class="s3">\n            </span><span class="s1">// about the inner parse.</span><span class="s3">\n            </span><span class="s1">let props = Object.assign(Object.create(null), inner.target.props);</span><span class="s3">\n            </span><span class="s1">props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);</span><span class="s3">\n            </span><span class="s1">inner.target.props = props;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parsedPos() {</span><span class="s3">\n        </span><span class="s1">if (this.baseParse)</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">let pos = this.input.length;</span><span class="s3">\n        </span><span class="s1">for (let i = this.innerDone; i &lt; this.inner.length; i++) {</span><span class="s3">\n            </span><span class="s1">if (this.inner[i].from &lt; pos)</span><span class="s3">\n                </span><span class="s1">pos = Math.min(pos, this.inner[i].parse.parsedPos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stopAt(pos) {</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = pos;</span><span class="s3">\n        </span><span class="s1">if (this.baseParse)</span><span class="s3">\n            </span><span class="s1">this.baseParse.stopAt(pos);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">for (let i = this.innerDone; i &lt; this.inner.length; i++)</span><span class="s3">\n                </span><span class="s1">this.inner[i].parse.stopAt(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startInner() {</span><span class="s3">\n        </span><span class="s1">let fragmentCursor = new FragmentCursor(this.fragments);</span><span class="s3">\n        </span><span class="s1">let overlay = null;</span><span class="s3">\n        </span><span class="s1">let covered = null;</span><span class="s3">\n        </span><span class="s1">let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);</span><span class="s3">\n        </span><span class="s1">scan: for (let nest, isCovered;;) {</span><span class="s3">\n            </span><span class="s1">let enter = true, range;</span><span class="s3">\n            </span><span class="s1">if (this.stoppedAt != null &amp;&amp; cursor.from &gt;= this.stoppedAt) {</span><span class="s3">\n                </span><span class="s1">enter = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (fragmentCursor.hasNode(cursor)) {</span><span class="s3">\n                </span><span class="s1">if (overlay) {</span><span class="s3">\n                    </span><span class="s1">let match = overlay.mounts.find(m =&gt; m.frag.from &lt;= cursor.from &amp;&amp; m.frag.to &gt;= cursor.to &amp;&amp; m.mount.overlay);</span><span class="s3">\n                    </span><span class="s1">if (match)</span><span class="s3">\n                        </span><span class="s1">for (let r of match.mount.overlay) {</span><span class="s3">\n                            </span><span class="s1">let from = r.from + match.pos, to = r.to + match.pos;</span><span class="s3">\n                            </span><span class="s1">if (from &gt;= cursor.from &amp;&amp; to &lt;= cursor.to &amp;&amp; !overlay.ranges.some(r =&gt; r.from &lt; to &amp;&amp; r.to &gt; from))</span><span class="s3">\n                                </span><span class="s1">overlay.ranges.push({ from, to });</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">enter = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (covered &amp;&amp; (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {</span><span class="s3">\n                </span><span class="s1">enter = isCovered != 2 /* Cover.Full */;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!cursor.type.isAnonymous &amp;&amp; (nest = this.nest(cursor, this.input)) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(cursor.from &lt; cursor.to || !nest.overlay)) {</span><span class="s3">\n                </span><span class="s1">if (!cursor.tree)</span><span class="s3">\n                    </span><span class="s1">materialize(cursor);</span><span class="s3">\n                </span><span class="s1">let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);</span><span class="s3">\n                </span><span class="s1">if (typeof nest.overlay == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let ranges = punchRanges(this.ranges, nest.overlay ||</span><span class="s3">\n                        </span><span class="s1">(cursor.from &lt; cursor.to ? [new Range(cursor.from, cursor.to)] : []));</span><span class="s3">\n                    </span><span class="s1">if (ranges.length)</span><span class="s3">\n                        </span><span class="s1">checkRanges(ranges);</span><span class="s3">\n                    </span><span class="s1">if (ranges.length || !nest.overlay)</span><span class="s3">\n                        </span><span class="s1">this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)</span><span class="s3">\n                            </span><span class="s1">: nest.parser.startParse(</span><span class="s3">\&quot;\&quot;</span><span class="s1">), nest.overlay ? nest.overlay.map(r =&gt; new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));</span><span class="s3">\n                    </span><span class="s1">if (!nest.overlay)</span><span class="s3">\n                        </span><span class="s1">enter = false;</span><span class="s3">\n                    </span><span class="s1">else if (ranges.length)</span><span class="s3">\n                        </span><span class="s1">covered = { ranges, depth: 0, prev: covered };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (overlay &amp;&amp; (range = overlay.predicate(cursor))) {</span><span class="s3">\n                </span><span class="s1">if (range === true)</span><span class="s3">\n                    </span><span class="s1">range = new Range(cursor.from, cursor.to);</span><span class="s3">\n                </span><span class="s1">if (range.from &lt; range.to)</span><span class="s3">\n                    </span><span class="s1">overlay.ranges.push(range);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (enter &amp;&amp; cursor.firstChild()) {</span><span class="s3">\n                </span><span class="s1">if (overlay)</span><span class="s3">\n                    </span><span class="s1">overlay.depth++;</span><span class="s3">\n                </span><span class="s1">if (covered)</span><span class="s3">\n                    </span><span class="s1">covered.depth++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">for (;;) {</span><span class="s3">\n                    </span><span class="s1">if (cursor.nextSibling())</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">if (!cursor.parent())</span><span class="s3">\n                        </span><span class="s1">break scan;</span><span class="s3">\n                    </span><span class="s1">if (overlay &amp;&amp; !--overlay.depth) {</span><span class="s3">\n                        </span><span class="s1">let ranges = punchRanges(this.ranges, overlay.ranges);</span><span class="s3">\n                        </span><span class="s1">if (ranges.length) {</span><span class="s3">\n                            </span><span class="s1">checkRanges(ranges);</span><span class="s3">\n                            </span><span class="s1">this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r =&gt; new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">overlay = overlay.prev;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (covered &amp;&amp; !--covered.depth)</span><span class="s3">\n                        </span><span class="s1">covered = covered.prev;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkCover(covered, from, to) {</span><span class="s3">\n    </span><span class="s1">for (let range of covered) {</span><span class="s3">\n        </span><span class="s1">if (range.from &gt;= to)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (range.to &gt; from)</span><span class="s3">\n            </span><span class="s1">return range.from &lt;= from &amp;&amp; range.to &gt;= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 0 /* Cover.None */;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Take a piece of buffer and convert it into a stand-alone</span><span class="s3">\n</span><span class="s1">// TreeBuffer.</span><span class="s3">\n</span><span class="s1">function sliceBuf(buf, startI, endI, nodes, positions, off) {</span><span class="s3">\n    </span><span class="s1">if (startI &lt; endI) {</span><span class="s3">\n        </span><span class="s1">let from = buf.buffer[startI + 1];</span><span class="s3">\n        </span><span class="s1">nodes.push(buf.slice(startI, endI, from));</span><span class="s3">\n        </span><span class="s1">positions.push(from - off);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// This function takes a node that's in a buffer, and converts it, and</span><span class="s3">\n</span><span class="s1">// its parent buffer nodes, into a Tree. This is again acting on the</span><span class="s3">\n</span><span class="s1">// assumption that the trees and buffers have been constructed by the</span><span class="s3">\n</span><span class="s1">// parse that was ran via the mix parser, and thus aren't shared with</span><span class="s3">\n</span><span class="s1">// any other code, making violations of the immutability safe.</span><span class="s3">\n</span><span class="s1">function materialize(cursor) {</span><span class="s3">\n    </span><span class="s1">let { node } = cursor, stack = [];</span><span class="s3">\n    </span><span class="s1">let buffer = node.context.buffer;</span><span class="s3">\n    </span><span class="s1">// Scan up to the nearest tree</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">stack.push(cursor.index);</span><span class="s3">\n        </span><span class="s1">cursor.parent();</span><span class="s3">\n    </span><span class="s1">} while (!cursor.tree);</span><span class="s3">\n    </span><span class="s1">// Find the index of the buffer in that tree</span><span class="s3">\n    </span><span class="s1">let base = cursor.tree, i = base.children.indexOf(buffer);</span><span class="s3">\n    </span><span class="s1">let buf = base.children[i], b = buf.buffer, newStack = [i];</span><span class="s3">\n    </span><span class="s1">// Split a level in the buffer, putting the nodes before and after</span><span class="s3">\n    </span><span class="s1">// the child that contains `node` into new buffers.</span><span class="s3">\n    </span><span class="s1">function split(startI, endI, type, innerOffset, length, stackPos) {</span><span class="s3">\n        </span><span class="s1">let targetI = stack[stackPos];</span><span class="s3">\n        </span><span class="s1">let children = [], positions = [];</span><span class="s3">\n        </span><span class="s1">sliceBuf(buf, startI, targetI, children, positions, innerOffset);</span><span class="s3">\n        </span><span class="s1">let from = b[targetI + 1], to = b[targetI + 2];</span><span class="s3">\n        </span><span class="s1">newStack.push(children.length);</span><span class="s3">\n        </span><span class="s1">let child = stackPos</span><span class="s3">\n            </span><span class="s1">? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)</span><span class="s3">\n            </span><span class="s1">: node.toTree();</span><span class="s3">\n        </span><span class="s1">children.push(child);</span><span class="s3">\n        </span><span class="s1">positions.push(from - innerOffset);</span><span class="s3">\n        </span><span class="s1">sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);</span><span class="s3">\n        </span><span class="s1">return new Tree(type, children, positions, length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);</span><span class="s3">\n    </span><span class="s1">// Move the cursor back to the target node</span><span class="s3">\n    </span><span class="s1">for (let index of newStack) {</span><span class="s3">\n        </span><span class="s1">let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];</span><span class="s3">\n        </span><span class="s1">cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class StructureCursor {</span><span class="s3">\n    </span><span class="s1">constructor(root, offset) {</span><span class="s3">\n        </span><span class="s1">this.offset = offset;</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Move to the first node (in pre-order) that starts at or after `pos`.</span><span class="s3">\n    </span><span class="s1">moveTo(pos) {</span><span class="s3">\n        </span><span class="s1">let { cursor } = this, p = pos - this.offset;</span><span class="s3">\n        </span><span class="s1">while (!this.done &amp;&amp; cursor.from &lt; p) {</span><span class="s3">\n            </span><span class="s1">if (cursor.to &gt;= pos &amp;&amp; cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;</span><span class="s3">\n            </span><span class="s1">else if (!cursor.next(false))</span><span class="s3">\n                </span><span class="s1">this.done = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasNode(cursor) {</span><span class="s3">\n        </span><span class="s1">this.moveTo(cursor.from);</span><span class="s3">\n        </span><span class="s1">if (!this.done &amp;&amp; this.cursor.from + this.offset == cursor.from &amp;&amp; this.cursor.tree) {</span><span class="s3">\n            </span><span class="s1">for (let tree = this.cursor.tree;;) {</span><span class="s3">\n                </span><span class="s1">if (tree == cursor.tree)</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">if (tree.children.length &amp;&amp; tree.positions[0] == 0 &amp;&amp; tree.children[0] instanceof Tree)</span><span class="s3">\n                    </span><span class="s1">tree = tree.children[0];</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class FragmentCursor {</span><span class="s3">\n    </span><span class="s1">constructor(fragments) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments;</span><span class="s3">\n        </span><span class="s1">this.curTo = 0;</span><span class="s3">\n        </span><span class="s1">this.fragI = 0;</span><span class="s3">\n        </span><span class="s1">if (fragments.length) {</span><span class="s3">\n            </span><span class="s1">let first = this.curFrag = fragments[0];</span><span class="s3">\n            </span><span class="s1">this.curTo = (_a = first.tree.prop(stoppedInner)) !== null &amp;&amp; _a !== void 0 ? _a : first.to;</span><span class="s3">\n            </span><span class="s1">this.inner = new StructureCursor(first.tree, -first.offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.curFrag = this.inner = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasNode(node) {</span><span class="s3">\n        </span><span class="s1">while (this.curFrag &amp;&amp; node.from &gt;= this.curTo)</span><span class="s3">\n            </span><span class="s1">this.nextFrag();</span><span class="s3">\n        </span><span class="s1">return this.curFrag &amp;&amp; this.curFrag.from &lt;= node.from &amp;&amp; this.curTo &gt;= node.to &amp;&amp; this.inner.hasNode(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextFrag() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.fragI++;</span><span class="s3">\n        </span><span class="s1">if (this.fragI == this.fragments.length) {</span><span class="s3">\n            </span><span class="s1">this.curFrag = this.inner = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let frag = this.curFrag = this.fragments[this.fragI];</span><span class="s3">\n            </span><span class="s1">this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null &amp;&amp; _a !== void 0 ? _a : frag.to;</span><span class="s3">\n            </span><span class="s1">this.inner = new StructureCursor(frag.tree, -frag.offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findMounts(pos, parser) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">if (this.inner) {</span><span class="s3">\n            </span><span class="s1">this.inner.cursor.moveTo(pos, 1);</span><span class="s3">\n            </span><span class="s1">for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {</span><span class="s3">\n                </span><span class="s1">let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);</span><span class="s3">\n                </span><span class="s1">if (mount &amp;&amp; mount.parser == parser) {</span><span class="s3">\n                    </span><span class="s1">for (let i = this.fragI; i &lt; this.fragments.length; i++) {</span><span class="s3">\n                        </span><span class="s1">let frag = this.fragments[i];</span><span class="s3">\n                        </span><span class="s1">if (frag.from &gt;= pos.to)</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">if (frag.tree == this.curFrag.tree)</span><span class="s3">\n                            </span><span class="s1">result.push({</span><span class="s3">\n                                </span><span class="s1">frag,</span><span class="s3">\n                                </span><span class="s1">pos: pos.from - frag.offset,</span><span class="s3">\n                                </span><span class="s1">mount</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function punchRanges(outer, ranges) {</span><span class="s3">\n    </span><span class="s1">let copy = null, current = ranges;</span><span class="s3">\n    </span><span class="s1">for (let i = 1, j = 0; i &lt; outer.length; i++) {</span><span class="s3">\n        </span><span class="s1">let gapFrom = outer[i - 1].to, gapTo = outer[i].from;</span><span class="s3">\n        </span><span class="s1">for (; j &lt; current.length; j++) {</span><span class="s3">\n            </span><span class="s1">let r = current[j];</span><span class="s3">\n            </span><span class="s1">if (r.from &gt;= gapTo)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (r.to &lt;= gapFrom)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (!copy)</span><span class="s3">\n                </span><span class="s1">current = copy = ranges.slice();</span><span class="s3">\n            </span><span class="s1">if (r.from &lt; gapFrom) {</span><span class="s3">\n                </span><span class="s1">copy[j] = new Range(r.from, gapFrom);</span><span class="s3">\n                </span><span class="s1">if (r.to &gt; gapTo)</span><span class="s3">\n                    </span><span class="s1">copy.splice(j + 1, 0, new Range(gapTo, r.to));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (r.to &gt; gapTo) {</span><span class="s3">\n                </span><span class="s1">copy[j--] = new Range(gapTo, r.to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">copy.splice(j--, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return current;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findCoverChanges(a, b, from, to) {</span><span class="s3">\n    </span><span class="s1">let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;</span><span class="s3">\n        </span><span class="s1">let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;</span><span class="s3">\n        </span><span class="s1">if (inA != inB) {</span><span class="s3">\n            </span><span class="s1">let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);</span><span class="s3">\n            </span><span class="s1">if (start &lt; end)</span><span class="s3">\n                </span><span class="s1">result.push(new Range(start, end));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pos = Math.min(nextA, nextB);</span><span class="s3">\n        </span><span class="s1">if (pos == 1e9)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (nextA == pos) {</span><span class="s3">\n            </span><span class="s1">if (!inA)</span><span class="s3">\n                </span><span class="s1">inA = true;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">inA = false;</span><span class="s3">\n                </span><span class="s1">iA++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (nextB == pos) {</span><span class="s3">\n            </span><span class="s1">if (!inB)</span><span class="s3">\n                </span><span class="s1">inB = true;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">inB = false;</span><span class="s3">\n                </span><span class="s1">iB++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Given a number of fragments for the outer tree, and a set of ranges</span><span class="s3">\n</span><span class="s1">// to parse, find fragments for inner trees mounted around those</span><span class="s3">\n</span><span class="s1">// ranges, if any.</span><span class="s3">\n</span><span class="s1">function enterFragments(mounts, ranges) {</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">for (let { pos, mount, frag } of mounts) {</span><span class="s3">\n        </span><span class="s1">let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;</span><span class="s3">\n        </span><span class="s1">let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);</span><span class="s3">\n        </span><span class="s1">if (mount.overlay) {</span><span class="s3">\n            </span><span class="s1">let overlay = mount.overlay.map(r =&gt; new Range(r.from + pos, r.to + pos));</span><span class="s3">\n            </span><span class="s1">let changes = findCoverChanges(ranges, overlay, from, to);</span><span class="s3">\n            </span><span class="s1">for (let i = 0, pos = from;; i++) {</span><span class="s3">\n                </span><span class="s1">let last = i == changes.length, end = last ? to : changes[i].from;</span><span class="s3">\n                </span><span class="s1">if (end &gt; pos)</span><span class="s3">\n                    </span><span class="s1">result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from &gt;= pos || frag.openStart, frag.to &lt;= end || frag.openEnd));</span><span class="s3">\n                </span><span class="s1">if (last)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">pos = changes[i].to;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from &gt;= startPos || frag.openStart, frag.to &lt;= endPos || frag.openEnd));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>